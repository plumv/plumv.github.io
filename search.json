[{"title":"日志的学习","url":"/2021/07/29/尚硅谷说Java/中间件/日志/","content":"\n* 包含JUL,Log4j,JCL,Slf4j,Logback,Log4j2\n\n<!--more-->\n\n# 日志\n\n* 日志门面：对常用日志技术的接口封装。\n  * 类似于在JPA中的JPA。\n* 日志实现：常用的日志技术。\n  * 类似于JPA中的HIbernate\n* 常见的日志门面：JCL,slf4j\n* 常见的日志实现：JUL,logback,log4j,log4j2\n\n\n\n# JUL\n\n* 是Java内置的日志实现。所有的操作都在java.util.logging下。\n\n* 日志的原理：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210727150821.png)\n\n  * Logger：被称为记录器，应用程序通过获取Logger对象，调用其API来来发布日志信息。Logger通常时应用程序访问日志系统的入口程序。\n  * Handler：每个Logger都会关联一组Handlers，Logger会将日志交给关联Handlers处理，由Handlers负责将日志做记录。Handlers在此是一个抽象，其具体的实现决定了日志记录的位置可以是控制台、文件、网络上的其他日志服务或操作系统日志等。\n  * Filters：过滤器，根据需要定制哪些信息会被记录，哪些信息会被放过。\n  * Formatters：它负责对日志事件中的数据进行转换和格式化。Formatters决定了数据在一条日志记录中的最终形式。\n  * Level：每条日志消息都有一个关联的日志级别。该级别粗略指导了日志消息的重要性和紧迫，我可以将Level和Loggers，Formatters做关联以便于我们过滤消息。\n\n* Logger用于记录日志，Handler用来打印日志(可以选择打印在文件中或者控制台中)\n\n* 文件日志打印默认是覆盖原来的日志。\n\n\n\n## 日志级别\n\n```markdown\n# JUL的日志级别\n\tSEVERE -- 1000 -- 错误级别\n\tWARNING -- 900 -- 警告级别\n\tINFO -- 800 -- 信息级别\n\tCONFIG -- 700 -- 配置级别\n\tFINE -- 500 -- 详细信息(不太详细)\n\tFINER -- 400 -- 详细信息(详细)\n\tFINEST -- 300 -- 详细信息(特别详细)\n\tOFF -- Integer.MAX_VALUE -- 关闭所有信息的日志记录\n\tALL -- Integer.MIN_VALUE -- 开启所有信息的日志记录\n- 如果设置的日志级别为 INFO -- 800 。则最终只会显示级别大于等于800的日志信息。\n- 默认日志级别是 INFO -- 800\n```\n\n\n\n## 默认配置文件的解析\n\n```properties\n# 配置文件的配置都是配置RootLogger的配置。\n\n# 配置处理器。ConsoleHandler表示控制台输出\nhandlers= java.util.logging.ConsoleHandler\n# 指定日志级别\n.level= INFO\n\n# 文件处理器的相关配置\n# 日志文件的位置。%h表示用户的根目录。%u表示0，1，2，3等数字。日志文件名示例：java0.log\njava.util.logging.FileHandler.pattern = %h/java%u.log\n# 日志文件大小的限制(50000字节)\njava.util.logging.FileHandler.limit = 50000\n# 日志文件的数量(1个)\njava.util.logging.FileHandler.count = 1\n# 日志文件的锁的数量\njava.util.logging.FileHandler.maxLocks = 100\n# 日志文件的日志格式\njava.util.logging.FileHandler.formatter = java.util.logging.XMLFormatter\n\n# 控制台处理器的相关配置\n# 控制台日志的级别\njava.util.logging.ConsoleHandler.level = INFO\n# 控制台日志的日志格式\njava.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter\n\n# 没有任何作用，仅作示例存在。\n# 表示可以设置指定包的指定日志级别\ncom.xyz.foo.level = SEVERE\n\n# 以下为自定义的\n# 自定义 指定包的指定日志级别\ncom.lc.handlers = java.util.logging.FileHandler\ncom.lc.level = CONFIG\ncom.lc.useParentHandlers = false\n\n# 设置文件日志打印不是覆盖，而是追加\njava.util.logging.FileHandler.append = true\n```\n\n\n\n## 示例\n\n\n\n```java\n/**\n * 注意以下类都是在java.util.logging包下的类\n * 简单的使用 ：\n *  第一步：创建logger对象。传入日志要记录的是那个类，还是哪个包\n *  第二步：使用logger对象。使用方式有两种\n *    1. 直接通过logger对象调用指定日志级别的方法。输入日志信息即可。\n *    2. 使用logger对象的log方法，输入日志级别和日志信息。\n * logger支持动态的输出日志。{index} 格式\n *\n * 日志级别的设置：\n *  第一步：先关闭默认的日志打印方式\n *  第二步：创建handler和Formater，使用自定义的日志打印方式\n *  第三步：设置处理器和打印的日志级别。注意两个设置的要一样才能起作用。\n *\n * 日志信息打印到磁盘中：\n *  在设置日志级别时，使用FileHandler即可\n *\n * 同时在控制台和文件中记录日志；\n *  只需要添加ConsoleHandler和FileHandler即可。\n *  两个处理器可以设置不同的日志级别。\n *\n * Logger具有父子结构。父子结构以构建时传入的name为根据。name越详细logger越为子。\n *  所有的logger的父logger都是RootLogger。RootLogger是作为根Logger存在的。\n *  父子关系的体现是以树的形式体现的\n *  好处：\n *    1. 父logger的设置，它的子logger会继承父logger的设置。\n *\n * 配置文件的使用\n *  默认的配置文件位置在 java.home.conf.logging.properties 文件 (11版本的)\n *    具体的源码在 java.util.logging.LogManager 类的下面的一个方法中\n *  配置文件是作用在RootLogger上的。因此具有全局性。在整个项目中都起作用。\n *\n * 使用自定义的日志配置文件：\n *  第一步：创建配置文件的输入流\n *  第二步：创建LogManager对象\n *  第三步：读取输入流。\n *\n */\n```\n\n* 使用\n\n```java\npublic static void main(String[] args) throws IOException {\n    // 参数为当前类的全路径\n    Logger logger = Logger.getLogger(\"com.lc.jul_test.JulTest\");\n\n    // 方式1\n    logger.info(\"hello 阿松大\");\n    // 方式2\n    logger.log(Level.INFO,\"方式2的输出\");\n\n    // 动态的输出日志\n    String name = \"lisi\";\n    int age = 123;\n    // 其中{0} 表示匹配数组的第一个值\n    // 其中{1} 表示匹配数组的第二个值\n    logger.log(Level.INFO,\"姓名：{0},年龄：{1}\",new Object[]{name,age});\n\n    // 设置日志级别\n\n    /************\n      // logger.setLevel(Level.FINEST); // 此方法单独不会起作用。需要搭配Handler一起使用才有效果\n\n    // 第一步：先关闭默认的日志打印方式\n    logger.setUseParentHandlers(false);\n    // 第二步：创建handler和Formater，使用自定义的日志打印方式\n      // 控制台处理器\n    ConsoleHandler handler = new ConsoleHandler();\n    Formatter formatter = new SimpleFormatter();\n    handler.setFormatter(formatter);\n    logger.addHandler(handler);\n    // 第三步：设置处理器和打印的日志级别。注意两个设置的要一样才能起作用。\n    handler.setLevel(Level.FINEST);\n    logger.setLevel(Level.FINEST);\n\n    logger.severe(\"severe 信息\");\n    logger.warning(\"warning 信息\");\n    logger.info(\"info 信息\");\n    logger.config(\"config 信息\");\n    logger.fine(\"fine 信息\");\n    logger.finer(\"finer 信息\");\n    logger.finest(\"finest 信息\");\n\n     **************/\n\n\n    // 日志信息打印到磁盘中\n\n    /********\n    logger.setUseParentHandlers(false);\n\n    FileHandler handler = new FileHandler(\"E:\\\\JavaStudent\\\\logger\\\\JUL-logger\\\\log\\\\myJUL.log\");\n    Formatter formatter = new SimpleFormatter();\n\n    handler.setFormatter(formatter);\n    handler.setLevel(Level.FINEST);\n    logger.addHandler(handler);\n    logger.setLevel(Level.FINEST);\n\n    logger.severe(\"severe 信息\");\n    logger.warning(\"warning 信息\");\n    logger.info(\"info 信息\");\n    logger.config(\"config 信息\");\n    logger.fine(\"fine 信息\");\n    logger.finer(\"finer 信息\");\n    logger.finest(\"finest 信息\");\n\n     **************/\n\n    // 同时在控制台和文件中记录日志\n\n    /*************\n    logger.setUseParentHandlers(false);\n\n    FileHandler fileHandler = new FileHandler(\"E:\\\\JavaStudent\\\\logger\\\\JUL-logger\\\\log\\\\myJUL.log\");\n    fileHandler.setFormatter(new XMLFormatter());\n    fileHandler.setLevel(Level.FINEST);\n    logger.addHandler(fileHandler);\n\n    ConsoleHandler consoleHandler = new ConsoleHandler();\n    consoleHandler.setFormatter(new SimpleFormatter());\n    consoleHandler.setLevel(Level.FINEST);\n    logger.addHandler(consoleHandler);\n\n    logger.setLevel(Level.FINEST);\n\n    logger.severe(\"severe 信息\");\n    logger.warning(\"warning 信息\");\n    logger.info(\"info 信息\");\n    logger.config(\"config 信息\");\n    logger.fine(\"fine 信息\");\n    logger.finer(\"finer 信息\");\n    logger.finest(\"finest 信息\");\n    ******************/\n\n    // 使用自定义的日志配置文件\n\n    /**********\n    // 第一步：创建配置文件的输入流\n    FileInputStream inputStream = new FileInputStream(\"E:\\\\JavaStudent\\\\logger\\\\JUL-logger\\\\src\\\\resource\\\\logging.properties\");\n    // 第二步：创建日志管理器对象\n    LogManager logManager = LogManager.getLogManager();\n    // 第三步：读取配置文件\n    logManager.readConfiguration(inputStream);\n    **********/\n\n\n  }\n```\n\n\n\n# Log4j\n\n* Log4j是Apache的一个开源项目，通过使用Log4j,我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等;\n* 我们也可以控制每一条日志的输出格式;通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。\n* 最令人感兴趣的就是，这些可以通过一 个配置文件来灵活地进行配置，而不需要修改应用的代码。\n* 引用依赖\n\n```xml\n<dependency>\n  <groupId>log4j</groupId>\n  <artifactId>log4j</artifactId>\n  <version>1.2.17</version>\n</dependency>\n```\n\n\n\n## 组件介绍\n\n* Log4j主要由Loggers (日志记录器)、Appenders (输出控制器)和Layout (日志格式化器)组成。\n\n* 其中Loggers控制日志的输出以及输出级别;Appenders指定日志的输出方式 ; Layout 控制日志信息的输出格式。\n\n* Loggers：\n  * 日志记录器，负责收集处理日志记录，实例的命名就是类的全限定名。\n  * Loggers的大小写敏感，其命名有继承机制。\n  * Log4j中有一个特殊的Logger叫做“root”。他是所有logger 的根，也就意味着其他所有的logger 都会直接或者间接地继承自root。root logger 可以用Logger.getRootI ogger()方法获取。\n  \n* Appenders：\n\n  * Appender 用来指定日志输出到哪个地方，可以同时指定日志的输出目的地。\n  * Log4j 常用的输出目的地有以下几种：\n\n  | 输出终端类型             | 作用                                                         |\n  | ------------------------ | ------------------------------------------------------------ |\n  | ConsoleAppender          | 将日志输出到控制台                                           |\n  | FileAppender             | 将日志输出到文件中                                           |\n  | DailyRollingFileAppender | 将日志输出到一个日志文件，并且每天输出到一个新的文件         |\n  | RollingFileAppender      | 将日志信息输出到一个日志文件，并且指定文件的尺寸，当文件大<br/>小达到指定尺寸时，会自动把文件改名，同时产生一个新的文件 |\n  | JDBCAppender             | 把日志信息保存到数据库中                                     |\n\n* Layouts\n\n  * 布局器 Layouts用于控制日志输出内容的格式，让我们可以使用各种需要的格式输出日志。\n  * Log4j常用的Layouts:\n\n  | 格式化器类行  | 作用                                                         |\n  | ------------- | ------------------------------------------------------------ |\n  | HTMLLayout    | 格式化日志输出为HTML表格形式                                 |\n  | SimpleLayout  | 简单的日志输出格式化，打印的日志格式为（info - message）     |\n  | PatternLayout | 可以根据自定义格式输出日志，如果没有指定转换格式，就是用默认的转换格式 |\n\n\n\n## 格式化符号\n\n```markdown\n# log4j 采用类似 C 语言的 printf 函数的打印格式格式化日志信息，具体的占位符及其含义如下：\n\t%m 输出代码中指定的日志信息 \n\t%p 输出优先级，及 DEBUG、INFO 等 \n\t%n 换行符（Windows平台的换行符为 \"\\n\"，Unix 平台为 \"\\n\"） \n\t%r 输出自应用启动到输出该 log 信息耗费的毫秒数 \n\t%c 输出打印语句所属的类的全名 \n\t%t 输出产生该日志的线程全名 \n\t%d 输出服务器当前时间，默认为 ISO8601，也可以指定格式，如：%d{yyyy年MM月dd日 HH:mm:ss}\n\t%l 输出日志时间发生的位置，包括类名、方法名、及在代码中的行数。如： Test.method(Test.java:10) \n\t%F 输出日志消息产生时所在的文件名称 \n\t%L 输出代码中的行号 %% 输出一个 \"%\" 字符\n# 可以在 % 与字符之间加上修饰符来控制最小宽度、最大宽度和文本的对其方式。如：\n\t%5c 输出logger名称，最小宽度是5，category<5，默认的情况下右对齐 \n\t%-5c 输出logger名称，最小宽度是5，category<5，\"-\"号指定左对齐,会有空格 \n\t%.5c 输出logger名称，最大宽度是5，category>5，就会将左边多出的字符截掉，<5不 会有空格 \n\t%20.30c logger名称<20补空格，并且右对齐，>30字符，就从左边交远销出的字符截掉\n```\n\n\n\n## 日志级别\n\n```markdown\n\n# Log4j提供了8个级别的日志输出，分别为\n\tALL\t-- Integer.MIN_VALUE -- 最低等级用于打开所有级别的日志记录\n\tTRACE -- 5000 -- 程序推进下的追踪信息，这个追踪信息的日志级别非常低，一般情况下是不会使用的\n\tDEBUG -- 10000 -- 指出细粒度信息事件对调试应用程序是非常有帮助的，\n\t\t\t\t\t\t主要是配合开发，在开发过程中打印一些重要的运行信息\n\tINFO -- 20000 -- 消息的粗粒度级别运行信息|\n\tWARN -- 30000 -- 表示警告，程序在运行过程中会出现的有可能会发生的隐形的错误\n\t\t\t\t\t\t注意，有些信息不是错误，但是这个级别的输出目的就是为了给程序员以提示.\n\tERROR -- 40000 -- 系统的错误信息，发生的错误不影响系统的运行\n\t\t\t\t\t\t一般情况下，如果不想输出太多的日志，则使用该级别即可\n\tFATAL -- 50000 -- 表示严重错误，它是那种一旦发生系统就不可能继续运行的严重错误\n\t\t\t\t\t\t如果这种级别的错误出现了，表示程序可以停止运行了\n\t0FF -- Integer.MAX_VALUE -- 最高等级的级别，用户关闭所有的日志记录\n- 如果设置的日志级别为 INFO -- 20000 。则最终只会显示级别大于等于20000的日志信息。\n- 默认的日志级别是 DEBUG -- 10000\n```\n\n\n\n## 配置文件\n\n* 配置文件的种类：log4j.properties / log4j.xml\n\n* 配置文件的地址：当前项目的资源目录下。例如maven项目的在resources下\n\n* log4j.properties配置文件解析\n\n  ```properties\n  # 配置根logger的属性。第一个参数为日志级别。往后的参数为appender的名字\n  # log4j.rootLogger=日志级别,appenderName1,appenderName2,,,\n  # log4j.rootLogger=trace,console,custom\n  # log4j.rootLogger=trace,file\n  \n  # 配置自定义父logger的属性。一般设置包的logger作为父logger\n  # 如果根logger和父logger的输出和级别不同。\n  #  则输出选择二者的并集。级别选择父logger的级别\n  # 设置路径为com.lc的logger的属性：日志级别为info。日志输出为file\n  log4j.logger.com.lc=info,file\n  \n  # 配置 给ConsoleAppender 起个名字为console 。即ConsoleAppender的appenderName为console\n  log4j.appender.console=org.apache.log4j.ConsoleAppender\n  #  配置输出的格式\n  log4j.appender.console.layout=org.apache.log4j.SimpleLayout\n  \n  #  PatternLayout 的使用\n  log4j.appender.custom=org.apache.log4j.ConsoleAppender\n  log4j.appender.custom.layout=org.apache.log4j.PatternLayout\n  # 设置 自定义的输出日志输出\n  log4j.appender.custom.layout.conversionPattern=%m%n %p%n %r%n %c%n %t%n %d%n %l%n %F%n %L%n %%\n  \n  # FileAppender 的使用。各种属性以set方法为名字\n  log4j.appender.file=org.apache.log4j.FileAppender\n  log4j.appender.file.layout=org.apache.log4j.SimpleLayout\n  # 设置日志文件的路径（file属性）。文件路径为绝对路径\n  log4j.appender.file.file=E:\\\\JavaStudent\\\\logger\\\\log4j-logger\\\\log\\\\log4j.log\n  # 是否附加到已有日志文件后面。默认为true,即追加\n  log4j.appender.file.append=true\n  # 设置日志文件的大小。默认为8K-->8*1024\n  log4j.appender.file.bufferSize=8192\n  # 设置是否使用缓冲。默认为false\n  log4j.appender.file.bufferedIO=false\n  # 设置日志文件内容的字符编码\n  log4j.appender.file.encoding=UTF-8\n  \n  # RollingFileAppender的使用。滚动式的更新文件。是FileAppender的子类。\n  log4j.appender.rollingFile=org.apache.log4j.RollingFileAppender\n  log4j.appender.rollingFile.layout=org.apache.log4j.SimpleLayout\n  # 设置文件的大小。默认10M-->10*1024*1024 。long型\n  log4j.appender.rollingFile.maxFileSize=1048576\n  # 设置文件的数量。默认1个。\n  log4j.appender.rollingFile.maxBackupIndex=org.apache.log4j.SimpleLayout\n  # 。。。文件的地址\n  \n  # DailyRollingFileAppednder的使用。按照时间更新文件。是FileAppender的子类。\n  log4j.appender.dailyRollingFile=org.apache.log4j.DailyRollingFileAppender\n  log4j.appender.dailyRollingFile.layout=org.apache.log4j.SimpleLayout\n  # 设置更新的日期格式。默认为\"'.'yyyy-MM-dd\"，以天为更新日期。注意前面要有单引号。\n  # 日期格式参照SimpleDateFormat类\n  log4j.appender.dailyRollingFile.datePattern='.'yyyy-MM-dd HH:mm:ss\n  # 。。。文件的地址\n  \n  # JDBCAppender的使用。将日志保存在数据库中\n  log4j.appender.jdbc=org.apache.log4j.jdbc.JDBCAppender\n  # 数据库的字段名和格式一一对象\n  log4j.appender.jdbc.layout=org.apache.log4j.PatternLayout\n  log4j.appender.jdbc.layout.conversionPattern=%p %l %t %f %d{yyyy年MM月dd日 HH:mm:ss}\n  log4j.appender.jdbc.URL=jdbc:mysql://localhost:3306/test\n  log4j.appender.jdbc.Driver=com.mysql.jdbc.Driver\n  log4j.appender.jdbc.Password=root\n  log4j.appender.jdbc.User=root\n  # 往数据库中插入数据的sql语句。sql语句写在一行中。不要换行\n  log4j.appender.jdbc.Sql=INSERT INTO log(name,level,position,threadName,fileName,createName) VALUES('project_log','%p','%l','%t','%f','%d{yyyy-MM-dd HH:mm:ss}')\n  \n  ```\n\n\n\n## 自定义logger\n\n* 如果根logger和父logger的输出和级别不同。\n  * 则输出选择二者的**并集**。级别选择父logger的级别。\n\n```properties\n# 配置根logger的属性。第一个参数为日志级别。往后的参数为appender的名字\n# log4j.rootLogger=日志级别,appenderName1,appenderName2,,,\n# log4j.rootLogger=trace,console,custom\n# log4j.rootLogger=trace,file\n\n# 配置自定义父logger的属性。一般设置包的logger作为父logger。\n# 设置路径为com.lc的logger的属性：日志级别为info。日志输出为file\nlog4j.logger.com.lc=info,file\n# 也可以设置经停某个jar包中的某个类的执行情况\nlog4j.logger.org.apache.log4j=info,file \n```\n\n* 应用场景：\n  * 可以打印jar包中的某个类或者某个包的使用的日志。\n\n\n\n## 示例\n\n```java\n/**\n * 简单使用：\n *  第一步：加载配置初始化\n *  第二步：创建logger对象\n *  第三步：使用logger对象\n *\n * LogLog是对Logger的监听日志。默认是关闭的。需要手动开启\n *    LogLog.setInternalDebugging(true);\n * LogLog开启后会打印Logger初始化时的详细信息\n *\n */\npublic class Log4jTest {\n\n  @Test\n  public void test1() {\n\n    // 使用默认的加载初始化配置\n    /*****\n    BasicConfigurator.configure();\n\n    Logger logger = Logger.getLogger(Log4jTest.class);\n    logger.info(\"hello info log4j\");\n    *****/\n\n    // 使用自定的加载配置\n\n    // 开启LogLog的功能\n    LogLog.setInternalDebugging(true);\n\n    Logger logger = Logger.getLogger(Log4jTest.class);\n    logger.fatal(\"hello info log4j\");\n//    logger.error(\"hello info log4j\");\n//    logger.warn(\"hello info log4j\");\n//    logger.info(\"hello info log4j\");\n//    logger.debug(\"hello info log4j\");\n//    logger.trace(\"hello info log4j\");\n    \n  }\n}\n```\n\n\n\n# JCL\n\n* 全称为Jakarta Commons Logging,是Apache提供的一个通用日志API。\n* 用户可以自由选择第三方的日志组件作为具体实现，像log4j，或者jdk 自带的jul,common-logging会通过动态查找的机制，在程序运行时自动找出真正使用的日志库。\n* 当然，common-logging 内部有一个Simple logger 的简单实现，但是功能很弱。所以使用common-logging，通常都是配合着log4j 以及其他日志框架来使用。\n* 使用它的好处就是,代码依赖是common-logging而非log4j的API，避免 了和具体的日志API直接耦合，在有必要时，可以更改日志实现的第三方库。\n* JCL有两个基本的抽象类:\n  * Log:日志记录器\n  * LogFactory:日志工厂(负责创建Log实例)\n* 引入依赖：\n\n```xml\n<dependency>\n  <groupId>commons-logging</groupId>\n  <artifactId>commons-logging</artifactId>\n  <version>1.2</version>\n</dependency>\n```\n\n* 日志级别\n\n```markdown\n# 和log4j的日志级别类似\n\twarn\n\ttrace\n\tinfo\n\tfatal\n\terror\n\tdebug\n```\n\n* 示例\n\n```java\n@Test\npublic void test1(){\n  // JCL和JUL的结合使用。\n  // 在没有引入第三方依赖时，默认JCL的实现为JUL\n  Log log = LogFactory.getLog(JclTest.class);\n  log.info(\"hello jcl info\");\n\n}\n@Test\npublic void test2(){\n  // JCL和Log4j的结合使用。首先先引入依赖,然后添加log4j.properties文件以初始化logger\n  Log log = LogFactory.getLog(JclTest.class);\n  log.info(\"hello jcl info\");\n}\n```\n\n\n\n# SLF4J\n\n* 简单日志门面(Simple Logging Facade For Java) SLF4J主要是为了给Java日志访问提供一套标准、规范的API框架，其主要意义在于提供接口，具体的实现可以交由其他日志框架，例如log4j和logback等。\n* 当然slf4j自己也提供了功能较为简单的实现，但是一般很少用到。对于一般的Java项目而言，日志框架会选择slf4j-api作为门面，配上具体的实现框架（log4j、logback等），中间使用桥接器完成桥接。\n* 官方网站： https://www.slf4j.org/\n* SLF4J日志门面主要提供两大功能：\n  * 日志框架的绑定 \n  * 日志框架的桥接：由于slf4j是在log4j，jul之后出现的，因此它们两个和slf4j的结合不是很好，因此需要有桥接技术。\n* 相关依赖：\n\n```xml\n    <!--slf4j 的核心依赖-->\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-api</artifactId>\n      <version>1.7.31</version>\n    </dependency>\n\n    <!--slf4j 的自带简单日志实现-->\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-simple</artifactId>\n      <version>1.7.31</version>\n    </dependency>\n\n    <!-- log4j 的适配依赖-->\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-log4j12</artifactId>\n      <version>1.7.31</version>\n    </dependency>\n    <!--log4j 的核心依赖-->\n    <dependency>\n      <groupId>log4j</groupId>\n      <artifactId>log4j</artifactId>\n      <version>1.2.17</version>\n    </dependency>\n    <!-- jul 的适配依赖-->\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-jdk14</artifactId>\n      <version>1.7.31</version>\n    </dependency>\n\n    <!--jcl 的适配依赖-->\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-jcl</artifactId>\n      <version>1.7.31</version>\n    </dependency>\n\n    <!-- nop 的核心依赖-->\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-nop</artifactId>\n      <version>1.7.31</version>\n    </dependency>\n\n```\n\n\n\n## 日志级别\n\n* 默认日志级别为INFO\n* 日志级别为trace,debug,info,warn,error。\n\n\n\n## 日志的绑定\n\n* SLF4J的绑定情况\n  * 没有绑定任何日志实现时，日志是不能打印的。\n  * logback和slf4j-simple和nop，因为是在slf4j之后出现的，因此和slf4j的无缝衔接。只需要提供相应的jar包或依赖就可以使用。\n    * 注意nop虽然也是日志实现，但是不实现日志记录。当它放在所有日志实现的依赖的上方时，会关闭日志记录功能。\n  * log4j和jul因为是在slf4j之前出现的，因此需要通过适配桥接技术完成与日志门面的衔接。\n* 整体架构图\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210728144141.png)\n\n\n\n## 日志的桥接\n\n* 例如：现在又一个使用log4j日志的项目。现在需要将它转成slf4j+logback的日志。\n\n  * 第一步：删除log4j的所有相关依赖。\n  * 第二步：添加log4j转slf4j的桥接器。\n  * 第三步：添加logback的依赖。\n\n* 在上述过程中的第二步的转换的桥接器。总共有三个分别是log4j,jcl,jul转slf4j的桥接器。\n\n  ```xml\n  <!-- log4j 转 slf4j 的桥接器-->\n  <dependency>\n    <groupId>org.slf4j</groupId>\n    <artifactId>log4j-over-slf4j</artifactId>\n    <version>1.7.31</version>\n  </dependency>\n  <!-- jul 转 slf4j 的桥接器-->\n  <dependency>\n    <groupId>org.slf4j</groupId>\n    <artifactId>jul-to-slf4j</artifactId>\n    <version>1.7.31</version>\n  </dependency>\n  <!--jcl 转 slf4j 的桥接器-->\n  <dependency>\n    <groupId>org.slf4j</groupId>\n    <artifactId>jcl-over-slf4j</artifactId>\n    <version>1.7.31</version>\n  </dependency>\n  ```\n\n* 注意：当使用桥接器后，slf4j-api的依赖可以不添加，原日志和slf4j的适配器的依赖不要添加。\n\n* 所有的桥接都只对Logger日志记录器对象有效，如果程序中调用了内部的配置类或者是Appender,Filter等对象，将无法产生效果。\n\n\n\n## 多个日志实现都引用的异常\n\n* 默认会使用第一个引用的日志实现的依赖\n\n```markdown\n# 多个日志实现都引用的异常\n\tSLF4J: Class path contains multiple SLF4J bindings.\n```\n\n## 示例\n\n```java\n@Test\npublic void test1(){\n  // 简单使用\n  Logger logger = LoggerFactory.getLogger(Slf4jTest.class);\n  logger.info(\"hello info slf4j\");\n  logger.error(\"hello error slf4j\");\n  logger.trace(\"hello trace slf4j\");\n  logger.warn(\"hello warn slf4j\");\n  logger.debug(\"hello debug slf4j\");\n}\n@Test\npublic void test2(){\n  // 动态拼接字符串。占位符的方式\n  Logger logger = LoggerFactory.getLogger(Slf4jTest.class);\n  String name = \"lisi\";\n  int age = 10;\n  logger.info(\"hello info slf4j name={},age={}\",name,age);\n}\n@Test\npublic void test3(){\n  // 日志打印异常信息的使用。具体使用的是info(String msg, Throwable t)方法\n  Logger logger = LoggerFactory.getLogger(Slf4jTest.class);\n  try {\n    int i = 10/0;\n  }catch (Exception e){\n    logger.info(\"计算10/0\",e);\n  }\n}\n@Test\npublic void test4(){\n  // 和log4j的适配\n  // 第一步：导入log4j的依赖和slf4j-log4j12的依赖\n  // 第二步：创建log4j的配置文件\n  // 第三步: 正常使用即可\n  Logger logger = LoggerFactory.getLogger(Slf4jTest.class);\n  logger.info(\"hello slf4j log4j info\");\n}\n```\n\n\n\n# Logback\n\n* Logback主要分为三个模块：\n\n  * logback-core：其它两个模块的基础模块\n  * logback-classic：它是log4j的一个改良版本，同时它完整实现了slf4j API\n  * logback-access：访问模块与Servlet容器集成提供通过Http来访问日志的功能\n\n* logback的组件和log4j非常类似。组件大致相同。\n\n  * 不同 在于：logback中layout被封装在encoder中。即encoder就是layout\n\n* 配置文件：\n\n  ```\n  logback.groovy\n  logback-test.xml\n  logback.xml\n  ```\n\n* 日志输出格式\n\n  ```\n  %level -- 级别\n  %d{yyyy-MM-dd HH:mm:ss.SSS} -- 日期\n  %c -- 当前类全限定名\n  %M -- 当前执行日志的方法\n  %L -- 行号\n  %thread -- 线程名称\n  %m 或者 %msg -- 信息\n  %n -- 换行\n  ```\n\n* 日志级别：\n\n  ```\n  trace < debug < info < warn < error\n  默认日志级别为 debug\n  ```\n\n\n\n## 配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <!--\n    配置文件通用属性:<property name=\"\" value=\"\">\n      可以通过${name}的方式取得value值。相当于Java中定义一个变量，然后通过name取值\n  -->\n  <!--配置固定的日期格式-->\n  <property name=\"timePattern\" value=\"[%-5level] %d{yyyy-MM-dd HH:mm:ss.SSS} %c %M %L %thread %m%n\"></property>\n  <!--配置html固定的日期格式-->\n  <property name=\"htmlPattern\" value=\"%level%d{yyyy-MM-dd HH:mm:ss.SSS}%c%M%L%thread%m\"></property>\n  <!--配置固定的日志文件路径-->\n  <property name=\"fileDir\" value=\"E:\\\\JavaStudent\\\\logger\\\\logback-logger\\\\log\"></property>\n\n  <!--设置一个文件Appender-->\n  <appender name=\"fileAppender\" class=\"ch.qos.logback.core.FileAppender\">\n    <!--设置文件地址-->\n    <file>${fileDir}\\\\logback.log</file>\n    <encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\">\n      <pattern>${timePattern}</pattern>\n    </encoder>\n  </appender>\n\n  <!--设置一个控制台Appender-->\n  <appender name=\"consoleAppender\" class=\"ch.qos.logback.core.ConsoleAppender\">\n    <!--配置日志的字体颜色：System.out 黑色字体。System.err 红色字体-->\n    <target>System.err</target>\n    <!--配置日志的输出格式-->\n    <encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\">\n      <pattern>${timePattern}</pattern>\n    </encoder>\n  </appender>\n\n  <!--设置一个html文件的fileAppender。文件的内容我们可以指定，文件的样式和格式的由系统指定-->\n  <appender name=\"htmlFileAppender\" class=\"ch.qos.logback.core.FileAppender\">\n    <file>${fileDir}\\\\logback.html</file>\n    <encoder class=\"ch.qos.logback.core.encoder.LayoutWrappingEncoder\">\n      <!--这里可以指定html,xml,-->\n      <layout class=\"ch.qos.logback.classic.html.HTMLLayout\">\n        <pattern>${htmlPattern}</pattern>\n      </layout>\n    </encoder>\n  </appender>\n\n  <!--设置一个更新文件的Appender-->\n  <appender name=\"rollingFileAppender\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n    <!--引入文件地址-->\n    <file>${fileDir}\\\\roll_logback.log</file>\n    <encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\">\n      <pattern>${timePattern}</pattern>\n    </encoder>\n    <!--指定拆分规则：-->\n    <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n      <!--指定文件的大小-->\n      <maxFileSize>1KB</maxFileSize>\n      <!--按照时间和压缩格式生命文件名，压缩格式gz-->\n      <fileNamePattern>${fileDir}\\\\roll.%d{yyyy-MM-dd}.log%i.gz</fileNamePattern>\n    </rollingPolicy>\n  </appender>\n\n\n  <!--设置加过滤器的控制台Appender-->\n  <appender name=\"consoleFilterAppender\" class=\"ch.qos.logback.core.ConsoleAppender\">\n    <target>System.err</target>\n    <encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\">\n      <pattern>${timePattern}</pattern>\n    </encoder>\n    <!--添加过滤器-->\n    <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n      <!--设置过滤器过滤的级别-->\n      <level>ERROR</level>\n      <!--设置只有级别大于level的才能被输出-->\n      <onMatch>ACCEPT</onMatch>\n      <!--设置级别低于level的不打印-->\n      <onMismatch>DENY</onMismatch>\n    </filter>\n  </appender>\n\n  <!--配置根logger的属性\n    name :指定logger的路径\n    level ：指定logger的日志级别\n  -->\n  <root level=\"ALL\">\n<!--    <appender-ref ref=\"consoleAppender\"></appender-ref>-->\n<!--    <appender-ref ref=\"fileAppender\"></appender-ref>-->\n    <appender-ref ref=\"consoleFilterAppender\"></appender-ref>\n  </root>\n\n</configuration>\n```\n\n\n\n## 异步日志\n\n* logback默认使用同步日志的方式。\n\n  * 缺点是：在打印日志时会占用CPU，此时的项目不能很好的运行。\n\n* 异步日志的开启\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n  <configuration>\n    <property name=\"timePattern\" value=\"[%-5level] %d{yyyy-MM-dd HH:mm:ss.SSS} %c %M %L %thread %m%n\"></property>\n    <!--配置异步Appender-->\n    <appender name=\"asyncAppender\" class=\"ch.qos.logback.classic.AsyncAppender\">\n      <!--引入需要异步执行的Appender-->\n      <appender-ref ref=\"consoleAppender\"></appender-ref>\n    </appender>\n    <appender name=\"consoleAppender\" class=\"ch.qos.logback.core.ConsoleAppender\">\n      <target>System.err</target>\n      <encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\">\n        <pattern>${timePattern}</pattern>\n      </encoder>\n    </appender>\n    <root level=\"ALL\">\n      <appender-ref ref=\"asyncAppender\"></appender-ref>\n    </root>\n  </configuration>\n  ```\n\n* 异步的原理是：给日志单独分配一个线程。日志线程会和主线程争夺CPU执行。\n\n* 补充:\n\n```\n配置了一个阈值\n当队列的剩余容量小于这个阈值的时候，当前日志的级别trace、 debug、 info这3个级别的日志将被丢弃\n设置为-1，说明永远都不会丢弃trace、debug、info这3个级别的日志\n<discardingThreshold>-1</discardingThreshold>\n配置队列的深度，这个值会影响记录日志的性能，默认值就是256\n<queueSize>256</ queueSize>\n关于这两个属性，一般情况下，我们使用默认值即可\n```\n\n\n\n## 自定义logger\n\n* 自定义的logger的由于是rootlogger的子logger。因此执行时会根据自定义的logger属性来设置\n\n```xml\n<!--自定义logger.自定义logger，比rootLogger优先级高.\n    additivity=false 表示不继承rootLogger的属性\n  -->\n<logger name=\"com.lc\" level=\"info\" additivity=\"false\">\n  <appender-ref ref=\"consoleAppender\"></appender-ref>\n</logger>\n```\n\n\n\n## 配置文件转换器\n\n* 主要将log4j的properties文件转换成logback的xml文件\n  * 详细内容在logback的官网上。\n* 这个转换只会转换两者兼用的配置。因此不怎么建议使用\n\n\n\n## 示例\n\n```java\npublic void test1(){\n  // 注意引入的包为org.slf4j下的\n  Logger logger = LoggerFactory.getLogger(LogbackTest.class);\n  logger.error(\"hello info logback\");\n  logger.warn(\"hello info logback\");\n  logger.info(\"hello info logback\");\n  logger.debug(\"hello info logback\");\n  logger.trace(\"hello info logback\");\n}\n```\n\n\n\n# Log4j2\n\n* 特点：\n\n```markdown\n# 性能提升\n\tLog4j2包含基于LMAX Disruptor库的下一代异步记录器。在多线程场景中，异步记录器的吞吐量比Log4j 1.x和Logback高18倍，延迟低。\n# 自动重新加载配置\n\t与Logback一样，Log4j2可以在修改时自动重新加载其配置。与Logback不同，它会在重新配置发生时不会丢失日志事件。\n# 高级过滤\n\t与Logback一样，Log4j2 支持基于Log事件中的上下文数据，标记，正则表达式和其他组件进行过滤。\n\t此外，过滤器还可以与记录器关联。与Logback不同，Log4j2 可以在任何这些情况下使用通用的Filter类。\n# 插件架构\n\tLog4j使用插件模式配置组件。因此，您无需编写代码来创建和配置Appender, Layout,Pattern Converter等。在配置了的情况下，Log4j自动识别插件并使用它们。\n# 无垃圾机制\n\t在稳态日志记录期间，Log4j2在独立应用程序中是无垃圾的，在Web应用程序中是低垃圾。这减少了垃圾收集器的压力，并且可以提供更好的响应性能。\n```\n\n* 官网： https://logging.apache.org/log4j/2.x/\n* 相关依赖\n\n```xml\n<!--log4j-core依赖中内置了log4j-api依赖。log4j-core为日志实现 log4j-api为日志门面-->\n<dependency>\n  <groupId>org.apache.logging.log4j</groupId>\n  <artifactId>log4j-core</artifactId>\n  <version>2.14.1</version>\n</dependency>\n<!--导入slf4j的依赖-->\n<dependency>\n  <groupId>org.slf4j</groupId>\n  <artifactId>slf4j-api</artifactId>\n  <version>1.7.32</version>\n</dependency>\n<!--slf4j和log4j2的适配器-->\n<dependency>\n  <groupId>org.apache.logging.log4j</groupId>\n  <artifactId>log4j-slf4j-impl</artifactId>\n  <version>2.14.1</version>\n</dependency>\n<!--log4j2异步日志的支持依赖-->\n<dependency>\n  <groupId>com.lmax</groupId>\n  <artifactId>disruptor</artifactId>\n  <version>3.4.4</version>\n</dependency>\n```\n\n\n\n## 简单配置文件\n\n* 涉及到的类AbstractFilterable的子类。AbstractTriggeringPolicy的子类\n\n```xml\n<?xml version=\"1.1\" encoding=\"UTF-8\" ?>\n<Configuration>\n  <!--Configuration 标签的属性设置\n  status=debug ：对日志框架的日志记录以debug的级别记录\nmonitorInterval=数值 设置自动加载配置文件的间隔。单位 秒\n  -->\n\n  <Properties>\n    <Property name=\"pattern\">%d %l %m%n</Property>\n    <Property name=\"logDir\">E:\\\\JavaStudent\\\\logger\\\\log4j2-logger\\\\log</Property>\n  </Properties>\n\n  <Appenders>\n    <Console name=\"consoleAppender\" target=\"SYSTEM_ERR\">\n      <PatternLayout pattern=\"${pattern}\" ></PatternLayout>\n    </Console>\n\n    <File name=\"fileAppender\" fileName=\"${logDir}\\\\lof4j2.log\">\n      <PatternLayout pattern=\"${pattern}\"></PatternLayout>\n    </File>\n\n    <!--按照指定规则拆分日志\n    fileName ：日志文件的名字\n    filePattern : 拆分后文件的命名格式\n      $${date:yyy-MM-dd} ：表示根据年月日创建一个文件夹，即一天一个文件夹。\n      rollog-%d{yyyy-MM-dd-HH-mm}-%i.log ：指具体的拆分后文件的名字格式\n    -->\n    <RollingFile name=\"rollingFileAppender\"\n                 fileName=\"${logDir}\\\\roll_lof4j2.log\"\n                 filePattern=\"${logDir}\\\\$${date:yyy-MM-dd}\\\\rollog-%d{yyyy-MM-dd-HH-mm}-%i.log\">\n      <PatternLayout pattern=\"${pattern}\"></PatternLayout>\n      <Policies>\n        <!--子标签都是AbstractTriggeringPolicy的子类-->\n\n        <!--设置在系统启动时，触发拆分规则，产生一个日志文件-->\n        <OnStartupTriggeringPolicy/>\n        <!--按照时间大小进行拆分-->\n        <SizeBasedTriggeringPolicy size=\"10KB\"/>\n        <!--按照时间节点进行拆分。拆分规则是filePattern属性-->\n        <TimeBasedTriggeringPolicy/>\n      </Policies>\n\n      <!--设置同意目录下文件的个数最多为30.如果超过则按照时间覆盖-->\n      <DefaultRolloverStrategy max=\"30\"/>\n\n    </RollingFile>\n\n  </Appenders>\n  <Loggers>\n    <!--配置root logger-->\n    <Root level=\"trace\">\n<!--      <AppenderRef ref=\"consoleAppender\"></AppenderRef>-->\n<!--      <AppenderRef ref=\"fileAppender\"></AppenderRef>-->\n      <AppenderRef ref=\"rollingFileAppender\"></AppenderRef>\n    </Root>\n  </Loggers>\n</Configuration>\n```\n\n\n\n## 异步日志\n\n* Log4j2提供了两种日志的实现方式：\n  * 一个是通过AsyncAppender。对应Appender组件\n  * 一个是通过AsyncLogger。对应Logger组件。\n* 两个实现方式在设计以及原理上都是不相同的。\n* 异步：指另外创建一个子线程来做日志记录，而不影响主线程的执行。\n* AsyncAppender和AsyncLogger不要同时出现。如果同时出现会以AsyncAppender为主。\n* 使用异步日志首先要添加异步日志的依赖\n\n```xml\n<!--log4j2异步日志的支持依赖-->\n<dependency>\n  <groupId>com.lmax</groupId>\n  <artifactId>disruptor</artifactId>\n  <version>3.4.4</version>\n</dependency>\n```\n\n\n\n### AsyncAppender方式\n\n* 是通过引用别的Appender来实现的。\n* 当有日志事件到达时，会开启另外一个线程来处理它们。\n* 需要注意的是，如果在Appender的时候出现异常，对应用来说是无法感知的。\n* AsyncAppender应该在它引用的Appender之后配置，默认使用java.til.concurent.ArrayBlockingQueue实现而不需要其它外部的类库。\n* 当使用此Appender的时候，在多线程的环境下需要注意，阻塞队列容易受到锁争用的影响，这可能会对性能产生影响。\n* 这时候，我们应该考虑使用无锁的异步记录器(AsyncLogger)。\n* 配置方式\n\n```xml\n<!--要先引入异步的依赖-->\n<?xml version=\"1.1\" encoding=\"UTF-8\" ?>\n<Configuration>\n  <Properties>\n    <Property name=\"pattern\">%d %l %m%n</Property>\n    <Property name=\"logDir\">E:\\\\JavaStudent\\\\logger\\\\log4j2-logger\\\\log</Property>\n  </Properties>\n  <Appenders>\n    <Console name=\"consoleAppender\" target=\"SYSTEM_ERR\">\n      <PatternLayout pattern=\"${pattern}\" ></PatternLayout>\n    </Console>\n\n    <!--配置异步Appender-->\n    <Async name=\"myAsync\">\n      <!--将控制台输出做异步操作-->\n      <AppenderRef ref=\"consoleAppender\"></AppenderRef>\n    </Async>\n  </Appenders>\n  <Loggers>\n    <!--配置root logger-->\n    <Root level=\"trace\">\n      <AppenderRef ref=\"myAsync\"></AppenderRef>\n    </Root>\n  </Loggers>\n</Configuration>\n```\n\n\n\n### AsyncLogger方式(推荐)\n\n* AsyncLogger方式提供了两种配置：全局异步，混合异步。\n\n* 混合异步和全局异步不要同时出现。\n\n* 全局异步：\n\n  * 所有的日志都异步的记录，在配置文件上不用做任何改动。\n  * 配置全局异步时，不要配置AsyncAppender。\n\n* 混合异步:(推荐)\n\n  * 你可以在应用中同时使用同步日志和异步日志，这使得日志的配置方式更加灵活。\n  * 虽然Log4j2提供以一套异常处理机制，可以覆盖大部分的状态，但是还是会有一小部分的特殊情况是无法完全处理的，比如我们如果是记录审计日志(特殊情况之一)，那么官方就推荐使用同步日志的方式，而对于其他的一些仅仅是记录一个程序日志的地方，使用异步日志将大幅提升性能，减少对应用本身的影响。\n  * 混合异步的方式需要通过修改配置文件来实现，**使用AsyncLogger标记配置**。\n\n* 全局异步的实现：\n\n  * 在资源路径下创建名为`log4j2.component.properties`的文件\n  * 在文件中添加如下内容\n\n  ```properties\n  Log4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector\n  ```\n\n  * log4j2的配置文件中不要配置AsyncAppender，其他的任意配置即可。\n\n* 混合异步的实现：\n\n  * 由于log4j2默认是同步的，因此只需要在想异步的地方配置异步即可。\n\n```xml\n<?xml version=\"1.1\" encoding=\"UTF-8\" ?>\n<Configuration>\n  <Properties>\n    <Property name=\"pattern\">%d %l %m%n</Property>\n    <Property name=\"logDir\">E:\\\\JavaStudent\\\\logger\\\\log4j2-logger\\\\log</Property>\n  </Properties>\n\n  <Appenders>\n    <Console name=\"consoleAppender\" target=\"SYSTEM_ERR\">\n      <PatternLayout pattern=\"${pattern}\" ></PatternLayout>\n    </Console>\n  </Appenders>\n  <Loggers>\n\n    <!--自定义Logger  让这个logger为异步输出\n      includeLocation=\"false\" 表示去除日志记录中的行号信息，这个行号信息非常的影响日志记录的效率(生产中都不加这个行号)\n        严重的时候可能记录的比同步的日志效率还有低\n      additivity=\"false\" 表示不继承rootLogger\n\n    -->\n    <AsyncLogger name=\"com.lc.async\" level=\"trace\" includeLocation=\"false\" additivity=\"false\">\n      <!--将此Logger的日志输出设置为控制台输出-->\n      <AppenderRef ref=\"consoleAppender\"></AppenderRef>\n    </AsyncLogger>\n\n    <!--配置root logger-->\n    <Root level=\"trace\">\n      <AppenderRef ref=\"consoleAppender\"></AppenderRef>\n    </Root>\n  </Loggers>\n</Configuration>\n```\n\n\n\n# SpringBoot日志的使用\n\n* SpringBoot默认使用SLF4J作为日志门面，Logback 作为日志实现来记录日志。\n\n* 在application.properties中可以配置一些日志的简单配置。\n\n* 日志的具体配置仍需要日志配置文件进行配置。\n\n* Logback日志和生产环境的集合使用：\n\n  ```xml\n  <encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\">\n    <springProfile name=\"dev\">\n      <pattern>${timePattern}</pattern>\n    </springProfile>\n    <springProfile name=\"pro\">\n      <pattern>%d{yyyy-MM-dd:HH:mm:ss.SSS} [%thread] %-5level %msg%n</pattern>\n    </springProfile>\n  </encoder>\n  \n  spring.profiles.active=dev\n  ```\n\n* 当使用配置文件的形式时，application.properties中的配置将会被覆盖。\n\n* 改Logback的日志实现为Log4j2日志实现\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter</artifactId>\n  <exclusions>\n    <!--剔除SpringBoot中关于Looging的实现-->\n    <exclusion>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-logging</artifactId>\n    </exclusion>\n  </exclusions>\n</dependency>\n<!--log4j-core依赖中内置了log4j-api依赖。log4j-core为日志实现 log4j-api为日志门面-->\n<dependency>\n  <groupId>org.apache.logging.log4j</groupId>\n  <artifactId>log4j-core</artifactId>\n</dependency>\n<!--slf4j和log4j2的适配器-->\n<dependency>\n  <groupId>org.apache.logging.log4j</groupId>\n  <artifactId>log4j-slf4j-impl</artifactId>\n</dependency>\n<!--log4j2异步日志的支持依赖-->\n<dependency>\n  <groupId>com.lmax</groupId>\n  <artifactId>disruptor</artifactId>\n  <version>3.4.4</version>\n</dependency>\n<!--搭配@Slf4j注解的使用-->\n<dependency>\n  <groupId>org.projectlombok</groupId>\n  <artifactId>lombok</artifactId>\n</dependency>\n```","categories":["Java学习","中间件"]},{"title":"SpringJPA的学习","url":"/2021/07/15/学习/技术架构/SpringJPA/","content":"\n* JPA简单使用\n\n<!--more-->\n\n\n\n* 引入的依赖\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter</artifactId>\n  <version>2.1.11.RELEASE</version>\n</dependency>\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-jpa</artifactId>\n  <version>2.1.11.RELEASE</version>\n</dependency>\n```\n\n* 配置文件\n\n```yaml\nspring:\n  data:\n    jpa:\n      repositories:\n        # 存储库的存储模式\n        bootstrap-mode: default\n        enabled: true\n  jpa:\n    # 数据库方言，自动检测即可。示例\n    # database-platform:\n    # 指定jpa的使用的数据库\n    database: mysql\n    # 是否创建数据库\n    generate-ddl: true\n    # 映射文件的位置\n    mapping-resources:\n    # JPA的一些其他属性\n    # properties:\n    # 是否显示sql语句\n    show-sql: true\n    # ？？？？\n    open-in-view: true\n    hibernate:\n      # 配置是否创建数据库表\n      ddl-auto: none\n      # 使用新的id生成器\n      use-new-id-generator-mappings: true\n      naming:\n        implicit-strategy: org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy\n        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl\n```\n\n* 实体类的注解\n\n```markdown\n# @Entity\n\t指定此类是个实体类\n# @Table(name = \"persons\")\n\t指定此类对应的表名为\n# @Id\n\t指定此属性是此实体类的id,主键。可以写在get方法或者属性上\n# @GeneratedValue(strategy = GenerationType.AUTO)\n\t指定此id的自定生成策略为auto\n# @Column(name = \"per_name\")\n\t指定此属性对应的表的字段名\n#  @Temporal(TemporalType.TIMESTAMP)\n\t适用于java.util.date类型的参数,指定日期的精度\n# @Basic\n\t标识此属性可以映射到表的字段上。可以不写\n# @Transient\n\t标识此属性与表的字段不产生映射，即表中不应有此属性的对应字段\n# @TableGenerator\n\tname = \"id_generator\", //表示该主键生成策略的名称，它被引用在@GeneratedValue中设置的generator 值中。\n\ttable = \"idgenerator\", //对应主键表的表名。\n\tallocationSize = 1, //表示pk_value字段的值递增的增量。\n\tinitialValue = 1, //表示第一次pk_value字段的初始值。\n\tpkColumnName = \"pk_name\", //\n\tpkColumnValue = \"orders_id\", //表示pk_name字段的值\n\tvalueColumnName = \"pk_value\") //\n# @ManyToOne(fetch = FetchType.LAZY)\n\t与@JoinColumn一起使用\n\t表示单向多对一的映射\n# @JoinColumn(name = \"dep_id\")\n\t表示映射到外键列的列名\n# @OneToMany(fetch = FetchType.EAGER,cascade = {CascadeType.REMOVE})\n\t与@JoinColumn一起使用\n\t表示单向表示一对多的关系\n#  @OneToMany(mappedBy = \"boss\")\n\t表示双向一对多的关系\n#  @OneToOne(mappedBy = \"idCard\")\n\t表示单向一对多的关系\n# @ManyToMany\n\t表示双向多对多的关系\n\t常于JoinTable一起使用\n# @JoinTable\n\t表示关联一张中间表\n\tname = \"author_book\", //表示中间表的表名\n\tjoinColumns = { //关联外键。外键名为author_id，关联到当前表的id\n\t@JoinColumn(name = \"author_id\",referencedColumnName = \"id\")\n\t},\n\tinverseJoinColumns = { //反向关联的外键。外键名为book_id，关联到另一个表的id\n\t@JoinColumn(name = \"book_id\",referencedColumnName = \"id\")\n\t}\n\t)\n```\n\n* 接口\n\n```markdown\n# Repository\n\t仅表示此接口是一个持久层访问，提供基本的增删改查。\n\t可以使用 @RepositoryDefinition 注解，并为其指定 domainClass 和 idClass 属性。\n# CrudRepository： \n\t继承 Repository，实现了一组 CRUD 相关的方法 。\n# PagingAndSortingRepository： \n\t继承 CrudRepository，实现了一组分页排序相关的方法 。\n# JpaRepository： \n\t继承 PagingAndSortingRepository，实现一组 JPA 规范相关的方法 。\n# JpaSpecificationExecutor： \n\t不属于Repository体系，实现一组 JPA Criteria 查询相关的方法 。\n# 自定义的 XxxxRepository \n\t需要继承 JpaRepository，这样的 XxxxRepository 接口就具备了通用的数据访问控制层的能力。\n```\n\n* 接口的方法规范\n\n```markdown\n# 使用命名式方式查询\n\t查询方法以 find | read | get 开头\n\t涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性以首字母大写。\n\t条件的属性名称与个数要与参数的位置与个数一一对应。\n\t\tfindByLastNameAndFirstName(String lastName,String firstName);\n\t在方法的参数上加入分页或排序的参数：Page<UserModel> findByName(String name, Pageable pageable);\n# 使用@Query注解\n\t使用JPQL语句，参数使用命名参数，与@Param(\"ID\")注解一起使用\n\t使用原生的sql语句：@Query(value = \"select * from student\", nativeQuery = true)\n# @Modifying\n\t表明这个方法是一个修改的方法。修改包括删除和更新操作。\n\t 常与 Query使用\n\t 调用方必须添加@Transactional注解声明事务。\n# 自定义实现Repository接口的规则\n\t先声明一个Repository接口，再创建实现该接口的实现类，实现类的类名格式是：XxxRepository+Impl。\n\t使用时继承这个自己声明的Repository接口即可。\n\tpublic class SchoolRepositoryImpl implements SchoolDao{\n\t@PersistenceContext\n\tprivate EntityManager entityManager;\n\t@Override\n\tpublic void test() {\n    //此处可以来连接数据库，进行各种操作\n    System.out.println(\"自定义的Repository方法\" + entityManager);\n\t}\n\t}\n```\n\n* ","categories":["学习","技术架构"]},{"title":"Mysql日志的应用","url":"/2021/06/25/尚硅谷说Java/数据库/MySQL日志的应用/","content":"\n\n\n使用SSM框架和MySQL整合，通过AOP功能实现对代码中方法的调用进行记录，将记录保存在数据库中。\n\n进行应用性能的优化：分页优化，索引优化，排序优化，读写分离，应用优化。\n\n实现使用主从数据库时，SSM框架配置。\n\n\n\n<!--more-->\n\n\n\n#  需求分析\n\n在业务系统中，需要记录当前业务系统的访问日志，该访问日志包含：操作人，操作时间，访问类，访问方法，请求参数，请求结果，请求结果类型，请求时长 等信息。记录详细的系统访问日志，主要便于对系统中的用户请求进行追踪，并且在系统 的管理后台可以查看到用户的访问记录。\n\n记录系统中的日志信息，可以通过Spring 框架的AOP来实现。具体的请求处理流程，如下：\n\n![1555075760661](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625171256.png) \n\n\n\n#  搭建案例环境\n\n\n\n##  数据库表\n\n```sql\nCREATE DATABASE mysql_demo DEFAULT CHARACTER SET utf8mb4;\n\nCREATE TABLE `brand` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) DEFAULT NULL COMMENT '品牌名称',\n  `first_char` varchar(1) DEFAULT NULL COMMENT '品牌首字母',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n\nCREATE TABLE `item` (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '商品id',\n  `title` varchar(100) NOT NULL COMMENT '商品标题',\n  `price` double(10,2) NOT NULL COMMENT '商品价格，单位为：元',\n  `num` int(10) NOT NULL COMMENT '库存数量',\n  `categoryid` bigint(10) NOT NULL COMMENT '所属类目，叶子类目',\n  `status` varchar(1) DEFAULT NULL COMMENT '商品状态，1-正常，2-下架，3-删除',\n  `sellerid` varchar(50) DEFAULT NULL COMMENT '商家ID',\n  `createtime` datetime DEFAULT NULL COMMENT '创建时间',\n  `updatetime` datetime DEFAULT NULL COMMENT '更新时间',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='商品表';\n\n\n\nCREATE TABLE `user` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(45) NOT NULL,\n  `password` varchar(96) NOT NULL,\n  `name` varchar(45) NOT NULL,\n  `birthday` datetime DEFAULT NULL,\n  `sex` char(1) DEFAULT NULL,\n  `email` varchar(45) DEFAULT NULL,\n  `phone` varchar(45) DEFAULT NULL,\n  `qq` varchar(32) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\nCREATE TABLE `operation_log` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',\n  `operate_class` varchar(200) DEFAULT NULL COMMENT '操作类',\n  `operate_method` varchar(200) DEFAULT NULL COMMENT '操作方法',\n  `return_class` varchar(200) DEFAULT NULL COMMENT '返回值类型',\n  `operate_user` varchar(20) DEFAULT NULL COMMENT '操作用户',\n  `operate_time` varchar(20) DEFAULT NULL COMMENT '操作时间',\n  `param_and_value` varchar(500) DEFAULT NULL COMMENT '请求参数名及参数值',\n  `cost_time` bigint(20) DEFAULT NULL COMMENT '执行方法耗时, 单位 ms',\n  `return_value` varchar(200) DEFAULT NULL COMMENT '返回值',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4;\n\n```\n\n\n\n##  pom.xml\n\n```xml\n<properties>\n  <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n  <maven.compiler.source>1.8</maven.compiler.source>\n  <maven.compiler.target>1.8</maven.compiler.target>\n  <spring.version>5.0.2.RELEASE</spring.version>\n  <slf4j.version>1.6.6</slf4j.version>\n  <log4j.version>1.2.12</log4j.version>\n  <mybatis.version>3.4.5</mybatis.version>\n</properties>\n\n<dependencies> <!-- spring -->\n  <dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjweaver</artifactId>\n    <version>1.6.8</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.16.16</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n    <version>${spring.version}</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context-support</artifactId>\n    <version>${spring.version}</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-orm</artifactId>\n    <version>${spring.version}</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-test</artifactId>\n    <version>${spring.version}</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>${spring.version}</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-tx</artifactId>\n    <version>${spring.version}</version>\n  </dependency>\n\n  <dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.12</version>\n    <scope>test</scope>\n  </dependency>\n\n  <dependency>\n    <groupId>javax.servlet</groupId>\n    <artifactId>javax.servlet-api</artifactId>\n    <version>3.1.0</version>\n    <scope>provided</scope>\n  </dependency>\n\n  <dependency>\n    <groupId>javax.servlet.jsp</groupId>\n    <artifactId>jsp-api</artifactId>\n    <version>2.0</version>\n    <scope>provided</scope>\n  </dependency>\n\n\n  <dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>${log4j.version}</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis</artifactId>\n    <version>${mybatis.version}</version>\n  </dependency>\n\n  <dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis-spring</artifactId>\n    <version>1.3.0</version>\n  </dependency>\n\n  <dependency>\n    <groupId>c3p0</groupId>\n    <artifactId>c3p0</artifactId>\n    <version>0.9.1.2</version>\n  </dependency>\n\n  <dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>5.1.5</version>\n  </dependency>\n\n  <dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-core</artifactId>\n    <version>2.9.0</version>\n  </dependency>\n\n  <dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.9.0</version>\n  </dependency>\n\n  <dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-annotations</artifactId>\n    <version>2.9.0</version>\n  </dependency>\n</dependencies>\n\n```\n\n\n\n##  web.xml\n\n```xml\n<!DOCTYPE web-app PUBLIC\n    \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"\n    \"http://java.sun.com/dtd/web-app_2_3.dtd\" >\n\n<web-app>\n  <display-name>Archetype Created Web Application</display-name>\n  <!--加载Spring配置文件-->\n  <context-param>\n    <param-name>contextConfigLocation</param-name>\n    <param-value>classpath:applicationContext.xml</param-value>\n  </context-param>\n  <!--解决post乱码-->\n  <filter>\n    <filter-name>characterEncodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n    <init-param>\n      <param-name>encoding</param-name>\n      <param-value>utf-8</param-value>\n    </init-param>\n    <init-param>\n      <param-name>forceEncoding</param-name>\n      <param-value>true</param-value>\n    </init-param>\n  </filter>\n  <filter-mapping>\n    <filter-name>characterEncodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n  </filter-mapping>\n\n  <listener>\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n  </listener>\n  <!--加载SpringMVC配置文件-->\n  <servlet>\n    <servlet-name>springmvc</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n      <param-name>contextConfigLocation</param-name>\n      <param-value>classpath:springmvc.xml</param-value>\n    </init-param>\n  </servlet>\n  <servlet-mapping>\n    <servlet-name>springmvc</servlet-name>\n    <url-pattern>*.do</url-pattern>\n  </servlet-mapping>\n  <!--设置起始页面-->\n  <welcome-file-list>\n    <welcome-file>log-datalist.html</welcome-file>\n  </welcome-file-list>\n</web-app>\n\n```\n\n\n\n##  db.properties\n\n```properties\njdbc.driver=com.mysql.jdbc.Driver\n# 虚拟机的ip地址\njdbc.url=jdbc:mysql://192.168.56.102:3306/mysql_demo\njdbc.username=root\njdbc.password=root\n```\n\n\n\n##  applicationContext.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/tx \n       http://www.springframework.org/schema/tx/spring-tx.xsd \n       http://www.springframework.org/schema/context \n       http://www.springframework.org/schema/context/spring-context.xsd\">\n\n<!--加载配置文件-->\n  <context:property-placeholder location=\"classpath:db.properties\"></context:property-placeholder>\n  <!--配置SpringIOC容器扫描的包-->\n  <context:component-scan base-package=\"com.lc\" use-default-filters=\"true\">\n    <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n  </context:component-scan>\n  <!--配置c3p0数据连接池-->\n  <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n    <property name=\"driverClass\" value=\"${jdbc.driver}\"></property>\n    <property name=\"jdbcUrl\" value=\"${jdbc.url}\"></property>\n    <property name=\"user\" value=\"${jdbc.username}\"></property>\n    <property name=\"password\" value=\"${jdbc.password}\"></property>\n  </bean>\n  <!--配置Mybatis的Session工厂-->\n  <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n    <property name=\"dataSource\" ref=\"dataSource\"></property>\n    <!--开启类型别名-->\n    <property name=\"typeAliasesPackage\" value=\"com.lc.pojo\"></property>\n    <!--指定mybatis的mapper文件的位置-->\n    <property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/>\n  </bean>\n  <!--配置Mybatis的Mapper接口扫描-->\n  <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n    <property name=\"basePackage\" value=\"com.lc.dao\"></property>\n  </bean>\n  <!--配置数据库事务管理器-->\n  <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n    <property name=\"dataSource\" ref=\"dataSource\"></property>\n  </bean>\n  <!--开启事务的注解驱动-->\n  <tx:annotation-driven transaction-manager=\"transactionManager\"></tx:annotation-driven>\n</beans>\n```\n\n\n\n##  springmvc.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n       http://www.springframework.org/schema/beans/spring-beans.xsd \n       http://www.springframework.org/schema/aop \n       http://www.springframework.org/schema/aop/spring-aop.xsd\n       http://www.springframework.org/schema/context \n       http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n  <!--配置SpringMVC aop容器扫描-->\n  <context:component-scan base-package=\"com.lc.controller\"></context:component-scan>\n  <!--开启aop功能-->\n  <aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n  <!--必有的两个配置-->\n  <mvc:annotation-driven></mvc:annotation-driven>\n  <mvc:default-servlet-handler></mvc:default-servlet-handler>\n</beans>\n```\n\n\n\n#  编写基本代码\n\n![1555076434270](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625171913.png) \n\n\n\n#  通过AOP记录操作日志\n\n\n\n##  自定义注解\n\n通过自定义注解，来标示方法需不需要进行记录日志，如果该方法在访问时需要记录日志，则在该方法上标示该注解既可。\n\n```java\n@Inherited\n@Documented\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface OperateLog {\n}\n```\n\n\n\n##  定义通知类\n\n```java\n@Component\n@Aspect\npublic class OperateAdvice {\n   \n   private static Logger log = Logger.getLogger(OperateAdvice.class);\n   \n   @Autowired\n   private OperationLogService operationLogService;\n   \n\n   @Around(\"execution(* cn.itcast.controller.*.*(..)) && @annotation(operateLog)\")\n   public Object insertLogAround(ProceedingJoinPoint pjp , OperateLog operateLog) throws Throwable{\n      System.out.println(\" ************************ 记录日志 [start]  ****************************** \");\n      \n      OperationLog op = new OperationLog();\n      \n      DateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n      op.setOperateTime(sdf.format(new Date()));\n      op.setOperateUser(DataUtils.getRandStr(8));\n      \n      op.setOperateClass(pjp.getTarget().getClass().getName());\n      op.setOperateMethod(pjp.getSignature().getName());\n      \n      //获取方法调用时传递的参数\n      Object[] args = pjp.getArgs();\n      op.setParamAndValue(Arrays.toString(args));\n\n      long start_time = System.currentTimeMillis();\n\n      //放行\n      Object object = pjp.proceed();\n\n      long end_time = System.currentTimeMillis();\n      op.setCostTime(end_time - start_time);\n\n      if(object != null){\n         op.setReturnClass(object.getClass().getName());\n         op.setReturnValue(object.toString());\n      }else{\n         op.setReturnClass(\"java.lang.Object\");\n         op.setParamAndValue(\"void\");\n      }\n\n      log.error(JsonUtils.obj2JsonString(op));\n\n      operationLogService.insert(op);\n      \n      System.out.println(\" ************************** 记录日志 [end]  *************************** \");\n      \n      return object;\n   }\n   \n}\n```\n\n\n\n##  方法上加注解\n\n在需要记录日志的方法上加上注解@OperateLog。\n\n```java\n@OperateLog\n@RequestMapping(\"/insert\")\npublic Result insert(@RequestBody Brand brand){\n    try {\n        brandService.insert(brand);\n        return new Result(true,\"操作成功\");\n    } catch (Exception e) {\n        e.printStackTrace();\n        return new Result(false,\"操作失败\");\n    }\n}\n```\n\n\n\n#  日志查询后端代码实现\n\n\n\n##  Mapper接口\n\n```java\npublic interface OperationLogMapper {\n\n    public void insert(OperationLog operationLog);\n\n    public List<OperationLog> selectListByCondition(Map dataMap);\n\n    public Long countByCondition(Map dataMap);\n\n}\n```\n\n\n\n##  Mapper.xml 映射配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"cn.itcast.mapper.OperationLogMapper\" >\n\n    <insert id=\"insert\" parameterType=\"operationLog\">\n        INSERT INTO operation_log(id,return_value,return_class,operate_user,operate_time,param_and_value,\n        operate_class,operate_method,cost_time)\n      VALUES(NULL,#{returnValue},#{returnClass},#{operateUser},#{operateTime},#{paramAndValue},\n        #{operateClass},#{operateMethod},#{costTime})\n    </insert>\n\n    <select id=\"selectListByCondition\" parameterType=\"map\" resultType=\"operationLog\">\n      select\n        id ,\n        operate_class as operateClass ,\n        operate_method as operateMethod,\n        return_class as returnClass,\n        operate_user as operateUser,\n        operate_time as operateTime,\n        param_and_value as paramAndValue,\n        cost_time as costTime,\n        return_value as returnValue\n      from operation_log\n      <include refid=\"oplog_where\"/>\n      limit #{start},#{size}\n    </select>\n\n\n    <select id=\"countByCondition\" resultType=\"long\" parameterType=\"map\">\n        select count(*) from operation_log\n        <include refid=\"oplog_where\"/>\n    </select>\n\n\n    <sql id=\"oplog_where\">\n        <where>\n            <if test=\"operateClass != null and operateClass != '' \">\n                and operate_class = #{operateClass}\n            </if>\n            <if test=\"operateMethod != null and operateMethod != '' \">\n                and operate_method = #{operateMethod}\n            </if>\n            <if test=\"returnClass != null and returnClass != '' \">\n                and return_class = #{returnClass}\n            </if>\n            <if test=\"costTime != null\">\n                and cost_time =  #{costTime}\n            </if>\n        </where>\n    </sql>\n\n</mapper>\n```\n\n\n\n##  Service\n\n```java\n@Service\n@Transactional\npublic class OperationLogService {\n\n    //private static Logger logger = Logger.getLogger(OperationLogService.class);\n\n    @Autowired\n    private OperationLogMapper operationLogMapper;\n\n    //插入数据\n    public void insert(OperationLog operationLog){\n        operationLogMapper.insert(operationLog);\n    }\n\n    //根据条件查询\n    public PageResult selectListByCondition(Map dataMap, Integer pageNum , Integer pageSize){\n\n       if(paramMap ==null){\n            paramMap = new HashMap();\n        }\n        paramMap.put(\"start\" , (pageNum-1)*rows);\n        paramMap.put(\"rows\",rows);\n\n        Object costTime = paramMap.get(\"costTime\");\n        if(costTime != null){\n            if(\"\".equals(costTime.toString())){\n                paramMap.put(\"costTime\",null);\n            }else{\n                paramMap.put(\"costTime\",new Long(paramMap.get(\"costTime\").toString()));\n            }\n        }\n\n        System.out.println(dataMap);\n\n\n        long countStart = System.currentTimeMillis();\n        Long count = operationLogMapper.countByCondition(dataMap);\n        long countEnd = System.currentTimeMillis();\n        System.out.println(\"Count Cost Time : \" + (countEnd-countStart)+\" ms\");\n\n\n        List<OperationLog> list = operationLogMapper.selectListByCondition(dataMap);\n        long queryEnd = System.currentTimeMillis();\n        System.out.println(\"Query Cost Time : \" + (queryEnd-countEnd)+\" ms\");\n\n\n        return new PageResult(count,list);\n\n    }\n\n}\n```\n\n\n\n##  Controller\n\n```java\n@RestController\n@RequestMapping(\"/operationLog\")\npublic class OperationLogController {\n\n    @Autowired\n    private OperationLogService operationLogService;\n\n    @RequestMapping(\"/findList\")\n    public PageResult findList(@RequestBody Map dataMap, Integer pageNum , Integer pageSize){\n        PageResult page = operationLogService.selectListByCondition(dataMap, pageNum, pageSize);\n        return page;\n    }\n\n}\n```\n\n\n\n#  日志查询前端代码实现\n\n前端代码使用 BootStrap + AdminLTE 进行布局， 使用Vuejs 进行视图层展示。\n\n\n\n##  js\n\n```html\n<script>\n   var vm = new Vue({\n       el: '#app',\n       data: {\n           dataList:[],\n           searchEntity:{\n               operateClass:'',\n               operateMethod:'',\n               returnClass:'',\n               costTime:''\n           },\n\n           page: 1,  //显示的是哪一页\n           pageSize: 10, //每一页显示的数据条数\n           total: 150, //记录总数\n           maxPage:8  //最大页数\n       },\n       methods: {\n           pageHandler: function (page) {\n               this.page = page;\n               this.search();\n           },\n\n           search: function () {\n               var _this = this;\n               this.showLoading();\n               axios.post('/operationLog/findList.do?pageNum=' + _this.page + \"&pageSize=\" + _this.pageSize, _this.searchEntity).then(function (response) {\n                   if (response) {\n                       _this.dataList = response.data.dataList;\n                       _this.total = response.data.total;\n                       _this.hideLoading();\n                   }\n               })\n           },\n\n           showLoading: function () {\n               $('#loadingModal').modal({backdrop: 'static', keyboard: false});\n           },\n\n           hideLoading: function () {\n               $('#loadingModal').modal('hide');\n           },\n       },\n\n       created:function(){\n           this.pageHandler(1);\n       }\n   });\n\n</script>\n```\n\n\n\n##  列表数据展示\n\n```html\n<tr v-for=\"item in dataList\">\n    <td><input name=\"ids\" type=\"checkbox\"></td>\n    <td>{{item.id}}</td>\n    <td>{{item.operateClass}}</td>\n    <td>{{item.operateMethod}}</td>\n    <td>{{item.returnClass}}</td>\n    <td>{{item.returnValue}}</td>\n    <td>{{item.operateUser}}</td>\n    <td>{{item.operateTime}}</td>\n    <td>{{item.costTime}}</td>\n    <td class=\"text-center\">\n        <button type=\"button\" class=\"btn bg-olive btn-xs\">详情</button>\n        <button type=\"button\" class=\"btn bg-olive btn-xs\">删除</button>\n    </td>\n</tr>\n```\n\n\n\n## 分页插件\n\n```html\n<div class=\"wrap\" id=\"wrap\">\n    <zpagenav v-bind:page=\"page\" v-bind:page-size=\"pageSize\" v-bind:total=\"total\"\n              v-bind:max-page=\"maxPage\"  v-on:pagehandler=\"pageHandler\">\n    </zpagenav>\n</div>\n```\n\n\n\n#  联调测试\n\n可以通过postman来访问业务系统，再查看数据库中的日志信息，验证能不能将用户的访问日志记录下来。\n\n![1555077276426](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625171922.png) \n\n\n\n#  分析性能问题\n\n系统中用户访问日志的数据量，随着时间的推移，这张表的数据量会越来越大，因此我们需要根据业务需求，来对日志查询模块的性能进行优化。\n\n1） 分页查询优化\n\n由于在进行日志查询时，是进行分页查询，那也就意味着，在查看时，至少需要查询两次：\n\nA. 查询符合条件的总记录数。--> count 操作\n\nB. 查询符合条件的列表数据。--> 分页查询 limit 操作\n\n通常来说，count() 都需要扫描大量的行（意味着需要访问大量的数据）才能获得精确的结果，因此是很难对该SQL进行优化操作的。如果需要对count进行优化，可以采用另外一种思路，可以增加汇总表，或者redis缓存来专门记录该表对应的记录数，这样的话，就可以很轻松的实现汇总数据的查询，而且效率很高，但是这种统计并不能保证百分之百的准确 。对于数据库的操作，“快速、精确、实现简单”，三者永远只能满足其二，必须舍掉其中一个。\n\n2） 条件查询优化\n\n针对于条件查询,需要对查询条件,及排序字段建立索引。\n\n3） 读写分离\n\n通过主从复制集群，来完成读写分离，使写操作走主节点， 而读操作，走从节点。\n\n4） MySQL服务器优化\n\n5） 应用优化\n\n\n\n\n\n#  性能优化 - 分页\n\n\n\n##  优化count\n\n创建一张表用来记录日志表的总数据量：\n\n```SQL\ncreate table log_counter(\n\tlogcount bigint not null\n)engine = innodb default CHARSET = utf8;\n```\n\n在每次插入数据之后，更新该表 ：\n\n```xml\n<update id=\"updateLogCounter\" >\n    update log_counter set logcount = logcount + 1\n</update>\n```\n\n在进行分页查询时, 获取总记录数，从该表中查询既可。\n\n```xml\n<select id=\"countLogFromCounter\" resultType=\"long\">\n    select logcount from log_counter limit 1\n</select>\n```\n\n\n\n##  优化 limit\n\n在进行分页时，一般通过创建覆盖索引，能够比较好的提高性能。一个非常常见，而又非常头疼的分页场景就是 \"limit 1000000,10\" ，此时MySQL需要搜索出前1000010 条记录后，仅仅需要返回第 1000001 到 1000010 条记录，前1000000 记录会被抛弃，查询代价非常大。 \n\n![1555081714638](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625171926.png) \n\n当点击比较靠后的页码时，就会出现这个问题，查询效率非常慢。\n\n优化SQL：\n\n```sql\nselect * from operation_log limit 3000000 , 10;\n```\n\n将上述SQL优化为 : \n\n```SQL\nselect * from operation_log t , (select id from operation_log order by id limit 3000000,10) b where t.id = b.id ;\n```\n\n```xml\n<select id=\"selectListByCondition\" parameterType=\"map\" resultType=\"operationLog\">\n  select\n    id ,\n    operate_class as operateClass ,\n    operate_method as operateMethod,\n    return_class as returnClass,\n    operate_user as operateUser,\n    operate_time as operateTime,\n    param_and_value as paramAndValue,\n    cost_time as costTime,\n    return_value as returnValue\n  from operation_log t,\n    \n  (select id from operation_log \n  <where>\n    <include refid=\"oplog_where\"/>\n  </where>\n  order by id limit #{start},#{rows}) b  where t.id = b.id  \n</select>\n```\n\n\n\n\n\n#  性能优化 - 索引\n\n![1555152703824](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625171930.png)\n\n当根据操作人进行查询时， 查询的效率很低，耗时比较长。原因就是因为在创建数据库表结构时，并没有针对于 操作人 字段建立索引。\n\n```SQL\nCREATE INDEX idx_user_method_return_cost ON operation_log(operate_user,operate_method,return_class,cost_time);\n```\n\n同上 ， 为了查询效率高，我们也需要对 操作方法、返回值类型、操作耗时 等字段进行创建索引，以提高查询效率。\n\n```SQL\nCREATE INDEX idx_optlog_method_return_cost ON operation_log(operate_method,return_class,cost_time);\n\nCREATE INDEX idx_optlog_return_cost ON operation_log(return_class,cost_time);\n\nCREATE INDEX idx_optlog_cost ON operation_log(cost_time);\n\n```\n\n\n\n#  性能优化 - 排序\n\n在查询数据时，如果业务需求中需要我们对结果内容进行了排序处理 , 这个时候,我们还需要对排序的字段建立适当的索引, 来提高排序的效率 。\n\n\n\n#  性能优化 - 读写分离\n\n\n\n##  概述\n\n在Mysql主从复制的基础上，可以使用读写分离来降低单台Mysql节点的压力，从而来提高访问效率，读写分离的架构如下：\n\n![1555235426739](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625171933.png) \n\n对于读写分离的实现，可以通过Spring AOP 来进行动态的切换数据源，进行操作 ：\n\n\n\n##  实现方式\n\ndb.properties\n\n```properties\n# 写数据库/主库\njdbc.write.driver=com.mysql.jdbc.Driver\njdbc.write.url=jdbc:mysql://192.168.56.102.128:3306/mysql_demo\njdbc.write.username=root\njdbc.write.password=root\n# 读数据库/从库\njdbc.read.driver=com.mysql.jdbc.Driver\njdbc.read.url=jdbc:mysql://192.168.56.103:3306/mysql_demo\njdbc.read.username=root\njdbc.read.password=root\n```\n\napplicationContext-datasource.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n\n\n    <!-- 配置数据源 - Read -->\n    <bean id=\"readDataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" destroy-method=\"close\"  lazy-init=\"true\">\n        <property name=\"driverClass\" value=\"${jdbc.read.driver}\"></property>\n        <property name=\"jdbcUrl\" value=\"${jdbc.read.url}\"></property>\n        <property name=\"user\" value=\"${jdbc.read.username}\"></property>\n        <property name=\"password\" value=\"${jdbc.read.password}\"></property>\n    </bean>\n\n\n    <!-- 配置数据源 - Write -->\n    <bean id=\"writeDataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"  destroy-method=\"close\"  lazy-init=\"true\">\n        <property name=\"driverClass\" value=\"${jdbc.write.driver}\"></property>\n        <property name=\"jdbcUrl\" value=\"${jdbc.write.url}\"></property>\n        <property name=\"user\" value=\"${jdbc.write.username}\"></property>\n        <property name=\"password\" value=\"${jdbc.write.password}\"></property>\n    </bean>\n\n\n    <!-- 配置动态分配的读写 数据源 自定义选择规则：ChooseDataSource-->\n    <bean id=\"dataSource\" class=\"com.lc.aop.datasource.ChooseDataSource\" lazy-init=\"true\">\n        <property name=\"targetDataSources\">\n            <map key-type=\"java.lang.String\" value-type=\"javax.sql.DataSource\">\n                <entry key=\"write\" value-ref=\"writeDataSource\"/>\n                <entry key=\"read\" value-ref=\"readDataSource\"/>\n            </map>\n        </property>\n\n        <property name=\"defaultTargetDataSource\" ref=\"writeDataSource\"/>\n\n        <property name=\"methodType\">\n            <map key-type=\"java.lang.String\">\n              <!-- 选择规则：get等方法开头的是read操作，使用从库数据源。add等开头的是write操作，使用主库数据源。-->\n                <entry key=\"read\" value=\",get,select,count,list,query,find\"/>\n                <entry key=\"write\" value=\",add,create,update,delete,remove,insert\"/>\n            </map>\n        </property>\n    </bean>\n\n</beans>\n```\n\nChooseDataSource\n\n```java\npublic class ChooseDataSource extends AbstractRoutingDataSource {\n\n    public static Map<String, List<String>> METHOD_TYPE_MAP = new HashMap<String, List<String>>();\n\n    /**\n     * 实现父类中的抽象方法，获取数据源名称\n     * @return\n     */\n    protected Object determineCurrentLookupKey() {\n        return DataSourceHandler.getDataSource();\n    }\n\n    // 设置方法名前缀对应的数据源\n    public void setMethodType(Map<String, String> map) {\n        for (String key : map.keySet()) {\n            List<String> v = new ArrayList<String>();\n            String[] types = map.get(key).split(\",\");\n            for (String type : types) {\n                if (!StringUtils.isEmpty(type)) {\n                    v.add(type);\n                }\n            }\n            METHOD_TYPE_MAP.put(key, v);\n        }\n        System.out.println(\"METHOD_TYPE_MAP : \"+METHOD_TYPE_MAP);\n    }\n}\n```\n\nDataSourceHandler\n\n```java\npublic class DataSourceHandler {\n\n    // 数据源名称\n    public static final ThreadLocal<String> holder = new ThreadLocal<String>();\n\n    /**\n     * 在项目启动的时候将配置的读、写数据源加到holder中\n     */\n    public static void putDataSource(String datasource) {\n        holder.set(datasource);\n    }\n\n    /**\n     * 从holer中获取数据源字符串\n     */\n    public static String getDataSource() {\n        return holder.get();\n    }\n}\n```\n\nDataSourceAspect\n\n```java\n@Aspect\n@Component\n@Order(-9999) // 设置优先级，数值越小优先级越高\n@EnableAspectJAutoProxy(proxyTargetClass = true)\npublic class DataSourceAspect {\n\n    protected Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 配置前置通知,使用在方法aspect()上注册的切入点\n     */\n    @Before(\"execution(* com.lc.service.*.*(..))\")\n    @Order(-9999)\n    public void before(JoinPoint point) {\n        \n        String className = point.getTarget().getClass().getName();\n        String method = point.getSignature().getName();\n        logger.info(className + \".\" + method + \"(\" + Arrays.asList(point.getArgs())+ \")\");\n\n        try {\n            for (String key : ChooseDataSource.METHOD_TYPE_MAP.keySet()) {\n                for (String type : ChooseDataSource.METHOD_TYPE_MAP.get(key)) {\n                    if (method.startsWith(type)) {\n                        System.out.println(\"key : \" + key);\n                        DataSourceHandler.putDataSource(key);\n                        break;\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n```\n\n通过 @Order(-9999) 注解来控制事务管理器, 与该通知类的加载顺序 , 需要让通知类 , 先加载 , 来判定使用哪个数据源 .\n\n\n\n## 验证\n\n在主库和从库中，执行如下SQL语句，来查看是否读的时候， 从从库中读取 ； 写入操作的时候，是否写入到主库。\n\n```sql\nshow status like 'Innodb_rows_%' ;\n```\n\n![1555235982584](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625171939.png) \n\n\n\n##  原理\n\n![1555235982584](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625171943.png)\n\n\n\n#  性能优化 - 应用优化\n\n\n\n##  缓存\n\n可以在业务系统中使用redis来做缓存，缓存一些基础性的数据，来降低关系型数据库的压力，提高访问效率。\n\n\n\n##  全文检索\n\n如果业务系统中的数据量比较大（达到千万级别），这个时候，如果再对数据库进行查询，特别是进行分页查询，速度将变得很慢（因为在分页时首先需要count求合计数），为了提高访问效率，这个时候，可以考虑加入Solr 或者 ElasticSearch全文检索服务，来提高访问效率。\n\n\n\n##  非关系数据库\n\n也可以考虑将非核心（重要）数据，存在 MongoDB 中，这样可以提高插入以及查询的效率。","categories":["Java学习","数据库"]},{"title":"Mysql高级下","url":"/2021/06/24/尚硅谷说Java/数据库/MySQL高级下/","content":"\n\n\nMySQL的深入学习：SQL执行分析，SQL优化，应用优化，查询缓存优化，内存优化，SQL操作常用工具，SQL日志，主从复制模式，常用SQL技巧\n\n\n\n<!--more-->\n\n\n\n# 优化SQL步骤\n\n在应用的的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多 SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 SQL 语句就成为整个系统性能的瓶颈，因此我们必须要对它们进行优化，本章将详细介绍在 MySQL 中优化 SQL 语句的方法。\n\n当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题。\n\n## 查看SQL执行频率\n\nMySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”。\n\n下面的命令显示了当前 session 中所有统计参数的值：\n\n```\nshow status like 'Com_______';\n```\n\n![1552487172501](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163448.png)  \n\n```\nshow status like 'Innodb_rows_%';\n```\n\n![1552487245859](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163453.png)\n\nCom_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。\n\n| 参数                 | 含义                                                         |\n| :------------------- | ------------------------------------------------------------ |\n| Com_select           | 执行 select 操作的次数，一次查询只累加 1。                   |\n| Com_insert           | 执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。 |\n| Com_update           | 执行 UPDATE 操作的次数。                                     |\n| Com_delete           | 执行 DELETE 操作的次数。                                     |\n| Innodb_rows_read     | select 查询返回的行数。                                      |\n| Innodb_rows_inserted | 执行 INSERT 操作插入的行数。                                 |\n| Innodb_rows_updated  | 执行 UPDATE 操作更新的行数。                                 |\n| Innodb_rows_deleted  | 执行 DELETE 操作删除的行数。                                 |\n| Connections          | 试图连接 MySQL 服务器的次数。                                |\n| Uptime               | 服务器工作时间。                                             |\n| Slow_queries         | 慢查询的次数。                                               |\n\nCom_***      :  这些参数对于`所有存储引擎`的表操作都会进行累计。\n\nInnodb_*** :  这几个参数只是`针对InnoDB 存储引擎`的，累加的算法也略有不同。\n\n\n\n##  定位低效率执行SQL\n\n可以通过以下两种方式定位执行效率较低的 SQL 语句。\n\n- 慢查询日志 : 通过慢查询日志定位那些执行效率较低的 SQL 语句，用--log-slow-queries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。\n- show processlist  : 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。\n\n![1556098544349](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163459.png) \n\n```\n1） id列，用户登录mysql时，系统分配的\"connection_id\"，可以使用函数connection_id()查看\n\n2） user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句\n\n3） host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户\n\n4） db列，显示这个进程目前连接的是哪个数据库\n\n5） command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等\n\n6） time列，显示这个状态持续的时间，单位是秒\n\n7） state列，显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成\n\n8） info列，显示这个sql语句，是判断问题语句的一个重要依据\n```\n\n\n\n##  explain分析执行计划\n\n通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。\n\n查询SQL语句的执行计划 ： \n\n```sql\nexplain  select * from tb_item where id = 1;\n```\n\n![1552487489859](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163507.png)\n\n```sql\nexplain  select * from tb_item where title = '阿尔卡特 (OT-979) 冰川白 联通3G手机3';\n```\n\n![1552487526919](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163512.png)  \n\n| 字段          | 含义                                                         |\n| ------------- | ------------------------------------------------------------ |\n| id            | select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。 |\n| select_type   | 表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等 |\n| table         | 输出结果集的表                                               |\n| partitions    | 表示查询涉及到的分区信息。（5.7版本以后存在）                |\n| type          | 表示表的连接类型，性能由好到差的连接类型为( system  --->  const  ----->  eq_ref  ------>  ref  ------->  ref_or_null---->  index_merge  --->  index_subquery  ----->  range  ----->  index  ------> all ) |\n| possible_keys | 表示查询时，可能使用的索引                                   |\n| key           | 表示实际使用的索引                                           |\n| key_len       | 索引字段的长度                                               |\n| rows          | 扫描行的数量                                                 |\n| filtered      | 通过过滤条件之后对比总数的百分比。（5.7版本以后存在）        |\n| extra         | 执行情况的说明和描述                                         |\n\n\n\n###  环境准备\n\n![1556122799330](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163517.png) \n\n```sql\nCREATE TABLE `t_role` (\n  `id` varchar(32) NOT NULL,\n  `role_name` varchar(255) DEFAULT NULL,\n  `role_code` varchar(255) DEFAULT NULL,\n  `description` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `unique_role_name` (`role_name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\nCREATE TABLE `t_user` (\n  `id` varchar(32) NOT NULL,\n  `username` varchar(45) NOT NULL,\n  `password` varchar(96) NOT NULL,\n  `name` varchar(45) NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `unique_user_username` (`username`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\nCREATE TABLE `user_role` (\n  `id` int(11) NOT NULL auto_increment ,\n  `user_id` varchar(32) DEFAULT NULL,\n  `role_id` varchar(32) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `fk_ur_user_id` (`user_id`),\n  KEY `fk_ur_role_id` (`role_id`),\n  CONSTRAINT `fk_ur_role_id` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION,\n  CONSTRAINT `fk_ur_user_id` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n\n\ninsert into `t_user` (`id`, `username`, `password`, `name`) values('1','super','$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe','超级管理员');\ninsert into `t_user` (`id`, `username`, `password`, `name`) values('2','admin','$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe','系统管理员');\ninsert into `t_user` (`id`, `username`, `password`, `name`) values('3','itcast','$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui','test02');\ninsert into `t_user` (`id`, `username`, `password`, `name`) values('4','stu1','$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK/y/spH5rftCpUMZa','学生1');\ninsert into `t_user` (`id`, `username`, `password`, `name`) values('5','stu2','$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr/p1FR6ZKgc18u.Tvqm','学生2');\ninsert into `t_user` (`id`, `username`, `password`, `name`) values('6','t1','$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe','老师1');\n\n\n\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES('5','学生','student','学生');\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES('7','老师','teacher','老师');\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES('8','教学管理员','teachmanager','教学管理员');\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES('9','管理员','admin','管理员');\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES('10','超级管理员','super','超级管理员');\n\n\nINSERT INTO user_role(id,user_id,role_id) VALUES(NULL, '1', '5'),(NULL, '1', '7'),(NULL, '2', '8'),(NULL, '3', '9'),(NULL, '4', '8'),(NULL, '5', '10') ;\n\n\n```\n\n\n\n### explain 之 id\n\nid 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。id 情况有三种 ： \n\n1） id 相同表示加载表的顺序是从上到下。\n\n```\nexplain select * from t_role r, t_user u, user_role ur where r.id = ur.role_id and u.id = ur.user_id ;\n```\n\n![1556102471304](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163534.png)\n\n\n\n2） id 不同id值越大，优先级越高，越先被执行。 \n\n``` SQL\nEXPLAIN SELECT * FROM t_role WHERE id = (SELECT role_id FROM user_role WHERE user_id = (SELECT id FROM t_user WHERE username = 'stu1'))\n```\n\n![1556103009534](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163538.png) \n\n\n\n3） id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。\n\n```sql \nEXPLAIN SELECT * FROM t_role r , (SELECT * FROM user_role ur WHERE ur.`user_id` = '2') a WHERE r.id = a.role_id ; \n```\n\n![1556103294182](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163543.png) \n\n\n\n###  explain 之 select_type\n\n 表示 SELECT 的类型，常见的取值，如下表所示：\n\n| select_type  | 含义                                                         |\n| ------------ | ------------------------------------------------------------ |\n| SIMPLE       | 简单的select查询，查询中不包含子查询或者UNION。join连接查询。 |\n| PRIMARY      | 查询中若包含任何复杂的子查询，**最外层查询**标记为该标识     |\n| SUBQUERY     | 在**SELECT 或 WHERE 列表中包含了子查询**                     |\n| DERIVED      | 在**FROM 列表中包含的子查询**，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中 |\n| UNION        | 若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 ： DERIVED |\n| UNION RESULT | 从UNION表获取结果的SELECT。即使用union连接查询结果后生成的表，对这个表的查询就被标记为UNION RESULT |\n\n\n\n###  explain 之 table\n\n展示这一行的数据是关于哪一张表的 \n\n\n\n###  explain 之 type\n\ntype 显示的是访问类型，是较为重要的一个指标，可取值为： \n\n| type   | 含义                                                         |\n| ------ | ------------------------------------------------------------ |\n| NULL   | MySQL不访问任何表，索引，直接返回结果                        |\n| system | 表只有一行记录(等于系统表)，这是const类型的特例，一般不会出现 |\n| const  | 表示通过索引一次就找到了，const 用于比较primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL 就能将该查询转换为一个常亮。const于将 \"主键\" 或 \"唯一\" 索引的所有部分与常量值进行比较 |\n| eq_ref | 类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描 |\n| ref    | 非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多个） |\n| range  | 只检索给定返回的行，使用一个索引来选择行。 where 之后出现 between ， < , > , in 等操作。 |\n| index  | index 与 ALL的区别为  index 类型只是遍历了索引树， 通常比ALL 快， ALL 是遍历数据文件。 |\n| all    | 将遍历全表以找到匹配的行                                     |\n\n结果值从最好到最坏以此是：\n\n```\nNULL > system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL\n\n\nsystem > const > eq_ref > ref > range > index > ALL\n```\n\n**一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref 。**\n\n\n\n###  explain 之  key\n\n```\npossible_keys : 显示可能应用在这张表的索引， 一个或多个。 \n\nkey ： 实际使用的索引， 如果为NULL， 则没有使用索引。\n\nkey_len : 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。\n```\n\n\n\n###  explain 之 rows\n\n扫描行的数量。\n\n\n\n###  explain 之 extra\n\n其他的额外的执行计划信息，在该列展示 。\n\n| extra            | 含义                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| using  filesort  | 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为 “文件排序”, 效率低。 |\n| using  temporary | 使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于 order by 和 group by； 效率低 |\n| using  index     | 表示相应的select操作使用了覆盖索引， 避免访问表的数据行， 效率不错。 |\n\n\n\n##  show profile分析SQL\n\nMysql从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。\n\n通过 have_profiling 参数，能够看到当前MySQL是否支持profile：\n\n![1552488401999](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163553.png) \n\n默认profiling是关闭的，可以通过set语句在Session级别开启profiling：\n\n![1552488372405](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163557.png) \n\n```sql\nset @@profiling=1; //开启profiling 开关；\n```\n\n通过profile，我们能够更清楚地了解SQL执行的过程。\n\n首先，我们可以执行一系列的操作，如下图所示：\n\n```sql\nshow databases;\n\nuse db01;\n\nshow tables;\n\nselect * from tb_item where id < 5;\n\nselect count(*) from tb_item;\n```\n\n执行完上述命令之后，再执行show profiles 指令， 来查看SQL语句执行的耗时：\n\n![1552489017940](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163601.png)  \n\n通过show  profile for  query  query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间：\n\n![1552489053763](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163605.png) \n\n```tex\nTIP ：\n\tSending data 状态表示MySQL线程开始访问数据行并把结果返回给客户端，而不仅仅是返回给客户端的过程。由于在Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整各查询中耗时最长的状态。\n```\n\n\n\n在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。例如，选择查看CPU的耗费时间  ：\n\n![1552489671119](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163609.png) \n\n| 字段       | 含义                           |\n| ---------- | ------------------------------ |\n| Status     | sql 语句执行的状态             |\n| Duration   | sql 执行过程中每一个步骤的耗时 |\n| CPU_user   | 当前用户占有的cpu              |\n| CPU_system | 系统占有的cpu                  |\n\n\n\n##  trace分析优化器执行计划\n\nMySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。\n\n打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。\n\n```sql\nSET optimizer_trace=\"enabled=on\",end_markers_in_json=on;\nset optimizer_trace_max_mem_size=1000000;\n```\n\n执行SQL语句 ：\n\n```sql\nselect * from tb_item where id < 4;\n```\n\n最后， 检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 ：\n\n```sql\nselect * from information_schema.optimizer_trace\\G;\n```\n\n```json\n*************************** 1. row ***************************\nQUERY: select * from tb_item where id < 4\nTRACE: {\n  \"steps\": [\n    {\n      \"join_preparation\": {\n        \"select#\": 1,\n        \"steps\": [\n          {\n            \"expanded_query\": \"/* select#1 */ select `tb_item`.`id` AS `id`,`tb_item`.`title` AS `title`,`tb_item`.`price` AS `price`,`tb_item`.`num` AS `num`,`tb_item`.`categoryid` AS `categoryid`,`tb_item`.`status` AS `status`,`tb_item`.`sellerid` AS `sellerid`,`tb_item`.`createtime` AS `createtime`,`tb_item`.`updatetime` AS `updatetime` from `tb_item` where (`tb_item`.`id` < 4)\"\n          }\n        ] /* steps */\n      } /* join_preparation */\n    },\n    {\n      \"join_optimization\": {\n        \"select#\": 1,\n        \"steps\": [\n          {\n            \"condition_processing\": {\n              \"condition\": \"WHERE\",\n              \"original_condition\": \"(`tb_item`.`id` < 4)\",\n              \"steps\": [\n                {\n                  \"transformation\": \"equality_propagation\",\n                  \"resulting_condition\": \"(`tb_item`.`id` < 4)\"\n                },\n                {\n                  \"transformation\": \"constant_propagation\",\n                  \"resulting_condition\": \"(`tb_item`.`id` < 4)\"\n                },\n                {\n                  \"transformation\": \"trivial_condition_removal\",\n                  \"resulting_condition\": \"(`tb_item`.`id` < 4)\"\n                }\n              ] /* steps */\n            } /* condition_processing */\n          },\n          {\n            \"table_dependencies\": [\n              {\n                \"table\": \"`tb_item`\",\n                \"row_may_be_null\": false,\n                \"map_bit\": 0,\n                \"depends_on_map_bits\": [\n                ] /* depends_on_map_bits */\n              }\n            ] /* table_dependencies */\n          },\n          {\n            \"ref_optimizer_key_uses\": [\n            ] /* ref_optimizer_key_uses */\n          },\n          {\n            \"rows_estimation\": [\n              {\n                \"table\": \"`tb_item`\",\n                \"range_analysis\": {\n                  \"table_scan\": {\n                    \"rows\": 9816098,\n                    \"cost\": 2.04e6\n                  } /* table_scan */,\n                  \"potential_range_indices\": [\n                    {\n                      \"index\": \"PRIMARY\",\n                      \"usable\": true,\n                      \"key_parts\": [\n                        \"id\"\n                      ] /* key_parts */\n                    }\n                  ] /* potential_range_indices */,\n                  \"setup_range_conditions\": [\n                  ] /* setup_range_conditions */,\n                  \"group_index_range\": {\n                    \"chosen\": false,\n                    \"cause\": \"not_group_by_or_distinct\"\n                  } /* group_index_range */,\n                  \"analyzing_range_alternatives\": {\n                    \"range_scan_alternatives\": [\n                      {\n                        \"index\": \"PRIMARY\",\n                        \"ranges\": [\n                          \"id < 4\"\n                        ] /* ranges */,\n                        \"index_dives_for_eq_ranges\": true,\n                        \"rowid_ordered\": true,\n                        \"using_mrr\": false,\n                        \"index_only\": false,\n                        \"rows\": 3,\n                        \"cost\": 1.6154,\n                        \"chosen\": true\n                      }\n                    ] /* range_scan_alternatives */,\n                    \"analyzing_roworder_intersect\": {\n                      \"usable\": false,\n                      \"cause\": \"too_few_roworder_scans\"\n                    } /* analyzing_roworder_intersect */\n                  } /* analyzing_range_alternatives */,\n                  \"chosen_range_access_summary\": {\n                    \"range_access_plan\": {\n                      \"type\": \"range_scan\",\n                      \"index\": \"PRIMARY\",\n                      \"rows\": 3,\n                      \"ranges\": [\n                        \"id < 4\"\n                      ] /* ranges */\n                    } /* range_access_plan */,\n                    \"rows_for_plan\": 3,\n                    \"cost_for_plan\": 1.6154,\n                    \"chosen\": true\n                  } /* chosen_range_access_summary */\n                } /* range_analysis */\n              }\n            ] /* rows_estimation */\n          },\n          {\n            \"considered_execution_plans\": [\n              {\n                \"plan_prefix\": [\n                ] /* plan_prefix */,\n                \"table\": \"`tb_item`\",\n                \"best_access_path\": {\n                  \"considered_access_paths\": [\n                    {\n                      \"access_type\": \"range\",\n                      \"rows\": 3,\n                      \"cost\": 2.2154,\n                      \"chosen\": true\n                    }\n                  ] /* considered_access_paths */\n                } /* best_access_path */,\n                \"cost_for_plan\": 2.2154,\n                \"rows_for_plan\": 3,\n                \"chosen\": true\n              }\n            ] /* considered_execution_plans */\n          },\n          {\n            \"attaching_conditions_to_tables\": {\n              \"original_condition\": \"(`tb_item`.`id` < 4)\",\n              \"attached_conditions_computation\": [\n              ] /* attached_conditions_computation */,\n              \"attached_conditions_summary\": [\n                {\n                  \"table\": \"`tb_item`\",\n                  \"attached\": \"(`tb_item`.`id` < 4)\"\n                }\n              ] /* attached_conditions_summary */\n            } /* attaching_conditions_to_tables */\n          },\n          {\n            \"refine_plan\": [\n              {\n                \"table\": \"`tb_item`\",\n                \"access_type\": \"range\"\n              }\n            ] /* refine_plan */\n          }\n        ] /* steps */\n      } /* join_optimization */\n    },\n    {\n      \"join_execution\": {\n        \"select#\": 1,\n        \"steps\": [\n        ] /* steps */\n      } /* join_execution */\n    }\n  ] /* steps */\n}\n```\n\n\n\n#  SQL优化\n\n##  大批量插入数据\n\n环境准备 ： \n\n```sql\nCREATE TABLE `tb_user_2` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(45) NOT NULL,\n  `password` varchar(96) NOT NULL,\n  `name` varchar(45) NOT NULL,\n  `birthday` datetime DEFAULT NULL,\n  `sex` char(1) DEFAULT NULL,\n  `email` varchar(45) DEFAULT NULL,\n  `phone` varchar(45) DEFAULT NULL,\n  `qq` varchar(32) DEFAULT NULL,\n  `status` varchar(32) NOT NULL COMMENT '用户状态',\n  `create_time` datetime NOT NULL,\n  `update_time` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `unique_user_username` (`username`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 ;\n```\n\n\n\n当使用load 命令导入数据的时候，适当的设置可以提高导入的效率。\n\n![1556269346488](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163803.png) \n\n```sql\nload data local infile '/root/sql1.log'   # 加载本地文件\ninto table 'tb_user_1'  \t\t\t\t\t\t\t\t\t# 加载到哪个表\nfields terminated by ',' \t\t\t\t\t\t\t\t\t# 文件中数据的属性之间的分割符\nlines terminated by '\\n';\t\t\t\t\t\t\t\t\t# 文件中一条数据与另一条数据之间的分隔符\n```\n\n\n\n对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率：\n\n1） 主键顺序插入\n\n因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。\n\n```\n脚本文件介绍 :\n\tsql1.log  ----> 主键有序\n\tsql2.log  ----> 主键无序\n```\n\n插入ID顺序排列数据：\n\n![1555771750567](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163808.png)\n\n插入ID无序排列数据：\n\n![1555771959734](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163812.png) \n\n\n\n2） 关闭唯一性校验\n\n在导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。\n\n![1555772132736](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163817.png) \n\n\n\n3） 手动提交事务\n\n如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。\n\n![1555772351208](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163821.png)\n\n\n\n##  优化insert语句\n\n当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。\n\n- 如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。\n\n  示例， 原始方式为：\n\n  ```sql\n  insert into tb_test values(1,'Tom');\n  insert into tb_test values(2,'Cat');\n  insert into tb_test values(3,'Jerry');\n  ```\n\n  优化后的方案为 ： \n\n  ```sql\n  insert into tb_test values(1,'Tom'),(2,'Cat')，(3,'Jerry');\n  ```\n\n- 在事务中进行数据插入。\n\n  ```sql\n  start transaction;\n  insert into tb_test values(1,'Tom');\n  insert into tb_test values(2,'Cat');\n  insert into tb_test values(3,'Jerry');\n  commit;\n  ```\n\n- 数据有序插入\n\n  ```sql\n  insert into tb_test values(4,'Tim');\n  insert into tb_test values(1,'Tom');\n  insert into tb_test values(3,'Jerry');\n  insert into tb_test values(5,'Rose');\n  insert into tb_test values(2,'Cat');\n  ```\n\n  优化后\n\n  ```sql\n  insert into tb_test values(1,'Tom');\n  insert into tb_test values(2,'Cat');\n  insert into tb_test values(3,'Jerry');\n  insert into tb_test values(4,'Tim');\n  insert into tb_test values(5,'Rose');\n  ```\n\n\n\n##  优化order by语句\n\n###  环境准备\n\n```SQL\nCREATE TABLE `emp` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(100) NOT NULL,\n  `age` int(3) NOT NULL,\n  `salary` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4;\n\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('1','Tom','25','2300');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('2','Jerry','30','3500');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('3','Luci','25','2800');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('4','Jay','36','3500');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('5','Tom2','21','2200');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('6','Jerry2','31','3300');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('7','Luci2','26','2700');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('8','Jay2','33','3500');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('9','Tom3','23','2400');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('10','Jerry3','32','3100');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('11','Luci3','26','2900');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('12','Jay3','37','4500');\n\ncreate index idx_emp_age_salary on emp(age,salary);\n```\n\n\n\n###  两种排序方式\n\n1). 第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。\n\n![1556335817763](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163828.png) \n\n2). 第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。\n\n![1556335866539](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163831.png) \n\n多字段排序\n\n![1556336352061](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163835.png) \n\n\n\n了解了MySQL的排序方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。where 条件和Order by 使用相同的索引，并且**Order By 的顺序和索引顺序相同**， 并且Order  by 的字段都是升序，或者都是降序。否则肯定需要额外的操作，这样就会出现FileSort。\n\n\n\n###  Filesort 的优化\n\n通过创建合适的索引，能够减少 Filesort 的出现，但是在某些情况下，条件限制不能让Filesort消失，那就需要加快 Filesort的排序操作。对于Filesort ， MySQL 有两种排序算法：\n\n1） 两次扫描算法 ：MySQL4.1 之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buffer 中排序，如果sort buffer不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I/O操作。\n\n2）一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort  buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。\n\n\n\nMySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query语句取出的满足条件的所有字段总大小， 来判定是否那种排序算法，如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。\n\n可以适当提高 sort_buffer_size  和 max_length_for_sort_data  系统变量，来增大排序区的大小，提高排序的效率。\n\n![1556338367593](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163842.png) \n\n\n\n##  优化group by 语句\n\n由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以，在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。\n\n如果查询包含 group by 但是用户想要避免排序结果的消耗， 则可以执行order by null 禁止排序。如下 ：\n\n```SQL\ndrop index idx_emp_age_salary on emp;\n\nexplain select age,count(*) from emp group by age;\n```\n\n![1556339573979](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163846.png)  \n\n优化后\n\n```sql\nexplain select age,count(*) from emp group by age order by null;\n```\n\n![1556339633161](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163850.png)  \n\n从上面的例子可以看出，第一个SQL语句需要进行\"filesort\"，而第二个SQL由于order  by  null 不需要进行 \"filesort\"， 而上文提过Filesort往往非常耗费时间。\n\n\n\n创建索引 ：\n\n```SQL\ncreate index idx_emp_age on emp(age)；\n```\n\n![1556339688158](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163856.png) \n\n\n\n##  优化嵌套查询\n\nMysql4.1版本之后，开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。\n\n示例 ，查找有角色的所有的用户信息 : \n\n```SQL\n explain select * from t_user where id in (select user_id from user_role );\n```\n\n执行计划为 : \n\n![1556359399199](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163901.png)   \n\n\n\n优化后 :\n\n```SQL\nexplain select * from t_user u , user_role ur where u.id = ur.user_id;\n```\n\n![1556359482142](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163908.png)   \n\n\n\n连接(Join)查询之所以更有效率一些 ，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。\n\n\n\n##  优化OR条件\n\n对于包含OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引 ， 而且不能使用到复合索引； 如果没有索引，则应该考虑增加索引。\n\n获取 emp 表中的所有的索引 ： \n\n![1556354464657](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163915.png)  \n\n示例 ： \n\n```SQL\nexplain select * from emp where id = 1 or age = 30;\n```\n\n![1556354887509](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163921.png)\n\n![1556354920964](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163925.png)  \n\n建议使用 union 替换 or ： \n\n![1556355027728](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163929.png) \n\n我们来比较下重要指标，发现主要差别是 type 和 ref 这两项\n\ntype 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：\n\n```\nsystem > const > eq_ref > ref > fulltext > ref_or_null  > index_merge > unique_subquery > index_subquery > range > index > ALL\n```\n\nUNION 语句的 type 值为 ref，OR 语句的 type 值为 range，可以看到这是一个很明显的差距\n\nUNION 语句的 ref 值为 const，OR 语句的 type 值为 null，const 表示是常量值引用，非常快\n\n这两项的差距就说明了 UNION 要优于 OR 。\n\n\n\n##  优化分页查询\n\n一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10  ，此时需要MySQL排序前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。\n\n![1556361314783](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163935.png) \n\n###  优化思路一\n\n在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。\n\n![1556416102800](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163939.png) \n\n\n\n###  优化思路二\n\n该方案适用于主键自增的表，且主键不能出现断层，可以把Limit 查询转换成某个位置的查询 。\n\n![1556363928151](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163943.png) \n\n\n\n##  使用SQL提示\n\nSQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。\n\n###  USE INDEX\n\n在查询语句中表名的后面，添加 use index 来提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。\n\n```\ncreate index idx_seller_name on tb_seller(name);\n```\n\n![1556370971576](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163947.png) \n\n###  IGNORE INDEX\n\n如果用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index 作为 hint 。\n\n```\n explain select * from tb_seller ignore index(idx_seller_name) where name = '小米科技';\n```\n\n![1556371004594](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163951.png) \n\n###  FORCE INDEX\n\n为强制MySQL使用一个特定的索引，可在查询中使用 force index 作为hint 。 \n\n``` SQL\ncreate index idx_seller_address on tb_seller(address);\n```\n\n![1556371355788](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163955.png) \n\n\n\n#  应用优化\n\n在实际生产环境中，由于数据库本身的性能局限，就必须要对前台的应用进行一些优化，来降低数据库的访问压力。\n\n\n\n##  使用连接池\n\n对于访问数据库来说，建立连接的代价是比较昂贵的，因为我们频繁的创建关闭连接，是比较耗费资源的，我们有必要建立 数据库连接池，以提高访问的性能。\n\n\n\n##  减少对MySQL的访问\n\n\n\n###  避免对数据进行重复检索\n\n在编写应用代码时，需要能够理清对数据库的访问逻辑。能够一次连接就获取到结果的，就不用两次连接，这样可以大大减少对数据库无用的重复请求。\n\n比如 ，需要获取书籍的id 和name字段 ， 则查询如下： \n\n```\n select id , name from tb_book;\n```\n\n之后，在业务逻辑中有需要获取到书籍状态信息， 则查询如下：\n\n```\nselect id , status from tb_book;\n```\n\n这样，就需要向数据库提交两次请求，数据库就要做两次查询操作。其实完全可以用一条SQL语句得到想要的结果。\n\n```\nselect id, name , status from tb_book;\n```\n\n\n\n###  增加cache层\n\n在应用中，我们可以在应用中增加 缓存 层来达到减轻数据库负担的目的。缓存层有很多种，也有很多实现方式，只要能达到降低数据库的负担又能满足应用需求就可以。\n\n因此可以部分数据从数据库中抽取出来放到应用端以文本方式存储， 或者使用框架(Mybatis, Hibernate)提供的一级缓存/二级缓存，或者使用redis数据库来缓存数据 。\n\n\n\n##  负载均衡\n\n负载均衡是应用中使用非常普遍的一种优化方法，它的机制就是利用某种均衡算法，将固定的负载量分布到不同的服务器上， 以此来降低单台服务器的负载，达到优化的效果。\n\n\n\n###  利用MySQL复制分流查询\n\n通过MySQL的主从复制，实现读写分离，使增删改操作走主节点，查询操作走从节点，从而可以降低单台服务器的读写压力。\n\n![1](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625165711.jpg) \n\n\n\n###  采用分布式数据库架构\n\n分布式数据库架构适合大数据量、负载高的情况，它有良好的拓展性和高可用性。通过在多台服务器之间分布数据，可以实现在多台服务器之间的负载均衡，提高访问效率。\n\n\n\n\n\n#  Mysql中查询缓存优化\n\n\n\n##  概述\n\n开启Mysql的查询缓存，当执行完全相同的SQL语句的时候，服务器就会直接从缓存中读取结果，当数据被修改，之前的缓存会失效，修改比较频繁的表不适合做查询缓存。\n\n##  操作流程\n\n ![20180919131632347](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625165716.png) \n\n1. 客户端发送一条查询给服务器；\n2. 服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；\n3. 服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；\n4. MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；\n5. 将结果返回给客户端。\n\n\n\n##  查询缓存配置\n\n1. 查看当前的MySQL数据库是否支持查询缓存：\n\n   ```SQL\n   SHOW VARIABLES LIKE 'have_query_cache';\t\n   ```\n\n   ![1555249929012](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625165721.png) \n\n2. 查看当前MySQL是否开启了查询缓存 ：\n\n   ```SQL\n   SHOW VARIABLES LIKE 'query_cache_type';\n   ```\n\n   ![1555250015377](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625165726.png) \n\n3. 查看查询缓存的占用大小 ：\n\n   ```SQL\n   SHOW VARIABLES LIKE 'query_cache_size';\n   ```\n\n   ![1555250142451](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625165729.png)  \t\n\n4. 查看查询缓存的状态变量：\n\n   ```SQL\n   SHOW STATUS LIKE 'Qcache%';\n   ```\n\n   ![1555250443958](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625165733.png) \n\n   各个变量的含义如下：\n\n   | 参数                    | 含义                                                         |\n   | ----------------------- | ------------------------------------------------------------ |\n   | Qcache_free_blocks      | 查询缓存中的可用内存块数                                     |\n   | Qcache_free_memory      | 查询缓存的可用内存量                                         |\n   | Qcache_hits             | 查询缓存命中数                                               |\n   | Qcache_inserts          | 添加到查询缓存的查询数                                       |\n   | Qcache_lowmen_prunes    | 由于内存不足而从查询缓存中删除的查询数                       |\n   | Qcache_not_cached       | 非缓存查询的数量（由于 query_cache_type 设置而无法缓存或未缓存） |\n   | Qcache_queries_in_cache | 查询缓存中注册的查询数                                       |\n   | Qcache_total_blocks     | 查询缓存中的块总数                                           |\n\n##  开启查询缓存\n\nMySQL的查询缓存默认是关闭的，需要手动配置参数 query_cache_type ， 来开启查询缓存。query_cache_type 该参数的可取值有三个 ：\n\n| 值          | 含义                                                         |\n| ----------- | ------------------------------------------------------------ |\n| OFF 或 0    | 查询缓存功能关闭                                             |\n| ON 或 1     | 查询缓存功能打开，SELECT的结果符合缓存条件即会缓存，否则，不予缓存，显式指定 SQL_NO_CACHE，不予缓存 |\n| DEMAND 或 2 | 查询缓存功能按需进行，显式指定 SQL_CACHE 的SELECT语句才会缓存；其它均不予缓存 |\n\n在 /usr/my.cnf 配置中，增加以下配置 ： \n\n![1555251383805](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625165738.png) \t\t\n\n配置完毕之后，重启服务既可生效 ；\n\n然后就可以在命令行执行SQL语句进行验证 ，执行一条比较耗时的SQL语句，然后再多执行几次，查看后面几次的执行时间；获取通过查看查询缓存的缓存命中数，来判定是否走查询缓存。\n\n\n\n##  查询缓存SELECT选项\n\n可以在SELECT语句中指定两个与查询缓存相关的选项 ：\n\nSQL_CACHE : 如果查询结果是可缓存的，并且 query_cache_type 系统变量的值为ON或 DEMAND ，则缓存查询结果 。\n\nSQL_NO_CACHE : 服务器不使用查询缓存。它既不检查查询缓存，也不检查结果是否已缓存，也不缓存查询结果。\n\n例子：\n\n```SQL\nSELECT SQL_CACHE id, name FROM customer;\nSELECT SQL_NO_CACHE id, name FROM customer;\n```\n\n​\t\n\n##  查询缓存失效的情况\n\n1） SQL 语句不一致的情况， 要想命中查询缓存，查询的SQL语句必须一致。\n\n```SQL\nSQL1 : select count(*) from tb_item;\nSQL2 : Select count(*) from tb_item;\n```\n\n2） 当查询语句中有一些不确定的时，则不会缓存。如 ： now() , current_date() , curdate() , curtime() , rand() , uuid() , user() , database() 。\n\n```SQL\nSQL1 : select * from tb_item where updatetime < now() limit 1;\nSQL2 : select user();\nSQL3 : select database();\n```\n\n3） 不使用任何表查询语句。\n\n```SQL\nselect 'A';\n```\n\n4）  查询 mysql， information_schema或  performance_schema 数据库中的表时，不会走查询缓存。\n\n```SQL\nselect * from information_schema.engines;\n```\n\n5） 在存储的函数，触发器或事件的主体内执行的查询。\n\n6） 如果表更改，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除。这包括使用`MERGE`映射到已更改表的表的查询。一个表可以被许多类型的语句，如被改变 INSERT， UPDATE， DELETE， TRUNCATE TABLE， ALTER TABLE， DROP TABLE，或 DROP DATABASE 。\n\n\n\n#  Mysql内存管理及优化\n\n\n\n##  内存优化原则\n\n1） 将尽量多的内存分配给MySQL做缓存，但要给操作系统和其他程序预留足够内存。\n\n2） MyISAM 存储引擎的数据文件读取依赖于操作系统自身的IO缓存，因此，如果有MyISAM表，就要预留更多的内存给操作系统做IO缓存。\n\n3） 排序区、连接区等缓存是分配给每个数据库会话（session）专用的，其默认值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发连接较高时会导致物理内存耗尽。\n\n\n\n##  MyISAM 内存优化\n\nmyisam存储引擎使用 key_buffer 缓存索引块，加速myisam索引的读写速度。对于myisam表的数据块，mysql没有特别的缓存机制，完全依赖于操作系统的IO缓存。\n\n\n\n##### key_buffer_size\n\nkey_buffer_size决定MyISAM索引块缓存区的大小，直接影响到MyISAM表的存取效率。可以在MySQL参数文件中设置key_buffer_size的值，对于一般MyISAM数据库，建议至少将1/4可用内存分配给key_buffer_size。\n\n在/usr/my.cnf 中做如下配置：\n\n```\nkey_buffer_size=512M\n```\n\n\n\n##### read_buffer_size\n\n如果需要经常顺序扫描myisam表，可以通过增大read_buffer_size的值来改善性能。但需要注意的是read_buffer_size是每个session独占的，如果默认值设置太大，就会造成内存浪费。\n\n\n\n##### read_rnd_buffer_size\n\n对于需要做排序的myisam表的查询，如带有order by子句的sql，适当增加 read_rnd_buffer_size 的值，可以改善此类的sql性能。但需要注意的是 read_rnd_buffer_size 是每个session独占的，如果默认值设置太大，就会造成内存浪费。\n\n\n\n##  InnoDB 内存优化\n\ninnodb用一块内存区做IO缓存池，该缓存池不仅用来缓存innodb的索引块，而且也用来缓存innodb的数据块。\n\n\n\n##### innodb_buffer_pool_size\n\n该变量决定了 innodb 存储引擎表数据和索引数据的最大缓存区大小。在保证操作系统及其他程序有足够内存可用的情况下，innodb_buffer_pool_size 的值越大，缓存命中率越高，访问InnoDB表需要的磁盘I/O 就越少，性能也就越高。\n\n```\ninnodb_buffer_pool_size=512M\n```\n\n\n\n##### innodb_log_buffer_size\n\n决定了innodb重做日志缓存的大小，对于可能产生大量更新记录的大事务，增加innodb_log_buffer_size的大小，可以避免innodb在事务提交前就执行不必要的日志写入磁盘操作。\n\n```\ninnodb_log_buffer_size=10M\n```\n\n\n\n# MySql中常用工具\n\n\n\n##  mysql\n\n该mysql不是指mysql服务，而是指mysql的客户端工具。\n\n语法 ：\n\n```markdown\nmysql [options] [database]\n```\n\n###  连接选项\n\n```markdown\n参数 ： \n\t-u, --user=name\t\t\t指定用户名\n\t-p, --password[=name]\t指定密码\n\t-h, --host=name\t\t\t指定服务器IP或域名\n\t-P, --port=#\t\t\t指定连接端口\n\n示例 ：\n\tmysql -h 127.0.0.1 -P 3306 -u root -p\n\t\n\tmysql -h127.0.0.1 -P3306 -uroot -p2143\n\t\n```\n\n###  执行选项\n\n```markdown\n\t-e, --execute=name\t\t执行SQL语句并退出\n```\n\n此选项可以在Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便。\n\n```markdown\n示例：\n\tmysql -uroot -p2143 db01 -e \"select * from tb_book\";\n```\n\n![1555325632715](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625165958.png) \n\n\n\n##  mysqladmin\n\nmysqladmin 是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。\n\n可以通过 ： mysqladmin --help  指令查看帮助文档\n\n![1555326108697](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170002.png) \n\n```markdown\n示例 ：\n\tmysqladmin -uroot -p2143 create 'test01';  \n\tmysqladmin -uroot -p2143 drop 'test01';\n\tmysqladmin -uroot -p2143 version;\n\t\n```\n\n\n\n##  mysqlbinlog\n\n由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog 日志管理工具。\n\n语法 ：\n\n```markdown\n\tmysqlbinlog [options]  log-files1 log-files2 ...\n\n选项：\n\t\n\t-d, --database=name : 指定数据库名称，只列出指定的数据库相关操作。\n\t\n\t-o, --offset=# : 忽略掉日志中的前n行命令。\n\t\n\t-r,--result-file=name : 将输出的文本格式日志输出到指定文件。\n\t\n\t-s, --short-form : 显示简单格式， 省略掉一些信息。\n\t\n\t--start-datatime=date1  --stop-datetime=date2 : 指定日期间隔内的所有日志。\n\t\n\t--start-position=pos1 --stop-position=pos2 : 指定位置间隔内的所有日志。\n```\n\n\n\n##  mysqldump\n\nmysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。\n\n语法 ：\n\n```markdown\n\tmysqldump [options] db_name [tables]\n\t\t\t\t\t\t\t\t\t\t数据库名\n\tmysqldump [options] --database/-B db1 [db2 db3...]\n\n\tmysqldump [options] --all-databases/-A\n```\n\n\n\n###  连接选项\n\n```markdown\n参数 ： \n\t-u, --user=name\t\t\t指定用户名\n\t-p, --password[=name]\t指定密码\n\t-h, --host=name\t\t\t指定服务器IP或域名\n\t-P, --port=#\t\t\t指定连接端口\n```\n\n\n\n###  输出内容选项\n\n```markdown\n参数：\n\t--add-drop-database\t\t在每个数据库创建语句前加上 Drop database 语句\n\t--add-drop-table\t\t在每个表创建语句前加上 Drop table 语句 , 默认开启 ; 不开启 (--skip-add-drop-table)\n\t\n\t-n, --no-create-db\t\t不包含数据库的创建语句\n\t-t, --no-create-info\t不包含数据表的创建语句\n\t-d --no-data\t\t\t不包含数据\n\t\n\t -T, --tab=name\t\t\t自动生成两个文件：一个.sql文件，创建表结构的语句；\n\t \t\t\t\t\t\t一个.txt文件，数据文件，相当于select into outfile  \n```\n\n```markdown\n示例 ： \n\tmysqldump -uroot -p2143 db01 tb_book --add-drop-database --add-drop-table > a.sql\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t导出语句到当前目录下的a.sql文件中\n\tmysqldump -uroot -p2143 -T /tmp test city\n\t \t\t\t\t\t\t将test数据库的city表 输出到/tmp目录下，文件名默认为表明开头。\n```\n\n\n\n##  mysqlimport/source\n\nmysqlimport 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件。\n\n语法：\n\n```markdown\n\tmysqlimport [options]  db_name  textfile1  [textfile2...]‘\n```\n\n示例：\n\n```markdown\n\tmysqlimport -uroot -p2143 test /tmp/city.txt\n注意：test数据库中要有对应的city表。\n```\n\n\n\n如果需要导入sql文件,可以使用mysql中的source 指令 : \n\n```markdown\n\tsource /root/tb_book.sql\n```\n\n\n\n##  mysqlshow\n\nmysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。\n\n语法：\n\n```markdown\n\tmysqlshow [options] [db_name [table_name [col_name]]]\n```\n\n参数：\n\n```markdown\n# 显示数据库及表的统计信息（数据库，表 均可以不指定）\n\t--count\t\t\n# 显示指定数据库或者指定表的状态信息\n\t-i\t\t\t\n```\n\n\n\n示例：\n\n```markdown\n# 查询每个数据库的表的数量及表中记录的数量\n\tmysqlshow -uroot -p2143 --count\n\n# 查询test库中每个表中的字段书，及行数\n\tmysqlshow -uroot -p2143 test --count\n\n# 查询test库中book表的详细情况\n\tmysqlshow -uroot -p2143 test book --count\n\n```\n\n\n\n#  Mysql 日志\n\n在任何一种数据库中，都会有各种各样的日志，记录着数据库工作的方方面面，以帮助数据库管理员追踪数据库曾经发生过的各种事件。MySQL 也不例外，在 MySQL 中，有 4 种不同的日志，分别是错误日志、二进制日志（BINLOG 日志）、查询日志和慢查询日志，这些日志记录着数据库在不同方面的踪迹。\n\n\n\n##  错误日志\n\n错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，可以首先查看此日志。\n\n该日志是默认开启的 ， 默认存放目录为 mysql 的数据目录（var/lib/mysql）, 默认的日志文件名为  hostname.err（hostname是主机名）。\n\n查看日志位置指令 ： \n\n```sql\nshow variables like 'log_error%';\n```\n\n![1553993244446](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170010.png) \n\n\n\n查看日志内容 ： \n\n```shell\ntail -f /var/lib/mysql/xaxh-server.err\n```\n\n![1553993537874](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170013.png) \n\n\n\n##  二进制日志\n\n\n\n### 概述\n\n二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但是`不包括数据查询语句`。此日志对于灾难时的数据恢复起着极其重要的作用，MySQL的主从复制， 就是通过该binlog实现的。\n\n二进制日志，默认情况下是没有开启的，需要到MySQL的配置文件中开启，并配置MySQL日志的格式。 \n\n配置文件位置 : /usr/my.cnf\n\n日志存放位置 : 配置时，给定了文件名但是没有指定路径，日志默认写入Mysql的数据目录。\n\n```markdown\n# 配置开启binlog日志， 日志的文件前缀为 mysqlbin -----> 生成的文件名如 : mysqlbin.000001,mysqlbin.000002\n\tlog_bin=mysqlbin\n\n# 配置二进制日志的格式\n\tbinlog_format=STATEMENT\n```\n\n\n\n###  日志格式\n\n**STATEMENT**\n\n\t\t该日志格式在日志文件中记录的都是SQL语句（statement），每一条对数据进行修改的SQL都会记录在日志文件中，通过Mysql提供的mysqlbinlog工具，可以清晰的查看到每条语句的文本。主从复制的时候，从库（slave）会将日志解析为原文本，并在从库重新执行一次。\n\n\n\n**ROW**\n\n\t\t该日志格式在日志文件中记录的是每一行的数据变更，而不是记录SQL语句。比如，执行SQL语句 ： update tb_book set status='1' , 如果是STATEMENT 日志格式，在日志中会记录一行SQL文件； 如果是ROW，由于是对全表进行更新，也就是每一行记录都会发生变更，ROW 格式的日志中会记录每一行的数据变更。\n\n\n\n**MIXED**\n\n\t\t这是目前MySQL默认的日志格式，即混合了STATEMENT 和 ROW两种格式。默认情况下采用STATEMENT，但是在一些特殊情况下采用ROW来进行记录。MIXED 格式能尽量利用两种模式的优点，而避开他们的缺点。\n\n\n\n###  日志读取\n\n由于日志以二进制方式存储，不能直接读取，需要用mysqlbinlog工具来查看，语法如下 ：\n\n```markdown\n\tmysqlbinlog 日志文件名；\n```\n\n\n\n**查看STATEMENT格式日志** \n\n执行插入语句 ：\n\n```SQL\ninsert into tb_book values(null,'Lucene','2088-05-01','0');\n```\n\n 查看日志文件 ：\n\n![1554079717375](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170020.png) \n\nmysqlbin.index : 该文件是日志索引文件 ， 记录日志的文件名；\n\nmysqlbing.000001 ：日志文件\n\n查看日志内容 ：\n\n```shell\nmysqlbinlog mysqlbing.000001；\n```\n\n![1554080016778](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170024.png) \n\n\n\n**查看ROW格式日志**\n\n配置 :\n\n```markdown\n# 配置开启binlog日志， 日志的文件前缀为 mysqlbin -----> 生成的文件名如 : mysqlbin.000001,mysqlbin.000002\n\tlog_bin=mysqlbin\n\n# 配置二进制日志的格式\n\tbinlog_format=ROW\n```\n\n插入数据 :\n\n```sql\ninsert into tb_book values(null,'SpringCloud实战','2088-05-05','0');\n```\n\n如果日志格式是 ROW , 直接查看数据 , 是查看不懂的 ; 可以在mysqlbinlog 后面加上参数 -vv  \n\n```shell\nmysqlbinlog -vv mysqlbin.000002 \n```\n\n![1554095452022](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170030.png) \n\n\n\n###  日志删除\n\n对于比较繁忙的系统，由于每天生成日志量大 ，这些日志如果长时间不清楚，将会占用大量的磁盘空间。下面我们将会讲解几种删除日志的常见方法 ：\n\n**方式一** \n\n通过 Reset Master 指令删除全部 binlog 日志，删除之后，日志编号，将从 xxxx.000001重新开始 。\n\n查询之前 ，先查询下日志文件 ： \n\n![1554118609489](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170034.png)   \n\n执行删除日志指令： \n\n```\nReset Master\n```\n\n执行之后， 查看日志文件 ：\n\n![1554118675264](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170037.png) \n\n\n\n**方式二**\n\n执行指令 ``` purge  master logs to 'mysqlbin.******'``` ，该命令将删除  ``` ******``` 编号之前的所有日志。 \n\n\n\n**方式三**\n\n执行指令 ``` purge master logs before 'yyyy-mm-dd hh24:mi:ss'``` ，该命令将删除日志为 \"yyyy-mm-dd hh24:mi:ss\" 之前产生的所有日志 。\n\n\n\n**方式四**\n\n设置参数 --expire_logs_days=# ，此参数的含义是设置日志的过期天数， 过了指定的天数后日志将会被自动删除，这样将有利于减少DBA 管理日志的工作量。\n\n配置如下 ： \n\n![1554125506938](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170041.png) \n\n\n\n##  查询日志\n\n查询日志中记录了客户端的**所有操作语句**，而二进制日志不包含查询数据的SQL语句。\n\n默认情况下， 查询日志是未开启的。如果需要开启查询日志，可以设置以下配置 ：\n\n```markdown\n# 该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启 \n\tgeneral_log=1\n\n# 设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.log \n\tgeneral_log_file=file_name\n```\n\n在 mysql 的配置文件 /usr/my.cnf 中配置如下内容 ： \n\n![1554128184632](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170045.png) \n\n\n\n配置完毕之后，在数据库执行以下操作 ：\n\n```sql\nselect * from tb_book;\nselect * from tb_book where id = 1;\nupdate tb_book set name = 'lucene入门指南' where id = 5;\nselect * from tb_book where id < 8;\n```\n\n\n\n执行完毕之后， 再次来查询日志文件 ： \n\n![1554128089851](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170050.png) \n\n\n\n##  慢查询日志\n\n慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的SQL语句的日志。long_query_time 默认为 10 秒，最小为 0， 精度可以到微秒。\n\n\n\n###  文件位置和格式\n\n慢查询日志默认是关闭的 。可以通过两个参数来控制慢查询日志 ：\n\n```markdown\n# 该参数用来控制慢查询日志是否开启， 可取值： 1 和 0 ， 1 代表开启， 0 代表关闭\n\tslow_query_log=1 \n\n# 该参数用来指定慢查询日志的文件名\n\tslow_query_log_file=slow_query.log\n\n# 该选项用来配置查询的时间限制，单位秒。 超过这个时间将认为值慢查询， 将需要进行日志记录， 默认10s\n\tlong_query_time=10\n```\n\n\n\n###  日志的读取\n\n和错误日志、查询日志一样，慢查询日志记录的格式也是纯文本，可以被直接读取。\n\n1） 查询long_query_time 的值。\n\n![1554130333472](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170055.png) \n\n\n\n2） 执行查询操作\n\n```sql\nselect id, title,price,num ,status from tb_item where id = 1;\n```\n\n![1554130448709](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170058.png)\n\n由于该语句执行时间很短，为0s ， 所以不会记录在慢查询日志中。\n\n\n\n```\nselect * from tb_item where title like '%阿尔卡特 (OT-927) 炭黑 联通3G手机 双卡双待165454%' ;\n```\n\n![1554130532577](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170101.png) \n\n该SQL语句 ， 执行时长为 26.77s ，超过10s ， 所以会记录在慢查询日志文件中。\n\n\n\n3） 查看慢查询日志文件\n\n直接通过cat 指令查询该日志文件 ： \n\n![1554130669360](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170104.png) \n\n\n\n如果慢查询日志内容很多， 直接查看文件，比较麻烦， 这个时候可以借助于mysql自带的 mysqldumpslow 工具， 来对慢查询日志进行分类汇总。 \n\n![1554130856485](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170108.png) \n\n\n\n#  Mysql复制\n\n\n\n##  复制概述\n\n复制是指将主数据库的DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。\n\nMySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状复制。\n\n\n\n##  复制原理\n\nMySQL 的主从复制原理如下。\n\n![1554423698190](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170112.jpg) \n\n从上层来看，复制分成三步：\n\n- Master 主库在事务提交时，会把数据变更作为时间 Events 记录在二进制日志文件 Binlog 中。\n- 主库推送二进制日志文件 Binlog 中的日志事件到从库的中继日志 Relay Log 。\n\n- slave重做中继日志中的事件，将改变反映它自己的数据。\n\n\n\n##  复制优势\n\nMySQL 复制的有点主要包含以下三个方面：\n\n- 主库出现问题，可以快速切换到从库提供服务。\n\n- 可以在从库上执行查询操作，从主库中更新，实现读写分离，降低主库的访问压力。\n\n- 可以在从库中执行备份，以避免备份期间影响主库的服务。\n\n\n\n##  搭建步骤\n\n\n\n###  master\n\n1） 在master 的配置文件（/usr/my.cnf）中，配置如下内容：\n\n```properties\n#mysql 服务ID,保证整个集群环境中唯一\nserver-id=1\n\n#mysql binlog 日志的存储路径和文件名\nlog-bin=/var/lib/mysql/mysqlbin\n\n#错误日志,默认已经开启\n#log-err\n\n#mysql的安装目录\n#basedir\n\n#mysql的临时目录\n#tmpdir\n\n#mysql的数据存放目录\n#datadir\n\n#是否只读,1 代表只读, 0 代表读写\nread-only=0\n\n#忽略的数据, 指不需要同步的数据库\nbinlog-ignore-db=mysql\n\n#指定同步的数据库\n#binlog-do-db=db01\n```\n\n2） 执行完毕之后，需要重启Mysql：\n\n```sql\nservice mysqld.service restart ；\n```\n\n3） 创建同步数据的账户，并且进行授权操作：\n\n```sql\nmysql> grant replication slave on *.* to 'root'@'192.168.56.103' identified by 'root';\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t用户\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t密码\nflush privileges;\n```\n\n4） 查看master状态：\n\n```sql\nshow master status;\n```\n\n![1554477759735](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170118.png) \n\n字段含义：\n\n```\nFile : 从哪个日志文件开始推送日志文件 \nPosition ： 从哪个位置开始推送日志\nBinlog_Ignore_DB : 指定不需要同步的数据库\n```\n\n\n\n###  slave\n\n1） 在 slave 端配置文件中，配置如下内容：\n\n```properties\n#mysql服务端ID,唯一\nserver-id=2\n\n#指定binlog日志\nlog-bin=/var/lib/mysql/mysqlbin\n```\n\n2）  执行完毕之后，需要重启Mysql：\n\n```\nservice mysqld.service restart\n```\n\n3） 执行如下指令 ：\n\n```sql\nmysql> change master to master_host= '192.168.56.102', master_user='root', master_password='root', master_log_file='mysqlbin.000001', master_log_pos=413;\n master_user ：主库创建的用户\n master_password ：主库创建的密码\n```\n\n指定当前从库对应的主库的IP地址，用户名，密码，从哪个日志文件开始的那个位置开始同步推送日志。\n\n4） 开启同步操作\n\n```sql\nstart slave;\n\nshow slave status;\n\n出现的错误：\n\tSlave_IO_Running: No 。且会发现下面的错误\n\tFatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work.\n原因：我是直接复制主库的虚拟机，没有修改从库的mysql的uuid,导致主库和从库的虚拟机的uuid相同。\n解决方法：以下操作是在从库中完成的\n\t首先在mysql中执行 select uuid(); 获取到一个uuid，然后复制这个uuid.\n\t然后退出mysql，执行下面命令：\n\t\tcd /var/lib/mysql/\n\t\tvi auto.cnf\n\t然后将复制的uuid替换调原来的。\n\t重启mysql服务，即可。\n```\n\n![1554479387365](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170125.png) \n\n5） 停止同步操作\n\n```sql\nstop slave;\n```\n\n\n\n###  验证同步操作\n\n1） 在主库中创建数据库，创建表，并插入数据 ：\n\n```sql\ncreate database db01;\n\nuse db01;\n\ncreate table user(\n\tid int(11) not null auto_increment,\n\tname varchar(50) not null,\n\tsex varchar(1),\n\tprimary key (id)\n)engine=innodb default charset=utf8;\n\ninsert into user(id,name,sex) values(null,'Tom','1');\ninsert into user(id,name,sex) values(null,'Trigger','0');\ninsert into user(id,name,sex) values(null,'Dawn','1');\n```\n\n2） 在从库中查询数据，进行验证 ：\n\n在从库中，可以查看到刚才创建的数据库：\n\n![1554544658640](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170129.png) \n\n在该数据库中，查询user表中的数据：\n\n![1554544679538](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625170133.png) \n\n\n\n\n\n#  常用SQL技巧\n\n\n\n##  SQL执行顺序\n\n编写顺序\n\n```SQL\nSELECT DISTINCT\n\t<select list>\nFROM\n\t<left_table> <join_type>\nJOIN\n\t<right_table> ON <join_condition>\nWHERE\n\t<where_condition>\nGROUP BY\n\t<group_by_list>\nHAVING\n\t<having_condition>\nORDER BY\n\t<order_by_condition>\nLIMIT\n\t<limit_params>\n```\n\n执行顺序\n\n``` sql\nFROM\t<left_table>\n\nON \t\t<join_condition>\n\n<join_type>\t\tJOIN\t<right_table>\n\nWHERE\t\t<where_condition>\n\nGROUP BY \t<group_by_list>\n\nHAVING\t\t<having_condition>\n\nSELECT DISTINCT\t\t<select list>\n\nORDER BY\t<order_by_condition>\n\nLIMIT\t\t<limit_params>\n```\n\n\n\n##  正则表达式使用\n\n正则表达式（Regular Expression）是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。\n\n| 符号   | 含义                          |\n| ------ | ----------------------------- |\n| ^      | 在字符串开始处进行匹配        |\n| $      | 在字符串末尾处进行匹配        |\n| .      | 匹配任意单个字符, 包括换行符  |\n| [...]  | 匹配出括号内的任意字符        |\n| [^...] | 匹配不出括号内的任意字符      |\n| a*     | 匹配零个或者多个a(包括空串)   |\n| a+     | 匹配一个或者多个a(不包括空串) |\n| a?     | 匹配零个或者一个a             |\n| a1\\|a2 | 匹配a1或a2                    |\n| a(m)   | 匹配m个a                      |\n| a(m,)  | 至少匹配m个a                  |\n| a(m,n) | 匹配m个a 到 n个a              |\n| a(,n)  | 匹配0到n个a                   |\n| (...)  | 将模式元素组成单一元素        |\n\n```sql\nselect * from emp where name regexp '^T'; #以T开头的\n\nselect * from emp where name regexp '2$'; #以2结尾的\n\nselect * from emp where name regexp '[uvw]'; #name中包含u,v,w中的任一字符的\n```\n\n\n\n##  MySQL 常用函数\n\n\n\n### 数字函数\n\n| 函数名称        | 作 用                                                      |\n| --------------- | ---------------------------------------------------------- |\n| ABS             | 求绝对值                                                   |\n| SQRT            | 求二次方根                                                 |\n| MOD             | 求余数                                                     |\n| CEIL 和 CEILING | 两个函数功能相同，都是返回不小于参数的最小整数，即向上取整 |\n| FLOOR           | 向下取整，返回值转化为一个BIGINT                           |\n| RAND            | 生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列  |\n| ROUND           | 对所传参数进行四舍五入                                     |\n| SIGN            | 返回参数的符号                                             |\n| POW 和 POWER    | 两个函数的功能相同，都是所传参数的次方的结果值             |\n| SIN             | 求正弦值                                                   |\n| ASIN            | 求反正弦值，与函数 SIN 互为反函数                          |\n| COS             | 求余弦值                                                   |\n| ACOS            | 求反余弦值，与函数 COS 互为反函数                          |\n| TAN             | 求正切值                                                   |\n| ATAN            | 求反正切值，与函数 TAN 互为反函数                          |\n| COT             | 求余切值                                                   |\n\n\n\n### 字符串函数\n\n| 函数名称  | 作 用                                                        |\n| --------- | ------------------------------------------------------------ |\n| LENGTH    | 计算字符串长度函数，返回字符串的字节长度                     |\n| CONCAT    | 合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个 |\n| INSERT    | 替换字符串函数                                               |\n| LOWER     | 将字符串中的字母转换为小写                                   |\n| UPPER     | 将字符串中的字母转换为大写                                   |\n| LEFT      | 从左侧字截取符串，返回字符串左边的若干个字符                 |\n| RIGHT     | 从右侧字截取符串，返回字符串右边的若干个字符                 |\n| TRIM      | 删除字符串左右两侧的空格                                     |\n| REPLACE   | 字符串替换函数，返回替换后的新字符串                         |\n| SUBSTRING | 截取字符串，返回从指定位置开始的指定长度的字符换             |\n| REVERSE   | 字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串     |\n\n\n\n### 日期函数\n\n| 函数名称                | 作 用                                                        |\n| ----------------------- | ------------------------------------------------------------ |\n| CURDATE 和 CURRENT_DATE | 两个函数作用相同，返回当前系统的日期值                       |\n| CURTIME 和 CURRENT_TIME | 两个函数作用相同，返回当前系统的时间值                       |\n| NOW 和  SYSDATE         | 两个函数作用相同，返回当前系统的日期和时间值                 |\n| MONTH                   | 获取指定日期中的月份                                         |\n| MONTHNAME               | 获取指定日期中的月份英文名称                                 |\n| DAYNAME                 | 获取指定曰期对应的星期几的英文名称                           |\n| DAYOFWEEK               | 获取指定日期对应的一周的索引位置值                           |\n| WEEK                    | 获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53 |\n| DAYOFYEAR               | 获取指定曰期是一年中的第几天，返回值范围是1~366              |\n| DAYOFMONTH              | 获取指定日期是一个月中是第几天，返回值范围是1~31             |\n| YEAR                    | 获取年份，返回值范围是 1970〜2069                            |\n| TIME_TO_SEC             | 将时间参数转换为秒数                                         |\n| SEC_TO_TIME             | 将秒数转换为时间，与TIME_TO_SEC 互为反函数                   |\n| DATE_ADD 和 ADDDATE     | 两个函数功能相同，都是向日期添加指定的时间间隔               |\n| DATE_SUB 和 SUBDATE     | 两个函数功能相同，都是向日期减去指定的时间间隔               |\n| ADDTIME                 | 时间加法运算，在原始时间上添加指定的时间                     |\n| SUBTIME                 | 时间减法运算，在原始时间上减去指定的时间                     |\n| DATEDIFF                | 获取两个日期之间间隔，返回参数 1 减去参数 2 的值             |\n| DATE_FORMAT             | 格式化指定的日期，根据参数返回指定格式的值                   |\n| WEEKDAY                 | 获取指定日期在一周内的对应的工作日索引                       |\n\n\n\n### 聚合函数\n\n| 函数名称 | 作用                             |\n| -------- | -------------------------------- |\n| MAX      | 查询指定列的最大值               |\n| MIN      | 查询指定列的最小值               |\n| COUNT    | 统计查询结果的行数               |\n| SUM      | 求和，返回指定列的总和           |\n| AVG      | 求平均值，返回指定列数据的平均值 |","categories":["Java学习","数据库"]},{"title":"Mysql高级上","url":"/2021/06/23/尚硅谷说Java/数据库/MySQL高级上/","content":"\n\n\nMySQL的深入学习：索引，视图，存储过程，函数，触发器，存储引擎，并发参数，表锁和行锁\n\n\n\n<!--more-->\n\n\n\n# Mysql的体系结构概览\n\n![171214401286615](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163019.jpg) \n\n整个MySQL Server由以下组成\n\n- Connection Pool : 连接池组件\n- Management Services & Utilities : 管理服务和工具组件\n- SQL Interface : SQL接口组件\n- Parser : 查询分析器组件\n- Optimizer : 优化器组件\n- Caches & Buffers : 缓冲池组件\n- Pluggable Storage Engines : 存储引擎\n- File System : 文件系统\n\n\n\n1） 连接层\n\n最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。\n\n2） 服务层\n\n第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。\n\n3） 引擎层\n\n存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。\n\n4）存储层\n\n数据存储层， 主要是将数据存储在文件系统之上，并完成与存储引擎的交互。\n\n\n\n和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。\n\n\n\n# Linux 系统安装MySQL\n\n\n\n## 下载Linux 安装包\n\n```\nhttps://dev.mysql.com/downloads/mysql/5.7.html#downloads\n```\n\n\n\n##  安装MySQL\n\n```\n1). 卸载 centos 中预安装的 mysql\n\t\n查看\trpm -qa | grep -i mysql\nrpm -qa|grep mariadb\n\t\n卸载\trpm -e mysql-libs-5.1.71-1.el6.x86_64 --nodeps\nrpm -e --nodeps mariadb-libs-5.5-68-1.el7.x86_64\n\t\n2). 上传 mysql 的安装包\n\t\n\talt + p -------> put  E:/test/MySQL-5.7.34-1.el7.x86_64.rpm-bundle.tar\n\n3). 解压 mysql 的安装包 \n\t\n\tmkdir mysql\n\t\n\ttar -xvf MySQL-5.7.34-1.el7.x86_64.rpm-bundle.tar -C /root/mysql\n\t\n4). 安装第三方依赖包 \n\t\n\tyum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6 libncurses.so.5 --setopt=protected_multilib=false\n\t\n\tyum  update libstdc++-4.4.7-4.el6.x86_64\n\t\n5). 安装 mysql-client\n\trpm -ivh mysql-community-common-5.7.34-1.el7.x86_64.rpm \n\tpm -ivh mysql-community-libs-5.7.34-1.el7.x86_64.rpm\n\trpm -ivh mysql-community-client-5.7.34-1.el7.x86_64.rpm\n\t\n6). 安装 mysql-server\n\trpm -ivh mysql-community-server-5.7.34-1.el7.x86_64.rpm\n\n\n```\n\n\n\n## 启动 MySQL 服务\n\n```SQL\nservice mysqld.service start\n\nservice mysqld.service stop\n\nservice mysqld.service status\n\nservice mysqld.service restart\n```\n\n\n\n## 登录MySQL\n\n```\nmysql的rpm形式安装\n\t查看初始密码：grep 'temporary password' /var/log/mysqld.log\n2021-06-21T07:42:30.299762Z 1 [Note] A temporary password is generated for root@localhost: f=W2ZYzy>6.<\n\t其中\tf=W2ZYzy>6.< 就是初始密码\n\n登录：mysql -u root -p\n\t然后输入密码。\n\n出现错误：ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock'\n解决方法：打开/etc/my.cnf文件。在最下面添加下面配置。\n      [client]\n      port=3306\n      socket=/var/lib/mysql/mysql.sock # 这个sock要和mysqld的sock路径一致\n      \n登录之后, 修改密码 :\n\t设置一个符合规范的密码：\n\t\talter user 'root'@'localhost' identified by '12345Aa.';\n\t查看当前密码策略：\n\t\tSHOW VARIABLES LIKE 'validate_password%'; \n\t设置密码策略等级为：低\n\t\tset global validate_password_policy=LOW; \n\t设置密码长度为：4\n\t\tset global validate_password_length=4; \n\t设置新密码为：root\n\t\tset password = password('root');\n设置密码时出现的错误：\n\tERROR 1819 (HY000): Your password does not satisfy the current policy requirements\n\t错误1819（HY000）：您的密码不符合当前策略要求\nERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement\n\t错误1820（HY000）：在执行此语句之前，必须使用ALTER USER语句重置密码\n\n授权远程访问 : \n\t\tgrant all privileges on *.* to 'root' @'%' identified by 'root';\n\t\tflush privileges;\n关闭系统防火墙：\n\t\t暂时关闭防火墙：systemctl stop firewalld\n此时就能在本地使用sql的图形化工具连接虚拟机的mysql数据库\n```\n\n\n\n# 索引\n\n## 索引概述\n\nMySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。如下面的==示意图==所示 : \n\n![1555902055367](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625161832.png) \n\n左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。\n\n一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。\n\n\n\n## 索引优势劣势\n\n优势\n\n1） 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。\n\n2） 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。\n\n劣势\n\n1） 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。\n\n2） 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。\n\n\n\n## 索引结构\n\n索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引：\n\n- BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。\n- HASH 索引：只有Memory引擎支持 ， 使用场景简单 。\n- R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。\n- Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。\n\n<center><b>MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持</b></center>\n\n| 索引        | InnoDB引擎      | MyISAM引擎 | Memory引擎 |\n| ----------- | --------------- | ---------- | ---------- |\n| BTREE索引   | 支持            | 支持       | 支持       |\n| HASH 索引   | 不支持          | 不支持     | 支持       |\n| R-tree 索引 | 不支持          | 支持       | 不支持     |\n| Full-text   | 5.6版本之后支持 | 支持       | 不支持     |\n\n我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为 索引。\n\n\n\n###  BTREE 结构\n\nBTree又叫多路平衡搜索树，一颗m叉的BTree特性如下：\n\n- 树中每个节点最多包含m个孩子。\n- 除根节点与叶子节点外，每个节点至少有[ceil(m/2)]个孩子。\n- 若根节点不是叶子节点，则至少有两个孩子。\n- 所有的叶子节点都在同一层。\n- 每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m/2)-1] <= n <= m-1 \n\n\n\n以5叉BTree为例，key的数量：公式推导[ceil(m/2)-1] <= n <= m-1。所以 2 <= n <=4 。当n>4时，中间节点分裂到父节点，两边节点分裂。\n\n插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。\n\n演变过程如下：\n\n1). 插入前4个字母 C N G A \n\n![1555944126588](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625161850.png) \n\n2). 插入H，n>4，此时的顺序是A,C,G,H,N。中间元素G字母向上分裂成为父节点，两边的变成子节点。\n\n![1555944549825](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625161854.png) \n\n3). 插入E，K，Q不需要分裂\n\n![1555944596893](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625161901.png) \n\n4). 插入M，中间元素M字母向上分裂到父节点G\n\n![1555944652560](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625161906.png) \n\n5). 插入F，W，L，T不需要分裂\n\n![1555944686928](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625161911.png) \n\n6). 插入Z，中间元素T向上分裂到父节点中 \n\n![1555944713486](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625161916.png) \n\n7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂\n\n![1555944749984](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625161921.png) \n\n8). 最后插入S，NPQR节点n>5，中间节点Q向上分裂，但分裂后父节点DGMT的n>5，中间节点M向上分裂\n\n![1555944848294](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625161926.png) \n\n到此，该BTREE树就已经构建完成了， BTREE树 和 二叉树 相比， 查询数据的效率更高， 因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快。\n\n\n\n### B+TREE 结构\n\nB+Tree为BTree的变种，B+Tree与BTree的区别为：\n\n1). n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。\n\n2). B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。\n\n3). 所有的非叶子节点都可以看作是key的索引部分。\n\n![1555906287178](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625161931.jpg) \n\n由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定。\n\n\n\n###  MySQL中的B+Tree\n\nMySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问（即范围搜索）的性能。\n\nMySQL中的 B+Tree 索引结构示意图: \n\n![1555906287178](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625161935.png)  \n\n\n\n## 索引分类\n\n1） 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引。\n\n2） 唯一索引 ：索引列的值必须唯一，但允许有空值。类似的比如ID。\n\n3） 复合索引 ：即一个索引包含多个列。比如以年龄和姓名组成复合索引。\n\n\n\n## 索引语法\n\n索引在创建表的时候，可以同时创建， 也可以随时增加新的索引。\n\n准备环境:\n\n```SQL\ncreate database demo_01 default charset=utf8mb4;\n\nuse demo_01;\n\nCREATE TABLE `city` (\n  `city_id` int(11) NOT NULL AUTO_INCREMENT,\n  `city_name` varchar(50) NOT NULL,\n  `country_id` int(11) NOT NULL,\n  PRIMARY KEY (`city_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nCREATE TABLE `country` (\n  `country_id` int(11) NOT NULL AUTO_INCREMENT,\n  `country_name` varchar(100) NOT NULL,\n  PRIMARY KEY (`country_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\ninsert into `city` (`city_id`, `city_name`, `country_id`) values(1,'西安',1);\ninsert into `city` (`city_id`, `city_name`, `country_id`) values(2,'NewYork',2);\ninsert into `city` (`city_id`, `city_name`, `country_id`) values(3,'北京',1);\ninsert into `city` (`city_id`, `city_name`, `country_id`) values(4,'上海',1);\n\ninsert into `country` (`country_id`, `country_name`) values(1,'China');\ninsert into `country` (`country_id`, `country_name`) values(2,'America');\ninsert into `country` (`country_id`, `country_name`) values(3,'Japan');\ninsert into `country` (`country_id`, `country_name`) values(4,'UK');\n```\n\n\n\n### 创建索引\n\n语法 ： \t\n\n```sql\nCREATE \t[UNIQUE|FULLTEXT|SPATIAL]  INDEX index_name [USING  index_type] ON tbl_name(index_col_name,...)\n#-- 说明：CREATE 索引类型 INDEX 索引名称 索引结构？ ON 表名(列名...)\nUNIQUE : 唯一索引\nFULLTEXT ：全文索引\nSPATIAL ：空间索引\n都不加时：普通索引\n列名多时：复合索引\n\n\nindex_col_name : column_name[(length)][ASC | DESC]\n```\n\n示例 ： 为city表中的city_name字段创建索引 ；\n\n![1551438009843](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625162015.png)    \t  \n\n​\t\n\n### 查看索引\n\n语法： \n\n```sql\nshow index  from  table_name[\\G];\n结果说明：\n        Table: city        \t\t\t\t\t表名\n   Non_unique: 1\t\t\t\t\t\t\t\t\t\t索引的值是否重复？1为可以重复\n     Key_name: idx_city_name\t\t\t\t索引名\n Seq_in_index: 1\t\t\t\t\t\t\t\t\t\t索引中的列序列号，从1开始。\t\n  Column_name: city_name\t\t\t\t\t\t列名称。\n    Collation: A\t\t\t\t\t\t\t\t\t\t列以什么顺序在索引中。A表示升序，null表示无序\n  Cardinality: 4\t\t\t\t\t\t\t\t\t\t索引中不重复值的数量\n     Sub_part: NULL\t\t\t\t\t\t\t\t\t如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL\n       Packed: NULL\t\t\t\t\t\t\t\t\t指示关键字如何被压缩。如果没有被压缩，则为NULL\n         Null: \t\t\t\t\t\t\t\t\t\t\t如果列含有NULL，则含有YES。如果没有，则该列含有NO。\n   Index_type: BTREE\t\t\t\t\t\t\t\t用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。\n      Comment: \t\t\t\t\t\t\t\t\t\t\t索引注释\nIndex_comment: \n\n```\n\n示例：查看city表中的索引信息；\n\n![1551440511890](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625162021.png) \n\n![1551440544483](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625162025.png) \t \n\n\n\n###  删除索引\n\n语法 ：\n\n```\nDROP  INDEX  index_name  ON  tbl_name;\n```\n\n示例 ： 想要删除city表上的索引idx_city_name，可以操作如下：\n\n![1551438238293](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625162030.png) \t \n\n\n\n###  ALTER命令\n\n```\n1). alter  table  tb_name  add  primary  key(column_list); \n\t\t\t\t\t\t\t\t\t\t表名\t\t\t\t索引名必须为primary\n\t该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL\n\t\n2). alter  table  tb_name  add  unique index_name(column_list);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t索引名\n\t这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）\n\t\n3). alter  table  tb_name  add  index index_name(column_list);\n\n\t添加普通索引， 索引值可以出现多次。\n\t\n4). alter  table  tb_name  add  fulltext  index_name(column_list);\n\t\n\t该语句指定了索引为FULLTEXT， 用于全文索引\n\t\n```\n\n\n\n##  索引设计原则\n\n\t索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。\n\n- 对**查询频次较高**，且数据量比较大的表建立索引。\n\n- 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。\n\n- 使用唯一索引，区分度越高，使用索引的效率越高。\n\n- 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。\n\n- 使用**短索引**，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。\n\n- 利用**最左前缀**，N个列组合而成的复合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。\n\n  ```\n  创建复合索引:\n  \n  \tCREATE INDEX idx_name_email_status ON tb_seller(NAME,email,STATUS);\n  \n  就相当于\n  \t对name 创建索引 ;\n  \t对name , email 创建了索引 ;\n  \t对name , email, status 创建了索引 ;\n  ```\n\n\n\n##  索引的使用\n\n索引是数据库优化最常用也是最重要的手段之一, 通过索引通常可以帮助用户解决大多数的MySQL的性能优化问题。\n\n\n\n###  验证索引提升查询效率\n\n在我们准备的表结构tb_item 中， 一共存储了 300 万记录；\n\nA. 根据ID查询 \n\n```\nselect * from tb_item where id = 1999\\G;\n```\n\n![1553261992653](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163621.png) \n\n查询速度很快， 接近0s ， 主要的原因是因为id为主键， 有索引；\n\n![1553262044466](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163626.png) \n\n\n\n2). 根据 title 进行精确查询\n\n```SQL\nselect * from tb_item where title = 'iphoneX 移动3G 32G941'\\G; \n```\n\n![1553262215900](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163630.png) \n\n查看SQL语句的执行计划 ： \n\n![1553262469785](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163634.png) \n\n\n\n处理方案 ， 针对title字段， 创建索引 ： \n\n```SQL\ncreate index idx_item_title on tb_item(title);\n```\n\n![1553263229523](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164145.png) \n\n\n\n索引创建完成之后，再次进行查询 ： \n\n![1553263302706](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163638.png) \n\n通过explain ， 查看执行计划，执行SQL时使用了刚才创建的索引 \n\n![1553263355262](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163644.png) \n\n\n\n### 索引的使用\n\n####  准备环境\n\n```sql\ncreate table `tb_seller` (\n\t`sellerid` varchar (100),\n\t`name` varchar (100),\n\t`nickname` varchar (50),\n\t`password` varchar (60),\n\t`status` varchar (1),\n\t`address` varchar (100),\n\t`createtime` datetime,\n    primary key(`sellerid`)\n)engine=innodb default charset=utf8mb4; \n\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('alibaba','阿里巴巴','阿里小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('baidu','百度科技有限公司','百度小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('huawei','华为科技有限公司','华为小店','e10adc3949ba59abbe56e057f20f883e','0','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('itcast','传智播客教育科技有限公司','传智播客','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('itheima','黑马程序员','黑马程序员','e10adc3949ba59abbe56e057f20f883e','0','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('luoji','罗技科技有限公司','罗技小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('oppo','OPPO科技有限公司','OPPO官方旗舰店','e10adc3949ba59abbe56e057f20f883e','0','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('ourpalm','掌趣科技股份有限公司','掌趣小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('qiandu','千度科技','千度小店','e10adc3949ba59abbe56e057f20f883e','2','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('sina','新浪科技有限公司','新浪官方旗舰店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('xiaomi','小米科技','小米官方旗舰店','e10adc3949ba59abbe56e057f20f883e','1','西安市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('yijia','宜家家居','宜家家居旗舰店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\n\n# 创建复合索引\ncreate index idx_seller_name_sta_addr on tb_seller(name,status,address);\n```\n\n\n\n####  避免索引失效\n\n**1).**  全值匹配 ，对索引中所有列都指定具体值。\n\n改情况下，索引生效，执行效率高。\n\n```sql\nexplain select * from tb_seller where name='小米科技' and status='1' and address='北京市'\\G;\n```\n\n![1556170997921](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163651.png) \n\n\n\n**2).** 最左前缀法则\n\n如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。\n\n\n\n匹配最左前缀法则，走索引：\n\n![1556171348995](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163655.png)  \n\n\n\n违法最左前缀法则 ， 索引失效：\n\n![1556171428140](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163659.png) \n\n\n\n如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：\n\n![1556171662203](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163703.png) \n\n\n\n**3).** 范围查询右边的列，不能使用索引 。\n\n![1556172256791](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163708.png) \n\n根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。\n\n\n\n**4).** 不要在索引列上进行运算操作， 索引将失效。\n\n![1556172813715](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163712.png) \n\n\n\n**5).** 字符串不加单引号，造成索引失效。\n\n![1556172967493](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163716.png) \n\n由于，在查询是，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。\n\n\n\n**6).** 尽量使用覆盖索引，避免select *\n\n尽量使用覆盖索引（只访问索引的列（索引列完全包含查询列）），减少select * 。\n\n![1556173928299](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163720.png) \n\n如果查询列，超出索引列，也会降低性能。\n\n![1556173986068](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163726.png) \n\n```\nTIP : \n\t\n    using index ：使用覆盖索引的时候就会出现\n\n    using where：在查找使用索引的情况下，需要回表去查询所需的数据\n\n    using index condition：查找使用了索引，但是需要回表查询数据\n\n    using index ; using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据\n    回表查询：即需要到表结构中查询表的结构。\n```\n\n\n\n**7).** 用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。\n\n示例，name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 ： \n\n```sql\nexplain select * from tb_seller where name='黑马程序员' or createtime = '2088-01-01 12:00:00'\\G;\t\n```\n\n![1556174994440](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163731.png) \n\n\n\n**8).**  以%开头的Like模糊查询，索引失效。\n\n如果仅**仅是尾部模糊匹配，索引不会失效**。如果是头部模糊匹配，索引失效。\n\n![1556175114369](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163736.png) \n\n解决方案 ： \n\n通过覆盖索引来解决 \n\n![1556247686483](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163740.png) \n\n\n\n**9).** 如果MySQL评估使用索引比全表更慢，则不使用索引。\n\n![1556175445210](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163743.png) \n\n\n\n**10).** is  NULL ， is NOT NULL  <font color='red'>有时</font>索引失效。\n\n\t示意图的解释：\n\t\n\t\t在tb_seller表中，name是非空的，即整个表中很少有空的，因此is null 走索引。is not null因为查询的结果会有很多，走索引还不如走全文扫描，因此不走索引。\n\t\n\t\t在t_user表中，name是可以空的，即整个表中可能有很多空的，因此is null 不走索引。is not null走索引。\n\t\n\t总的来说，如果此索引的字段空值的少，则is null走索引，is not null不走索引。反之亦然。\n\n![1556180634889](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163747.png)  \n\n\n\n**11).** in 走索引， not in 索引失效。\n\n![1556249602732](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163751.png)  \n\n\n\n**12).** 单列索引和复合索引。\n\n尽量使用复合索引，而少使用单列索引 。\n\n创建复合索引 \n\n```\ncreate index idx_name_sta_address on tb_seller(name, status, address);\n\n就相当于创建了三个索引 ： \n\tname\n\tname + status\n\tname + status + address\n\n```\n\n\n\n创建单列索引 \n\n```\ncreate index idx_seller_name on tb_seller(name);\ncreate index idx_seller_status on tb_seller(status);\ncreate index idx_seller_address on tb_seller(address);\n```\n\n在复合查询时，数据库会选择一个最优的索引（辨识度最高索引）来使用，并不会使用全部索引 。\n\n\n\n###  查看索引使用情况\n\n```sql\nshow status like 'Handler_read%';\t#查看当前会话的\n\nshow global status like 'Handler_read%';\t#查看全局的\n```\n\n![1552885364563](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163756.png) \n\n```\nHandler_read_first：索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）。\n\nHandler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。\n\nHandler_read_next ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。\n\nHandler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC。\n\nHandler_read_rnd ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。\n\nHandler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。\n```\n\n\n\n#  视图\n\n\n\n##  视图概述\n\n\t视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。\n\n视图相对于普通的表的优势主要包括以下几项。\n\n- 简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。\n- 安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。\n- 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。\n\n\n\n## 创建或者修改视图\n\n创建视图的语法为：\n\n```sql\nCREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] \nVIEW view_name [(column_list)] \nAS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION]\n\n创建视图：CREATE VIEW\n替换视图：CREATE OR REPLACE VIEW\nview_name[(column_list)] ：视图名称[(视图中的列名)]\nselect_statement ：select语句，即查询语句\nALGORITHM ：指定创建视图的算法。默认UNDEFINED。\nUNDEFINED ：由MySQL选择使用哪种算法，一般会首选MERGE，因为MERGE更有效率，而且TEMPTABLE不支持更新。\nMERGE ：将查询视图的语句与视图的定义语句合并处理\nTEMPTABLE ：视图查询的结果保存到临时表，而后在该临时表基础上执行查询视图的语句；\n```\n\n修改视图的语法为：\n\n```sql\nALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\n\nVIEW view_name [(column_list)]\n\nAS select_statement\n\n[WITH [CASCADED | LOCAL] CHECK OPTION]\n```\n\n```\n选项 : \n\tWITH [CASCADED | LOCAL] CHECK OPTION 决定了是否允许更新数据使记录不再满足视图的条件。\n\t\n\tLOCAL ： 只要满足本视图的条件就可以更新。\n\t\t即可以任意修改此视图的数据。\n\tCASCADED ： 必须满足所有针对该视图的所有视图的条件才可以更新。 默认值.\n\t\t修改视图数据时，修改的数据不能和视图的select_statement语句中的规则有关联。否则修改失败。\n\t\t简单来说，with check option 的作用就是，当你更新或添加视图数据的时候，视图里的where条件select出有多少rows, 你修改完以后这些rows都还在。\n```\n\n示例 , 创建city_country_view视图 , 执行如下SQL : \n\n```sql\ncreate or replace view city_country_view \nas \nselect t.*,c.country_name from country c , city t where c.country_id = t.country_id;\n\n```\n\n查询视图 : \n\n![1551503428635](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625162039.png) \t\n\n\n\n## 查看视图\n\n\t从 MySQL 5.1 版本开始，使用 SHOW TABLES 命令的时候不仅显示表的名字，同时也会显示视图的名字，而不存在单独显示视图的 SHOW VIEWS 命令。因此select语句同样能够查询视图的数据。\n\n![1551537565159](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625162044.png)\t \n\n同样，在使用 SHOW TABLE STATUS 命令的时候，不但可以显示表的信息，同时也可以显示视图的信息。\t\n\n![1551537646323](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625162048.png) \n\n如果需要查询某个视图的定义，可以使用 SHOW CREATE VIEW 视图名 命令进行查看 ： \n\n![1551588962944](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625162053.png)  \n\n## 删除视图\n\n语法 : \n\n```sql\nDROP VIEW [IF EXISTS] view_name [, view_name] ...[RESTRICT | CASCADE]\t\n```\n\n示例 , 删除视图city_country_view :\n\n```\nDROP VIEW city_country_view ;\n```\n\n\n\n# 存储过程和函数\n\n\n\n## 存储过程和函数概述\n\n\t存储过程和函数是  事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。\t\n\t\n\t存储过程和函数的区别在于函数必须有返回值，而存储过程没有。\n\t\n\t函数 ： 是一个有返回值的过程 ；\n\t\n\t过程 ： 是一个没有返回值的函数 ；\n\n## 创建存储过程\n\n```sql\nCREATE PROCEDURE procedure_name ([proc_parameter[,...]])\n\t\t\t\t\t\t\t\t\t名字 \t\t\t\t\t\t\t参数\nbegin\n\t-- SQL语句\nend \n\n因为sql语句有分号。因此常与delimiter结合使用。\n```\n\n\n\n示例 ：\n\n```sql \nmysql> delimiter $    #设置分隔符为$\nmysql> create procedure pro_test1()\n\t\t > begin\n\t\t > select 'Hello Mysql' ;\n\t\t > end$\nmysql> delimiter ;   #设置分隔符为;\n```\n\n**DELIMITER 说明**\n\n\t该关键字用来声明SQL语句的分隔符 , 告诉 MySQL 解释器，该段命令是否已经结束了，mysql是否可以执行了。默认情况下，delimiter是分号;。在命令行客户端中，如果有一行命令以分号结束，那么回车后，mysql将会执行该命令。\n\n\n\n## 调用存储过程\n\n```sql\ncall procedure_name() ;\t\n```\n\n\n\n##  查看存储过程\n\n```sql\n-- 查询db_name数据库中的所有的存储过程\nselect name from mysql.proc where db='demo_01';\n\n-- 查询存储过程的状态信息\nshow procedure status;\n\n-- 查询某个存储过程的定义\nshow create procedure pro_test1 \\G;\n```\n\n\n\n##  删除存储过程\n\n```sql\nDROP PROCEDURE  [IF EXISTS] sp_name ；\n```\n\n\n\n##  语法\n\n存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。\n\n\n\n###  变量\n\n-  **DECLARE**\n\n  通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中。\n\n```sql\nDECLARE var_name[,...] type [DEFAULT value]\n可以同时声明多个变量。\n```\n\n示例 : \n\n```sql\n delimiter $\n\n create procedure pro_test2() \n begin \n \tdeclare num int default 5;\n \tselect num+ 10; \n end$\n\n delimiter ; \n```\n\n\n\n- **SET**\n\n直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下：\n\n```\n  SET var_name = expr [, var_name = expr] ...\n```\n\n示例 : \n\n```sql\n  DELIMITER $\n  \n  CREATE  PROCEDURE pro_test3()\n  BEGIN\n  \tDECLARE NAME VARCHAR(20);\n  \tSET NAME = 'MYSQL';\n  \tSELECT NAME ;\n  END$\n  \n  DELIMITER ;\n```\n\n\n\n也可以通过select ... into 方式进行赋值操作 :\n\n```SQL\nDELIMITER $\n\nCREATE  PROCEDURE pro_test5()\nBEGIN\n\tdeclare  countnum int;\n\tselect count(*) into countnum from city; #将city表中的记录数放在countnum变量中\n\tselect countnum;\nEND$\n\nDELIMITER ;\n```\n\n\n\n###  if条件判断\n\n语法结构 : \n\n```sql\nif search_condition then statement_list\n\n\t[elseif search_condition then statement_list] ...\n\t\n\t[else statement_list]\n\t\nend if;\n\n说明：\n\tsearch_condition ： 条件判断\n\tstatement_list ：编程语句\n```\n\n需求： \n\n```\n根据定义的身高变量，判定当前身高的所属的身材类型 \n\n\t180 及以上 ----------> 身材高挑\n\n\t170 - 180  ---------> 标准身材\n\n\t170 以下  ----------> 一般身材\n```\n\n示例 : \n\n```sql\ndelimiter $\n\ncreate procedure pro_test6()\nbegin\n  declare  height  int  default  175; \n  declare  description  varchar(50);\n  \n  if  height >= 180  then\n    set description = '身材高挑';\n  elseif height >= 170 and height < 180  then\n    set description = '标准身材';\n  else\n    set description = '一般身材';\n  end if;\n  \n  select description ;\nend$\n\ndelimiter ;\n```\n\n调用结果为 : \n\n![1552057035580](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625162104.png) \n\n\n\n###  传递参数\n\n语法格式 : \n\n```\ncreate procedure procedure_name([in/out/inout] 参数名   参数类型)\n...\n\n\nIN :   该参数可以作为输入，也就是需要调用方传入值 , 默认\nOUT:   该参数作为输出，也就是该参数可以作为返回值\nINOUT: 既可以作为输入参数，也可以作为输出参数\n```\n\n**IN - 输入**\n\n需求 :\n\n```\n根据定义的身高变量，判定当前身高的所属的身材类型 \n```\n\n示例  : \n\n```sql\ndelimiter $\n\ncreate procedure pro_test5(in height int)\nbegin\n    declare description varchar(50) default '';\n  if height >= 180 then\n    set description='身材高挑';\n  elseif height >= 170 and height < 180 then\n    set description='标准身材';\n  else\n    set description='一般身材';\n  end if;\n  select concat('身高 ', height , '对应的身材类型为:',description);\nend$\n\ndelimiter ;\n```\n\n\n\n**OUT-输出**\n\n 需求 :\n\n```\n根据传入的身高变量，获取当前身高的所属的身材类型  \n```\n\n示例:\n\n```SQL \ncreate procedure pro_test5(in height int , out description varchar(100))\nbegin\n  if height >= 180 then\n    set description='身材高挑';\n  elseif height >= 170 and height < 180 then\n    set description='标准身材';\n  else\n    set description='一般身材';\n  end if;\nend$\t\n```\n\n调用:\n\n```\ncall pro_test5(168, @description)$\n\nselect @description$\n```\n\n<font color='red'>**小知识** </font>\n\n@description :  这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。\n\n@@global.sort_buffer_size : 这种在变量前加上 \"@@\" 符号, 叫做 系统变量 \n\n\n\n###  case结构\n\n语法结构 : \n\n```SQL\n方式一 : 指定判断的变量值case_value\n\nCASE case_value\n\n  WHEN when_value THEN statement_list\n  \n  [WHEN when_value THEN statement_list] ...\n  \n  [ELSE statement_list]\n  \nEND CASE;\n\n\n方式二 : 不指定变量值\n\nCASE\n\n  WHEN search_condition THEN statement_list\n  \n  [WHEN search_condition THEN statement_list] ...\n  \n  [ELSE statement_list]\n  \nEND CASE;\n\n```\n\n需求:\n\n```\n给定一个月份, 然后计算出所在的季度\n```\n\n示例  :\n\n```sql\ndelimiter $\n\n\ncreate procedure pro_test9(month int)\nbegin\n  declare result varchar(20);\n  case \n    when month >= 1 and month <=3 then \n      set result = '第一季度';\n    when month >= 4 and month <=6 then \n      set result = '第二季度';\n    when month >= 7 and month <=9 then \n      set result = '第三季度';\n    when month >= 10 and month <=12 then \n      set result = '第四季度';\n  end case;\n  \n  select concat('您输入的月份为 :', month , ' , 该月份为 : ' , result) as content ;\n  \nend$\n\n\ndelimiter ;\n```\n\n\n\n###  while循环\n\n语法结构: \n\n```sql\nwhile search_condition do\n\n\tstatement_list\n\t\nend while;\n```\n\n需求:\n\n```\n计算从1加到n的值\n```\n\n示例  : \n\n```sql\ndelimiter $\n\ncreate procedure pro_test8(n int)\nbegin\n  declare total int default 0;\n  declare num int default 1;\n  while num<=n do\n    set total = total + num;\n\t\tset num = num + 1;\n  end while;\n  select total;\nend$\n\ndelimiter ;\n```\n\n\n\n###  repeat结构\n\n有条件的循环控制语句, 当满足条件的时候退出循环 。while 是满足条件才执行，repeat 是**满足条件就退出循环**。\n\n语法结构 : \n\n```SQL\nREPEAT\n\n  statement_list\n\n  UNTIL search_condition  # 直到满足search_condition条件\n\nEND REPEAT;\n```\n\n需求: \n\n```\n计算从1加到n的值\n```\n\n示例  : \n\n```sql\ndelimiter $\n\ncreate procedure pro_test10(n int)\nbegin\n  declare total int default 0;\n  \n  repeat \n    set total = total + n;\n    set n = n - 1;\n    until n=0  \n  end repeat;\n  \n  select total ;\n  \nend$\n\n\ndelimiter ;\n```\n\n\n\n###  loop语句\n\nLOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，具体语法如下：\n\n```sql\n[begin_label:] LOOP\n\n  statement_list\n\nEND LOOP [end_label]\n```\n\n如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环。\n\n\n\n###  leave语句\n\n用来从标注的流程构造中退出，通常和 BEGIN ... END 或者循环一起使用。下面是一个使用 LOOP 和 LEAVE 的简单例子 , 退出循环：\n\n```SQL\ndelimiter $\n\nCREATE PROCEDURE pro_test11(n int)\nBEGIN\n  declare total int default 0;\n  \n  ins: LOOP\n    \n    IF n <= 0 then\n      leave ins;  # 如果n<=0则退出循环到LOOP的ins结束位置(第16行)\n    END IF;\n    \n    set total = total + n;\n    set n = n - 1;\n  \t\n  END LOOP ins;\n  \n  select total;\nEND$\n\ndelimiter ;\n```\n\n\n\n###  游标/光标\n\n游标是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用光标对结果集进行循环的处理。光标的使用包括光标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。\n\n声明光标：\n\n```sql\nDECLARE cursor_name CURSOR FOR select_statement ;\n```\n\nOPEN 光标：\n\n```sql\nOPEN cursor_name ;\n```\n\nFETCH 光标：\n\n```sql\nFETCH cursor_name INTO var_name [, var_name] ...\n```\n\nCLOSE 光标：\n\n```sql\nCLOSE cursor_name ;\n```\n\n\n\n示例 : \n\n初始化脚本:\n\n``` sql\ncreate table emp(\n  id int(11) not null auto_increment ,\n  name varchar(50) not null comment '姓名',\n  age int(11) comment '年龄',\n  salary int(11) comment '薪水',\n  primary key(`id`)\n)engine=innodb default charset=utf8 ;\n\ninsert into emp(id,name,age,salary) values(null,'金毛狮王',55,3800),(null,'白眉鹰王',60,4000),(null,'青翼蝠王',38,2800),(null,'紫衫龙王',42,1800);\n\n```\n\n\n\n``` SQL\n-- 查询emp表中数据, 并逐行获取进行展示\ncreate procedure pro_test11()\nbegin\n  declare e_id int(11);\n  declare e_name varchar(50);\n  declare e_age int(11);\n  declare e_salary int(11);\n  declare emp_result cursor for select * from emp;\n  \n  open emp_result;\n  \n  fetch emp_result into e_id,e_name,e_age,e_salary;\n  select concat('id=',e_id , ', name=',e_name, ', age=', e_age, ', 薪资为: ',e_salary);\n  \n  fetch emp_result into e_id,e_name,e_age,e_salary;\n  select concat('id=',e_id , ', name=',e_name, ', age=', e_age, ', 薪资为: ',e_salary);\n  \n  fetch emp_result into e_id,e_name,e_age,e_salary;\n  select concat('id=',e_id , ', name=',e_name, ', age=', e_age, ', 薪资为: ',e_salary);\n  \n  fetch emp_result into e_id,e_name,e_age,e_salary;\n  select concat('id=',e_id , ', name=',e_name, ', age=', e_age, ', 薪资为: ',e_salary);\n  \n  fetch emp_result into e_id,e_name,e_age,e_salary;\n  select concat('id=',e_id , ', name=',e_name, ', age=', e_age, ', 薪资为: ',e_salary);\n  \n  close emp_result;\nend$\n\n```\n\n\n\n通过循环结构 , 获取游标中的数据 : \n\n```sql\nDELIMITER $\n\ncreate procedure pro_test12()\nbegin\n  DECLARE id int(11);\n  DECLARE name varchar(50);\n  DECLARE age int(11);\n  DECLARE salary int(11);\n  DECLARE has_data int default 1;\n  \n  DECLARE emp_result CURSOR FOR select * from emp;\n  DECLARE EXIT HANDLER FOR NOT FOUND set has_data = 0;\n  \n  open emp_result;\n  \n  repeat\n    fetch emp_result into id , name , age , salary;\n    select concat('id为',id, ', name 为' ,name , ', age为 ' ,age , ', 薪水为: ', salary);\n    until has_data = 0\n  end repeat;\n  \n  close emp_result;\nend$\n\nDELIMITER ; \n```\n\n\n\n##  存储函数\n\n语法结构:\n\n``` \nCREATE FUNCTION function_name([param type ... ]) \nRETURNS type \nBEGIN\n\t...\nEND;\n```\n\n案例 : \n\n定义一个存储过程, 请求满足条件的总记录数 ;\n\n```SQL\n\ndelimiter $\n\ncreate function count_city(countryId int)\nreturns int\nbegin\n  declare cnum int ;\n  \n  select count(*) into cnum from city where country_id = countryId;\n  \n  return cnum;\nend$\n\ndelimiter ;\n```\n\n调用: \n\n```\nselect count_city(1);\n\nselect count_city(2);\n```\n\n\n\n#  触发器\n\n\n\n##  介绍\n\n触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。\n\n使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。\n\n| 触发器类型      | NEW 和 OLD的使用                                        |\n| --------------- | ------------------------------------------------------- |\n| INSERT 型触发器 | NEW 表示将要或者已经新增的数据                          |\n| UPDATE 型触发器 | OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据 |\n| DELETE 型触发器 | OLD 表示将要或者已经删除的数据                          |\n\n\n\n##  创建触发器\n\n语法结构 : \n\n```sql\ncreate trigger trigger_name \n\nbefore/after insert/update/delete\n\non tbl_name \n\n[ for each row ]  -- 行级触发器\n\nbegin\n\n\ttrigger_stmt ;\n\nend;\n```\n\n**示例** ：\n\n需求\n\n```\n通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除 ;\n```\n\n首先创建一张日志表 : \n\n```sql\ncreate table emp_logs(\n  id int(11) not null auto_increment,\n  operation varchar(20) not null comment '操作类型, insert/update/delete',\n  operate_time datetime not null comment '操作时间',\n  operate_id int(11) not null comment '操作表的ID',\n  operate_params varchar(500) comment '操作参数',\n  primary key(`id`)\n)engine=innodb default charset=utf8;\n```\n\n创建 insert 型触发器，完成插入数据时的日志记录 : \n\n```sql\nDELIMITER $\n\ncreate trigger emp_logs_insert_trigger\nafter insert \non emp \nfor each row \nbegin\n  insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'insert',now(),new.id,concat('插入后(id:',new.id,', name:',new.name,', age:',new.age,', salary:',new.salary,')'));\t\nend $\n\nDELIMITER ;\n```\n\n创建 update 型触发器，完成更新数据时的日志记录 : \n\n``` sql\nDELIMITER $\n\ncreate trigger emp_logs_update_trigger\nafter update \non emp \nfor each row \nbegin\n  insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'update',now(),new.id,concat('修改前(id:',old.id,', name:',old.name,', age:',old.age,', salary:',old.salary,') , 修改后(id',new.id, 'name:',new.name,', age:',new.age,', salary:',new.salary,')'));                                                                      \nend $\n\nDELIMITER ;\n```\n\n创建delete 行的触发器 , 完成删除数据时的日志记录 : \n\n```sql\nDELIMITER $\n\ncreate trigger emp_logs_delete_trigger\nafter delete \non emp \nfor each row \nbegin\n  insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'delete',now(),old.id,concat('删除前(id:',old.id,', name:',old.name,', age:',old.age,', salary:',old.salary,')'));                                                                      \nend $\n\nDELIMITER ;\n```\n\n测试：\n\n```sql\ninsert into emp(id,name,age,salary) values(null, '光明左使',30,3500);\ninsert into emp(id,name,age,salary) values(null, '光明右使',33,3200);\n\nupdate emp set age = 39 where id = 3;\n\ndelete from emp where id = 5;\n```\n\n\n\n##  删除触发器\n\n语法结构 : \n\n```\ndrop trigger [schema_name.]trigger_name\n```\n\n如果没有指定 schema_name，默认为当前数据库 。\n\n\n\n##  查看触发器\n\n可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。\n\n语法结构 ： \n\n```\nshow triggers ；\n```\n\n\n\n#  存储引擎\n\n##  存储引擎概述\n\n\t和大多数的数据库不同, MySQL中有一个存储引擎的概念, 针对不同的存储需求可以选择最优的存储引擎。\n\t\n\t存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式 。**存储引擎是基于表的**，而不是基于库的。所以存储引擎也可被称为表类型。\n\t\n\t因此同一个数据库中，有多个表。这些表可以以不同的存储引擎进行存储。\n\t\n\tOracle，SqlServer等数据库只有一种存储引擎。MySQL提供了插件式的存储引擎架构。所以MySQL存在多种存储引擎，可以根据需要使用相应引擎，或者编写存储引擎。\n\t\n\tMySQL5.0支持的存储引擎包含 ： InnoDB 、MyISAM 、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和BDB提供事务安全表，其他存储引擎是非事务安全表。\n\n可以通过指定 *show engines* ， 来查询当前数据库支持的存储引擎 ： \n\n![1551186043529](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163120.png) \n\n翻译：\n\n| Engine             | Comment                                           |\n| :----------------- | ------------------------------------------------- |\n| InnoDB             | 支持事务、行级锁定和外键                          |\n| MRG_MYISAM         | 相同MyISAM表的集合                                |\n| MEMORY             | 基于哈希的，存储在内存中，对临时表有用            |\n| BLACKHOLE          | /dev/null存储引擎（您向其写入的任何内容都将消失） |\n| MyISAM             | MyISAM存储引擎                                    |\n| CSV                | CSV存储引擎                                       |\n| ARCHIVE            | 存档存储引擎                                      |\n| PERFORMANCE_SCHEMA | 性能模式                                          |\n| FEDERATED          | 联合MySQL存储引擎                                 |\n\n创建新表时如果不指定存储引擎，那么系统就会使用默认的存储引擎，MySQL5.5之前的默认存储引擎是MyISAM，5.5之后就改为了InnoDB。\n\n查看Mysql数据库默认的存储引擎 ， 指令 ：\n\n```\n show variables like '%storage_engine%' ； \n```\n\n![1556086372754](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163146.png)  \t \n\n\n\n##  各种存储引擎特性\n\n下面重点介绍几种常用的存储引擎， 并对比各个存储引擎之间的区别， 如下表所示 ： \n\n| 特点         | InnoDB               | MyISAM   | MEMORY | MERGE | NDB  |\n| ------------ | -------------------- | -------- | ------ | ----- | ---- |\n| 存储限制     | 64TB                 | 有       | 有     | 没有  | 有   |\n| 事务安全     | **支持**             |          |        |       |      |\n| 锁机制       | **行锁(适合高并发)** | **表锁** | 表锁   | 表锁  | 行锁 |\n| B树索引      | 支持                 | 支持     | 支持   | 支持  | 支持 |\n| 哈希索引     |                      |          | 支持   |       |      |\n| 全文索引     | 支持(5.6版本之后)    | 支持     |        |       |      |\n| 集群索引     | 支持                 |          |        |       |      |\n| 数据索引     | 支持                 |          | 支持   |       | 支持 |\n| 索引缓存     | 支持                 | 支持     | 支持   | 支持  | 支持 |\n| 数据可压缩   |                      | 支持     |        |       |      |\n| 空间使用     | 高                   | 低       | N/A    | 低    | 低   |\n| 内存使用     | 高                   | 低       | 中等   | 低    | 高   |\n| 批量插入速度 | 低                   | 高       | 高     | 高    | 高   |\n| 支持外键     | **支持**             |          |        |       |      |\n\n\n\n##  InnoDB\n\n\tInnoDB存储引擎是Mysql的默认存储引擎。InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。\n\nInnoDB存储引擎不同于其他存储引擎的特点 ： \n\n**事务控制**\n\n```\ncreate table goods_innodb(\n\tid int NOT NULL AUTO_INCREMENT,\n\tname varchar(20) NOT NULL,\n    primary key(id)\n)ENGINE=innodb DEFAULT CHARSET=utf8;\n```\n\n```\nstart transaction;\n\ninsert into goods_innodb(id,name)values(null,'Meta20');\n\ncommit;\n```\n\n![1556075130115](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163128.png) \n\n测试，发现在InnoDB中是存在事务的 ；\n\n\n\n**外键约束**\n\n\tMySQL支持外键的存储引擎只有InnoDB ， 在创建外键的时候， 要求父表必须有对应的索引 ， 子表在创建外键的时候， 也会自动的创建对应的索引。\n\t\n\t父表：没有外键，有主键。\n\t\n\t子表：有主键，有外键，引用父表的主键。\n\t\n\t下面两张表中 ， country_innodb是父表 ， country_id为主键索引，city_innodb表是子表，country_id字段为外键，对应于country_innodb表的主键country_id 。\n\n```sql\ncreate table country_innodb(\n\tcountry_id int NOT NULL AUTO_INCREMENT,\n    country_name varchar(100) NOT NULL,\n    primary key(country_id)\n)ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\ncreate table city_innodb(\n\tcity_id int NOT NULL AUTO_INCREMENT,\n    city_name varchar(50) NOT NULL,\n    country_id int NOT NULL,\n    primary key(city_id),\n    key idx_fk_country_id(country_id),\n    CONSTRAINT `fk_city_country` FOREIGN KEY(country_id) REFERENCES country_innodb(country_id) ON DELETE RESTRICT ON UPDATE CASCADE\n)ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n\ninsert into country_innodb values(null,'China'),(null,'America'),(null,'Japan');\ninsert into city_innodb values(null,'Xian',1),(null,'NewYork',2),(null,'BeiJing',1);\n\n```\n\n在创建索引时， 可以指定在删除、更新父表时，对子表进行的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION。\n\nRESTRICT和NO ACTION相同， 是指限制在子表有关联记录的情况下， 父表不能更新；\n\nCASCADE表示父表在更新或者删除时，更新或者删除子表对应的记录；\n\nSET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL 。\n\n针对上面创建的两个表， 子表的外键指定是ON DELETE RESTRICT ON UPDATE CASCADE 方式的， 那么在父表删除记录的时候， 如果子表有对应记录， 则不允许删除， 主表在更新记录的时候， 如果子表有对应记录， 则子表对应更新 。\n\n表中数据如下图所示 ： \n\n![1556087540767](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163131.png) \n\n\n\n外键信息可以使用如下两种方式查看 ： \n\n```\nshow create table city_innodb ;\n```\n\n![1556087611295](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163159.png) \t\n\n\n\n删除country_id为1 的country数据： \n\n```\n delete from country_innodb where country_id = 1;\n```\n\n![1556087719145](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163204.png) \n\n更新主表country表的字段 country_id : \n\n```\nupdate country_innodb set country_id = 100 where country_id = 1;\n```\n\n![1556087759615](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163354.png)  \n\n更新后， 子表的数据信息为 ： \n\n![1556087793738](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163357.png)  \n\n\n\n**存储方式**\t\n\nInnoDB 存储表和索引有以下两种方式 ： \n\n①. 使用共享表空间存储， 这种方式创建的表的表结构保存在.frm文件中， 数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。\n\n②. 使用多表空间存储， 这种方式创建的表的表结构仍然存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。\n\n![1556075336630](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163404.png) \n\n\n\n##  MyISAM\n\n\tMyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表 。有以下两个比较重要的特点： \n\n**不支持事务**\n\n```sql\ncreate table goods_myisam(\n\tid int NOT NULL AUTO_INCREMENT,\n\tname varchar(20) NOT NULL,\n    primary key(id)\n)ENGINE=myisam DEFAULT CHARSET=utf8;\n```\n\n\n\n**文件存储方式**\n\n每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但拓展名分别是 ： \n\n.frm (存储表定义)；\n\n.MYD(MYData , 存储数据)；\n\n.MYI(MYIndex , 存储索引)；\n\n![1556075073836](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163409.png) \n\n\n\n##  MEMORY\n\n\tMemory存储引擎将表的数据存放在内存中。每个MEMORY表实际对应一个磁盘文件，格式是.frm ，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY 类型的表访问非常地快，因为他的数据是存放在内存中的，并且默认使用HASH索引 ， 但是服务一旦关闭，表中的数据就会丢失。\n\n\n\n##  MERGE\n\n\tMERGE存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身并没有存储数据，对MERGE类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行的。\n\t\n\t对于MERGE类型表的插入操作，是通过INSERT_METHOD子句定义插入的表，可以有3个不同的值，使用FIRST 或 LAST 值使得插入操作被相应地作用在第一或者最后一个表上，不定义这个子句或者定义为NO，表示不能对这个MERGE表执行插入操作。\n\t\n\t可以对MERGE表进行DROP操作，但是这个操作只是删除MERGE表的定义，对内部的表是没有任何影响的。\n\n![1556076359503](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163417.png) \n\n下面是一个创建和使用MERGE表的示例 ： \n\n1）. 创建3个测试表 order_1990, order_1991, order_all , 其中order_all是前两个表的MERGE表 ： \n\n```sql\ncreate table order_1990(\n\torder_id int ,\n\torder_money double(10,2),\n\torder_address varchar(50),\n\tprimary key (order_id)\n)engine = myisam default charset=utf8;\n\n\ncreate table order_1991(\n\torder_id int ,\n\torder_money double(10,2),\n\torder_address varchar(50),\n\tprimary key (order_id)\n)engine = myisam default charset=utf8;\n\n\ncreate table order_all(\n\torder_id int ,\n\torder_money double(10,2),\n\torder_address varchar(50),\n\tprimary key (order_id)\n)engine = merge union = (order_1990,order_1991) INSERT_METHOD=LAST default charset=utf8;\n\n\n```\n\n2）. 分别向两张表中插入记录 \n\n```sql\ninsert into order_1990 values(1,100.0,'北京');\ninsert into order_1990 values(2,100.0,'上海');\n\ninsert into order_1991 values(10,200.0,'北京');\ninsert into order_1991 values(11,200.0,'上海');\n```\n\n3）. 查询3张表中的数据。\n\norder_1990中的数据 ： \n\n![1551408083254](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163426.png) \n\norder_1991中的数据 ： \n\n![1551408133323](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163431.png)  \n\norder_all中的数据 ：\n\n![1551408216185](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163436.png) \n\n​\t \n\n4）. 往order_all中插入一条记录 ，由于在MERGE表定义时，INSERT_METHOD 选择的是LAST，那么插入的数据会想最后一张表中插入。\n\n```sql\ninsert into order_all values(100,10000.0,'西安')；\n```\n\n![1551408519889](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625163441.png) \t \t\n\n\n\n##  存储引擎的选择\n\n\t在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。以下是几种常用的存储引擎的使用环境。\n\n- InnoDB : 是Mysql的默认存储引擎，用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询意外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定， 还可以确保事务的完整提交和回滚，对于类似于计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择。\n- MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。\n- MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。\n- MERGE：用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。MERGE表的优点在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率。这对于存储诸如数据仓储等VLDB环境十分合适。\n\n\n\n# Mysql并发参数调整\n\n从实现上来说，MySQL Server 是多线程结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。在Mysql中，控制并发连接和线程的主要参数包括 max_connections、back_log、thread_cache_size、table_open_cahce。\n\n##  max_connections\n\n采用max_connections 控制允许连接到MySQL数据库的最大数量，默认值是 151。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。\n\nMysql 最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。\n\n\n\n##  back_log\n\nback_log 参数控制MySQL监听TCP端口时设置的积压请求栈大小。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections / 5）， 但最大不超过900。\n\n如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。\n\n\n\n##  table_open_cache\n\n该参数用来控制所有SQL语句执行线程可打开表缓存的数量， 而在执行SQL语句时，每一个SQL执行线程至少要打开 1 个表缓存。该参数的值应该根据设置的最大连接数 max_connections 以及每个连接执行关联查询中涉及的表的最大数量来设定 ：\n\n\tmax_connections x N ；\n\n\n\n##  thread_cache_size\n\n为了加快连接数据库的速度，MySQL 会缓存一定数量的客户服务线程以备重用，通过参数 thread_cache_size 可控制 MySQL 缓存客户服务线程的数量。\n\n\n\n##  innodb_lock_wait_timeout\n\n该参数是用来设置InnoDB 事务等待行锁的时间，默认值是50ms ， 可以根据需要进行动态设置。对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起； 对于后台运行的批量处理程序来说， 可以将行锁的等待时间调大， 以避免发生大的回滚操作。\n\n\n\n#  Mysql锁问题\n\n##  锁概述\n\n锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。\n\n在数据库中，除传统的计算资源（如 CPU、RAM、I/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。\n\n\n\n##  锁分类\n\n从对数据操作的粒度分 ： \n\n1） 表锁：操作时，会锁定整个表。\n\n2） 行锁：操作时，会锁定当前操作行。\n\n从对数据操作的类型分：\n\n1） 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。\n\n2） 写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。\n\n\n\n##  Mysql 锁\n\n相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。下表中罗列出了各存储引擎对锁的支持情况：\n| 存储引擎 | 表级锁 | 行级锁 | 页面锁 |\n| -------- | ------ | ------ | ------ |\n| MyISAM   | 支持   | 不支持 | 不支持 |\n| InnoDB   | 支持   | 支持   | 不支持 |\n| MEMORY   | 支持   | 不支持 | 不支持 |\n| BDB      | 支持   | 不支持 | 支持   |\n\nMySQL这3种锁的特性可大致归纳如下 ：\n\n| 锁类型 | 特点                                                         |\n| ------ | ------------------------------------------------------------ |\n| 表级锁 | 偏向MyISAM 存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。 |\n| 行级锁 | 偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。 |\n| 页面锁 | 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 |\n\n从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理（OLTP）系统。\n\n\n\n##  MyISAM 表锁\n\nMyISAM 存储引擎只支持表锁，这也是MySQL开始几个版本中唯一支持的锁类型。\n\n\n\n###  如何加表锁\n\nMyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。\n\n显示加表锁语法：\n\n```SQL\n加读锁 ： lock table table_name read;\n\n加写锁 ： lock table table_name write；\n```\n\n\n\n###  读锁案例\n\n准备环境\n\n```SQL\ncreate database demo_03 default charset=utf8mb4;\n\nuse demo_03;\n\nCREATE TABLE `tb_book` (\n  `id` INT(11) auto_increment,\n  `name` VARCHAR(50) DEFAULT NULL,\n  `publish_time` DATE DEFAULT NULL,\n  `status` CHAR(1) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=myisam DEFAULT CHARSET=utf8 ;\n\nINSERT INTO tb_book (id, name, publish_time, status) VALUES(NULL,'java编程思想','2088-08-01','1');\nINSERT INTO tb_book (id, name, publish_time, status) VALUES(NULL,'solr编程思想','2088-08-08','0');\n\n\n\nCREATE TABLE `tb_user` (\n  `id` INT(11) auto_increment,\n  `name` VARCHAR(50) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=myisam DEFAULT CHARSET=utf8 ;\n\nINSERT INTO tb_user (id, name) VALUES(NULL,'令狐冲');\nINSERT INTO tb_user (id, name) VALUES(NULL,'田伯光');\n\n```\n\n\n\n客户端 一 ：\n\n1）获得tb_book 表的读锁 \n\n```\nlock table tb_book read;\n```\n\n\n\n2） 执行查询操作\n\n```\nselect * from tb_book;\n```\n\n![1553906896564](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164636.png) \n\n可以正常执行 ， 查询出数据。\n\n\n\n客户端 二 ：\n\n3） 执行查询操作\n\n```\nselect * from tb_book;\n```\n\n![1553907044500](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164640.png) \n\n\n\n客户端 一 ：\n\n4）查询未锁定的表\n\n```\nselect name from tb_seller;\n```\n\n![1553908913515](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164644.png) \n\n\n\n客户端 二 ：\n\n5）查询未锁定的表\n\n```\nselect name from tb_seller;\n```\n\n![1553908973840](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164649.png) \n\n可以正常查询出未锁定的表；\n\n\n\n客户端 一 ：\n\n6） 执行插入操作 \n\n```\ninsert into tb_book values(null,'Mysql高级','2088-01-01','1');\n```\n\n![1553907198462](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164653.png) \n\n执行插入， 直接报错 ， 由于当前tb_book 获得的是 读锁， 不能执行更新操作。\n\n\n\n客户端 二 ：\n\n7） 执行插入操作 \n\n```\ninsert into tb_book values(null,'Mysql高级','2088-01-01','1');\n```\n\n![1553907403957](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164657.png) \n\n\n\n当在客户端一中释放锁指令 unlock tables  后 ， 客户端二中的 inesrt 语句 ， 立即执行 ；\n\n\n\n###  写锁案例\n\n客户端 一 :\n\n1）获得tb_book 表的写锁 \n\n```\nlock table tb_book write ;\n```\n\n2）执行查询操作\n\n```\nselect * from tb_book ;\n```\n\n![1553907849829](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164701.png) \n\n查询操作执行成功；\n\n3）执行更新操作\n\n```\nupdate tb_book set name = 'java编程思想（第二版）' where id = 1;\n```\n\n![1553907875221](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164705.png) \n\n更新操作执行成功 ；\n\n\n\n客户端 二 :\n\n4）执行查询操作\n\n```\nselect * from tb_book ;\n```\n\n![1553908019755](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164709.png) \n\n\n\n当在客户端一中释放锁指令 unlock tables  后 ， 客户端二中的 select 语句 ， 立即执行 ；\n\n![1553908131373](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164713.png) \n\n\n\n###  结论\n\n锁模式的相互兼容性如表中所示：\n\n![1553905621992](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164717.png) \n\n由上表可见： \n\n\t1） 对MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；\n\t\n\t2） 对MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；\n\t\n\t简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁，则既会阻塞读，又会阻塞写。\n\n\n\n此外，MyISAM 的读写锁调度是写优先，这也是MyISAM不适合做写为主的表的存储引擎的原因。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。\n\n\n\n###  查看锁的争用情况\n\n``` \nshow open tables；\n```\n\n![1556443073322](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164721.png) \n\nIn_user : 表当前被查询使用的次数。如果该数为零，则表是打开的，但是当前没有被使用。\n\nName_locked：表名称是否被锁定。名称锁定用于取消表或对表进行重命名等操作。\n\n\n\n```\nshow status like 'Table_locks%';\n```\n\n![1556443170082](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164726.png) \n\nTable_locks_immediate ： 指的是能够立即获得表级锁的次数，每立即获取锁，值加1。\n\nTable_locks_waited ： 指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加1，此值高说明存在着较为严重的表级锁争用情况。\n\n\n\n##  InnoDB 行锁\n\n##### 3 行锁介绍\n\n行锁特点 ：偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。\n\nInnoDB 与 MyISAM 的最大不同有两点：一是支持事务；二是 采用了行级锁。\n\n\n\n###  背景知识\n\n**事务及其ACID属性**\n\n事务是由一组SQL语句组成的逻辑处理单元。\n\n事务具有以下4个特性，简称为事务ACID属性。\n\n| ACID属性             | 含义                                                         |\n| -------------------- | ------------------------------------------------------------ |\n| 原子性（Atomicity）  | 事务是一个原子操作单元，其对数据的修改，要么全部成功，要么全部失败。 |\n| 一致性（Consistent） | 在事务开始和完成时，数据都必须保持一致状态。                 |\n| 隔离性（Isolation）  | 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的 “独立” 环境下运行。 |\n| 持久性（Durable）    | 事务完成之后，对于数据的修改是永久的。                       |\n\n\n\n**并发事务处理带来的问题**\n\n| 问题                               | 含义                                                         |\n| ---------------------------------- | ------------------------------------------------------------ |\n| 丢失更新（Lost Update）            | 当两个或多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖。 |\n| 脏读（Dirty Reads）                | 当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。 |\n| 不可重复读（Non-Repeatable Reads） | 一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现和以前读出的数据不一致。 |\n| 幻读（Phantom Reads）              | 一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其他事务插入了满足其查询条件的新数据。 |\n\n\n\n**事务隔离级别**\n\n为了解决上述提到的事务并发问题，数据库提供一定的事务隔离机制来解决这个问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使用事务在一定程度上“串行化” 进行，这显然与“并发” 是矛盾的。 \n\n数据库的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏写、脏读、不可重复读、幻读这几类问题。\n\n| 隔离级别                | 丢失更新 | 脏读 | 不可重复读 | 幻读 |\n| ----------------------- | -------- | ---- | ---------- | ---- |\n| Read uncommitted        | ×        | √    | √          | √    |\n| Read committed          | ×        | ×    | √          | √    |\n| Repeatable read（默认） | ×        | ×    | ×          | √    |\n| Serializable            | ×        | ×    | ×          | ×    |\n\n备注 ： √  代表可能出现 ， × 代表不会出现 。\n\nMysql 的数据库的默认隔离级别为 Repeatable read ， 查看方式：\n\n```\nshow variables like 'tx_isolation';\n```\n\n![1554331600009](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164733.png)  \n\n\n\n###  InnoDB 的行锁模式\n\nInnoDB  实现了以下两种类型的行锁。\n\n- 共享锁（S）：又称为读锁，简称S锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。\n- 排他锁（X）：又称为写锁，简称X锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。\n\n对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；\n\n对于普通SELECT语句，InnoDB不会加任何锁；\n\n\n\n可以通过以下语句显示给记录集加共享锁或排他锁 。\n\n```\n共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE\n\n排他锁（X) ：SELECT * FROM table_name WHERE ... FOR UPDATE\n```\n\n\n\n###  案例准备工作\n\n```sql\ncreate table test_innodb_lock(\n\tid int(11),\n\tname varchar(16),\n\tsex varchar(1)\n)engine = innodb default charset=utf8;\n\ninsert into test_innodb_lock values(1,'100','1');\ninsert into test_innodb_lock values(3,'3','1');\ninsert into test_innodb_lock values(4,'400','0');\ninsert into test_innodb_lock values(5,'500','1');\ninsert into test_innodb_lock values(6,'600','0');\ninsert into test_innodb_lock values(7,'700','0');\ninsert into test_innodb_lock values(8,'800','1');\ninsert into test_innodb_lock values(9,'900','1');\ninsert into test_innodb_lock values(1,'200','0');\n\ncreate index idx_test_innodb_lock_id on test_innodb_lock(id);\ncreate index idx_test_innodb_lock_name on test_innodb_lock(name);\n```\n\n\n\n###  行锁基本演示\n\n| Session-1                                                    | Session-2                                                    |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| ![1554354615030](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164740.png)      关闭自动提交功能 | ![1554354601867](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164745.png)  关闭自动提交功能 |\n| ![1554354713628](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164753.png) 可以正常的查询出全部的数据 | ![1554354717336](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164756.png) 可以正常的查询出全部的数据 |\n| ![1554354830589](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164800.png)查询id 为3的数据 ； | ![1554354832708](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164803.png)获取id为3的数据 ； |\n| ![1554382789984](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164807.png) 更新id为3的数据，但是不提交； | ![1554382905352](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164820.png) 更新id为3 的数据， 出于等待状态 |\n| ![1554382977653](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164810.png) 通过commit， 提交事务 | ![1554383044542](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164824.png) 解除阻塞，更新正常进行 |\n| 以上， 操作的都是同一行的数据，接下来，演示不同行的数据 ：   |                                                              |\n| ![1554385220580](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164815.png) 更新id为3数据，正常的获取到行锁 ， 执行更新 ； | ![1554385236768](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164828.png) 由于与Session-1 操作不是同一行，获取当前行锁，执行更新； |\n\n\n\n###  无索引行锁升级为表锁\n\n如果**不通过索引**条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。\n\n\n\n查看当前表的索引 ： show  index  from test_innodb_lock ;\n\n![1554385956215](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164832.png) \n\n| Session-1                                                    | Session-2                                                    |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 关闭事务的自动提交![1554386287454](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164835.png) | 关闭事务的自动提交![1554386312524](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164839.png) |\n| 执行更新语句 ：![1554386654793](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164843.png) | 执行更新语句， 但处于阻塞状态：![1554386685610](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164850.png) |\n| 提交事务：![1554386721653](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164846.png) | 解除阻塞，执行更新成功 ：![1554386750004](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164853.png) |\n|                                                              | 执行提交操作 ：![1554386804807](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164857.png) |\n\n由于 执行更新时 ， name字段本来为varchar类型， 我们是作为数字类型使用，存在类型转换，索引失效，最终行锁变为表锁 ；\n\n\n\n###  间隙锁危害\n\n当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据进行加锁； 对于键值在条件范围内但并不存在的记录，叫做 \"间隙（GAP）\" ， InnoDB也会对这个 \"间隙\" 加锁，这种锁机制就是所谓的 间隙锁（Next-Key锁） 。\n\n示例 ： \n\n\t表test_innodb_lock 中有id为1，3的两条数据。没有id为2的数据。\n\n| Session-1                                                    | Session-2                                                    |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 关闭事务自动提交 ![1554387987130](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164901.png) | 关闭事务自动提交![1554387994533](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164914.png) |\n| 根据id范围更新数据![1554388492478](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164906.png) |                                                              |\n| 此时会对id为1，2，3的数据进行加锁。由于id为2的数据不存在，因此对id为2的加的是`间隙锁`。 | 插入id为2的记录， 出于阻塞状态![1554388515936](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164917.png) |\n| 提交事务 ；![1554388149305](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164910.png) |                                                              |\n|                                                              | 解除阻塞 ， 执行插入操作 ：![1554388548562](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164921.png) |\n|                                                              | 提交事务 ：                                                  |\n\n\n\n###  InnoDB 行锁争用情况\n\n```sql\nshow  status like 'innodb_row_lock%';\n```\n\n![1556455943670](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210625164925.png)\n\n```\nInnodb_row_lock_current_waits: 当前正在等待锁定的数量\n\nInnodb_row_lock_time: 从系统启动到现在锁定总时间长度\n\nInnodb_row_lock_time_avg:每次等待所花平均时长\n\nInnodb_row_lock_time_max:从系统启动到现在等待最长的一次所花的时间\n\nInnodb_row_lock_waits: 系统启动后到现在总共等待的次数\n\n\n当等待的次数很高，而且每次等待的时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。\n\n```\n\n\n\n##  总结\n\nInnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高一些，但是在整体并发处理能力方面要远远由于MyISAM的表锁的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势。\n\n但是，InnoDB的行级锁同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。\n\n\n\n优化建议：\n\n- 尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁。\n- 合理设计索引，尽量缩小锁的范围\n- 尽可能减少索引条件，及索引范围，避免间隙锁\n- 尽量控制事务大小，减少锁定资源量和时间长度\n- 尽可使用低级别事务隔离（但是需要业务层面满足需求）","categories":["Java学习","数据库"]},{"title":"Zookpeer的学习","url":"/2021/06/11/尚硅谷说Java/分布式技术/zookeeper的学习/","content":"\n* Zookeeper的分布式锁的实现，集群的搭建，Curator的API使用。\n* Watch事件的监听。\n\n<!--more-->\n\n\n\n# 认识Zookeeper\n\n* Zookeeper 是 Apache Hadoop 项目下的一个子项目，是一个树形目录服务。\n* Zookeeper 是一个分布式的、开源的分布式应用程序的协调服务。\n* Zookeeper 提供的主要功能包括：\n  * 配置管理\n  * 分布式锁\n  * 集群管理\n* 配置管理：假设有三台服务器A,B,C,它们都要连接数据库。\n  * 在正常情况下是三个服务器各自有自己的配置。但是当数据库变更时，就需要一个一个的改，很麻烦。\n  * 使用Zookpeer后，就可以将公有的配置信息写在配置中心中，而三台服务器不需要再写相关的配置了。修改时只需要修改配置中心的信息就可以了。\n* 分布式锁：\n  * 在原来的项目中，一个项目只有一个服务器，在访问数据时一般是由JVM添加的锁。这个锁只适用于此服务器。\n  * 但在分布式里，有多个服务器，每个服务器提供的锁和其他服务器都是无关的，没有关系的。\n  * 因此在分布式中想要就有锁的功能就要使用分布式锁。\n  * 而Zookpeer就提供了这样的功能。\n* 集群管理：\n  * 指zookpeer提供注册中心的功能，在项目中，\n  * 多个服务提供方将自身的信息注册到注册中心中，\n  * 消费者从注册中心获取到某一个服务的访问，然后通过RPC的方式访问访问服务提供方。\n* 总结：在多个项目服务器之间，Zookpeer可以从当一个第三方管理者的角色，它提供了配置中心，分布式锁和集群管理的三个功能。\n* Zookeeper有服务端和客户端两个端口。\n  * 服务端只提供服务。\n  * 客户端可以对服务端进行各种配置，比如配置中心管理等等。\n* 对Zookeeper服务的操作方式有两种。\n  * 一种是通过客户端进行操作\n  * 一种是编写代码通过API进行操作。\n\n\n\n#  ZooKeeper 安装与配置\n\n* 准备工作：\n\n  * ZooKeeper服务器是用Java创建的，它运行在JVM之上。需要安装JDK 7或更高版本。\n\n  ```markdown\n  \t查看当前虚拟机云端支持的jdk版本\n  yum search java|grep jdk\n  \t安装\n  yum install -y java-1.8.0-openjdk\n  \t查看jdk版本\n  java -version\n  ```\n\n  * 下载：https://plumriver.lanzoui.com/itq71q2sg1i\n\n* 安装步骤：\n\n  * 第一步：将本地下载的压缩包通过Xftp传送到Linux的opt/zookeeper下。\n    * zookeeper目录需要提前创建\n  * 第二步：解压压缩包\n\n  ```shell\n  tar -zxvf apache-zooKeeper-3.5.6-bin.tar.gz \n  ```\n\n* 修改配置文件\n\n  ```markdown\n  进入到配置文件中\n  \t[root@localhost apache-zookeeper-3.5.6-bin]# cd conf\n  查看配置文件列表\n  \t[root@localhost conf]# ls\n  \tconfiguration.xsl  log4j.properties  zoo_sample.cfg\n  复制一份配置文件。尽量不在源文件上修改，这样方便恢复。\n  \t[root@localhost conf]# cp zoo_sample.cfg zoo.cfg\n  修改zoo.cfg文件\n  \t[root@localhost conf]# vi zoo.cfg\n  修改内容如下。指定zookpeer的数据存放位置。\n  \tdataDir=/opt/zookeeper/zkdata\n  在zookeeper下创建zkdata目录\n  \t[root@localhost zookeeper]# mkdir zkdata\n  \t[root@localhost zookeeper]# ls\n  \tapache-zookeeper-3.5.6-bin  apache-zookeeper-3.5.6-bin.tar.gz  zkdata\n  \n  ```\n\n* 启动\n\n  ```markdown\n  启动相关的文件都在zookeeper的bin目录下\n  \tzkCli.sh 客户端启动命令\n  \tzkServer.sh 服务端启动命令\n  启动\n  \t[root@localhost bin]# ./zkServer.sh start\n  \t/usr/bin/java\n  \tZooKeeper JMX enabled by default\n  \tUsing config: /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg\n  \tStarting zookeeper ... STARTED\n  ```\n\n* 查看状态\n\n  ```markdown\n  [root@localhost bin]# ./zkServer.sh status\n  /usr/bin/java\n  ZooKeeper JMX enabled by default\n  Using config: /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg\n  Client port found: 2181. Client address: localhost. #客户端连接的IP和端口号\n  Mode: standalone #表示服务信息，standalone表示zk没有搭建集群，现在是单节点\n  ```\n\n\n\n#  ZooKeeper 命令操作\n\n\n\n## 数据模型\n\n* ZooKeeper 是一个树形目录服务,其数据模型和Unix的文件系统目录树很类似，拥有一个层次化结构。\n\n* 这里面的每一个节点都被称为： ZNode，每个节点上都会保存自己的数据和节点信息。 \n\n* 节点可以拥有子节点，同时也允许少量（1MB）数据存储在该节点之下。\n\n* 节点可以分为四大类：\n\n  * PERSISTENT 持久化节点 。(默认类型)\n  * EPHEMERAL 临时节点 ：-e\n  * PERSISTENT_SEQUENTIAL 持久化顺序节点 ：-s\n  * EPHEMERAL_SEQUENTIAL 临时顺序节点  ：-es\n\n* 说明：\n\n  ```markdown\n  \t这个树形目录服务可以想象成数据结构中的树结构。\n  \t每个节点可以有多个叶子。\n  \t节点可以存放节点信息，也会存放少于1M的数据。\n  \t叶子和节点相同。\n  \t所有节点有四种属性：持久化，临时，持久化顺序，临时顺序。\n  \t持久化：指此节点会被存储在磁盘上。\n  \t临时：指此节点对应的客户端关闭后，这个节点会被删除。\n  \t顺序：指这个节点的信息中会有类似于数组的下标的属性。\n  ```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210611085235.png)\n\n\n\n## 服务端常用命令\n\n```markdown\n启动 ZooKeeper 服务: \n\t./zkServer.sh start\n查看 ZooKeeper 服务状态: \n\t./zkServer.sh status\n停止 ZooKeeper 服务: \n\t./zkServer.sh stop \n重启 ZooKeeper 服务: \n\t./zkServer.sh restart \n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210611085123.png)\n\n\n\n## 客户端常用命令\n\n* 基础命令\n\n```markdown\n连接Zookeeper服务器，即启动客户端：./zkCli.sh –server ip:port\n\t[root@localhost ~]# cd /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin\n\t[root@localhost bin]# ./zkCli.sh -server localhost:2181\n断开连接\n\t[zk: localhost:2181(CONNECTED) 3] quit\n查看帮助命令文档\n\t[zk: localhost:2181(CONNECTED) 0] help\n显示指定目录(节点)下的节点:查看/节点下的节点\n\t[zk: localhost:2181(CONNECTED) 1] ls /   \n\t[zookeeper] \n```\n\n* CRUD命令\n\n```markdown\n创建节点(value可以不写)：create /节点path value   \n\t[zk: localhost:2181(CONNECTED) 0] create /test hello\n\tCreated /test\n获取节点值：get /节点path\n\t[zk: localhost:2181(CONNECTED) 1] get /test\n\thello\n设置节点值：set /节点path value\n\t[zk: localhost:2181(CONNECTED) 0] create /test hello\n\tCreated /test\n删除单个节点：delete /节点path\n\t[zk: localhost:2181(CONNECTED) 4] delete /test\n\t[zk: localhost:2181(CONNECTED) 5] ls /\n\t[zookeeper]\n删除带有子节点的节点：deleteall /节点path\n\t[zk: localhost:2181(CONNECTED) 6] create /test\n\tCreated /test\n\t[zk: localhost:2181(CONNECTED) 7] create /test/a\n\tCreated /test/a\n\t[zk: localhost:2181(CONNECTED) 8] ls /test\n\t[a]\n\t[zk: localhost:2181(CONNECTED) 9] delete /test\n\tNode not empty: /test\n\t[zk: localhost:2181(CONNECTED) 10] deleteall /test\n\t[zk: localhost:2181(CONNECTED) 11] ls /\n\t[zookeeper]\n```\n\n* 节点命令\n\n```markdown\n创建临时节点：create -e /节点path value\n\t[zk: localhost:2181(CONNECTED) 37] create -e /test\n\tCreated /test\n创建顺序节点：create -s /节点path value\n\t[zk: localhost:2181(CONNECTED) 38] create -s /num\n\tCreated /num0000000006\n\t[zk: localhost:2181(CONNECTED) 39] create -s /num\n\tCreated /num0000000007\n\t[zk: localhost:2181(CONNECTED) 40] create -s /num\n\tCreated /num0000000008\n\t[zk: localhost:2181(CONNECTED) 41] ls /\n\t[num0000000006, num0000000007, num0000000008, test, zookeeper]\n创建临时顺序节点：会发现临时顺序节点的下标会紧跟其他顺序节点的下标\n\t[zk: localhost:2181(CONNECTED) 42] create -es /num\n\tCreated /num0000000009\n\t[zk: localhost:2181(CONNECTED) 43] ls /\n\t[num0000000006, num0000000007, num0000000008, num0000000009, test, zookeeper]\n查询节点详细信息：ls –s /节点path\n\t[zk: localhost:2181(CONNECTED) 45] ls -s /test\n\t[]cZxid = 0x15\n\tctime = Fri Jun 11 09:16:13 CST 2021\n\tmZxid = 0x15\n\tmtime = Fri Jun 11 09:16:13 CST 2021\n\tpZxid = 0x15\n\tcversion = 0\n\tdataVersion = 0\n\taclVersion = 0\n\tephemeralOwner = 0x1000010c1f80001\n\tdataLength = 0\n\tnumChildren = 0\n信息说明\n\tczxid：节点被创建的事务ID \n\tctime: 创建时间 \n\tmzxid: 最后一次被更新的事务ID \n\tmtime: 修改时间 \n\tpzxid：子节点列表最后一次被更新的事务ID\n\tcversion：子节点的版本号 \n\tdataversion：数据版本号 \n\taclversion：权限版本号 \n\tephemeralOwner：用于临时节点，代表临时节点的事务ID，如果为持久节点则为0 \n\tdataLength：节点存储的数据的长度 \n\tnumChildren：当前节点的子节点个数 \n```\n\n\n\n#  ZooKeeper JavaAPI 操作\n\n\n\n## Curator\n\n* Curator 是 Apache ZooKeeper 的Java客户端库。\n* 常见的ZooKeeper Java API ：\n  * 原生Java API\n  * ZkClient：对原生Java API的简化\n  * Curator：对原生Java API的进一步简化\n* Curator 项目的目标是简化 ZooKeeper 客户端的使用。\n* Curator 最初是 Netfix 研发的,后来捐献了 Apache 基金会,目前是 Apache 的顶级项目。\n* 官网：http://curator.apache.org/\n* 注意：Curator高版本的能操作低版本的Zookeeper，但是仍要注意Curator和Zookeeper的版本匹配情况。\n  * 在引入版本时，可以先在maven网站上查看zookeeper的版本依赖出现的时间，\n  * 然后再看curator的版本依赖出现的时间，然后尽量选择高一点的版本，但不要高太多。\n  * 实际过程中可以在IDEA的maven插件中看curator具体匹配的哪个版本的zookeeper，然后一步一步调。\n* 版本不匹配出现的问题：\n  * 在创建连接时可能是正常的，但在添加节点时会一直运行，就是不报错。\n  * 或者添加节点就是添加不进去。\n\n\n\n## API的常用操作\n\n\n\n### 建立连接\n\n* 创建maven工程项目\n\n* 引入依赖\n\n  ```xml\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.10</version>\n    </dependency>\n    <!--curator-->\n    <dependency>\n      <groupId>org.apache.curator</groupId>\n      <artifactId>curator-framework</artifactId>\n      <version>4.2.0</version>\n    </dependency>\n    <dependency>\n      <groupId>org.apache.curator</groupId>\n      <artifactId>curator-recipes</artifactId>\n      <version>4.2.0</version>\n    </dependency>\n    <!--日志-->\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-api</artifactId>\n      <version>1.7.21</version>\n    </dependency>\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-log4j12</artifactId>\n      <version>1.7.21</version>\n    </dependency>\n  </dependencies>\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <version>3.8.1</version>\n      </plugin>\n    </plugins>\n  </build>\n  ```\n\n* 创建日志配置文件:log4j.properties\n\n  ```properties\n  log4j.rootLogger=off,stdout\n  \n  log4j.appender.stdout = org.apache.log4j.ConsoleAppender\n  log4j.appender.stdout.Target = System.out\n  log4j.appender.stdout.layout = org.apache.log4j.PatternLayout\n  log4j.appender.stdout.layout.ConversionPattern = [%d{yyyy-MM-dd HH/:mm/:ss}]%-5p %c(line/:%L) %x-%m%n\n  ```\n\n* 建立连接\n\n```java\n@Test\npublic void testConnection() {\n  /**\n     * connectString ：连接的字符串，由IP和端口组成，集群时，多个服务之间适用，(逗号)隔开\n     * sessionTimeoutMs ：会话超时时间，单位毫秒\n     * connectionTimeoutMs ：连接超时时间，单位毫秒\n     * retryPolicy ：重试策略。其部分实现类如下\n     *  RetryForever ：永远重试\n     *  RetryOneTime ：重试一次\n     *  RetryNTimes ：重试多次\n     *  ExponentialBackoffRetry ：以指定的间隔时间重试\n     */\n  String connectString = \"192.168.56.120:2181\";\n  int sessionTimeoutMs = 60 * 1000;\n  int connectionTimeoutMs = 15 * 1000;\n  /**\n     * baseSleepTimeMs ：每一次休眠/间隔的时间，单位毫秒\n     * maxRetries ：最大的重试次数\n     */\n  RetryPolicy retryPolicy = new ExponentialBackoffRetry(3 * 1000, 10);\n  // 创建CuratorFramework的第一种方式：构造器方式\n  //CuratorFramework curatorFramework = CuratorFrameworkFactory.newClient(connectString, sessionTimeoutMs, connectionTimeoutMs, retryPolicy);\n  // 开启连接\n  //curatorFramework.start();\n\n  // 创建CuratorFramework的第二种方式：链式方式\n  CuratorFramework curatorFramework = CuratorFrameworkFactory.builder()\n    .connectString(connectString)\n    .sessionTimeoutMs(sessionTimeoutMs)\n    .connectionTimeoutMs(connectionTimeoutMs)\n    .retryPolicy(retryPolicy)\n    .namespace(\"curator\")  //名称空间的作用：在/目录下创建一个curator节点，往后所有的操作都会在此节点下。\n    .build();\n  // 开启连接\n  curatorFramework.start();\n  //关闭连接\n  curatorFramework.close();\n}\n// namespace补充说明：如果指定的namespace节点下没有子节点了，这个节点存活一段时间后就会被删除。\n```\n\n\n\n### 添加节点\n\n```java\npublic void  testNode() throws Exception {\n  //基本创建\n  // 注意1：如果创建节点没有指认数据，则默认将客户端的IP作为数据存储\n  curatorFramework.create().forPath(\"/base\");\n\n  //创建带有数据的节点\n  curatorFramework.create().forPath(\"/data\",\"curator data\".getBytes());\n\n  //创建指定类型的节点\n  /**\n     * EPHEMERAL：临时的\n     * EPHEMERAL_SEQUENTIAL：临时有序\n     * PERSISTENT：持久的\n     * PERSISTENT_SEQUENTIAL：持久有序\n     */\n  curatorFramework.create().withMode(CreateMode.EPHEMERAL).forPath(\"/custom1\");\n  curatorFramework.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(\"/custom2\");\n  curatorFramework.create().withMode(CreateMode.PERSISTENT).forPath(\"/custom3\");\n  curatorFramework.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(\"/custom4\");\n\n  //创建多级节点\n  // 不允许父节点不存在就创建子节点\n  // creatingParentsIfNeeded ：如果父节点不存在就创建父节点\n  curatorFramework.create().creatingParentsIfNeeded().forPath(\"/a/b/c\");\n\n}\n```\n\n\n\n### 删除节点\n\n```java\npublic void testDeleteNode() throws Exception {\n  // 1.删除单个节点\n  curatorFramework.delete().forPath(\"/base\");\n\n  // 2.删除带有子节点的节点\n  curatorFramework.delete().deletingChildrenIfNeeded().forPath(\"/a\");\n\n  // 3.必须成功的删除。为了防止网络抖动\n  \t// 过程：如果此次请求断网了，没有发过去。那么会一直发送删除的请求，直到删除成功\n  curatorFramework.delete().guaranteed().forPath(\"/data\");\n\n  // 4.删除后能够回调\n  curatorFramework.delete().inBackground(new BackgroundCallback(){\n    @Override\n    public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {\n      // client：客户端对象。 event：事件对象\n      System.out.println(event);\n    }\n  }).forPath(\"/custom3\");\n}\n```\n\n\n\n### 修改节点\n\n```java\npublic void testUpdateNode() throws Exception {\n\n  // 1.修改数据\n  // 返回值为此节点的详细信息\n  /*   Stat stat = curatorFramework.setData().forPath(\"/base\", \"base\".getBytes());\n    System.out.println(stat);*/\n\n  // 2.根据版本修改\n  // 先查询版本号，然后版本号匹配的才能成功修改\n  Stat stat = new Stat();\n  curatorFramework.getData().storingStatIn(stat).forPath(\"/base\");\n  int version =  stat.getVersion();\n  curatorFramework.setData().withVersion(version).forPath(\"/base\", \"\".getBytes());\n\n}\n```\n\n\n\n### 查询节点\n\n```java\npublic void testSelectNode() throws Exception {\n  // 1.查询节点的数据：get\n  byte[] bytes = curatorFramework.getData().forPath(\"/base\");\n  System.out.println(new String(bytes));\n\n  // 2.查询节点：ls\n  List<String> list = curatorFramework.getChildren().forPath(\"/a\");\n  System.out.println(list.toString());\n\n  // 3.查询节点的详细信息：ls -s 。查询到的数据会放到stat中。\n  Stat stat = new Stat();\n  System.out.println(stat);\n  byte[] value = curatorFramework.getData().storingStatIn(stat).forPath(\"/base\");\n  System.out.println(stat);\n  System.out.println(new String(value));\n}\n```\n\n\n\n### Watch事件监听\n\n* ZooKeeper 允许用户在指定节点上**注册一些Watcher**，并且在一些**特定事件触发**的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。\n\n* ZooKeeper 中引入了Watcher机制来实现了发布/订阅功能能，能够让多个订阅者同时监听某一个对象，当一个对象自身状态变化时，会通知所有订阅者。\n\n* ZooKeeper 原生支持通过注册Watcher来进行事件监听，但是其使用并不是特别方便需要开发人员自己反复注册Watcher，比较繁琐。\n\n* Curator引入了 Cache 来实现对 ZooKeeper 服务端事件的监听。\n\n* ZooKeeper提供了三种Watcher：\n\n  * NodeCache : 只是监听某一个特定的节点\n  * PathChildrenCache : 监控一个ZNode的子节点. \n  * TreeCache : 可以监控整个树下的所有节点，类似于NodeCache和多重PathChildrenCache的组合。\n\n* 特定事件：指增删改操作。增分为添加此节点和为此节点添加值。\n\n* NodeCache 的使用\n\n  ```java\n    /**\n     * 测试监听一个节点\n     */\n  public void testNodeCache() throws Exception {\n    // 1.创建NodeCache对象\n    NodeCache nodeCache = new NodeCache(curatorFramework, \"node\");\n    // 2.注册监听\n    nodeCache.getListenable().addListener(new NodeCacheListener() {\n      @Override\n      public void nodeChanged() throws Exception {\n        System.out.println(\"节点变化了~~~\");\n        //获取修改后的节点数据\n        byte[] data = nodeCache.getCurrentData().getData();\n        System.out.println(new String(data));\n      }\n    });\n    // 3.开启监听。如果设置为true，则开启监听时，加载缓冲数据。\n    nodeCache.start(true);\n  }\n  ```\n\n* PathChildrenCache 的使用\n\n  ```java\n    /**\n     * 测试监听指定节点的子节点。不包括子子节点。\n     */\n  public void testPathChildrenCache() throws Exception {\n    /**\n       * client ：服务端对象\n       * path ：节点的路径\n       * cacheData ：是否缓存节点的数据\n       * dataIsCompressed ：是否压缩节点变化后发送的数据\n       * executorService ：一个线程池\n       */\n    PathChildrenCache pathChildrenCache = new PathChildrenCache(curatorFramework,\"/app2\",true);\n    //绑定监听器\n    pathChildrenCache.getListenable().addListener(new PathChildrenCacheListener() {\n      @Override\n      public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {\n        System.out.println(\"子节点变化了\");\n        System.out.println(event.getType() + event.getData().toString());\n      }\n    });\n    //开启监听\n    pathChildrenCache.start();\n  }\n  ```\n\n* TreeCache 的使用\n\n  ```java\n  /**\n     * 测试监听指定节点以及它的下级所有节点，包括子子节点\n     */\n  public void testTreeCache() throws Exception {\n    TreeCache treeCache = new TreeCache(curatorFramework,\"/app2\");\n    treeCache.getListenable().addListener(new TreeCacheListener() {\n      @Override\n      public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception {\n        System.out.println(\"节点变化了\");\n        System.out.println(event);\n      }\n    });\n    treeCache.start();\n  }\n  ```\n\n\n\n## 分布式锁\n\n* 在我们进行单机应用开发，涉及并发同步的时候，我们往往采用synchronized或者Lock的方式来解决多线程间的代码同步问题，这时多线程的运行都是在同一个JVM之下，没有任何问题。\n\n* 但当我们的应用是分布式集群工作的情况下，属于多JVM下的工作环境，跨JVM之间已经无法通过多线程的锁解决同步问题。\n\n* 那么就需要一种更加高级的锁机制，来处理种跨机器的进程之间的数据同步问题——这就是分布式锁。\n\n* 锁的样式：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210611155714.png)\n\n  * 说明：\n    * A1访问数据前，先去分布式锁组件那里拿锁，拿到了，就去访问数据。\n    * 此时A2想要访问数据，也先去分布式锁组件那里拿锁，但是锁已经被A1拿走了。因此A2无法获取到锁，就不能访问数据。\n\n* 实现分布式锁方法：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210611155737.png)\n\n* 分布式锁的原理\n\n  * 核心思想：当客户端要获取锁，则创建节点，使用完锁，则删除该节点。\n\n* 步骤：\n\n  ```markdown\n  \t1.客户端获取锁时，在lock节点下创建临时顺序节点。\n  \t2.然后获取lock下面的所有子节点，客户端获取到所有的子节点之后，如果发现自己创建的子节点序号最小，那么就认为该客户端获取到了锁。使用完锁后，将该节点删除。\n  \t3.如果发现自己创建的节点并非lock所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，同时对其注册事件监听器，监听删除事件。\n  \t4.如果发现比自己小的那个节点被删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是lock子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。\n  ```\n\n* 说明：\n\n  * 创建的一定是<font color=\"red\">临时顺序</font>的节点。\n  * 临时的作用：如果一个服务器获取到了锁，但它宕机了，此时它获取到的锁就会被删除。不会阻碍其他服务器获取锁。\n  * 顺序的作用：能保证执行的顺序是总体上是先到先得的。\n\n* 在Curator中有五种锁方案：\n\n  * InterProcessSemaphoreMutex：分布式排它锁（非可重入锁）\n  * InterProcessMutex：分布式可重入排它锁\n  * InterProcessReadWriteLock：分布式读写锁\n  * InterProcessMultiLock：将多个锁作为单个实体管理的容器\n  * InterProcessSemaphoreV2：共享信号量\n\n\n\n## 模拟12306售票案例\n\n* 模拟12306\n\n```java\npublic class Train12306 implements Runnable {\n  private int num = 20;\n  private InterProcessMutex lock;\n  public Train12306(){\n    //初始化锁\n    CuratorFramework curatorFramework = CuratorFrameworkFactory.builder()\n        .connectString(\"192.168.56.120:2181\")\n        .sessionTimeoutMs(6*1000)\n        .connectionTimeoutMs(15*1000)\n        .retryPolicy(new ExponentialBackoffRetry(1000,10))\n        .namespace(\"demo\")\n        .build();\n    // 开启连接\n    curatorFramework.start();\n    lock = new InterProcessMutex(curatorFramework, \"/lock\");\n  }\n\n  @Override\n  public void run() {\n    while (true) {\n      try {\n        // 获取锁：每三秒获取一次锁\n        lock.acquire(3, TimeUnit.SECONDS);\n\n        if (num > 0) {\n          System.out.println(Thread.currentThread()+\" : 当前还剩\" + num + \"张票\");\n          num--;\n          Thread.sleep(100);\n        }\n\n      }catch (Exception e){\n        e.printStackTrace();\n      }finally {\n        //释放锁\n        try {\n          lock.release();\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n      }\n    }\n  }\n}\n```\n\n* 模拟携程，去哪儿.\n\n```java\npublic class LockTest {\n  public static void main(String[] args) {\n    Train12306 train12306 = new Train12306();\n\n    Thread thread1 = new Thread(train12306,\"携程\");\n    Thread thread2 = new Thread(train12306,\"去哪儿\");\n    thread1.start();\n    thread2.start();\n  }\n}\n```\n\n\n\n#  ZooKeeper 集群搭建\n\n* Leader选举：\n\n  ```markdown\n  1.Serverid：服务器ID\n  \t比如有三台服务器，编号分别是1,2,3。编号越大在选择算法中的权重越大。\n  2.Zxid：数据ID\n  \t服务器中存放的最大数据ID.值越大说明数据  越新，在选举算法中数据越新权重越大。\n  3.在Leader选举的过程中，如果某台ZooKeeper获得了超过半数的选票，则此ZooKeeper就可以成为Leader了。\n  ```\n\n* 集群角色\n\n  ```markdown\n  Leader 领导者 ：          \n  \t1. 处理事务请求\n  \t2. 集群内部各服务器的调度者\n  Follower 跟随者 ：\n  \t1. 处理客户端非事务请求，转发事务请求给Leader服务器\n  \t2. 参与Leader选举投票\n  Observer 观察者：\n  \t1. 处理客户端非事务请求，转发事务请求给Leader服务器\n  ```\n\n* 集群的说明：\n\n  * 真实的集群是需要部署在不同的服务器上的，但是在我们测试时同时启动很多个虚拟机内存会吃不消，所以我们通常会搭建**伪集群**，也就是把所有的服务都搭建在一台虚拟机上，用端口进行区分。\n\n* 准备工作：\n\n  * 一台虚拟机，具有JDK的环境\n  * 三个文件夹，三个文件夹中都有一个完整的zookeeper的加压后的文件。\n\n  ```shell\n  [root@localhost /]# cd opt\n  [root@localhost opt]# cd zookeeper-cluster/\n  [root@localhost zookeeper-cluster]# ll\n  drwxr-xr-x. 7 root root 146 6月  11 16:53 zookeeper-1\n  drwxr-xr-x. 7 root root 146 6月  11 16:53 zookeeper-2\n  drwxr-xr-x. 7 root root 146 6月  11 16:53 zookeeper-3\n  # 三个zookeeper为一模一样的zookeeper加压后的文件。\n  ```\n\n* 修改配置文件\n\n  * 第一步：在三个zookeeper目录下分别创建data目录\n\n  ```shell\n  [root@localhost zookeeper-cluster]# mkdir zookeeper-1/data\n  [root@localhost zookeeper-cluster]# mkdir zookeeper-2/data\n  [root@localhost zookeeper-cluster]# mkdir zookeeper-3/data\n  ```\n\n  * 第二步：修改三个zookeeper配置文件的数据目录为data所在目录，\n    * 配置文件名都为zoo.cfg\n    * 并修改端口号分别2181，2182，2183.\n\n  ```markdown\n  [root@localhost zookeeper-cluster]# vi zookeeper-1/conf/zoo.cfg \n  \tdataDir=/opt/zookeeper-cluster/zookeeper-1/data\n  \tclientPort=2181\n  [root@localhost zookeeper-cluster]# vi zookeeper-2/conf/zoo.cfg \n  \tdataDir=/opt/zookeeper-cluster/zookeeper-2/data\n  \tclientPort=2182\n  [root@localhost zookeeper-cluster]# vi zookeeper-3/conf/zoo.cfg \n  \tdataDir=/opt/zookeeper-cluster/zookeeper-3/data\n  \tclientPort=2183\n  ```\n\n* 配置集群\n\n  * 在每个zookeeper的 data 目录下创建一个 myid 文件，内容分别是1、2、3 。这个文件就是记录每个服务器的ID\n\n  ```shell\n  [root@localhost zookeeper-cluster]# echo 1 >/opt/zookeeper-cluster/zookeeper-1/data/myid\n  [root@localhost zookeeper-cluster]# echo 2 >/opt/zookeeper-cluster/zookeeper-2/data/myid\n  [root@localhost zookeeper-cluster]# echo 3 >/opt/zookeeper-cluster/zookeeper-3/data/myid\n  [root@localhost zookeeper-cluster]# cat zookeeper-1/data/myid\n  1\n  ```\n\n  * 在每一个zookeeper 的 zoo.cfg配置客户端访问端口（clientPort）和集群服务器IP列表。\n\n    集群服务器IP列表如下\n\n  ```markdown\n  [root@localhost zookeeper-cluster]# vi zookeeper-1/conf/zoo.cfg \n  [root@localhost zookeeper-cluster]# vi zookeeper-2/conf/zoo.cfg \n  [root@localhost zookeeper-cluster]# vi zookeeper-3/conf/zoo.cfg\n  \n  都在文件最后加上下面的内容\n  \tserver.1=192.168.56.120:2881:3881\n  \tserver.2=192.168.56.120:2882:3882\n  \tserver.3=192.168.56.120:2883:3883\n  ```\n\n  * 说明：server.服务器ID=服务器IP地址：服务器之间通信端口：服务器之间投票选举端口\n\n* 启动集群\n\n  ```shell\n  [root@localhost zookeeper-cluster]# zookeeper-1/bin/zkServer.sh start\n  [root@localhost zookeeper-cluster]# zookeeper-2/bin/zkServer.sh start\n  [root@localhost zookeeper-cluster]# zookeeper-3/bin/zkServer.sh start\n  ```\n\n* 查看集群\n\n  ```shell\n  [root@localhost zookeeper-cluster]# zookeeper-2/bin/zkServer.sh status\n    /usr/bin/java\n    ZooKeeper JMX enabled by default\n    Using config: /opt/zookeeper-cluster/zookeeper-2/bin/../conf/zoo.cfg\n    Client port found: 2182. Client address: localhost.\n    Mode: follower (跟随着/从)\n  [root@localhost zookeeper-cluster]# zookeeper-3/bin/zkServer.sh status\n    /usr/bin/java\n    ZooKeeper JMX enabled by default\n    Using config: /opt/zookeeper-cluster/zookeeper-3/bin/../conf/zoo.cfg\n    Client port found: 2183. Client address: localhost.\n    Mode: leader (领导者/主)\n  [root@localhost zookeeper-cluster]# zookeeper-1/bin/zkServer.sh status\n    /usr/bin/java\n    ZooKeeper JMX enabled by default\n    Using config: /opt/zookeeper-cluster/zookeeper-1/bin/../conf/zoo.cfg\n    Client port found: 2181. Client address: localhost.\n    Mode: follower (跟随着/从)\n  ```\n\n* 集群宕机的特点：\n\n  * 当领导者产生后，再次有新服务器加入集群，不会影响到现任领导者。\n  * 当集群中的主服务器挂了，集群中的其他服务器会自动进行选举状态，然后产生新得leader \n  * 3个节点的集群，2个从服务器都挂掉，主服务器也无法运行。因为可运行的机器没有超过集群总数量的半数。\n\n\n\n#  Zookeeper 核心理论\n\n","categories":["Java学习","分布式技术"]},{"title":"RabbitMQ的学习","url":"/2021/06/06/尚硅谷说Java/中间件/RabbitMQ/","content":"\n* sss包含RabbitMQ的基本知识，以及五种模型的使用。\n* 与SpringBoot的集成使用。普通集群和镜像集群的搭建。\n\n<!--more-->\n\n# MQ的简介\n\n* MQ (Message Queue):翻译为消息队列通过典型的**生产者和消费者模型**,生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是**异步的**，而且只关心消息的发送和接收，**没有业务逻辑的侵入**,轻松的实现系统间解耦。\n* 别名为**消息中间件**通过利用高效可靠的消息传递机制进行平台无关的数据交流， 并基于数据通信来进行分布式系统的集成。\n* 当今市面上有很多主流的消息中间件，如老牌的**ActiveMQ**、**RabbitMQ** , 炙手可热的**Kafka**，阿里巴巴自主开发**RocketMQ**等。\n* ActiveMQ：\n  * ActiveMQ是Apache出品， 最流行的，能力强劲的开源消息总线。它是一个完全支持JMS规范的的消息中间件。丰富的API,多种集群架构模式让ActiveMQ在业界成为老牌的消息中间件在中小型企业颇受欢迎!\n* Kafka：\n  * Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pul1的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。\n* RocketMQ：\n  * RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。\n  * RocketMQ思路起源于Kafka,但并不是Kafka的一个Copy,它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、*binglog*分发等场景。\n* RabbitMQ：\n  * RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于*AMQP*协议来实现。\n  * *AMQP*的主要特征是面向消息、队列、路由(包括点对点和发布/订阅)、可靠性、安全。*AMQP*协议更多用在企业系统内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。\n* 总结：\n  * RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性(少量延迟)，可靠性(少量丢数据)要求稍低的场景使用，比如ELK日志收集。\n\n\n\n# RabbitMQ的简介\n\n* 基于AMOP协议，Erlang语言开发， 是部署最广泛的开源消息中间件,是最受欢迎的开源消息中间件之一。\n\n* 特点：\n\n  * 基于AMQP协议，此协议支持很多种消息中间件，有多种业务场景，比如点对点，发布，广播等。\n  * 使用Erlang语言开发。此语言作为Socket编程的性能是非常不错的。\n  * RabbitMQ和Spring框架能够有很好的整合。\n  * 对于数据的一致性要求很多，能够达到几乎不丢失数据。能够恢复消息数据。\n\n* 官网：https://www.rabbitmq.com/\n\n* AMQP协议：\n\n  * AMQP (advanced message queuing prqtocol)在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。\n  * 顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol (链接协议)。 这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。\n  * 以下是AMQP协议模型:\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604213434.png)\n\n* AMQP模型说明：\n\n  * 生产者和消费者之间没有任何通信，通过Server进行间接通信。\n  * 生产者先把消息发送到虚拟主机的交换机中。\n  * 消费者从消息队列中消费消息。\n  * 交换机和消费队列之间有很多种绑定形式。\n\n\n\n## RabbitMQ的安装\n\n* 虚拟机的安装\n\n* 第一步：下载RabbitMQ和erlang的依赖。\n\n  * 下载地址：https://plumriver.lanzoui.com/b01cetjfg 密码:9uee\n\n* 第二步：将下载的文件传输到虚拟机上。\n\n* 第三步：安装RabbitMQ和erlang。\n\n  ```shell\n  [root@localhost src]# ls\n  debug                           kernels                                  socat-1.7.3.2-2.el7.x86_64.rpm\n  erlang-22.0.7-1.el7.x86_64.rpm  rabbitmq-server-3.7.18-1.el7.noarch.rpm\n  [root@localhost src]# rpm -ivh erlang-22.0.7-1.el7.x86_64.rpm \n  [root@localhost src]# rpm -ivh socat-1.7.3.2-2.el7.x86_64.rpm \n  [root@localhost src]# rpm -ivh rabbitmq-server-3.7.18-1.el7.noarch.rpm\n  ```\n\n  * 安装后配置文件在/etc/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.exaplie目录中。\n  * 需要把配置文件复制到/etc/rabbitmq/目录中，把那个修改名称为rabbitmq.config\n\n* 第四步：复制配置文件。\n\n  ```shell\n  [root@localhost /]# cp /usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config\n  [root@localhost /]# cd /etc/rabbitmq/\n  [root@localhost rabbitmq]# ls\n  rabbitmq.config\n  ```\n\n* 第五步：修改配置文件。\n\n  * 去掉前面的%,和后面的逗号。\n\n  ```config\n  {loopback_users, []}\n  ```\n\n  * 作用：打开后台管理页面的登录权限。\n\n* 第六步：启动RabbitMQ的插件管理。\n\n  ```shell\n  [root@localhost /]# rabbitmq-plugins enable rabbitmq_management\n  Enabling plugins on node rabbit@localhost:\n  rabbitmq_management\n  The following plugins have been configured:\n    rabbitmq_management\n    rabbitmq_management_agent\n    rabbitmq_web_dispatch\n  Applying plugin configuration to rabbit@localhost...\n  The following plugins have been enabled:\n    rabbitmq_management\n    rabbitmq_management_agent\n    rabbitmq_web_dispatch\n  set 3 plugins.\n  Offline change; changes will take effect at broker restart.\n  ```\n\n* 第七步：启动RabbitMQ的服务。\n\n  ```shell\n  # 启动rabbitmq服务\n  systemctl start rabbitmq-server\n  # 查看rabbitmq服务的状态\n  systemctl status rabbitmq-server\n  # 重启rabbitmq服务\n  systemctl restart rabbitmq-server\n  # 关闭rabbitmq服务\n  systemctl stop rabbitmq-server\n  ```\n\n* 第八步：关闭防火墙服务\n\n  ```shell\n  systemctl disable firewalld\n  systemctl stop firewalld\n  ```\n\n* 第九步：访问RabbitMQ的web管理界面\n\n  * 地址：虚拟机ip+**15672**端口号\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604225851.png)\n\n  * 默认账号密码：guest\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605153314.png)\n\n\n\n\n# RabbitMQ的使用方式\n\n\n\n## 以命令行的方式\n\n```markdown\n# 1.服务启动相关。访问默认端口号为15672\n\tsystemctl start|restart|stop|status rabbitmq-server\n\n# 2.管理命令行  用来在不使用web管理界面情况下命令操作RabbitMQ\n\trabbitmqctl  help  可以查看更多命令\n\n# 3.插件管理命令行\n\trabbitmq-plugins enable|list|disable \n```\n\n* 一般情况下，很少使用命令行方式来操作RabbitMQ,一般使用后台管理界面的方式。\n\n\n\n## 以后台管理界面的方式\n\n* 页面介绍\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605153305.png)\n\n  * **connections**：无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况。\n  * **channels**：通道，建立连接后，会形成通道，消息的投递获取依赖通道。\n  * **Exchanges**：交换机，用来实现消息的路由。\n  * **Queues**：队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列。\n\n* Admin介绍：\n\n  * 当点击Admin时在其右边有一列\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605151200.png)\n\n* 添加用户操作：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605151505.png)\n\n  * 上面的Tags选项，其实是指定用户的角色，可选的有以下几个：\n\n    - `超级管理员(administrator)`\n\n      可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。\n\n    - `监控者(monitoring)`\n\n      可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)\n\n    - `策略制定者(policymaker)`\n\n      可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。\n\n    - `普通管理者(management)`\n\n      仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。\n\n    - `其他`\n\n      无法登陆管理控制台，通常就是普通的生产者和消费者。\n\n* 创建虚拟主机：\n\n  * 为了让**各个用户可以互不干扰的工作**，RabbitMQ添加了虚拟主机（Virtual Hosts）的概念。其实就是一个**独立的访问路径**，不同用户使用不同路径，各自有自己的队列、交换机，互相不会影响。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605151749.png)\n\n  * 添加的虚拟主机默认绑定超级管理员，想要将其与其他用户绑定，想要手动操作。\n\n* 绑定虚拟主机和用户：\n\n  * 第一步：点击添加好的虚拟主机，进入设置页面。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605152919.png)\n\n  * 第二步：绑定即可。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605152847.png)\n\n* 交换机协议：\n\n  * 默认支持其中交换机协议。也可以自定义交换机。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605153256.png)\n\n* 端口说明：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605161001.png)\n\n\n\n# 使用RabbitMQ\n\n* AMQP协议的回顾：\n\n  * 首先一个虚拟主机对应一个生产者。\n  * 生产者往虚拟主机的交换机中发送消息。\n  * 消费者想要获取消息，想要先绑定这个虚拟主机，然后从消息队列中获取。\n  * 交换机和消息队列之间的规则有很多种，称为消息模型。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605154212.png)\n\n* 消息模型的种类七种：\n\n  * 版本不同，支持的消息模型也不同。\n  * 具体信息可以去官网上查看：https://www.rabbitmq.com/getstarted.html\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605155800.png)\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605154853.png)\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605154857.png)\n\n* 在1，2两种模型中，生产者是直接将消息发送到消息队列中的。\n\n* 在3，4，5模型中，生产者是将消息发送到交换机x中的。\n\n# 模型实例\n\n* 准备工作：\n\n  * 第一步：创建一个maven版的web工程。\n  * 第二步：引入下面依赖。\n\n  ```xml\n  <dependency>\n      <groupId>com.rabbitmq</groupId>\n      <artifactId>amqp-client</artifactId>\n      <version>5.7.2</version>\n  </dependency>\n  ```\n\n  * 第三步：在rabbitmq的管理界面创建生产者和虚拟主机。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605160606.png)\n\n\n\n## 直连模型\n\n* 模型图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605161107.png)\n\n* 说明：\n\n  * P：生产者，也就是要发送消息的程序\n  * C：消费者：消息的接受者，会一直等待消息到来。\n  * queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。\n\n* 开发生产者：\n\n  ```java\n  import com.rabbitmq.client.Channel;\n  import com.rabbitmq.client.Connection;\n  import com.rabbitmq.client.ConnectionFactory;\n  import org.junit.Test;\n  public class Provider {\n    @Test\n    public void testSendMessage() throws Exception{\n      //创建连接工厂\n      ConnectionFactory factory = new ConnectionFactory();\n      //设置rabbitmq的主机IP\n      factory.setHost(\"192.168.56.110\");\n      //设置端口号\n      factory.setPort(5672);\n      //设置连接的虚拟主机\n      factory.setVirtualHost(\"/ems\");\n      //设置生产者用户的名字和密码\n      factory.setUsername(\"ems\");\n      factory.setPassword(\"123\");\n      //获取连接对象，即生产者和AMQP服务的连接\n      Connection connection = factory.newConnection();\n      //获取连接对象的通道，通道用于传递消息。\n      Channel channel = connection.createChannel();\n      //将通道与消息队列进行绑定\n      /**\n       * String queue：队列名称，如果队列不存在则创建队列。\n       * boolean durable：定义队列是否持久化。\n       * boolean exclusive：定义队列是否为独占的，即只有当前连接使用此队列\n       * boolean autoDelete：定义消费者在消费完队列，且与队列断开连接后 是否自动删除队列。\n       * Map<String, Object> arguments：额外附加参数\n       */\n      channel.queueDeclare(\"directQueue\", false,false,false,null, );\n      //发布消息\n      /**\n       * String exchange：交换机名称\n       * String routingKey：消息队列名称\n       * BasicProperties props ：额外参数设置\n       * byte[] body：消息的具体信息\n       */\n      channel.basicPublish(\"\",\"directQueue\",null,\"hello rabbitmq\".getBytes());\n      //关闭通道和连接\n      channel.close();\n      connection.close();\n    }\n  }\n  ```\n\n  * 执行效果：在rabbitmq的管理页面的Queue中会发现出现了一个队列。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605163401.png)\n\n  * 说明：\n\n    * durable参数：只是设置队列是否持久化，而队列中的消息是否持久化并没有设置。\n      * 持久化是指在重启服务器后，这个队列还存不存在。\n    * 如果要设置队列中的消息持久化，则需要在发送消息时设置。\n\n    ```java\n    // 设置发送消息时的额外设置\n    // MessageProperties.PERSISTENT_TEXT_PLAIN：表示持久化此消息\n    channel.basicPublish(\"\",\"directQueue\", MessageProperties.PERSISTENT_TEXT_PLAIN,\"hello rabbitmq\".getBytes());\n    ```\n\n    * \n\n* 开发消费者：\n\n  ```java\n  import com.rabbitmq.client.*;\n  import java.io.IOException;\n  \n  public class Customer {\n  \n    public static void main(String[] args) throws Exception{\n      //创建连接工厂\n      ConnectionFactory factory = new ConnectionFactory();\n      factory.setHost(\"192.168.56.110\");\n      factory.setPort(5672);\n      factory.setVirtualHost(\"/ems\");\n      factory.setUsername(\"ems\");\n      factory.setPassword(\"123\");\n      Connection connection = factory.newConnection();\n      Channel channel = connection.createChannel();\n      // 要注意此处绑定的队列信息要和生产者绑定的队列信息相同。否则会报错\n      channel.queueDeclare(\"directQueue\", false,false,false,null );\n  \n      //消费消息\n      /**\n       * String queue：队列的名称\n       * boolean autoAck：是否开启消息的自动确认机制\n       * Consumer callback：获取消息后的回调接口。即获取消息后如何处理这个消息\n       */\n      channel.basicConsume(\"directQueue\",true,new DefaultConsumer(channel){\n        @Override\n        public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n          // 输出获取到的消息\n          System.out.println(\"Customer --- \" + new String(body));\n        }\n      });\n  \n      //关闭通道和连接。如果不关闭，则消费者会一直消费队列中的消息。\n  //    channel.close();\n  //    connection.close();\n    }\n  }\n  ```\n\n  * 由于消费者会在获取消息后使用子线程来处理消息，即回调接口，而Test运行后就会关掉主线程，子线程就无法运行了。所以不适用Test注解来测试消费者。\n  * 一般情况下不会关闭消费者的的通道。如果关闭通道的话，回调接口可能不被调用，但信息还是被消费了。\n\n* 工具类的创建：由于生产者和消费者有大量重复的代码，因此对冗余的代码进行封装。\n\n  ```java\n  public class RabbitMQUtils {\n    //重量级资源，一般使用静态代码块进行初始化\n    public static ConnectionFactory factory;\n  \n    static {\n      factory = new ConnectionFactory();\n      factory.setHost(\"192.168.56.110\");\n      factory.setPort(5672);\n      factory.setVirtualHost(\"/ems\");\n      factory.setUsername(\"ems\");\n      factory.setPassword(\"123\");\n    }\n  \n    //获取连接\n    public static Connection getConnection() {\n      try {\n        return factory.newConnection();\n      } catch (IOException e) {\n        e.printStackTrace();\n      } catch (TimeoutException e) {\n        e.printStackTrace();\n      }\n      return null;\n    }\n    //关闭资源\n    public static void closeResource(Connection connection, Channel channel){\n      try {\n        channel.close();\n        connection.close();\n      } catch (IOException e) {\n        e.printStackTrace();\n      } catch (TimeoutException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n  ```\n\n\n\n## work模型\n\n* `Work queues`也叫`Task queues`。\n\n* 当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用此模型：**让多个消费者绑定到一个队列，共同消费队列中的消息**。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605173352.png)\n\n* 角色：\n\n  - P：生产者：任务的发布者\n  - C1：消费者-1，领取任务并且完成任务。\n  - C2：消费者-2：领取任务并完成任务。\n\n* 消费者：\n\n  ```java\n  public class Provider {\n    public static void main(String[] args)throws Exception {\n      Connection connection = RabbitMQUtils.getConnection();\n      Channel channel = connection.createChannel();\n      channel.queueDeclare(\"fanoutQueue\", true,false ,false ,null );\n      for (int i = 0; i < 10; i++) {\n        channel.basicPublish(\"\", \"fanoutQueue\",null, (\"第\"+i+\"个消息\").getBytes());\n      }\n      RabbitMQUtils.closeResource(connection,channel);\n    }\n  }\n  ```\n\n* 生产者：\n\n  ```java\n  public class ConsumerA {\n    public static void main(String[] args) throws Exception{\n      Connection connection = RabbitMQUtils.getConnection();\n      Channel channel = connection.createChannel();\n      channel.queueDeclare(\"fanoutQueue\", true,false ,false ,null );\n      channel.basicConsume(\"fanoutQueue\", true, new DefaultConsumer(channel){\n        @Override\n        public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n          System.out.println(\"消费者A消费消息：\" + new String(body));\n        }\n      });\n    }\n  }\n  public class ConsumerB {\n    public static void main(String[] args) throws Exception{\n      Connection connection = RabbitMQUtils.getConnection();\n      Channel channel = connection.createChannel();\n      channel.queueDeclare(\"fanoutQueue\", true,false ,false ,null );\n      channel.basicConsume(\"fanoutQueue\", true, new DefaultConsumer(channel){\n        @Override\n        public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n          System.out.println(\"消费者B消费消息：\" + new String(body));\n        }\n      });\n    }\n  }\n  ```\n\n  * 测试发现：两个消费者总是交替消费消息。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606172032.png)\n\n* 总结：\n\n  * 默认情况下，RabbitMQ将按顺序将每个消息发送给下一个使用者。平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式称为循环。\n\n* 情况一：\n\n  * 问题：\n\n    * 在循环的机制下，如果一个消费者的消费速度较慢，另一个消费者的消费速度较快。则可能出现快消费者消费完信息后，慢消费者还在消费从消息队列中获取到的信息。\n    * 并且如果满消费者宕机了，由于消息已经分发给满消费者了，此时就会造成消息的丢失。\n    * 对于消费队列的消息，在通道中已经把此消息分发给哪个消费者做好的标记，即使消费者消费的慢，他也会把这个消息发给这个消费者。\n\n    ```java\n    //假设B消费速度较慢\n    public class ConsumerB {\n      public static void main(String[] args) throws Exception{\n        Connection connection = RabbitMQUtils.getConnection();\n        Channel channel = connection.createChannel();\n        channel.queueDeclare(\"fanoutQueue\", true,false ,false ,null );\n        channel.basicConsume(\"fanoutQueue\", true, new DefaultConsumer(channel){\n          @Override\n          public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n            System.out.println(\"消费者B消费消息：\" + new String(body));\n            try {\n              Thread.sleep(2000);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        });\n      }\n    }\n    ```\n\n  * 解决方法：\n\n    * 使用消费自动确认机制。\n\n* 消费自动确认机制：\n\n  * 即消费者消费消息时的第二个参数。boolean autoAck。\n  * 为true时：表示由rabbitmq自动分发消息，默认按照循环的方式分发。\n  * 为false时：表示由自定义的方式分发消息。\n\n* 解决循环产生的问题：\n\n  * 让通道一次只传输一个消息，当消费者消费完这个消息时在传输下一个。\n  * 让快消费者消费更多的消息。\n\n  ```java\n  //第一步：设置一次只接受一条消息\n  channel.basicQos(1);\n  //第二步：关闭自动确认参数。即第二个参数\n  channel.basicConsume(\"fanoutQueue\", false, new DefaultConsumer(channel){\n    @Override\n    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n      System.out.println(\"消费者B消费消息：\" + new String(body));\n      try {\n        Thread.sleep(2000);\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      }\n      //第三步：手动确认此消息已经消费完了。\n      //第一个参数表示这个消息的标签，第二个参数为false表示只确认当前的消息。\n      channel.basicAck(envelope.getDeliveryTag(), false);\n    }\n  });\n  ```\n\n\n\n## fanout模型\n\n* fanout：扇出 也称为广播。\n\n* 模型图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605195821.png)\n\n* 在广播模式下，消息发送流程是这样的：\n\n  -  可以有多个消费者\n  -  每个**消费者有自己的queue**（队列）\n  -  每个**队列都要绑定到Exchange**（交换机）\n  -  **生产者发送的消息，只能发送到交换机**，交换机来决定要发给哪个队列，生产者无法决定。\n  -  交换机把消息发送给绑定过的所有队列\n  -  队列的消费者都能拿到消息。实现**一条消息被多个消费者消费**。\n\n* 生产者：\n\n  ```java\n  public class Provider {\n    public static void main(String[] args) throws Exception{\n      //获取通道\n      Connection connection = RabbitMQUtils.getConnection();\n      Channel channel = connection.createChannel();\n      //声明交换机\n      //第一个参数：交换机的名字。第二个参数：交换机的类型，在广播模型中交换机的类型只能是fanout\n      channel.exchangeDeclare(\"exchange\", \"fanout\");\n      //发送消息\n      // 在生产者这里，不需要绑定任何消息队列，因此第二个参数没有值即可\n      channel.basicPublish(\"exchange\",\"\",null,\"hello exchange\".getBytes());\n      //关闭资源\n      RabbitMQUtils.closeResource(connection,channel);\n    }\n  }\n  ```\n\n* 消费者：\n\n  ```java\n  public class ConsumerA {\n    public static void main(String[] args) throws Exception{\n      Connection connection = RabbitMQUtils.getConnection();\n      Channel channel = connection.createChannel();\n      //绑定交换机\n      channel.exchangeDeclare(\"exchange\",\"fanout\");\n      //创建临时队列\n      String queueName = channel.queueDeclare().getQueue();\n      //将临时队列与交换机进行绑定\n      channel.queueBind(queueName,\"exchange\",\"\");\n      //消费消息\n      channel.basicConsume(queueName,true,new DefaultConsumer(channel){\n        @Override\n        public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n  \n          System.out.println(\"消费者A：\" + new String(body));\n        }\n      });\n    }\n  }\n  ```\n\n* 测试结果：\n\n  * 生产者发送消息后，消费者们都能接收到消息。\n  * 在rabbitmq的后台管理界面中，出现了新的交换机，但没有出现新的消息队列。\n\n\n\n## Routing模型\n\n* Routing模型有两种，一种是直连式的，一种是动态式的。\n\n\n\n### 直连式Routing模型\n\n* 出现的原因：在Fanout(广播)模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。\n\n* 也被称为**订阅模型**。\n\n* 在Direct模型下：\n\n  - 队列与交换机的绑定，不能是任意绑定了，而是要指定一个`RoutingKey`（路由key）\n  - 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 `RoutingKey`。\n  - Exchange不再把消息交给每一个绑定的队列，而是根据消息的`Routing Key`进行判断，只有队列的`Routingkey`与消息的 `Routing key`完全一致，才会接收到消息。\n\n* 与广播模型的区别在于，消息的发送和接收多了一层Routing key的加密，只有具有相同Routing key的才能完成发送接收。\n\n* 模型图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605204315.png)\n\n* 说明：\n\n  * P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。\n  * X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列\n  * C1：消费者，其所在队列指定了需要routing key 为 error 的消息。\n  * C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息。\n  * 图示的样例为日志的信息处理，c2相当于控制台接受全部信息。c1相当于日志的持久化操作，只持久化错误信息。\n  * 这样既可以看到完整的日志，又可以节省磁盘空间。\n\n* 生产者：\n\n  ```java\n  public class Provider {\n    public static void main(String[] args) throws Exception{\n      Connection connection = RabbitMQUtils.getConnection();\n      Channel channel = connection.createChannel();\n      //声明交换机。类型为direct\n      String exchange = \"directExchange\";\n      channel.exchangeDeclare(exchange, \"direct\");\n      //发送消息\n      String routeKey = \"warning\";\n      String message = \"生产者发送key为[\"+routeKey+\"]的消息\";\n      channel.basicPublish(exchange, routeKey,null,message.getBytes());\n      System.out.println(message);\n      //关闭资源\n      RabbitMQUtils.closeResource(connection,channel);\n    }\n  }\n  ```\n\n* 消费者A：\n\n  ```java\n  public class ConsumerA {\n    public static void main(String[] args) throws IOException {\n      Connection connection = RabbitMQUtils.getConnection();\n      Channel channel = connection.createChannel();\n  \n      String exchange = \"directExchange\";\n      channel.exchangeDeclare(exchange,\"direct\");\n      String queue = channel.queueDeclare().getQueue();\n      // 以key(error)绑定队列和交换机\n      channel.queueBind(queue,exchange,\"error\");\n      channel.basicConsume(queue,true,new DefaultConsumer(channel){\n        @Override\n        public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n          System.out.println(\"消费者A：\" + new String(body));\n        }\n      });\n    }\n  }\n  ```\n\n* 消费者B：\n\n  ```java\n  public class ConsumerB {\n    public static void main(String[] args) throws IOException {\n      Connection connection = RabbitMQUtils.getConnection();\n      Channel channel = connection.createChannel();\n      String exchange = \"directExchange\";\n      channel.exchangeDeclare(exchange,\"direct\");\n      String queue = channel.queueDeclare().getQueue();\n      // 以key(error,info,warning)绑定队列和交换机\n      channel.queueBind(queue,exchange,\"error\");\n      channel.queueBind(queue,exchange,\"info\");\n      channel.queueBind(queue,exchange,\"warning\");\n      channel.basicConsume(queue,true,new DefaultConsumer(channel){\n        @Override\n        public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n          System.out.println(\"消费者B：\" + new String(body));\n        }\n      });\n    }\n  }\n  ```\n\n* 测试：\n\n  * 发送一条error信息和一条warning信息的结果\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605211830.png)\n\n\n\n### 动态式Routing模型\n\n* `Topic`类型的`Exchange`与`Direct`相比，都是可以根据`RoutingKey`把消息路由到不同的队列。只不过`Topic`类型`Exchange`可以让队列在绑定`Routing key` 的时候**使用通配符**！这种模型`Routingkey` 一般都是由一个或多个单词组成，多个单词之间以”.”分割，例如： `item.insert`\n\n* 即Routing key是模糊的，可以产生动态的效果。\n\n* 模型图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605204645.png)\n\n* 通配符的说明：\n\n  ```markdown\n  # 统配符\n  \t\t* (star) can substitute for exactly one word.    匹配不多不少恰好1个词\n  \t\t# (hash) can substitute for zero or more words.  匹配0或多个词\n  # 如:\n  \t\taudit.#    匹配audit.irs.corporate或者 audit.irs 等\n      audit.*   只能匹配 audit.irs\n  ```\n\n* 生产者：\n\n  ```java\n  public class Provider {\n    public static void main(String[] args) throws Exception{\n      Connection connection = RabbitMQUtils.getConnection();\n      Channel channel = connection.createChannel();\n      //声明交换机。类型为topic\n      String exchange = \"topicExchange\";\n      channel.exchangeDeclare(exchange, \"topic\");\n      //发送消息\n      String routeKey = \"user.save.name\";\n      String message = \"生产者发送key为[\"+routeKey+\"]的消息\";\n      channel.basicPublish(exchange, routeKey,null,message.getBytes());\n      System.out.println(message);\n      //关闭资源\n      RabbitMQUtils.closeResource(connection,channel);\n    }\n  }\n  ```\n\n* 消费者A：\n\n  ```java\n  String exchange = \"topicExchange\";\n  channel.exchangeDeclare(exchange, \"topic\");\n  String queue = channel.queueDeclare().getQueue();\n  // 以key(user.#)绑定队列和交换机。user.#：表示接收以user.开头的所有key的消息\n  channel.queueBind(queue, exchange, \"user.#\");\n  ```\n\n* 消费者B：\n\n  ```java\n  String exchange = \"topicExchange\";\n  channel.exchangeDeclare(exchange,\"topic\");\n  String queue = channel.queueDeclare().getQueue();\n  // 以key(user.*)绑定队列和交换机 。user.* 表示key为两个单词，且第一个单词是user的key\n  channel.queueBind(queue,exchange,\"user.*\");\n  ```\n\n* 测试：\n\n  * 在发送key为user.save和user.save.name后的结果。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606120304.png)\n\n\n\n## 模型的总结\n\n* 前面的五种模型可以分为两种：带交换机和不带交换机的。\n* 不带交换机：比如直连模型和任务模型。\n  * 其默认也是带交换机的，不过交换机是隐藏的。\n  * 默认的犯法策略是循环均匀分配。\n  * 当一个队列只对应一个消费者时，被简称为直连模型。\n  * 当一个队列对应多个消费者时，又加上自动确认机制，此时被称为任务模型。\n* 带交换机：比如广播模型和路由模型。\n  * 广播模型类似于任务模型，不同之处在于交换机类型不一致，且分发机制不一样，广播是每个都分发。\n  * 广播模型中，由于信息是分发给所有消费者的，所以消息队列可以不创建或使用临时的。\n  * 路由模型在广播模型的基础上添加了一层身份验证。\n    * 分发机制可能还是广播的机制，但消费者的接受机制可能只接收身份验证通过的消息。\n    * 或者在分发时只发给身份验证通过的消费者。\n  * 动态路由模型是在订阅模型的基础上对身份验证信息进行了模糊化，采了通配符的方式。\n* 前面五种模型只是用到了三种交换机：direct,fanout,topic\n\n\n\n# SpringBoot集成RabbitMQ\n\n* 准备工作：\n\n  * 创建springboot项目，\n  * 选择web支持和amqp支持。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606140133.png)\n\n  * 或者不选择amqp支持而是手动添加依赖。\n\n  ```xml\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n  </dependency>\n  ```\n\n* 基础配置文件：\n\n  ```properties\n  # 这个名字在微服务时有用\n  spring.application.name=springboot-rabbitmq\n  spring.rabbitmq.host=192.168.56.110\n  spring.rabbitmq.port=5672\n  spring.rabbitmq.username=ems\n  spring.rabbitmq.password=123\n  spring.rabbitmq.virtual-host=/ems\n  ```\n\n* RabbitTemplate 是Spring中对RabbitMQ操作的模板对象。\n\n* RabbitTemplate 用来简化操作 ，使用时候直接在项目中注入即可使用。\n\n* RabbitTemplate 类似于JDBCtemplate。\n\n\n\n## 直连式模型\n\n* 生产者\n\n  * 注意：如果单独执行生产者的代码，是不会创建队列的。\n\n  ```java\n  @Autowired\n  private RabbitTemplate rabbitTemplate;\n  @Test\n  public void testDirectQueue(){\n    //发送消息，\n    //第一个参数为队列的名称\n    rabbitTemplate.convertAndSend(\"directQueue\",\"hello springboot rabbitmq\");\n  }\n  ```\n\n* 消费者\n\n  ```java\n  @Component\n  @RabbitListener(\n      queuesToDeclare =\n      @Queue(value = \"directQueue\",\n          durable = \"false\",\n          autoDelete = \"false\"))\n  public class DirectQueueConsumer {\n    // 消费者的回调函数：即对消息的具体处理逻辑。\n    // 方法名自定义，没有要求\n    @RabbitHandler\n    public void receivel(String message) {\n      System.out.println(\"直连模型之消费者：\" + message);\n    }\n  }\n  ```\n\n* 测试\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606144736.png)\n\n\n\n## 任务模型\n\n* 生产者\n\n  ```java\n  @Test\n  public void testWork(){\n    for (int i = 0; i < 10; i++) {\n      rabbitTemplate.convertAndSend(\"workQueue\",\"hello task model = \" + i);\n    }\n  }\n  ```\n\n* 消费者\n\n  ```java\n  @Component\n  public class WorkConsumerA {\n    // RabbitListener直接加在方法上，表示当前方法就是处理消息的方法\n    @RabbitListener(queuesToDeclare = @Queue(\"workQueue\"))\n    public void receivel(String message){\n      System.out.println(\"任务模型之消费者A：\" + message);\n    }\n  }\n  @Component\n  @RabbitListener(queuesToDeclare = @Queue(\"workQueue\"))\n  public class WorkConsumerB {\n    @RabbitHandler\n    public void receivel(String message){\n      System.out.println(\"任务模型之消费者B：\" + message);\n    }\n  }\n  ```\n\n  * 也可以在一个类中定义多个方法，方法上都添加@RabbitListener注解，则每个方法表示一个消费者。\n\n* 测试：\n\n  * 默认在Spring AMQP实现中Work这种方式就是公平调度,如果需要实现能者多劳需要额外配置。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606145215.png)\n\n\n\n## 广播式模型\n\n* 生产者\n\n  ```java\n  @Test\n  public void testFanout(){\n    //第一个参数表示交换机的名称，\n    rabbitTemplate.convertAndSend(\"logs\",\"\",\"hello fanout model\");\n  }\n  ```\n\n* 消费者\n\n  ```java\n  @Component\n  public class FanoutConsumer {\n    @RabbitListener(bindings = @QueueBinding(\n      value = @Queue(),  //不指定队列的名字，表示创建临时队列\n      exchange = @Exchange(name = \"logs\",type = \"fanout\")\n    ))\n    public void receivel1(String message){\n      System.out.println(\"广播模型之消费者A：\" + message);\n    }\n    @RabbitListener(bindings = @QueueBinding(\n      value = @Queue(),\n      exchange = @Exchange(name = \"logs\",type = \"fanout\")\n    ))\n    public void receivel2(String message){\n      System.out.println(\"广播模型之消费者B：\" + message);\n    }\n  }\n  ```\n\n* 测试：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606150232.png)\n\n\n\n## 直连路由模型\n\n* 生产者\n\n  ```java\n  @Test\n  public void testDirectRoute(){\n    rabbitTemplate.convertAndSend(\"directLog\",\"error\",\"error message\");\n    rabbitTemplate.convertAndSend(\"directLog\",\"waning\",\"waning message\");\n    rabbitTemplate.convertAndSend(\"directLog\",\"info\",\"info message\");\n  }\n  ```\n\n* 消费者\n\n  ```java\n  @Component\n  public class DirectRouteConsumer {\n    @RabbitListener(bindings = @QueueBinding(\n        value = @Queue(),\n        exchange = @Exchange(name = \"directLog\", type = \"direct\"),\n        key = {\"error\", \"waning\", \"info\"}\n    ))\n    public void receivel1(String message) {\n      System.out.println(\"订阅模型之消费者A：\" + message);\n    }\n  \n    @RabbitListener(bindings = @QueueBinding(\n        value = @Queue(),\n        exchange = @Exchange(name = \"directLog\", type = \"direct\"),\n        key = {\"error\"}\n    ))\n    public void receivel2(String message) {\n      System.out.println(\"订阅模型之消费者B：\" + message);\n    }\n  }\n  ```\n\n* 测试：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606151345.png)\n\n\n\n## 动态路由模型\n\n* 生产者\n\n  ```java\n    @Test\n    public void testTopicRoute(){\n      rabbitTemplate.convertAndSend(\"topicLog\",\"log.error\",\"log.error message\");\n      rabbitTemplate.convertAndSend(\"topicLog\",\"log.waning.info\",\"log.waning.info message\");\n      rabbitTemplate.convertAndSend(\"topicLog\",\"log\",\"log message\");\n    }\n  ```\n\n* 消费者\n\n  ```java\n  @Component\n  public class TopicRouteConsumer {\n    @RabbitListener(bindings = @QueueBinding(\n        value = @Queue(),\n        exchange = @Exchange(name = \"topicLog\", type = \"topic\"),\n        key = {\"log.*\"}\n    ))\n    public void receivel1(String message) {\n      System.out.println(\"订阅模型之消费者A：\" + message);\n    }\n  \n    @RabbitListener(bindings = @QueueBinding(\n        value = @Queue(),\n        exchange = @Exchange(name = \"topicLog\", type = \"topic\"),\n        key = {\"log.#\"}\n    ))\n    public void receivel2(String message) {\n      System.out.println(\"订阅模型之消费者B：\" + message);\n    }\n  }\n  ```\n\n* 测试：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606152230.png)\n\n\n\n# MQ的常用场景\n\n\n\n## 异步处理\n\n* 场景说明：用户注册后，需要发注册邮件和注册短信,传统的做法有两种 1.串行的方式 2.并行的方式\n\n* `串行方式:` 将注册信息写入数据库后,发送注册邮件,再发送注册短信,以上三个任务全部完成后才返回给客户端。 这有一个问题是,邮件,短信并不是必须的,它只是一个通知,而这种做法让客户端等待没有必要等待的东西. \n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153236.png)\n\n* `并行方式: `将注册信息写入数据库后,发送邮件的同时,发送短信,以上三个任务完成后,返回给客户端,并行的方式能提高处理的时间。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153249.png)\n\n* `消息队列:`假设三个业务节点分别使用50ms,串行方式使用时间150ms,并行使用时间100ms。虽然并行已经提高的处理时间,但是,前面说过,邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功,应该是写入数据库后就返回.  `消息队列`: 引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理 \n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153246.png)\n\n* 由此可以看出,引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计),引入消息队列后处理后,响应时间是串行的3倍,是并行的2倍。\n\n\n\n## 应用解耦\n\n* 场景：双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口. \n\n* 传统做法：当库存系统出现故障时,订单就会失败。 订单系统和库存系统高耦合。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153150.png)\n\n* 消息队列 ：\n\n  * `订单系统:`用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。\n  * `库存系统:`订阅下单的消息,获取下单消息,进行库操作。  就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153141.png)\n\n\n\n## 流量削峰\n\n* 场景:秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。\n\n*   `作用:` \n\n  * 1.可以控制活动人数，超过此一定阀值的订单直接丢弃。\n  * 2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单) 。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153047.png)\n\n* 具体实现：\n\n  * 1.用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面。  \n  * 2.秒杀业务根据消息队列中的请求信息，再做后续处理。\n\n# RabbitMQ的集群\n\n\n\n## 普通集群\n\n* 架构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153930.png)\n\n* 默认情况下:RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是消息队列，默认情况下，消息队列位于一个节点上，尽管它们可以从所有节点看到和访问。\n\n  * 即在`从服务器`中备份了`主服务器`的所有数据，但是消息队列的数据不备份。\n  * 但是消费者可以通过`从服务器`访问到消息队列的数据，因此`从服务器`会访问`主服务器`的消息队列。\n\n* **产生的问题**：当集群中某一时刻master节点宕机,可以对Quene中信息,进行备份\n\n* 集群的搭建：\n\n  * 准备工作：能够正常启动rabbitmq的三台服务器。\n\n  * 第一步：集群规划\n\n    ```markdown\n    \t\t\t\t\t\t\t\t     集群名字\n    node1: 192.168.56.110  mq1  master 主节点\n    node2: 192.168.56.111  mq2  repl1  副本节点\n    node3: 192.168.56.112  mq3  repl2  副本节点\n    ```\n\n  * 第二步：修改虚拟机的主机名和ip映射：\n\n    * 第二步的作用是方便在三台虚拟机之间互相传递文件，安装rabbitmq。\n\n    ```markdown\n    # 修改主机名，三台机器各加各的，修改后重启服务器\n    node1: vim /etc/hostname 加入:  mq1\n    node2: vim /etc/hostname 加入:  mq2\n    node3: vim /etc/hostname 加入:  mq3\n    # 修改主机名的后果，三台服务器的命令行都变成了下述所示：\n    [root@mq1 ~]# \n    [root@mq2 ~]# \n    [root@mq3 ~]# \n    # 修改ip映射。下面的内容要添加在每一个服务器上。因此可以使用xshell的发送到所有会话功能操作\n    [root@mq1 ~]# cd /\n    [root@mq1 /]# vi /etc/hosts\n    10.15.0.3 mq1\n    10.15.0.4 mq2\n    10.15.0.5 mq3\n    ```\n\n  * 第三步：三台机器都启动rabbitmq的插件和服务\n\n    ```markdown\n    rabbitmq-plugins enable rabbitmq_management\n    systemsctl start rabbitmq-server\n    ```\n\n  * 第四步：同步三台机器的cookie文件。\n\n    ```markdown\n    # 因为在第一二步设置了主机名和IP映射，因此可以使用scp命令将主机mq1的cookie传输到mq2,mq3\n    # 传输前，先关闭三台服务器的rabbitmq-server的服务\n    scp /var/lib/rabbitmq/.erlang.cookie root@mq2:/var/lib/rabbitmq/\n    scp /var/lib/rabbitmq/.erlang.cookie root@mq3:/var/lib/rabbitmq/\n    # 查看cookie文件内容\n    [root@mq3 /]# cat /var/lib/rabbitmq/.erlang.cookie\n    ```\n\n  * 第五步：使用后台启动方式启动rabbitmq的服务。三个都启动\n\n    ```markdown\n    rabbitmq-server -detached\n    # 此方式启动后，无法查看后台界面。因此使用下列命令查看服务是否启动成功了\n    rabbitmqctl cluster_status\n    # 可看到显示的信息中 running node 后面显示的是当前的服务器\n    ```\n\n  * 第六步：将mq2和mq3加入以mq1为主的集群中。mq1不执行，mq2,mq3执行下列命令。\n\n    ```markdown\n    # 此时mq1,mq2,mq3服务都启动\n    # 关闭程序\n    rabbitmqctl stop_app\n    # 加入集群。此时的rabbit@是写死的，后面跟的是主机名，不能是主机ip。\n    rabbitmqctl join_cluster rabbit@mq1\n    # 启动服务\n    rabbitmqctl start_app\n    # 此时可以通过后台界面查看三个rabbitmq的状态。\n    ```\n\n  * 第七步：查看集群状态。在那个节点执行都行。\n\n    ```markdown\n    rabbitmqctl cluster_status\n    # 显示下列信息\n    Cluster status of node rabbit@mq3 ...\n    [{nodes,[{disc,[rabbit@mq1,rabbit@mq2,rabbit@mq3]}]},\n    {running_nodes,[rabbit@mq2,rabbit@mq1,rabbit@mq3]},\n    {cluster_name,<<\"rabbit@mq1\">>},\n    {partitions,[]},\n    {alarms,[{rabbit@mq2,[]},{rabbit@mq1,[]},{rabbit@mq3,[]}]}]\n    ```\n\n* 测试：\n\n  * 在主服务器上创建一个队列，并往队列中生产一个消息，会发现另外两个接待你也能看到这个队列。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606165116.png)\n\n  * 关闭主服务器：执行rabbitmqctl stop_app。\n  * 此时查看从节点的界面发现，消息丢失了。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606165129.png)\n\n* 如果主节点又重启了。此时分为两种情况：\n\n  * 如果消息持久化了，则能正常的访问到这个消息，\n  * 如果消息没有持久化，则无法获取到这个消息。\n\n\n\n## 镜像集群\n\n* 镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间进行自动同步，且如果其中一个节点不可用，并不会导致消息丢失或服务不可用的情况，提升MQ集群的整体高可用性。\n\n  * 能够解决普通集群存在的问题。\n\n* 镜像集群是在普通集群的基础上进行搭建的。\n\n* 架构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606154621.png)\n\n* 集群的搭建：\n\n  * 在普通集群中设置策略即可变成镜像集群\n\n  ```markdown\n  # 0.策略说明\n  \trabbitmqctl set_policy [-p <vhost>] [--priority <priority>] [--apply-to <apply-to>] <name> <pattern>  <definition>\n  \t-p Vhost： 可选参数，针对指定虚拟主机下的queue进行设置\n  \tName:     policy的名称\n  \tPattern: queue的匹配模式(正则表达式)\n  \tDefinition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode\n             \t\tha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes\n                        all：表示在集群中所有的节点上进行镜像\n                        exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定\n                        nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定\n              \tha-params：ha-mode模式需要用到的参数\n                ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual(手动)\n                priority：可选参数，policy的优先级，数字越大优先级越高   \n  # 1.查看当前策略\n  \trabbitmqctl list_policies\n  \n  # 2.添加策略\n  \trabbitmqctl set_policy ha-all '^hello' '{\"ha-mode\":\"all\",\"ha-sync-mode\":\"automatic\"}' \n  \t说明:策略正则表达式为 “^” 表示所有匹配所有队列名称  ^hello:匹配hello开头队列，\n  \t    将所有服务器都进行镜像，队列的消息同步方式为自动\n  # 3.删除策略\n  \trabbitmqctl clear_policy ha-all\n  \tha-all ：表示策略名\n  ```\n\n* 与普通集群的区别：\n\n  * 当主节点宕机后，会选出一个从服务器作为主节点，此时的集群中的消息可以被消费。\n  * 当老的主节点重启后，老的主节点会作为新主节点的从节点。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["Java学习","中间件"]},{"title":"nginx的学习","url":"/2021/06/04/尚硅谷说Java/分布式技术/Ngnix/","content":"\n* ngnix的反向代理，负载均衡，动静分离配置。\n* ngnix的主从模式，双主模式。\n* keepalived的软件的应用。\n\n<!--more-->\n\n\n\n# nginx 简介\n\n* Nginx (\"engine x\") 是一个**高性能的 HTTP** 和**反向代理服务器**,特点是占有内存少，并发能力强，事实上 nginx 的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用 nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。\n\n* Nginx 可以**作为静态页面的 web 服务器**，同时还**支持 CGI 协议的动态语言**，比如 perl、php等。但是**不支持 java**。Java 程序只能通过与 tomcat 配合完成。\n\n* Nginx 专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率 ，能经受高负载的考验,有报告表明能支持高达 **50,000 个并发连接数**。\n\n* Nginx 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。\n\n* Ngnix的官网：http://nginx.org/\n\n* **正向代理**：如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603180750.png)\n\n* **反向代理**：其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603180754.png)\n\n* **负载均衡**：\n\n  * 客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。\n\n  * 这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？\n  * 我们首先想到的可能是升级服务器的配置，比如提高 CPU 执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢？\n  * 上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢？<font color=\"blue\">这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的**负载均衡**。</font>\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603180759.png)\n\n* **动静分离**：为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速\n\n  度。降低原来单个服务器的压力。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603180805.png)\n\n\n\n# nginx 安装\n\n* 准本工作：联网的linux，版本为centos7的Red Hat版\n\n* 安装ngnix时总共需要安装pcre,openssl,zlib,nginx。\n\n* 第一步：安装pcre\n\n  ```\n  yum install -y pcre pcre-devel\n  ```\n\n  * 查看版本：pcre-config --version\n\n* 第二步：安装openssl和zlib\n\n  ```\n  yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel\n  ```\n\n* 第二步：安装nginx\n  \n  * 添加源\n    \n    ```\n    sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm\n    ```\n    \n  * 安装nginx\n  \n    ```\n    sudo yum install -y nginx\n    ```\n  \n  * 查看版本：nginx -v\n  \n* 测试：\n\n  * 查看开放的端口号：firewall-cmd --list-all\n  * 设置开放的端口号：\n    * firewall-cmd --add-service=http –permanent\n    * sudo firewall-cmd --add-port=80/tcp --permanent\n  * 重启防火墙：\n    * firewall-cmd –reload\n\n* 查看nginx的安装位置：rpm -ql nginx\n\n* 结果说明：\n\n  <img src=\"https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603195635.png\" />\n\n\n\n# nginx 常用的命令和配置文件\n\n\n\n## nginx常用命令\n\n* 首先进入到usr/sbin的目录下\n\n* 启动命令：\n\n  ```\n  ./nginx\n  ```\n\n* 关闭命令\n\n  ```\n  ./nginx -s stop\n  ```\n\n* 重新加载命令\n\n  ```\n  ./nginx -s reload\n  ```\n\n* 启动nginx后，输入下面命令可以看到nginx的进程即表示启动成功\n\n  ```\n  ps -ef |grep nginx\n  ```\n\n* 在 windows 系统中访问 linux 中 nginx，默认不能访问的，因为防火墙问题\n\n  * （1）关闭防火墙\n  * （2）开放访问的端口号，80 端口\n\n* 解决方式：\n\n  * 查看开放的端口号\n\n  ```ini\n  firewall-cmd --list-all\n  ```\n\n  * 设置开放的端口号\n\n  ```ini\n  firewall-cmd --add-service=http --permanent\n  firewall-cmd --add-port=80/tcp --permanent\n  ```\n\n  * 重启防火墙\n\n  ```ini\n  firewall-cmd --reload\n  ```\n\n  * 此时查看开放的端口如下：\n\n  ```\n  public (active)\n    target: default\n    icmp-block-inversion: no\n    interfaces: enp0s3 enp0s8\n    sources: \n    services: dhcpv6-client http ssh\n    ports: 80/tcp  //表示此时的端口为80端口\n    protocols: \n    masquerade: no\n    ...\n  ```\n\n* 在设置防火墙后，在主机上就能够通过虚拟机的地址访问到如下页面。表示nginx启动了。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603201319.png)\n\n\n\n## nginx的配置页面\n\n* 在yum安装nginx时，配置文件的路径在/etc/nginx目录下。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603201603.png)\n\n* nginx.conf是nginx的主配置文件。后续对 nginx 的使用基本上都是对此配置文件进行相应的修改。\n\n* 查看nginx的配置文件的内容：cat nginx.conf | grep \\^\\[^#]\n\n  ```ini\n  # nginx.conf的内容\n  user  nginx;\n  worker_processes  auto;\n  error_log  /var/log/nginx/error.log notice;\n  pid        /var/run/nginx.pid;\n  events {\n      worker_connections  1024;\n  }\n  http {\n      include       /etc/nginx/mime.types;\n      default_type  application/octet-stream;\n      log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                        '$status $body_bytes_sent \"$http_referer\" '\n                        '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n      access_log  /var/log/nginx/access.log  main;\n      sendfile        on;\n      keepalive_timeout  65;\n      # 这里引用了同目录下的conf.d/*.conf的内容\n      include /etc/nginx/conf.d/*.conf;\n  }\n  # 同目录下的conf.d/*.conf的内容\n  server {\n      listen       80;\n      server_name  localhost;\n      location / {\n          root   /usr/share/nginx/html;\n          index  index.html index.htm;\n      }\n      error_page   500 502 503 504  /50x.html;\n      location = /50x.html {\n          root   /usr/share/nginx/html;\n      }\n  }\n  ```\n\n* 根据上述文件，我们可以很明显的将 nginx.conf 配置文件分为三部分：\n\n* <font color=\"red\">第一部分：全局块 </font>\n\n  * 从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。\n\n  * 比如上面第一行配置的：\n\n  ```ini\n  worker_processes  auto;\n  # 可以改为\n  worker_processes  1;\n  ```\n\n  * 这是 Nginx 服务器并发处理服务的关键配置，**worker_processes 值越大，可以支持的并发处理量也越多**，但是会受到硬件、软件等设备的制约。\n\n* <font color=\"red\">第二部分：events 块</font>\n\n  * 比如上面的配置：\n\n  ```ini\n  events {\n      worker_connections  1024;\n  }\n  ```\n\n  * events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接。\n  * 常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否**允许同时接收多个网络连接**，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。\n  * 上述例子就表示每个 work process 支持的最大连接数为 1024.\n  * 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。\n\n* <font color=\"red\">第三部分：http 块</font>\n\n  ```ini\n  http {\n      include       /etc/nginx/mime.types;\n      default_type  application/octet-stream;\n      log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                        '$status $body_bytes_sent \"$http_referer\" '\n                        '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n      access_log  /var/log/nginx/access.log  main;\n      sendfile        on;\n      keepalive_timeout  65;\n      server {\n      \t\t# 表示nginx目前监听的端口号\n          listen       80;\n          # 表示主机名称\n          server_name  localhost;\n          location / {\n              root   /usr/share/nginx/html;\n              index  index.html index.htm;\n          }\n          error_page   500 502 503 504  /50x.html;\n          location = /50x.html {\n              root   /usr/share/nginx/html;\n          }\n      }\n  }\n  ```\n\n  * 这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。\n  * 需要注意的是：**http 块也可以包括 http 全局块、server 块**。\n  * <font color=\"red\">① http 全局块</font>\n    * http 全局块配置的指令包括文件引入、MIME\\-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。\n  * <font color=\"red\">② server 块</font>\n    * 这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。\n    * 每个 **http 块可以包括多个 server 块**，而**每个 server 块就相当于一个虚拟主机**。\n    * 而每个 server 块也分为全局 server 块，以及可以**同时包含多个 locaton 块**。\n    * **1、全局 server 块**\n      * 最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。\n    *  **2、location 块**\n      *  一个 server 块可以配置多个 location 块。\n      *  这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。\n\n\n\n# nginx 配置实例\\-反向代理\n\n* 实现目标一：\n\n  * 打开浏览器，在浏览器地址栏输入地址 www.123.com，跳转到 liunx 系统 tomcat 主页面中\n\n* 准备工作：先安装jdk,再linux中安装tomcat，并启动。\n\n  * 安装JDK：\n\n    ```ini\n    yum install -y java-1.8.0-openjdk.x86_64\n    # 查看jdk版本,出现版本号即可\n    java -version\n    ```\n\n  * 第一步：下载tomcat,并通过Xftp上传到虚拟机的usr/src目录下。\n\n    * 下载地址：https://archive.apache.org/dist/tomcat/tomcat-9/v9.0.1/bin/apache-tomcat-9.0.1-deployer.tar.gz\n\n  * 第二步：解压，并进入到tomcat的bin目录下。\n\n    ```ini\n    [root@localhost src]# tar -xvf apache-tomcat.tar.gz \n    ```\n\n  * 第三步：启动tomcat。\n\n    ```ini\n    # 要先进入到tomcat的bin目录下\n    [root@localhost bin]# ./startup.sh\n    Using CATALINA_BASE:   /usr/src/apache-tomcat-9.0.1\n    Using CATALINA_HOME:   /usr/src/apache-tomcat-9.0.1\n    Using CATALINA_TMPDIR: /usr/src/apache-tomcat-9.0.1/temp\n    Using JRE_HOME:        /usr\n    Using CLASSPATH:       /usr/src/apache-tomcat-9.0.1/bin/bootstrap.jar:/usr/src/apache-tomcat-9.0.1/bin/tomcat-juli.jar\n    Tomcat started.\n    \n    ```\n\n    * 关闭tomcat的方法\n\n    ```shell\n    # 查看tomcat的进程\n    [root@localhost src]# ps -ef |grep tomcat\n    root      2360     1  0 14:33 pts/0    00:00:05 /usr/bin/java -Djava.util.logging.config.file=/usr/src/tomcat8080/apache-tomcat-9.0.1/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -classpath /usr/src/tomcat8080/apache-tomcat-9.0.1/bin/bootstrap.jar:/usr/src/tomcat8080/apache-tomcat-9.0.1/bin/tomcat-juli.jar -Dcatalina.base=/usr/src/tomcat8080/apache-tomcat-9.0.1 -Dcatalina.home=/usr/src/tomcat8080/apache-tomcat-9.0.1 -Djava.io.tmpdir=/usr/src/tomcat8080/apache-tomcat-9.0.1/temp org.apache.catalina.startup.Bootstrap start\n    root      2535  1563  0 15:25 pts/0    00:00:00 grep --color=auto tomcat\n    # 杀死tomcat的进程\n    [root@localhost src]# kill -9 2360\n    [root@localhost src]# ps -ef |grep tomcat\n    root      2537  1563  0 15:25 pts/0    00:00:00 grep --color=auto tomcat\n    ```\n\n  * 第四步：查看tomcat启动日志\n\n    ```ini\n    [root@localhost bin]# cd ..\n    [root@localhost apache-tomcat-9.0.1]# cd logs\n    [root@localhost logs]# tail -f catalina.out\n    ```\n\n  * 第五步：虚拟机开放8080端口。\n\n    ```ini\n    firewall-cmd --add-port=8080/tcp --permanent \n    firewall-cmd --reload\n    # 查看已经开放的端口号\n    firewall-cmd --list-all --permanent\n    ```\n\n  * 第六步：通过虚拟机ip+8080端口，访问虚拟机的tomcat。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604133949.png)\n\n* 反向代理的分析：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604135458.png)\n\n  * 当配置完host的域名解析时。\n  * 正向代理：在windows通过*www.123.com:8080*直接访问tomcat资源。\n  * 反向代理：在windows通过*www.123.com:80*访问nginx,然后nginx转发到tomcat。\n    * 由于80端口为默认访问，依次可以直接访问*www.123.com*即可。\n\n* 实现步骤：\n\n  * 第一步：配置windows的host文件\n\n    * host文件一般在C:\\Windows\\System32\\drivers\\etc\n\n    ```ini\n    192.168.56.107 www.123.com\n    ```\n\n  * 第二步：配置nginx反向代理。进入/etc/nginx/conf.d下，配置default.conf命令，\n\n    ```ini\n    server {\n    \t\t# 设置监听 192.168.56.107:80\n        listen       80;\n        server_name  192.168.56.107;\n    \t\t# 设置访问路径为/时，转发到 http://127.0.0.1:8080\n        location / {\n            proxy_pass http://127.0.0.1:8080;\n        }\n        ...\n    }\n    ```\n\n  * 第三步：启动nginx,并开放80端口\n\n    ```sh\n    [root@localhost logs]# cd /\n    [root@localhost /]# cd usr/sbin\n    [root@localhost sbin]# ./nginx\n    [root@localhost sbin]# \n    ```\n\n  * 第四步：在windows浏览器上访问www.123.com\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604185203.png)\n\n* 反向代理实现二：\n\n  * 实现效果：\n\n    * 使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中\n    * nginx 监听端口为 9001，\n    * 访问 http://192.168.56.107:9001/edu/ 直接跳转到 127.0.0.1:8080\n    * 访问 http://192.168.56.107:9001/vod/ 直接跳转到 127.0.0.1:8081\n\n  * 准备工作：\n\n    * 准备两个tomcat,一个8080端口，一个8081端口。\n    * 修改tomcat配置\n\n    ```xml\n    <Server port=\"8015\" shutdown=\"SHUTDOWN\">\n    <Connector port=\"8081\" protocol=\"HTTP/1.1\"\n               connectionTimeout=\"20000\"\n               redirectPort=\"8443\" />\n    <Connector port=\"8019\" protocol=\"AJP/1.3\" redirectPort=\"8443\" />\n    ```\n\n    * 创建tomcat的测试页面。\n      * 在对应tomcat目录下的webapps中创建一个文件，在此文件中分别创建一个页面即可。\n    * 准备成功后的检验\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604143710.png)\n\n  * 具体配置：\n\n    ```ini\n    server {\n        listen      9001;\n        server_name  192.168.56.107;\n        # ~ /edu/为正则表达式。表示路径中有/edu/的请求\n        location ~ /edu/ {\n    \t\t\t\tproxy_pass http://127.0.0.1:8080;\n        }\n        location ~ /vod/ {\n    \t\t\t\t\tproxy_pass http://127.0.0.1:8081;\t\n        }\n    }\n    ```\n\n  * 设置虚拟机对外开放端口9001，8080，8081\n\n    ```shell\n    [root@localhost /]# firewall-cmd --add-port=8080/tcp --permanent \n    [root@localhost /]# firewall-cmd --add-port=8081/tcp --permanent \n    [root@localhost /]# firewall-cmd --add-port=9001/tcp --permanent \n    [root@localhost /]# firewall-cmd --reload\n    ```\n\n  * 测试：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604185153.png)\n\n\n\n## location 指令说明 \n\n*  该指令用于匹配 URL。\n\n* 语法如下：\n\n  ```\n  location [ = | ~ | ~* | ^~ ] uri{\n  \n  }\n  ```\n\n  * 1、= ：用于**不含正则表达式**的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。\n  * 2、~：用于表示 uri 包含正则表达式，并且区分大小写。\n  * 3、~\\*：用于表示 uri 包含正则表达式，并且**不区分大小写**。\n  * 4、^~：用于**不含正则表达式**的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。\n\n* 注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~\\* 标识。\n\n\n\n# nginx 配置实例\\-负载均衡\n\n* 实验效果：\n\n  * 浏览器地址栏输入地址 http://192.168.56.107/edu/a.html，负载均衡效果，平均 8080和 8081 端口中。\n\n* 准备工作：\n\n  * 准备两台tomcat服务器，一台8080端口，一台8081端口。\n  * 在两个tomcat服务器的webapps目录下，都有一个edu文件夹，且文件夹中都有a.html文件。文件内容可以不同以为测试区分。\n\n* 步骤：\n\n  * 修改配置：\n\n  ```ini\n  http{\n    ....\n    # 设置转发的路径，myserver为此upstream的名字\n    upstream myserver{\n      server 192.168.56.107:8080;\n      server 192.168.56.107:8081;\n    }\n    server {\n      listen       80;\n      server_name  192.168.56.107;\n      location / {\n      \t# 此处的myserver应当对应上面的upstream的名字\n      \tproxy_pass http://myserver;\n      }\n  \t}\n  \t...\n  }\n  ```\n\n* 实验结果：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604185145.png)\n\n\n\n## 负载均衡的分配策略\n\n* 负载均衡即是将负载分摊到不同的服务单元，既保证服务的可用性，又保证响应足够快，给用户很好的体验。\n\n* 1、**轮询**（默认）\n\n  * 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。\n\n* 2、**weight**\n\n  * weight 代表权,重默认为 1,权重越高被分配的客户端越多。\n  * 指定轮询几率，weight 和访问比率成正比，**用于后端服务器性能不均的情况**。 例如：\n\n  ```ini\n  upstream server_pool{ \n    server 192.168.5.21 weight=10; \n    server 192.168.5.22 weight=10; \n  }\n  ```\n\n* 3、**ip_hash**\n\n  * 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，**可以解决 session 的问题**。 例如：\n\n  ```ini\n  upstream server_pool{ \n    ip_hash; \n    server 192.168.5.21:80; \n    server 192.168.5.22:80; \n  }\n  ```\n\n* 4、**fair**（第三方）\n\n  * 按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\n  ```ini\n  upstream server_pool{ \n    server 192.168.5.21:80; \n    server 192.168.5.22:80; \n    fair; \n  }\n  ```\n\n\n\n# nginx 配置实例\\-动静分离\n\n* Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。\n\n* 严格意义上说应该是动态请求跟静态请求分开，可以理解成使用 Nginx 处理静态页面，Tomcat 处理动态页面。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604164526.png)\n\n* 动静分离从目前实现角度来讲大致分为两种：\n\n  * 一种是纯粹把**静态文件独立成单独的域名**，放在独立的服务器上，也是目前主流推崇的方案；\n  * 另外一种方法就是动态跟静态文件混合在一起发布，**通过 nginx 来分开**。\n\n* 通过 **location** 指定不同的后缀名实现不同的请求转发。\n\n* 通过 **expires** 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。\n\n  * 具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过**浏览器自身确认是否过期**即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。\n  * （如果经常更新的文件，不建议使用 Expires 来缓存），比如设置为 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304，如果有修改，则直接从服务器重新下载，返回状态码 200。\n\n* 实验目的：\n\n  * 访问 192.168.56.107/image/01.jpg 不经过tomcat就可以直接获取。\n  * 访问 192.168.56.107/www/a.html 不经过tomcat就可以直接获取。\n\n* 准备工作：\n\n  * 在linux中准备静态资源，用于访问。不用放在tomcat中。\n\n  ```shell\n  [root@localhost /]# ls\n  bin  boot  data  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\n  [root@localhost /]# cd data\n  [root@localhost data]# ls\n  image  www\n  [root@localhost data]# cd www\n  [root@localhost www]# ls\n  a.html\n  [root@localhost www]# cd ..\n  [root@localhost data]# cd image/\n  [root@localhost image]# ls\n  01.JPG\n  ```\n\n* 具体配置：\n\n  ```ini\n  server {\n      listen       80;\n      server_name  192.168.56.107;\n      location /www/ {\n      \t\t# 转发访问/data/下的资源\n          root   /data/;\n          index  index.html index.htm;\n      }\n      location /image/ {\n          root /data/;\n          # autoindex on;表示开启资源目录效果\n          autoindex on;\n      }\n  }\n  ```\n\n* 测试：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604170037.png)\n\n  * 开启资源目录效果\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604170026.png)\n\n\n\n# 搭建 nginx 高可用集群\n\n* 使用Keepalived+Nginx搭建。\n* Keepalived软件相当于路由的功能，能够检测主服务器和从服务器的状态。\n* 在整个配置中主要修改Keepalived的配置，因为它管理着整个集群的结构。\n\n\n\n## 主从模式\n\n* 集群架构图\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604171151.png)\n\n* 准备工作\n\n  * 需要两台虚拟机服务器192.168.56.107和192.168.56.108\n  * 在两台服务器上安装nginx\n  * 在两台服务器上安装keepalived\n\n* 安装keepalived\n\n  * 使用yum安装\n\n  ```shell\n  [root@localhost /]# yum install keepalived –y\n  ```\n\n  * 安装成功的检测\n\n  ```shell\n  [root@localhost conf.d]# rpm -q -a keepalived\n  keepalived-1.3.5-19.el7.x86_64\n  ```\n\n  * 安装后的keepalived的配置文件在etc/中\n\n  ```shell\n  [root@localhost /]# cd etc/keepalived/\n  [root@localhost keepalived]# ls\n  keepalived.conf\n  ```\n\n* 配置\n\n  * 修改keepalived.conf\n\n  ```ini\n  # global_defs ：表示全局定义\n  global_defs { \n  \tnotification_email { \n  \t\tacassen@firewall.loc \n  \t\tfailover@firewall.loc \n  \t\tsysadmin@firewall.loc \n  \t} \n  \tnotification_email_from Alexandre.Cassen@firewall.loc \n  \t# 为当前虚拟机的IP\n  \tsmtp_server 192.168.56.107\n  \tsmtp_connect_timeout 30 \n  \t# router_id：路由id，全局唯一，也可以写成ip值。\n  \trouter_id LVS_DEVEL \n  } \n  vrrp_script chk_http_port { \n  \t# nginx_check.sh为脚本。根据此脚本来判断nginx是否活着。以及如何切换\n  \tscript \"/usr/keepalived/nginx_check.sh\" \n  \t#（检测脚本执行的间隔）\n  \tinterval 2  \n  \tweight 2 \n  } \n  vrrp_instance VI_1 { \n  \t# state：主服务器为MASTER,从服务器为BACKUP\n  \tstate MASTER  \n  \t# 当前服务器，网卡的名字，一般为192开头的虚拟机的网卡名\n  \tinterface ens33  \n  \t# 主、备机的 virtual_router_id 必须相同\n  \tvirtual_router_id 51  \n  \t# 主、备机取不同的优先级，主机值较大，备份机值较小\n  \tpriority 100  \n  \tadvert_int 1 \n  \tauthentication { \n  \t\tauth_type PASS \n  \t\tauth_pass 1111 \n  \t} \n  \tvirtual_ipaddress { \n  \t\t# VRRP H 虚拟IP地址 \n  \t\t192.168.56.150 \n  \t} \n  }\n  ```\n\n  * 创建脚本文件nginx_check.sh\n\n  ```sh\n  #!/bin/bash\n  A=`ps -C nginx –no-header |wc -l`\n  if [ $A -eq 0 ];then\n  \t# 下面路径为nginx启动的路径\n    /usr/sbin/nginx\n    sleep 2\n    if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then\n    \t# 这个判断的作用，如果当前nginx不能启动，切换另一个\n    \tkillall keepalived\n    fi\n  fi\n  ```\n\n* 启动服务：\n\n  * 启动nginx：*./nginx*\n  * 启动keepalived：*systemctl start keepalived.service*\n\n* 停止服务：\n\n  * 停止nginx：*./nginx -s stop*\n  * 停止keepalived：*systemctl stop keepalived.service*\n\n* 测试：\n\n  * 关闭主服务器时，虚拟IP仍可以访问。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604182158.png)\n\n  * 虚拟IP的配置效果。会与当前虚拟机的网卡进行绑定\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604184028.png)\n\n\n\n## 双主模式\n\n* 集群架构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604185529.png)\n\n* 与主从模式不同之处：在于keepalived.conf的配置。\n\n  * 对于其中一个服务器的配置：\n\n  ```ini\n  vrrp_instance VI_1 {\n   state MASTER\n   interface ens33\n   virtual_router_id 51\n   priority 150\n   advert_int 1\n   authentication {\n     auth_type PASS\n     auth_pass 1111\n   }\n   virtual_ipaddress {\n   \t 192.168.1.110/24 dev ens33 label ens33:1\n   } \n  }\n  \n  vrrp_instance VI_2 {\n   state BACKUP\n   interface ens33\n   virtual_router_id 52\n   priority 100\n   advert_int 1\n   authentication {\n     auth_type PASS\n     auth_pass 2222\n   }\n   virtual_ipaddress {\n   \t 192.168.1.210/24 dev ens33 label ens33:2\n   } \n  }\n  ```\n\n  * 另一个服务器的配置：\n\n  ```ini\n  vrrp_instance VI_1 {\n   state BACKUP\n   interface ens33\n   virtual_router_id 51\n   priority 100\n   advert_int 1\n   authentication {\n     auth_type PASS\n     auth_pass 1111\n   }\n   virtual_ipaddress {\n   \t\t192.168.1.110/24 dev ens33 label ens33:1\n   } \n  }\n  \n  vrrp_instance VI_2 {\n   state MASTER\n   interface ens33\n   virtual_router_id 52\n   priority 150\n   advert_int 1\n   authentication {\n     auth_type PASS\n     auth_pass 2222\n   }\n   virtual_ipaddress {\n   `192.168.1.210/24 dev ens33 label ens33:2\n   } \n  }\n  ```\n\n* 总结：\n\n  * 在主从模式中，是一个服务器在虚拟IP中表示为主节点，另一个服务器在虚拟IP中表示为从节点。\n  * 在双主模式中，\n    * 一个服务器在虚拟IPA中表示为主节点，在虚拟IPB中表示为从节点。\n    * 另一个服务器在虚拟IPB中表示为主节点，在虚拟IPA中表示为从节点。\n    * 总共有两个虚拟IP。但绑定的都是一个网卡。\n\n\n\n## keepalived配置文件解析\n\n* 整个配置文件可以分为三个部分：\n  * 全局配置：global_defs\n  * 脚本配置：vrrp_script\n  * 虚拟IP配置：vrrp_instance\n* 全局配置：\n  * router_id：定义了服务器的名字，在服务器的host文件中可以看到127.0.0.1 对应的就是router_id的值。\n* 脚本配置：\n  * script ：表示执行的脚本\n  * interval ：表示脚本每个多长时间执行一次。单位秒。\n  * weight ：表示权重，如果当前脚本的条件成立，则当前服务器的权重加上weight的值。\n    * weight的值可以为负值。\n* 虚拟IP配置：\n  * state ：服务器的状态\n  * interface ：虚拟IP绑定的网卡\n  * virtual_router_id ：虚拟IP 的路由id值\n  * priority ：主从机的优先级\n  * advert_int ：表示每隔多少秒发送一次心跳，以检测主从服务器是否存活。默认1秒。\n  * authentication ：表示权限校验的方式。\n    * auth_type PASS ：表示方式为校验密码。\n    * auth_pass 1111：表示密码为1111。\n  * virtual_ipaddress ：虚拟IP，可以绑定多个虚拟IP。\n\n\n\n# nginx 原理与优化参数配置\n\n* 首先在nginx中有两个角色：master和worker。角色的关系如下：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604184014.png)\n\n  * 并且在启动nginx后通过查看进程就会看到这两个角色。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604184020.png)\n\n* 工作原理：\n\n  * 当有新请求发到master时，master会告诉它下面的所有worker。\n  * 然后空闲的worker会通过争抢的机制来获取处理这个请求的权限。\n  * 当一个worker抢到这个权限时，就会执行剩余的操作。\n  * 大概原理如下图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604184101.png)\n\n* master-workers 的机制的好处：\n\n  * 对于每个 worker 进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销。\n  * 采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的worker 进程。当然，worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当前 worker 上的所有请求失败，不过不会影响到所有请求，所以降低了风险。\n  * 可以使用 nginx –s reload 热部署，利用 nginx 进行**热部署操作**。\n\n* 需要设置多少个worker合适：\n\n  * Nginx 同 redis 类似都采用了 io 多路复用机制，每个 worker 都是一个独立的进程，但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话下。\n  * 每个 worker 的线程可以把一个 cpu 的性能发挥到极致。\n  * 所以 **worker 数和服务器的 cpu数相等是最为适宜的**。\n  * 设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗。\n  * 设置worker 数量。\n\n  ```ini\n  worker_processes 4\n  #work 绑定 cpu(4 work 绑定 4cpu)。\n  worker_cpu_affinity 0001 0010 0100 1000\n  #work 绑定 cpu (4 work 绑定 8cpu 中的 4 个) 。\n  worker_cpu_affinity 0000001 00000010 00000100 00001000\n  ```\n\n* 连接数 worker_connection：\n\n  * 这个值是表示每个 worker 进程所能建立连接的最大值。\n  * 所以，一个 nginx 能建立的最大连接数，应该是 worker_connections \\* worker_processes。\n  * 对于HTTP 请 求 本 地 资 源 来 说 ， 能 够 支 持 的 最 大 并 发 数 量 是 worker_connections \\* \n    worker_processes。\n  * 因为支持 http1.1 的浏览器每次访问要占两个连接。因此：\n  * 普通的**静态访问最大并发数**是： worker_connections \\* worker_processes /2\n  * 如果是 **HTTP 作 为反向代理**来说，最大并发数量应该是 worker_connections \\* worker_processes/4。\n    * 因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。\n  * 总之：\n    * 发送请求，占用了 woker 的2个或4个连接数。\n  * nginx.conf的结构：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604185031.png)\n\n","categories":["Java学习","分布式技术"]},{"title":"maven的学习","url":"/2021/06/03/尚硅谷说Java/集成工具的使用/Maven的学习/","content":"\n* maven的生命周期和命令，与IDEA的整合，多maven的两种实现方式。\n* maven的常用设置。\n\n<!--more-->\n\n\n\n# Maven简介\n\n* 官网：http://maven.apache.org/\n\n\n\n## 软件工程\n\n* 软件工程：为了能够实现软件的流水线式生产，在设计和构建软件时能够有一种规范和工程化的方法，人们便提出了软件工程概念。\n* 软件开发需要编译代码—>开发人员自己测试代码—>把代码打包—>部署项目到测试服务器—>测试人员测试功能—>测试测试出 bug—>开发人员需要修改bug—>开发人员自己测试代码—>把代码打包—>部署项目到测试服务器—>测试人员测试功能—>直到符合功能要求。\n* 上述过程需要重复多次，大型项目中构建项目比较复杂，有很多的配置文件，jar 文件，多个子项目等等。都用人力完成费时费力，效率比较低。maven 可以让我们从上面的工作中解脱出来。\n* 一个项目做成一个工程，造成工程比较庞大，需要使用多模块来划分项目；\n* 项目中需要的数量众多的 jar 包，需要手动下载并引入，并且多个项目需要的 jar 包存在重复的问题；\n* 项目中需要的 jar 包有版本兼容的问题，需要手动解决；\n* 项目中需要的 jar 包又依赖其它的 jar 包，需要手动解决。\n\n\n\n## maven概述\n\n* Maven 是 Apache 软件基金会组织维护的一款自动化构建工具，专注服务于 Java 平台的项目构建和依赖管理。Maven 这个单词的本意是：专家，内行。读音是['meɪv(ə)n]或['mevn]。\n* Maven 是目前最流行的自动化构建工具，对于生产环境下多框架、多模块整合开发有重要作用，\n* Maven 是一款在大型项目开发过程中不可或缺的重要工具。\n* Maven 可以**整合多个项目之间的引用关系**，我们可以根据业务和分层需要任意拆分一个项目；\n* Maven 提供规范的管理各个常用 jar 包及其各个版本，并且可以**自动下载和引入项目**中；\n* Maven 可以根据指定版本自动**解决 jar 包版本兼容问题**；\n* Maven 可以把 jar 包所依赖的其它 jar 包自动下载并引入项目。\n* 类似自动化构建工具还有：Ant, Maven, Gradle。\n* **构建过程中的各个环节**：清理、编译、测试、报告、打包、安装、部署。\n* 构建（build），是面向过程的(从开始到结尾的多个步骤)，涉及到多个环节的协同工作。\n* 构建过程的几个主要环节：\n  * ①清理：删除以前的编译结果，为重新编译做好准备。\n  * ②编译：将Java源程序编译为字节码文件。\n  * ③测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。\n  * ④报告：在每一次测试后以标准的格式记录和展示测试结果。\n  * ⑤打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。**Java 工程对应 jar 包，Web工程对应war包**。\n  * ⑥安装：在Maven环境下特指将打包的结果——**jar包或war包**安装到本地仓库中。\n  * ⑦部署：将打包的结果部署到远程仓库或将war包部署到服务器上运行。\n* Maven能够实现自动化构建是和它的内部原理分不开的。\n* Maven有九个核心概念：\n  * ①POM \n  * ②约定的目录结构\n  * ③坐标\n  * ④依赖管理\n  * ⑤仓库管理\n  * ⑥生命周期\n  * ⑦插件和目标\n  * ⑧继承\n  * ⑨聚合\n\n\n\n## 安装Maven\n\n* 第一步： 确保安装了 java 环境:maven 本身就是 java 写的，所以要求必须安装 JDK。\n\n  * 查看 java 环境变量：echo %JAVA_HOME%\n\n* 第二步：下载并解压 maven 安装程序：\n\n  * 下载地址：http://maven.apache.org/download.cgi。\n  * 选择合适的版本下载后，解压即可。\n  * 解压后的文件目录说明：\n    * bin：放置Maven的执行程序，主要是mvn.cmd。\n    * conf：放置Maven本身的配置文件，settings.xml。\n\n* 第三步：配置 Maven 的环境变量：\n\n  ```ini\n  MAVEN_HOME=d:/apache-maven-3.6.3\n  path=%MAVEN_HOME%/bin;\n  # 或者 \n  M2_HOME=d:/apache-maven-3.6.3\n  path=%M2_HOME%/bin;\n  ```\n\n* 第四步：验证是否安装成功\n\n  * 在命令行输入mvn -v 查看是否出现版本号。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601.png)\n\n* 对Maven的优化：\n\n  * 修改settings.xml文件\n\n  ```xml\n  <!--设置本地仓库的位置。-->\n  <localRepository>E:\\maven</localRepository>\n  <!--设置阿里云镜像，这样在下载jar包时从阿里云下载，速度会比较快-->\n  <mirror>\n    <id>alimaven</id>\n    <mirrorOf>central</mirrorOf>\n    <name>aliyun maven</name>\n    <url>https://maven.aliyun.com/nexus/content/repositories/central/</url>\n  </mirror>\n  <!--设置maven打包后的Java项目的jdk版本-->\n  <profile>\n    <id>jdk-1.8</id>\n    <activation>\n      <activeByDefault>true</activeByDefault>\n      <jdk>1.8</jdk>\n    </activation>\n    <properties>\n      <maven.compiler.source>1.8</maven.compiler.source>\n      <maven.compiler.target>1.8</maven.compiler.target>\n      <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>\n    </properties>\n  </profile>\n  ```\n\n\n\n# Maven的核心概念\n\n\n\n## Maven工程约定目录结构\n\n* maven 中约定的目录结构：\n\n  ```mysql\n  Hello #根目录，也就是工程名\n  \t|---src #源代码\n  \t|---|---main #主程序\n  \t|---|---|---java #主程序的 java 源码\n  \t|---|---|---resources #主程序的配置文件\n  \t|---|---test #测试程序\n  \t|---|---|---java #测试程序的 java 源码\n  \t|---|---|---resources #测试程序的配置文件\n  \t|---pom.xml #Maven 工程的核心配置文件。\n  ```\n\n* 一般情况下，我们习惯上采取的措施是：约定>配置>编码\n\n* maven 的 pom.xml 记录的关于构建项目的各个方面的设置，\n\n* maven 从 pom.xml 文件开始，按照助约定的工程目录编译，测试，打包，部署，发布项目。\n\n* 创建Maven工程：\n\n  * 第一步：某个目录中创建文件夹 Hello\n\n  * 第二步：在 Hello 中创建子目录 src\n\n  * 第三步：拷贝 pom.xml 到 Hello 目录和 src 是同级放置的。\n\n  * 第四步：进入 src 目录，创建 main， test 目录\n\n  * 第五步：进入 main 目录，创建 java，resources 目录。\n\n  * 第六步：进入 java 目录，创建目录 com\n\n  * 第七步：在 com目录下创建 HelloMaven.java 文件\n\n    ```java\n    public static void main(String args[]) { \n      System.out.prinltn(“Hello Manven”);\n    }\n    ```\n\n  * 第八步：进入到 Hello 目录的命令行模式，执行 mvn compile \n\n  * 第九步：进入到 target/classes 目录执行 java com.HelloMaven\n\n  * 此时会发现HelloMaven被执行了。\n\n\n\n## POM文件\n\n* 即 Project Object Model 项目对象模型。Maven 把一个项目的结构和内容抽象成一个模型，在 xml 文件中进行声明，以方便进行构建和描述。\n* pom.xml 是 Maven 的灵魂。所以，maven 环境搭建好之后，所有的学习和操作都是关于 pom.xml 的。\n* pom.xml 初识：\n  * 基本信息：\n    * modelVersion：Maven 模型的版本，对于 Maven2 和 Maven3 来说，它只能是 4.0.0\n    * groupId：\n      * 组织 id，一般是公司域名的倒写。 格式可以为：\n        * 域名倒写。 例如 com.baidu\n        * 域名倒写+项目名。例如 com.baidu.appolo\n      * \n    * artifactId：项目名称，也是模块名称，对应 groupId 中 项目中的子项目。\n    * version ：\n      * 项目的版本号。如果项目还在开发中，是不稳定版本，通常在版本后带\\-SNAPSHOT。\n      * version 使用三位数字标识，例如 1.1.0。\n    * packaging：项目打包的类型，可以使 jar、war、rar、ear、pom，默认是 jar。\n    * groupId 、artifactId 、version 三个元素生成了一个Maven 项目的基本坐标，在众多的maven 项目中可以唯一定位到某一个项目。坐标也决定着将来项目在仓库 中 的 路 径 及 名称。\n  * 依赖：dependencies 和dependency\n    * Maven 的一个重要作用就是管理 jar 包，为了一个项目可以构建或运行，项目中不可避免的，会依赖很多其他的 jar 包，在 Maven 中，这些 jar 就被称为依赖，使用标签 dependency 来配置。而这种依赖的配置正是通过坐标来定位的，由此我们也不难看出，maven 把所有的 jar 包也都视为项目存在了。\n    * 依赖的作用相当于Java中的import命令功能。可以导入取它jar包到此项目中。\n  * 配置属性：properties\n    * properties 是 用 来 定 义 一 些 配 置 属 性 的 ， 例 如project.build.sourceEncoding（项目构建源码编码方式），可以设置为UTF-8，防止中文乱码，也可定义相关构建版本号，便于日后统一升级。\n  * 构建：build \n    * build 表示与构建相关的配置，例如设置编译插件的 jdk 版本\n  * 继承：parent\n    * 在 Maven 中，如果多个模块都需要声明相同的配置，例如：groupId、version、有相同的依赖、或者相同的组件配置等，也有类似 Java 的继承机制，用 parent 声明要继承的父工程的 pom 配置。\n  * 聚合：modules \n    * 在 Maven 的多模块开发中，为了统一构建整个项目的所有模块，可以提供一个额外的模块，该模块打包方式为 pom，并且在其中使用 modules 聚合的其它模块，这样通过本模块就可以一键自动识别模块间的依赖关系来构建所有模块，叫 Maven 的聚合。\n  * 样例：\n  \n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n  \n    <!--设置此项目的坐标-->\n    <groupId>org.example</groupId>\n    <artifactId>mavenTest</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <!--设置打包的项目类型-->\n    <packaging>jar</packaging>\n    <dependencies>\n      <!--添加 mysql连接 和 mybatis 的依赖-->\n      <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>5.1.40</version>\n      </dependency>\n      <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <!--引用properties中的设置-->\n        <version>${mybatis-version}</version>\n      </dependency>\n    </dependencies>\n    <properties>\n      <!--设置mybatis依赖的版本-->\n      <mybatis-version>3.5.3</mybatis-version>\n    </properties>\n  \n    <build>\n      <plugins>\n        <plugin>\n          <groupId>org.apache.maven.plugins</groupId>\n          <artifactId>maven-compiler-plugin</artifactId>\n          <!--设置maven的编译版本-->\n          <version>3.8.0</version>\n          <configuration>\n            <!--设置jdk的版本-->\n            <source>1.8</source>\n            <target>1.8</target>\n          </configuration>\n        </plugin>\n      </plugins>\n    </build>\n  \n  </project>\n  ```\n\n\n\n## 仓库\n\n* 在Maven中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。\n\n* Maven核心程序仅仅定义了自动化构建项目的生命周期，但具体的构建工作是由特定的构件完成的。而且为了提高构建的效率和构件复用，maven把所有的构件统一存储在某一个位置，这个位置就叫做仓库。\n\n* 仓库是存放东西的，Maven 仓库的是：\n  * 1.Maven 的插件，插件也是一些 jar，这些 jar 可以完成一定的功能。\n  * 2.我们自己开发项目的模块\n  * 3.第三方框架或工具的 jar 包\n  \n* 根据仓库存储的位置，把仓库分为本地仓库和远程仓库。\n\n* **本地仓库**：\n  \n  * 存在于当前电脑上,默认存放在~\\.m2\\repository中,为本机上所有的Maven工程服务。\n  * 你也可以通过Maven的配置文件Maven_home/conf/settings.xml中修改本地仓库所在的目录。\n  * ~ 是用户的主目录，windows系统中是 c：/user/登录系统的用户名。\n  \n* **远程仓库**：\n  \n  * 分为为全世界范围内的开发人员提供服务的中央仓库、为全世界范围内某些特定的用户提供服务的中央仓库镜像、为本公司提供服务自己架设的私服。\n  * 中央仓库是maven默认的远程仓库，其地址是:https://mvnrepository.com/\n  * 一般要查找maven的依赖，都是去这个中央仓库中寻找的。\n  \n* 中央仓库，包含了绝大多数流行的开源Java构件，以及源码、作者信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载得到。\n\n* 私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。我们还可以把一些无法从外部仓库下载到的构件上传到私服上。\n\n* 分类说明：\n\n  * 1）本地仓库：本机当前电脑上的资源存储位置，为本机上所有 Maven工程提供服务\n  * 2）远程仓库：不在本机上， 通过网络才能使用。多电脑共享使用的。\n    * ①：中央仓库：通过Internet访问，为全世界所有 Maven工程服务。 最权威的。\n    * ②：中央仓库的镜像：架设在不同位置，欧洲，美洲，亚洲等每个洲都有若干的服务器，为中央仓库分担流量。减轻中央仓库的访问，下载的压力。所在洲的用户首先访问的是本洲的镜像服务器。\n    * ③：私服：在局域网环境中部署的服务器，为当前局域网范围内的所有 Maven工程服务。公司中常常使用这种方式。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-1.png)\n\n* 在 Maven 构建项目的过程中如果需要某些插件，首先会到 Maven 的本地仓库中查找，\n\n  * 如果找到则可以直接使用；\n  * 如果找不到，它会自动连接外网，到远程中央仓库中查找；\n    * 如果远程仓库中能找到，则先把所需要的插件下载到本地仓库，然后再使用，并且下次再用到相同的插件也可以直接使用本地仓库的；\n    * 如果没有外网或者远程仓库中也找不到，则构建失败。\n\n\n\n## Maven的生命周期\n\n* 对项目的构建是建立在生命周期模型上的，它明确定义项目生命周期各个阶段，并且对于每一个阶段提供相对应的命令，对开发者而言仅仅需要掌握一小堆的命令就可以完成项目各个阶段的构建工作。\n* 构建项目时按照生命周期顺序构建，每一个阶段都有特定的插件来完成。不论现在要执行生命周期中的哪个阶段，都是从这个生命周期的最初阶段开始的。\n* 对于我们程序员而言，无论我们要进行哪个阶段的构建，直接执行相应的命令即可，无需担心它前边阶段是否构建，Maven 都会自动构建。这也就是 Maven 这种自动化构建工具给我们带来的好处。\n\n\n\n## Maven的常用命令\n\n* Maven 对所有的功能都提供相对应的命令，要想知道 maven 都有哪些命令，那要看 maven 有哪些功能。\n* maven 三大功能：管理依赖、构建项目、管理项目信息。\n  * 管理依赖，只需要声明就可以自动到仓库下载；\n  * 管理项目信息其实就是生成一个站点文档，一个命令就可以解决。\n* maven 功能的主体其实就是项目构建。\n* Maven 提供一个项目构建的模型，把编译、测试、打包、部署等都对应成一个个的生命周期阶段，并对每一个阶段提供相应的命令，程序员只需要掌握一小堆命令，就可以完成项目的构建过程。\n* **mvn clean**： 清理(会删除原来编译和测试的目录，即 target 目录，但是已经 install 到仓库里的包不会删除)\n* **mvn compile**： 编译主程序(会在当前目录下生成一个 target,里边存放编译主程序之后生成的字节码文件)\n* **mvn test-compile** ：编译测试程序(会在当前目录下生成一个 target,里边存放编译测试程序之后生成的字节码文件)\n* **mvn test**： 测试(会生成一个目录surefire-reports，保存测试结果)\n* **mvn package**：打包主程序(会编译、编译测试、测试、并且按照 pom.xml 配置把主程序打包生成 jar 包或者 war 包)\n* **mvn install**： 安装主程序(会把本工程打包，并且按照本工程的坐标保存到本地仓库中)\n* **mvn deploy**： 部署主程序(会把本工程打包，按照本工程的坐标保存到本地库中，并且还会保存到私服仓库中。还会自动把项目部署到 web 容器中)。\n* **注意：执行以上命令必须在命令行进入 pom.xml 所在目录！**\n* 测试：\n  * 测试使用的是junit的单元测试方法，会对每一个方法进行测试。\n  * 使用步骤：需要先导入单元测试的依赖，然后在测试方法上加一个@Test注解即可。\n  * 使用时使用 mvn test-compile，然后执行mvn-test即可\n\n\n\n## Maven插件\n\n* maven 过程构建周期，由 maven 的插件 plugin 来执行完成。\n* 官网插件说明：http://maven.apache.org/plugins/\n  * 例如：安装clear插件：mvn clean install。\n* **clean** 插件 maven-clean-plugin:2.5：\n  * clean 阶段是独立的一个阶段，功能就是清除工程目前下的 target 目录\n* **resources** 插件 maven-resources-plugin:2.6：\n  * resource 插件的功能就是把项目需要的配置文件拷贝到指定的目当，默认是拷贝 src\\main\\resources 目录下的件到classes 目录下\n* **compile** 插件 maven-compiler-plugin：\n  * compile 插件执行时先调用 resouces 插件，功能就是把 src\\mainjava 源码编译成字节码生成 class 文件，并把编译好的 class 文件输出到 target\\classes 目录下\n* **test** 测试插件：\n  * 单元测试所用的 compile 和 resources 插件和主代码是相同的，但执行的目标不行，目标 testCompile 和 testResources是把 src\\test\\java 下的代码编译成字节码输出到 target\\test-classes，同时把 src\\test\\resources 下的配置文件拷贝到target\\test-classes\n* **package** 打包插件 maven-jar-plugin：\n  * package 插件是把 class 文件、配置文件打成一个 jar(war 或其它格式)包\n* **deploy** 发布插件 maven-install-plugin：\n  * 发布插件的功能就是把构建好的 artifact 部署到本地仓库，还有一个 deploy 插件是将构建好的 artifact 部署到远程仓库\n\n\n\n## maven坐标\n\n* Maven 把任何一个插件都作为仓库中的一个项目进行管理，用一组(三个)向量组成的坐标来表示。坐标在仓库中可以唯一定位一个 Maven 项目。\n  * groupId：组织名，通常是公司或组织域名倒序+项目名\n  * artifactId：模块名，通常是工程名\n  * version：版本号\n* 需要特别指出的是，项目在仓库中的位置是由坐标来决定的：groupId、artifactId 和 version 决定项目在仓库中的路径，artifactId 和 version 决定 jar 包的名称。\n\n\n\n## maven依赖\n\n* 一个 Maven 项目正常运行需要其它项目的支持，Maven 会根据坐标自动到本地仓库中进行查找。对于程序员自己的 Maven 项目需要进行安装，才能保存到仓库中。\n\n* 不用 maven 的时候所有的 jar 都不是你的，需要去各个地方下载拷贝，用了 maven 所有的 jar 包都是你的，想要谁，叫谁的名字就行。maven 帮你下载。\n\n* pom.xml 加入依赖的方式：\n\n  ```xml\n  <!--log4j 日志依赖-->\n  <dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.17</version>\n  </dependency>\n  <!-- junit 单元测试依赖-->\n  <dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.11</version>\n  </dependency>\n  ```\n\n\n\n# Maven在IDEA中的应用\n\n* IDEA集成Maven\n\n  * 第一步：集成Maven\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-2.png)\n\n  * 第二步：配置Maven\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-3.png)\n\n* 使用IDEA创建maven版Java项目：\n\n  * 第一步：创建maven项目，File --> new project。选中maven，点击下一步\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-6.png)\n\n  * 第二步：填写maven项目名称。填写创建的maven项目的坐标。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-4.png)\n\n  * 第三步：在pom.xml文件中添加项目所需要的依赖。\n  * 项目的大体视图如下：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-5.png)\n\n* IDEA自带的Maven的插件功能：在IDEA的右侧。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-7.png)\n\n* 使用IDEA创建maven版Web项目:\n\n  * 第一步：File --> new project。选中maven，选中create from archetype,选择web原型，点击下一步。\n\n    * 注意此处的webapp模型有两个，要注意区分选择的是哪个。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-16.png)\n\n  * 第二步：填写项目信息和坐标。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-4.png)\n\n  * 第三步：设置maven的信息。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-8.png)\n\n  * 创建成功maven版web项目的结构图：\n    * 显然，按照 maven archetype 原型创建的 maven web 工程缺少 maven 项目的完整结构：src-main-java / resources，src-test-java/resources，所以需要我们手动添加文件目录。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-9.png)\n\n  * 创建缺省文件夹：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603172124.png)\n\n  * 把文件夹标识为源码文件夹：\n    * File -> Project Structure, 选择Modules：右边找到java这层机构，在上面有个“Mask as”, 点下Sources，表示这里面是源代码类。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-11.png)\n\n\n\n# 依赖管理\n\n* 依赖的范围：compile、test、provided，默认采用 compile\n\n  |                    | compile | test | provided |\n  | ------------------ | ------- | ---- | -------- |\n  | 对主程序是否有效   | 是      | 否   | 是       |\n  | 对测试程序是否有效 | 是      | 是   | 是       |\n  | 是否参与打包       | 是      | 否   | 否       |\n  | 是否参与部署       | 是      | 否   | 否       |\n\n* 依赖范围的作用：指明当前依赖在maven构建项目的那些阶段中存在。\n\n* 依赖范围可以使用scope标签指定。例如：\n\n  ```xml\n  <dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>5.1.40</version>\n    <scope>compile</scope>\n  </dependency>\n  ```\n\n* test：在只需要测试阶段时设置。\n\n* provided：在不识数，由服务器提供jar包，项目本身不需要自带。\n\n\n\n# Maven常用设置\n\n\n\n## 全局变量\n\n* 在 Maven 的 pom.xml 文件中，\\<properties>用于定义全局变量，POM 中通过${property_name}的形式引用变量的值。\n\n* 定义全局变量：\n\n  ```xml\n  <properties>\n    <spring.version>4.3.10.RELEASE</spring.version>\n  </properties>\n  ```\n\n* 引用全局变量：\n\n  ```xml\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n    <version>${spring.version}</version>\n  </dependency>\n  ```\n\n* Maven 系统采用的变量：\n\n  ```xml\n  <properties>\n    <!--源码编译 jdk 版本--> \n    <maven.compiler.source>1.8</maven.compiler.source> \n    <!--运行代码的 jdk 版本-->\n    <maven.compiler.target>1.8</maven.compiler.target> \n    <!--项目构建使用的编码，避免中文乱码-->\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> \n    <!--生成报告的编码-->\n    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding> \n  </properties>\n  ```\n\n\n\n## 指定资源位置\n\n* src/main/java 和 src/test/java 这两个目录中的所有*.java 文件会分别在 comile 和 test-comiple 阶段被编译，编译结果分别放到了 target/classes 和 targe/test-classes 目录中，但是这两个目录中的其他文件都会被忽略掉。\n\n* 如果需要把 src 目录下的文件包放到 target/classes 目录，作为输出的 jar 一部分。需要指定资源文件位置。以下内容放到\\<buid>标签中。\n\n  ```xml\n  <build>\n    <resources>\n      <resource>\n        <!--所在的目录-->\n        <directory>src/main/java</directory>\n        <!--包括目录下的.properties,.xml 文件都会扫描到-->\n        <includes>\n          <include>**/*.properties</include>\n          <include>**/*.xml</include>\n        </includes>\n        <!--filtering 选项 false 不启用过滤器， *.property 已经起到过滤的作用了 -->\n        <filtering>false</filtering>\n      </resource>\n    </resources>\n  </build>\n  ```\n\n* 此功能的用处：在mybais中，有可能会在src/main/java中创建mapper.xml文件。如果不配置此功能，这些xml文件就无法编译到target目录中。\n\n* 因此在使用mybatis中，需配置此功能。\n\n\n\n# Maven的多模块结构\n\n* 在一个项目中，有可能被分割成很多的模块，类似于搭积木时的积木。此时使用maven管理整个项目，又是如何管理各个模块之间的依赖关系呢？\n* 场景描述：\n  * commonModel：提供公共的基础服务，比如工具类、常量类等等；\n  * bussinessModel：业务模块，是系统真正要实现的业务，依赖于 common 模块，比如订单管理、财务统计、会员管理等；\n  * application：可发布的 web 应用，由各个 bussinessModel 组成，最终满足项目整体需求；\n  * 第三方模块：包括各类框架，Spring、MyBatis、日志等。整个应用都是依赖它们完成开发的；\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170731.png)\n\n\n\n# 多模块的实现\n\n* Maven 管理多模块应用的实现是互联网项目中多使用分布式开发，那么每个独立的服务都会使用独立的项目进行维护，那么这样就需要使用多模块应用管理，来实现项目的高度统一。\n\n\n\n## 实现方式一\n\n* 项目名称：maven-modules-project。\n\n* 完成功能：使用 IntelliJ IDEA 实现 Maven 管理多模块的应用开发。\n\n* 第一步：创建 Project 为 Empty Project\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-12.png)\n\n* 第二步：设置项目名称和项目存放位置\n\n  * Project name：项目名称\n  * Project location：项目存放位置\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-14.png)\n\n* 此时项目创建成功。\n\n  * 选择“Cencel”取消\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-15.png)\n\n  * Project空项目创建成功，如下图\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-17.png)\n\n* 第四步：创建 Maven 父工程\n\n  * 第一步：创建一个 Model 工程\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-20.png)\n\n  * 第二步：选择 Maven 工程\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-6.png)\n\n  * 第三步：设置 Module 的 GAV 坐标，并填写Moudle的名字maven-parent\n    * 注意Moudle的文件目录在总项目下\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-18.png)\n\n  * 第四步：配置导入设置\n\n    * Maven 项目被修改后，需要“手动更新”或“自动更新”，通常选择“Enable Auto-Import”\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-19.png)\n\n  * 第五步：设置父工程的 pom 文件\n\n    * 父工程的 packaging 标签的文本内容必须设置为 pom。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-21.png)\n\n  * 第六步：删除 src 目录\n\n    * 父工程要求 src 目录必须删除掉。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-23.png)\n\n* 第五步：创建子模块。\n\n  * 说明：模块名称：maven-java-001，是 maven-parent 父工程的子模块\n  * 第一步：创建一个 Model 工程\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-20.png)\n\n  * 第二步：选择 Maven 工程\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-6.png)\n\n  * 第三步：设置 Module 的 GAV 坐标，并填写Moudle的名字maven-java-001，并设置maven-parent为父工程\n\n    * Parent：选择模块的父工程\n    * GroupId：选择父工程后，默认继承父工程的 GroupId 值\n    * ArtifactId：模块的项目名称\n    * Version：选择父工程后，默认继承父工程的 Version 值\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-22.png)\n\n  * 第四步：子模块项目的 pom 文件\n\n    * parent 标签：指向父工程\n    * relativePath 标签：相对路径\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-25.png)\n\n  * 项目的结构图\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-24.png)\n\n* 第六步：设置父工程编译级别\n\n  * 执行效果：项目中会统一使用 JDK 版本和编译级别，所以项目的编译级别必须统一一致，那么将编译插件添加到父工程，子模块依然会无条件去继承父工程的插件。\n  * 指定编译级别前：在 File -> Settings -> Build, Execution, Deployment -> Compiler -> Java Compiler 查看\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-26.png)\n\n  * 在父工程的 build -> plugins 标签中添加编译插件\n\n  ```xml\n  <build>\n    <plugins>\n      <!--编译插件-->\n      <plugin>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <!--插件的版本-->\n        <version>3.5.1</version>\n        <!--编码级别-->\n        <configuration>\n          <source>1.8</source>\n          <target>1.8</target>\n          <!--编码格式-->\n          <encoding>UTF-8</encoding>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n  ```\n\n  * 指定编译级别后：在 File -> Settings -> Build, Execution, Deployment -> Compiler -> Java Compiler 查看\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-27.png)\n\n* 第七步：父工程添加依赖\n\n  * 执行后效果：在父工程dependencies标签中添加MySQL依赖，子模块会**无条件继承**父工程所有依赖。\n  * 添加 MySQL 依赖前\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-28.png)\n\n  * 添加 MySQL 依赖（父工程 pom 文件）：\n\n  ```xml\n  <dependencies>\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>5.1.43</version>\n    </dependency>\n  </dependencies>\n  ```\n\n  * 添加 MySQL 依赖后\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-29.png)\n\n* 第八步：父工程管理依赖版本号\n\n  * 以上写做法，子模块会无条件继承父工程的所有依赖，导致的问题是，本不需要的继承的依赖也会被继承，这就大大增加了项目模块最终打包的大小，也可能未上线埋下了隐患。\n  * 也就是说，**父工程管理的是所有项目模块的依赖**，而不是某一个项目模块的依赖，所以某一个项目模块不需要继承父工程中的所有依赖，这就需要子项目模块向父工程声明需要的依赖即可（**声明式依赖**）。而此时，父工程实际只需要管理依赖的版本号即可。\n  * 父工程添加 dependencyManagement 前。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-29.png)\n\n  * 父工程添加 dependencyManagement 标签管理依赖。\n\n  ```xml\n  <dependencyManagement>\n    <dependencies>\n      <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>5.1.43</version>\n      </dependency>\n    </dependencies>\n  </dependencyManagement>\n  ```\n\n  * 父工程添加 dependencyManagement 后。\n\n    * 子模块项目之前继承的依赖消失，由于父工程通过 dependencyManagement 标签管理依赖，那么之前子模块无条件继承的依赖就全部消失。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-28.png)\n\n  * 父工程添加 properties 管理版本号。\n\n    * 在 properties 标签中，可以自定义标签名称来管理依赖的版本号，通常自定义的标签名称由“项目名称”+version 英文单词构成。被管理的依赖版本号由“${算定标签名称}”来代替。\n\n    ```xml\n    <!--管理依赖的版本号-->\n    <properties>\n      <!--自定义标签-->\n      <mysql-connector-java-version>5.1.43</mysql-connector-java-version>\n    </properties>\n    <!--管理依赖-->\n    <dependencyManagement>\n      <dependencies>\n        <dependency>\n          <groupId>mysql</groupId>\n          <artifactId>mysql-connector-java</artifactId>\n          <version>${mysql-connector-java-version}</version>\n        </dependency>\n      </dependencies>\n    </dependencyManagement>\n    ```\n\n  * 子模块声明式添加依赖。\n\n    * 由于父工程管理依赖的版本号，那么**子模块要想继承依赖，只能通过声明式来添加依赖**，实际上，子模块中的依赖是继承父工程依赖的版本号；**如果子模块已定义依赖版本号，那么以子模块定义的版本号为准**。\n\n    ```xml\n    <dependencies>\n      <!--实际上继承夫工程依赖版本号-->\n      <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n      </dependency>\n    </dependencies>\n    ```\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-30.png)\n\n\n\n## 实现方式二\n\n* 项目名称：maven-parent\n\n* 完成功能：使用 IntelliJ IDEA 实现 Maven 管理多模块的应用开发\n\n* 第一步：创建 Maven 工程\n\n  * 第一步：选择 Maven，点击“Next”下一步\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-6.png)\n\n  * 第二步：设置项目坐标，设置项目名称和项目存放位置，点击“Next”下一步\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603172757.png)\n\n  * 第三步：配置导入设置\n    * Maven 项目被修改后，需要“手动更新”或“自动更新”，通常选择“Enable Auto-Import”\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-19.png)\n\n* 第二步：将 maven 工程修改为父工程\n\n  * 第一步：设置 packaging 标签的文本内容\n\n  ```\n  <packaging>pom</packaging>\n  ```\n\n  * 第二步：删除 src 目录\n\n* 第三步：父工程添加编译插件\n\n  * 执行效果：项目中会统一使用 JDK 版本和编译级别，所以项目的编译级别必须统一一致，那么将编译插件添加到父工程，子模块依然会无条件去继承父工程的插件。\n  * 添加编译插件前\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603171437.png)\n\n  * 在pom文件的build -> plugins标签中添加插件\n\n  ```xml\n  <build>\n    <plugins>\n      <!--编译插件-->\n      <plugin>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <!--插件的版本-->\n        <version>3.5.1</version>\n        <!--编码级别-->\n        <configuration>\n          <source>1.8</source>\n          <target>1.8</target>\n          <!--编码格式-->\n          <encoding>UTF-8</encoding>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n  ```\n\n  * 添加编译插件后\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-27.png)\n\n* 第四步：创建子模块maven-java-001\n\n  * 第一步：选择 New Module\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-20.png)\n\n  * 第二步：选择 maven 项目\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-6.png)\n\n  * 第三步：设置子模块坐标及父工程，设置模块名称及存放位置\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603173030.png)\n\n* 第五步：子模块 pom 文件\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <parent>\n      <artifactId>maven-parent</artifactId>\n      <groupId>com.lc</groupId>\n      <version>1.0.0</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n    <artifactId>maven-java-001</artifactId>\n  </project>\n  ```\n\n* 第六步：父工程 pom 文件\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>com.lc</groupId>\n    <artifactId>maven-parent</artifactId>\n    <version>1.0.0</version>\n    <modules>\n      <module>maven-java-001</module>\n    </modules>\n    <packaging>pom</packaging>\n    <build>\n      <plugins>\n        <!--编译插件-->\n        <plugin>\n          <artifactId>maven-compiler-plugin</artifactId>\n          <!--插件的版本-->\n          <version>3.5.1</version>\n          <!--编码级别-->\n          <configuration>\n            <source>1.8</source>\n            <target>1.8</target>\n            <!--编码格式-->\n            <encoding>UTF-8</encoding>\n          </configuration>\n        </plugin>\n      </plugins>\n    </build>\n  </project>\n  ```\n\n* 项目视图\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603173218.png)\n\n* 第七步：添加依赖\n\n  * 执行后效果：在父工程的 dependencies 标签里添加 MySQL 依赖，子模块会无条件继承父工程所有依赖。\n  * 添加 MySQL 依赖前\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-28.png)\n\n  * 添加 MySQL 依赖\n\n  ```xml\n  <dependencies>\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>5.1.43</version>\n    </dependency>\n  </dependencies>\n  ```\n\n  * 添加 MySQL 依赖后（父工程 pom 文件）\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210603170601-29.png)\n\n* 第八步：父工程管理依赖版本号\n\n  * 和实现一的方式相同。\n\n\n\n## 两种实现的区别\n\n* 实现一：\n  * 以一个project为总文件夹，project为普通的Java空项目，maven的父项目和子项目都在此文件夹下。\n* 实现二：\n  * 以maven的父项目为总文件夹，maven的子项目在父项目的文件夹下。\n\n\n\n","categories":["Java学习","集成工具的使用"]},{"title":"Git和其衍生产品","url":"/2021/06/02/尚硅谷说Java/集成工具的使用/Git和其衍生产品/","content":"\n* 包含Git，GitHub，Gitee，GitLab的搭建和命令。以及他们对于IDEA的集成。\n\n<!--more-->\n\n# Git简介\n\n* ‎Git 是一个**免费**和**开源**<font color=\"red\">分布式版本控制系统</font>，旨在以速度和效率处理从小型到非常大型项目的所有问题。\n* Git易于学习，足迹很小，性能快闪电。它超越了SCM工具，如颠覆，CVS，Perforce，和ClearCase的功能，如便宜的本地分支，方便的中转区，和多个工作流程。\n\n\n\n## 版本控制\n\n* 版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。\n* 版本控制其实最重要的是可以**记录文件修改历史记录**，从而让用户能够查看历史版本，方便版本切换。\n* 版本控制出现的原因：个人开发过渡到团队协作。\n\n\n\n## 版本控制工具\n\n* 集中式版本控制工具：CVS、**SVN**(Subversion)、VSS……\n\n  * 集中化的版本控制系统诸如 CVS、SVN 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。\n  * 这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。\n  * 事分两面，有好有坏。这么做显而易见的缺点是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002.png)\n\n* 分布式版本控制工具：**Git**、Mercurial、Bazaar、Darcs……\n\n  * 像 Git 这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。\n\n* 分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷:\n\n  * \\1. 服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）\n  * \\2. 每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全）\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-1.png)\n\n\n\n## Git简史\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-2.png)\n\n\n\n## Git工作机制\n\n* 在工作区和暂存区，删除代码是没有记录的。但在本地库中就会产生历史版记录。\n  * 工作区：一般为代码存放的目录。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-3.png)\n\n## Git和代码托管中心\n\n* 代码托管中心是基于网络服务器的远程代码仓库，一般我们简单称为**远程库**。\n* 局域网：GitLab\n* 互联网：\n  * GitHub (外网)\n  * Gitee 码云(国内网站)\n\n\n\n## Git安装\n\n* 第一步：打开官网：https://git-scm.com/。点击下载。\n\n* 第二步：下载后点击安装。选择安装的路径，要求是非中文并且没有空格的目录，然后下一步。\n\n* 第三步：Git选项配置，推荐默认设置。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-4.png)\n\n* 第四步：Git 安装目录名，不用修改，直接点击下一步。\n\n* 第五步：Git的默认编辑器。建议使用Vim编辑器。然后点击下一步。\n\n* 第六步：默认分支名设置，选择让 Git 决定，分支名默认为 master，下一步。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-5.png)\n\n* 第七步：修改Git的环境变量，选第一个，不修改环境变量，只在 Git Bash 里使用 Git。下一步。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-6.png)\n\n* 第八步：选择后台客户端连接协议，选默认值 OpenSSL，然后下一步。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-7.png)\n\n* 第九步：配置 Git 文件的行末换行符，Windows 使用 CRLF，Linux 使用 LF，选择第一个自动转换，然后继续下一步。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-8.png)\n\n* 第十步：选择Git终端类型。下一步。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-9.png)\n\n* 第十一步：选择 Git pull 合并的模式，选择默认。下一步。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-10.png)\n\n* 第十二步：选择 Git 的凭据管理器，选择默认的跨平台的凭据管理器，然后下一步。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-11.png)\n\n* 第十三步：其他配置，选择默认设置，然后下一步。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-12.png)\n\n* 第十四步：实验室功能，技术还不成熟，有已知的 bug，不要勾选，然后点击右下角的 Install按钮，开始安装 Git。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-13.png)\n\n* 第十五步：点击Finsh按钮，Git安装成功。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-14.png)\n\n* 安装成功测试：桌面右击，选择 Git Bash Here打开Git Bash命令行终端。\n\n* 输入git --version出现版本号几位安装成功。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-15.png)\n\n\n\n# Git常用命令\n\n* 常用命令：\n\n| 命令名称                             | 作用                           |\n| ------------------------------------ | ------------------------------ |\n| git config --global user.name 用户名 | 设置用户签名                   |\n| git config --global user.email  邮箱 | 设置用户签名                   |\n| git init                             | 初始化本地库                   |\n| git status                           | 查看本地库状态                 |\n| git add                              | 文件名 添加到暂存区            |\n| git commit -m                        | \"日志信息\" 文件名 提交到本地库 |\n| git reflog                           | 查看历史记录                   |\n| git reset --hard 版本号              | 版本穿梭                       |\n\n\n\n## 设置用户签名\n\n* 基本语法：\n\n  * git config --global user.name 用户名\n  * git config --global user.email 邮箱 \n\n* 实例：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-16.png)\n\n* 说明：\n\n  * 签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。**Git 首次安装必须设置一下用户签名，否则无法提交代码。**\n\n* 注意：这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。\n\n\n\n## 初始化本地库\n\n* 基本语法：git  init\n* 注意：\n  * 在哪个路径下执行初始化本地库命令，本地库就会放在哪里。\n  * 本地库的位置一般不要有其他文件夹存在。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-17.png)\n\n* 命令： \n  * ll  表示查看当前文件夹下的文件。加上-a表示隐藏文件也查看\n\n\n\n## 查看本地库状态\n\n* 基本语法：git status\n* 实例：\n  \n  * 首次查看\n    * 工作区没有任何文件。\n    * On branch master ：表示当前位于master分支。\n    * No commits yet ：表示当前没有提交过任何东西。因为是刚创建的。\n    * nothing to commit ：表示暂存区中当前没有需要提交的文件。\n  \n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-18.png)\n  \n  * 新增文件\n    * 使用vim方式编译文件。\n  \n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-19.png)\n  \n  * 再次查看\n    * 检测到未追踪的文件。\n    * 文件为红色，表示文件位于工作区，未添加到暂存区。\n  \n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-20.png)\n\n\n\n## 添加暂存区\n\n* 基本语法：git add 文件名\n\n* 实例：\n\n  * warning：表示警告。CRLF的换行将被转换成LF换行。警告一般不用管。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-21.png)\n\n  * 查看添加后的状态：\n    * 检测到暂存区有新文件(一般显示为绿色)\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-22.png)\n\n\n\n## 提交本地库\n\n* 基本语法：git commit -m \"日志信息\" 文件名。\n\n  * 日志信息一般为此次添加的说明性文字。\n  * -m表示填写日志信息。如果不写-m，也会弹出输入框，让写日志信息。\n\n* 实例：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-23.png)\n\n  * 查看提交后的状态\n    * 没有文件需要提交\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-24.png)\n\n\n\n## 修改文件\n\n* 修改文件\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-25.png)\n\n* 查看修改后的文件：\n\n  * 检测到工作区有文件被修改(红色显示)\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-26.png)\n\n* 添加到暂存区\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-27.png)\n\n* 查看状态\n\n  * 工作区的修改添加到了暂存区(绿色显示)\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-28.png)\n\n\n\n## 查看历史版本\n\n* 基本语法：\n\n  * git reflog  查看所有版本的精简信息。\n    * 此时查看的版本号为精简版的，是完整版版本号的前七位。\n  * git log  查看当前版本的详细信息。\n    * 此时查看的版本号是完整版的。\n\n* 实例：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-29.png)\n\n\n\n## 穿梭历史版本\n\n* 基本语法：git reset --hard  版本号\n\n* 实例：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-30.png)\n\n* Git 切换版本，底层其实是移动的 HEAD 指针。\n\n\n\n# Git分支操作\n\n\n\n## 什么是分支\n\n* 在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。\n\n* 对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用）。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-31.png)\n\n* 分支的好处：\n\n  * 同时并行推进多个功能开发，提高开发效率。\n  * 各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。\n\n* 分支的操作\n\n| 命令名称             | 作用                         |\n| -------------------- | ---------------------------- |\n| git branch 分支名    | 创建分支                     |\n| git branch -v        | 查看分支                     |\n| git checkout  分支名 | 切换分支                     |\n| git merge  分支名    | 把指定的分支合并到当前分支上 |\n\n\n\n## 查看分支\n\n* 基本语法：git branch -v\n\n  * git branch：也能查看分支，但只能看到分支名。加上-v能看到更多的信息。\n\n* 实例\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-32.png)\n\n\n\n## 创建分支\n\n* 基本语法：git branch 分支名\n\n  * 此时查看.git\\refs\\heads目录下可以看到有两个文件，分别对应hot-fox分支和master分支\n\n* 实例：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-33.png)\n\n\n\n## 修改分支\n\n* 即修改分支上的数据，以修改master分支上的数据为例。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-34.png)\n\n\n\n## 切换分支\n\n* 基本语法：git checkout 分支名\n\n* 实例：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-35.png)\n\n\n\n## 合并分支\n\n* 基本语法：git merge 分支名\n\n  * 把指定分支合并到当前分支上。\n\n* 实例\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-36.png)\n\n\n\n## 冲突产生\n\n* 冲突产生的表现：后面状态为 MERGING。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-37.png)\n\n* 冲突产生的原因：\n\n  * 合并分支时，两个分支在**同一个文件的同一个位置**有两套完全不同的修改。Git 无法替我们决定使用哪一个。必须**人为决定新代码内容**。\n    * 此时的文件都在对应分支的本地库中。\n\n* 查看状态：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-38.png)\n\n\n\n## 解决冲突\n\n* 编辑有冲突的文件，删除特殊符号，决定要使用的内容\n  * 特殊符号：<<<<<<< HEAD 当前分支的代码 ======= 合并过来的代码 >>>>>>> hot-fix\n* 第一步：手动编译此代码，决定保留哪一部分内容。\n* 第二步：添加到暂存区。\n* 第三步：提交到本地库。(注意：此时使用git commit命令时不能带有文件名)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-39.png)\n\n\n\n## 图解分支原理\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210531212002-40.png)\n\n* master、hot-fix 其实都是指向具体版本记录的指针。当前所在的分支，其实是由 HEAD决定的。所以创建分支的本质就是多创建一个指针。\n* HEAD 如果指向 master，那么我们现在就在 master 分支上。\n* HEAD 如果执行 hotfix，那么我们现在就在 hotfix 分支上。\n* 所以切换分支的本质就是移动 HEAD 指针。\n\n\n\n# Git团队协作机制\n\n* 团队协作的基础是有一个远程库。\n\n\n\n## 团队内协作\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155.png)\n\n* 第一步：岳不群创建一个本地库。并别写项目。然后通过push命令将本地库的项目上传到远程库中。\n* 第二步：令狐冲创建一个本地库。然后通过clone指令将远程库的代码全部下载到本地库中。\n* 第三步：令狐冲对本地库的项目进行了修改，然后通过push指令将修改后的项目提交到远程库中。\n* 第四步：岳不群看到远程库更新了版本，在本地库已有项目的基础上，通过pull指令拉取远程库的项目，并更新自己的本地库。\n\n## 跨团队协作\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-1.png)\n\n* 第一步：岳不群将自己的本地库代码通过push上传到远程库。\n* 第二步：另一个团队的东方不败也要使用岳不群的远程库代码。因此通过fork指令创建一个分支，将岳不群远程库的代码克隆到东方不败远程库中。\n* 第三步：东方不败从自己的远程库中通过clone指令将代码下载到自己的本地库中。\n* 第四步：东方不败再修改代码后，再通过push指令上传到自己的远程库中。\n* 第五步：东方不败冲自己的远程库中发送Pull request指令到岳不群远程库，为了告诉岳不群我已经更新了项目，让岳不群进行合并分支操作。\n* 第六步：岳不群对东方不败的远程库进行审核后，通过merge指令合并东方不败远程库到自己的远程库。\n* 第七步：岳不群通过pull指令将自己远程库的内容更新到本地库。此时本地库会有最新的内容，包含自己的和东方不败修改的。\n\n\n\n#  GitHub操作\n\n* 笑称：GitHub是全球最大同性交友网站，技术宅男的天堂，新世界的大门。\n* 首先要有github的账号。\n* 加速访问github的软件：https://gitee.com/docmirror/dev-sidecar\n\n\n\n## 创建远程仓库\n\n* 第一步：创建仓库\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-2.png)\n\n* 第二步：填写仓库信息\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-3.png)\n\n\n\n## 操作远程仓库\n\n* 操作指令\n\n| 命令名称                           | 作用                                                     |\n| ---------------------------------- | -------------------------------------------------------- |\n| git remote -v                      | 查看当前所有远程地址别名                                 |\n| git remote add 别名 远程地址       | 起别名                                                   |\n| git push 别名 分支                 | 推送本地分支上的内容到远程仓库                           |\n| git clone 远程地址                 | 将远程仓库的内容克隆到本地                               |\n| git pull 远程库地址别名 远程分支名 | 将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并 |\n\n\n\n### 起别名\n\n* 基本语法：\n\n  * git remote -v  查看当前本地库的所有原乘地址别名\n  * git remote add 别名 远程地址  将远程地址对应的仓库与本地库连接，并为远程仓库起个别名。\n\n* 远程地址：\n\n  * **这个地址在创建完远程仓库后生成的连接，如图所示红框中**\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-4.png)\n\n* 实例：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-5.png)\n\n\n\n### 推送本地到远程仓库\n\n* 基本语法：git push 别名 分支\n\n  * 别名：为远程仓库的别名。\n  * 分支：为本地库的分支名。一般推送master分支。\n\n* 推送过程中可能会弹出将github和git绑定的弹窗，选择第一个根据浏览器账户绑定即可。\n\n* 实例：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-6.png)\n\n* 推送结果：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-7.png)\n\n\n\n### 克隆远程仓库带本地\n\n* 基本语法：git clone 远程地址\n\n  * 此命令会执行的操作：1、拉取代码。2、初始化本地仓库。3、创建别名\n  * 执行克隆命令可以在没有本地仓库的地方执行。\n  * 对于公共库，克隆代码是不需要登陆绑定账号的。\n  * 创建别名时，默认别名为origin\n\n* 实例：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-8.png)\n\n* 结果：克隆后创建的本地仓库的内容会和远程仓库的一样。\n\n\n\n### 邀请加入团队\n\n* 第一步：选择邀请者\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-9.png)\n\n* 第二步：填入要合作的人\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-10.png)\n\n* 第三步：复制地址并通过聊天工具的方式发送给要合作的人。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-11.png)\n\n* 第四步：合作的人在自己账号的地址栏中复制收到的邀请链接。点击接受邀请。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-12.png)\n\n* 第五步：成功后，可以在合作的人的账户上看到远程仓库。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-13.png)\n\n* 此时合作的人如果更新了远程仓库，则你是会看见的。\n\n\n\n### 拉取远程仓库内容\n\n* 基本语法：git pull 远程仓库地址别名 远程分支名\n\n  * 拉取后的数据会和本地数据进行合并。\n\n* 实例：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-14.png)\n\n\n\n## 跨团队协作\n\n* 第一步：将远程仓库的地址发送给邀请跨团队协作的人，比如东方不败。\n\n* 第二步：\n\n  * 东方不败的登录自己的 GitHub 账号\n  * 然后再浏览器地址栏中复制收到的链接，然后访问，然后点击 Fork 将项目叉到自己的本地仓库\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-15.png)\n\n  * 叉入中\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-16.png)\n\n  * 叉入成后\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-17.png)\n\n* 东方不败就可以在线编辑叉取过来的文件。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-18.png)\n\n* 编辑完毕后，填写描述信息并点击左下角绿色按钮提交。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-19.png)\n\n* 接下来点击上方的 Pull 请求，并创建一个新的请求\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-20.png)\n\n* 回到岳岳 GitHub 账号可以看到有一个 Pull request 请求。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-21.png)\n\n  * 进入到聊天室，可以讨论代码相关内容。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-22.png)\n\n* 如果代码没有问题，可以点击 Merge pull reque 合并代码。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-23.png)\n\n\n\n## SSH免密登录\n\n* 我们可以看到远程仓库中还有一个 SSH 的地址，因此我们也可以使用 SSH 进行访问。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-24.png)\n\n* 具体操作如下：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-25.png)\n\n* 复制 id_rsa.pub 文件内容，登录 GitHub，点击用户头像→Settings→SSH and GPG keys\n\n  <img src=\"https://gitee.com/plumChuan/picture-bed/raw/master/img/20210601111155-26.png\" style=\"zoom: 67%;\" />\n\n* 接下来再往远程仓库 push 东西的时候使用 SSH 连接就不需要登录了。\n\n\n\n# IDEA集成Git\n\n\n\n## 配置忽略文件\n\n* 忽略文件：\n\n  * 指在IDEA创建项目时，除了src目录下的文件和pom.xml文件，其他的文件都不是必需的。\n  * Eclipse创建项目也有这样的情况。同时maven工程的项目还忽悠大量的.class文件产生。\n\n* 配置忽略文件的目的：在git上传时只上传主要的代码和相关的配置文件。与实际功能无关的文件不要上传。\n\n* 步骤：\n\n  * 第一步：创建忽略规则文件xxx.ignore(文件名随便起，但文件类型不能变)\n  * 第二步：此文件理论上放在哪里都行，但为了管理方便，一般放在c盘的用户目录下。\n  * 第三步：文件模板为：\n\n  ```ini\n  # Compiled class file\n  *.class\n  # Log file\n  *.log\n  # BlueJ files\n  *.ctxt\n  # Mobile Tools for Java (J2ME)\n  .mtj.tmp/\n  # Package Files #\n  *.jar\n  *.war\n  *.nar\n  *.ear\n  *.zip\n  *.tar.gz\n  *.rar\n  # virtual machine crash logs, see \n  http://www.java.com/en/download/help/error_hotspot.xml\n  hs_err_pid*\n  .classpath\n  .project\n  .settings\n  target\n  .idea\n  *.iml\n  ```\n\n  * 第四步：在git的配置文件中引用这个忽略规则文件。git的配置文件也在c盘的用户目录下。\n\n    * git的配置文件叫.gitconfig\n\n    ```ini\n    [user]\n    \t\tname = xxx\n    \t\temail = xxxxx\n    [core]\n    \t\texcludesfile = C:/Users/asus/git.ignore\n    # 注意：这里要使用“正斜线（/）”，不要使用“反斜线（\\）”\n    ```\n\n\n\n## IDEA添加Git\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240.png)\n\n\n\n## IDEA对Git的基本操作\n\n* 第一步：初始化本地库\n\n  * 初始化后可以看到此项目目录下有一个.git文件夹。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-1.png)\n\n  * 选择要初始化的项目\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-2.png)\n\n* 第二步：添加到暂存区\n\n  * 右键点击项目选择 Git -\\> Add 将项目添加到暂存区。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-3.png)\n\n* 第三步：提交到本地库\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-4.png)\n\n* 说明：对于正在编写的代码\n\n  * 如果左侧的.java文件是红色的表示未添加，未跟踪。\n  * 如果左侧的.java文件是篮色的表示未添加，已跟踪。\n  * 如果左侧的.java文件是绿色的表示未提交。\n  * 如果左侧的.java文件是黑色的表示已经提交了。\n\n\n\n## 版本切换\n\n* 在IDEA的最下方，有一个Git或者Version Control。点击然后再点击log。此时就能够看到版本的信息了。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-5.png)\n\n* 右击对应的版本选择切换即可。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-6.png)\n\n\n\n## 分支的操作\n\n* 创建分支：\n\n  * 右击项目，选择 Git，在 Repository 里面，点击 Branches 按钮。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-7.png)\n\n  * 在弹出的 Git Branches 框里，点击 New Branch 按钮。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-8.png)\n\n  * 填写分支名称，创建 hot\\-fix 分支。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-9.png)\n\n  * 然后再 IDEA 的右下角看到 hot\\-fix，说明分支创建成功，并且当前已经切换成 hot\\-fix 分支。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-10.png)\n\n* 切换分支：\n\n  * 再IDEA 的下方，找到版本信息，对应的也会有分支信息。\n  * 右击要切换到哪个分支，选择checkout即可。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-11.png)\n\n  * 在分支信息中，令牌标志位于哪个分支，即当前就位于哪个分支。\n  * 在 IDEA 窗口的右下角看到了 master，说明 分支切换到了master 。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-12.png)\n\n* 合并分支：\n\n  * 在切换到主分治后，在 IDEA 窗口的右下角，将 hot\\-fix 分支合并到当前 master 分支。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-13.png)\n\n  * 如果代码没有冲突，分支直接合并成功，分支合并成功以后，代码自动提交，无需手动提交本地库。\n\n* 分支冲突：\n\n  * 如果在master分支和hot-fox分支都修改了代码，在合并分支的时候就会发生冲突。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-14.png)\n\n  * 我们现在站在 master 分支上合并 hot\\-fix 分支，就会发生代码冲突。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-15.png)\n\n  * 点击 Conflicts 框里的 Merge 按钮，进行手动合并代码。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-16.png)\n\n  * 手动合并完代码以后，点击右下角的 Apply 按钮。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-17.png)\n\n  * 代码冲突解决，自动提交本地库。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-18.png)\n\n\n\n# IDEA集成GitHub\n\n* IDEA默认是有GitHub插件的，如果没有安装一个即可\n\n\n\n## 设置GitHub账户\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-19.png)\n\n* 如果出现 401 等情况连接不上的，是因为网络原因，可以使用以下方式连接：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-20.png)\n\n  * 然后去 GitHub 账户上设置 token。\n\n* GitHub设置token\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-21.png)\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-22.png)\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-23.png)\n\n  * 点击生成Token\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-24.png)\n\n  * 复制红框中的字符串到 idea 中。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-25.png)\n\n  * 点击登录。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-26.png)\n\n\n\n## 分享工程到GitHub\n\n* 即将IDEA 和GitHub上的仓库相对应\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-27.png)\n\n* 来到 GitHub 中发现已经帮我们创建好了 gitTest 的远程仓库。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-28.png)\n\n\n\n## push 推送本地库到远程库\n\n* 右键点击项目，可以将当前分支的内容 push 到 GitHub 的远程仓库中。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-29.png)\n\n  * 创建别名\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-30.png)\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-31.png)\n\n* 注意：push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，push 的操作是会被拒绝的。也就是说，要想 push 成功，一定要保证本地库的版本要比远程库的版本高！\n\n* 因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地代码的区别！如果本地的代码版本已经落后，切记要先 pull 拉取一下远程库的代码，将本地代码更新到最新以后，然后再修改，提交，推送！\n\n\n\n## pull 拉取远程库到本地库\n\n* 右键点击项目，可以将远程仓库的内容 pull 到本地仓库。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-32.png)\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-33.png)\n\n* 注意：pull 是拉取远端仓库代码到本地，如果远程库代码和本地库代码不一致，会自动合并，如果自动合并失败，还会涉及到手动解决冲突的问题。\n\n\n\n## clone 克隆远程库到本地\n\n* 创建一个空文件。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-34.png)\n\n\n\n# GitEE\n\n* 码云是开源中国推出的基于 Git 的代码托管服务中心，网址是 https://gitee.com/ ，使用方式跟 GitHub 一样，而且它还是一个中文网站，如果你英文不是很好它是最好的选择。\n\n\n\n## 创建远程库\n\n* 点击首页右上角的加号，选择下面的新建仓库\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-35.png)\n\n* 填写仓库名称，路径和选择是否开源（共开库或私有库）\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-36.png)\n\n* 最后根据需求选择分支模型，然后点击创建按钮。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-37.png)\n\n* 远程库创建好以后，就可以看到 HTTPS 和 SSH 的链接。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-38.png)\n\n\n\n## IDEA集成码云\n\n* Idea 默认不带码云插件，我们第一步要安装 Gitee 插件。\n\n* 如图所示，在 Idea 插件商店搜索 Gitee，然后点击右侧的 Install 按钮。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-39.png)\n\n* Idea 链接码云和链接 GitHub 几乎一样，安装成功后，重启 Idea。\n\n* Idea 重启以后在 Version Control 设置里面看到 Gitee，说明码云插件安装成功。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-40.png)\n\n* 然后在码云插件里面添加码云帐号，我们就可以用 Idea 连接码云了。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-41.png)\n\n\n\n## IDEA操作码云\n\n* Idea 连接码云和连接 GitHub 几乎一样，首先在 Idea 里面创建一个工程，初始化 git 工程，然后将代码添加到暂存区，提交到本地库。\n\n* 将本地代码 push 到码云远程库：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-42.png)\n\n  * 自定义远程库链接。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-43.png)\n\n  * 给远程库链接定义个 name，然后再 URL 里面填入码云远程库的 HTTPS 链接即可。码云服务器在国内，用 HTTPS 链接即可，没必要用 SSH 免密链接。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-44.png)\n\n  * 然后选择定义好的远程链接，点击 Push 即可。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-45.png)\n\n  * 只要码云远程库链接定义好以后，对码云远程库进行 pull 和 clone 的操作和 Github 一致。\n\n\n\n## 码云复制GitHub的项目\n\n* 码云提供了直接复制 GitHub 项目的功能，方便我们做项目的迁移和下载。\n\n* 具体操作如下：\n\n  * 新建项目时选择导入GitHub项目\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-46.png)\n\n  * 将 GitHub 的远程库 HTTPS 链接复制过来，点击创建按钮即可。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-47.png)\n\n  * 如果 GitHub 项目更新了以后，在码云项目端可以手动重新同步，进行更新！\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-48.png)\n\n\n\n# GitLab\n\n* GitLab 是由 GitLabInc.开发，使用 MIT 许可证的基于网络的 Git 仓库管理工具，且具有wiki 和 issue 跟踪功能。使用 Git 作为代码管理工具，并在此基础上搭建起来的 web 服务。\n* GitLab 由乌克兰程序员 DmitriyZaporozhets 和 ValerySizov 开发，它使用 Ruby 语言写成。后来，一些部分用 Go 语言重写。截止 2018 年 5 月，该公司约有 290 名团队成员，以及 2000 多名开源贡献者。GitLab 被 IBM，Sony，JülichResearchCenter，NASA，Alibaba，Invincea，O’ReillyMedia，Leibniz-Rechenzentrum(LRZ)，CERN，SpaceX 等组织使用。\n* 官网地址：https://about.gitlab.com/\n* 安装说明：https://about.gitlab.com/installation/\n\n\n\n## GitLab安装\n\n* 服务器准备：\n\n  * 准备一个系统为 CentOS7 以上版本的服务器，要求内存 4G，磁盘 50G。\n  * 关闭防火墙，并且配置好主机名和 IP，保证服务器可以上网。\n\n* 安装包准备：\n\n  * Yum 在线安装 gitlab\\- ce 时，需要下载几百 M 的安装文件，非常耗时，所以最好提前把所需 RPM 包下载到本地，然后使用离线 rpm 的方式安装。\n  * 将本地文件上传到虚拟机可以使用Xshell和Xshell的Xftp软件。\n  * 下载地址：https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-13.10.2ce.0.el7.x86_64.rpm\n  * 安装命令：\n    * 首先安装依赖包：yum install policycoreutils-python\n    * 然后安装gitlab：rpm -ivh gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm\n\n* 使用脚本的方式安装gitlab：\n\n  * 安装 gitlab 步骤比较繁琐，因此我们可以参考官网编写 gitlab 的安装脚本。\n\n  ```shell\n  [root@gitlab-server module]# vim gitlab-install.sh\n  sudo rpm -ivh /opt/module/gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm\n  sudo yum install -y curl policycoreutils-python openssh-server cronie\n  sudo lokkit -s http -s ssh\n  sudo yum install -y postfix\n  sudo service postfix start\n  sudo chkconfig postfix on\n  curl https://packages.gitlab.com/install/repositories/gitlab/gitlab\u0002ce/script.rpm.sh | sudo bash\n  sudo EXTERNAL_URL=\"http://gitlab.example.com\" yum -y install gitlab\u0002ce\n  ```\n\n  * 给脚本增加执行权限。\n\n  ```shell\n  [root@gitlab-server module]# chmod +x gitlab-install.sh\n  [root@gitlab-server module]# ll\n  总用量 403104\n  -rw-r--r--. 1 root root 412774002 4 月 7 15:47 gitlab-ce-13.10.2-\n  ce.0.el7.x86_64.rpm\n  -rwxr-xr-x. 1 root root 416 4 月 7 15:49 gitlab-install.sh\n  ```\n\n  * 然后执行该脚本，开始安装 gitlab-ce。注意一定要保证服务器可以上网。\n\n  ```shell\n  [root@gitlab-server module]# ./gitlab-install.sh \n  警告：/opt/module/gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm: 头 V4 \n  RSA/SHA1 Signature, 密钥 ID f27eab47: NOKEY\n  准备中... ################################# \n  [100%]\n  正在升级/安装...\n   1:gitlab-ce-13.10.2-ce.0.el7 \n  ################################# [100%]\n  ```\n\n* 初始化GitLab服务\n\n  * 执行以下命令初始化 GitLab 服务，过程大概需要几分钟，耐心等待\n\n  ```shell\n  [root@gitlab-server module]# gitlab-ctl reconfigure\n  。 。 。 。 。 。\n  Running handlers:\n  Running handlers complete\n  Chef Client finished, 425/608 resources updated in 03 minutes 08 \n  seconds\n  gitlab Reconfigured!\n  ```\n\n* 启动GitLab服务\n\n  * 执行以下命令启动 GitLab 服务，如需停止，执行 gitlab-ctl stop\n\n  ```shell\n  [root@gitlab-server module]# gitlab-ctl start\n  ok: run: alertmanager: (pid 6812) 134s\n  ok: run: gitaly: (pid 6740) 135s\n  ok: run: gitlab-monitor: (pid 6765) 135s\n  ```\n\n* 使用浏览器访问 GitLab\n\n  * 使用**虚拟机的 IP 地址**即可访问 GitLab 服务。\n    * 如果无法访问，可能是虚拟机的防火墙未关闭。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-49.png)\n\n* 登录GitLab\n\n  * 首次登陆之前，需要修改下 GitLab 提供的 root 账户的密码，要求 8 位以上，包含大小写子母和特殊符号。\n  * 然后使用修改后的密码登录 GitLab。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-50.png)\n\n  * GitLab 登录成功。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-51.png)\n\n\n\n## GitLab创建远程库\n\n* 点击创建\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-52.png)\n\n* 填写信息\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-53.png)\n\n* 创建成功\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-54.png)\n\n\n\n## IDEA 集成 GitLab\n\n* 安装GitLab插件\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-55.png)\n\n* 设置GitLab插件\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210602132240-56.png)\n\n* 对Gitlab进行操作。基本和github和gitee类似。\n\n  * 在push时，需要填写账号和密码。使用root账号即可。\n\n\n\n## 虚拟机相关gitlab的命令\n\n* 启动所有服务：gitlab-ctl start\n* 关闭所有服务：gitlab-ctl stop\n* 重启所有服务：gitlab-ctl restart\n* 查看所有服务状态：gitlab-ctl status\n* 查看日志信息：gitlab-ctl tail\n* 列举所有启动服务：gitlab-ctl service-list\n* 平稳停止一个服务：gitlab-ctl graceful-kill\n* 删除gitlab数据，重新白手起家：gitlab-ctl cleanse\n* 查看所有服务配置文件信息：gitlab-ctl show-config\n* 帮助：gitlab-ctl help\n* 相关命令的博客：https://www.cnblogs.com/yitianyouyitian/p/9214940.html#_label2_3\n\n","categories":["Java学习","集成工具的使用"]},{"title":"Shiro框架","url":"/2021/05/30/尚硅谷说Java/JavaEE框架/Shiro/","content":"\nShiro是一个针对用户权限管理和登录的框架。横跨JSTL标签，控制层和业务层。可以和Spring进行集成。具有缓存功能，会话功能。\n\nShiro对于用户的权限和认证都是自动的。\n\n<!--more-->\n\n# 简介\n\n* Apache Shiro 是 Java 的一个安全（权限）框架。 \n* Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在**JavaSE** 环境，也可以用在 **JavaEE** 环境。 \n* Shiro 可以完成：认证、授权、加密、会话管理、与Web 集成、缓存等。\n* 官网：http://shiro.apache.org/。\n\n\n\n## 基本功能\n\n* 基本功能如下图\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210528180207.png)\n\n* 解释：\n\n  * *Authentication*：**身份认证/登录**，验证用户是不是拥有相应的身份；\n  * *Authorization*：**授权，即权限验证**，验证某个已认证的用户是否拥有某个权限；即判断用 户是否能进行什么操作，如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户\n    对某个资源是否具有某个权限；\n  * *Session Manager*：会话**管理**，即用户登录后就是一次会话，在没有退出之前，它的所有\n    信息都在会话中；会话可以是普通 JavaSE 环境，也可以是 Web 环境的； \n  * *Cryptography*：**加密，保护数据的安全性**，如密码加密存储到数据库，而不是明文存储；\n  * *Web Support*：**Web 支持**，可以非常容易的集成到Web 环境；\n  * *Caching*：**缓存**，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可\n    以提高效率；\n  * *Concurrency*：Shiro支持**多线程应用的并发验证**，即如在一个线程中开启另一个线程，能把权限自动传播过去；\n  * Testing：**提供测试支持**；\n  * *Run As*：**允许一个用户假装为另一个用户**（如果他们允许）的身份进行访问；\n  * *Remember Me*：**记住我**，这个是非常常见的功能，即一次登录后，下次再来的话不用登\n    录了。\n\n\n\n## 架构(从外部方向)\n\n* 从外部来看Shiro ，即从应用程序角度的来观察如何使用 Shiro 完成工作：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210528180207-1.png)\n\n* 解释：\n\n  * *Subject*：**应用代码直接交互的对象是 Subject**，也就是说 Shiro 的对外API 核心就是 Subject。**Subject 代表了当前“用户”**， 这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，如网络爬虫，机器人等；**与 Subject 的所有交互都会委托给 SecurityManager；****Subject 其实是一个门面，SecurityManager 才是实际的执行者**； \n  * *SecurityManager*：安全管理器；即**所有与安全有关的操作都会与SecurityManager 交互**；且其管理着所有 Subject；可以看出它是 **Shiro的核心**，它**负责与 Shiro 的其他组件进行交互**，它相当于 SpringMVC 中DispatcherServlet 的角色\n  * *Realm*：Shiro **从 Realm 获取安全数据（如用户、角色、权限）**，就是说SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource。\n\n\n\n## 架构(从内部方向)\n\n* 从内部来看Shiro：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210528180207-2.png)\n\n* 解释：\n\n  * *Subject*：任何可以与应用交互的“用户”；\n  * *SecurityManager* ：相当于SpringMVC 中的 DispatcherServlet；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它**管理着所有 Subject、且负责进行认证、授权、会话及缓存的管理**。\n  * *Authenticator*：**负责 Subject 认证**，是一个扩展点，可以自定义实现；可以使用认证策略（Authentication Strategy），**即什么情况下算用户认证通过了**；\n  * *Authorizer*：**授权器、即访问控制器**，用来决定主体是否有权限进行相应的操作；**即控制着用户能访问应用中的哪些功能**；\n  * *Realm*：可以有 **1 个或多个 Realm**，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC 实现，也可以是内存实现等等；由用户提供；所以一般在应用中都需要实现自己的 Realm； \n  * *SessionManager*：**管理 Session 生命周期的组件**；而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境 \n  * *CacheManager*：**缓存控制器**，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少改变，放到缓存中后可以提高访问的性能\n  * *Cryptography*：**密码模块**，Shiro 提高了一些常见的加密组件用于如密码加密/解密。\n\n\n\n# HelloWorld\n\n* 下载Shiro的项目文件：https://mirrors.bfsu.edu.cn/apache/shiro/1.3.2/shiro-root-1.3.2-source-release.zip。\n\n  * 此项目文件中包含了Shiro的各种配置，以及集成配置。\n\n* 搭建环境：\n\n  * 第一步：创建Java 项目。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210528180207-3.png)\n\n  * 第二步：导入jar包。\n\n    * jar包地址：https://plumriver.lanzoui.com/iGDgwpixbcj\n\n  * 第三步：复制文件到项目中。\n\n    * shiro配置文件shiro.ini\n\n    ```ini\n    \n    # =============================================================================\n    # 快速启动INI领域配置\n    # =============================================================================\n    \n    # -----------------------------------------------------------------------------\n    # 用户及其分配的角色\n    #\n    # 每一行都符合\n    # org.apache.shiro.realm.text.TextConfigurationRealm#setUserDefinitions JavaDoc\n    # -----------------------------------------------------------------------------\n    [users]\n    # 每个用户都有用户名，密码。以及对应的角色\n    # 用户“root”，密码为“secret”，角色为“admin”\n    root = secret, admin\n    # 用户“guest”，密码为“guest”，角色为“guest”\n    guest = guest, guest\n    # 密码为“12345”的用户“presidentskroob”，角色为“president”\n    presidentskroob = 12345, president\n    # 用户“darkhelmet”，密码为“ludicrousspeed”，角色为“darklord”和“schwartz”\n    darkhelmet = ludicrousspeed, darklord, schwartz\n    #用户“lonestar”，密码为“vespa”，角色为“goodguy”和“schwartz”\n    lonestarr = vespa, goodguy, schwartz\n    \n    # -----------------------------------------------------------------------------\n    # 具有分配权限的角色\n    # \n    # 每一行都符合\n    # org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc\n    # -----------------------------------------------------------------------------\n    [roles]\n    # “admin”角色具有所有权限，由通配符“*”表示\n    admin = *\n    # “schwartz”角色具有对“lightsaber”的操作的所有权限\n    schwartz = lightsaber:*\n    # 允许“goodguy” 对 “winnebago”类型的 名为“eagle5”的对象，进行“drive”操作\n    goodguy = winnebago:drive:eagle5\n    ```\n\n    * 日志配置文件log4j.properties\n\n    ```properties\n    log4j.rootLogger=INFO, stdout\n    \n    log4j.appender.stdout=org.apache.log4j.ConsoleAppender\n    log4j.appender.stdout.layout=org.apache.log4j.PatternLayout\n    log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n\n    \n    # General Apache libraries\n    log4j.logger.org.apache=WARN\n    \n    # Spring\n    log4j.logger.org.springframework=WARN\n    \n    # Default Shiro logging\n    log4j.logger.org.apache.shiro=TRACE\n    \n    # Disable verbose logging\n    log4j.logger.org.apache.shiro.util.ThreadContext=WARN\n    log4j.logger.org.apache.shiro.cache.ehcache.EhCache=WARN\n    ```\n\n    * 快速启动代码Quickstart.java\n\n    ```java\n    import org.apache.shiro.SecurityUtils;\n    import org.apache.shiro.authc.*;\n    import org.apache.shiro.config.IniSecurityManagerFactory;\n    import org.apache.shiro.mgt.SecurityManager;\n    import org.apache.shiro.session.Session;\n    import org.apache.shiro.subject.Subject;\n    import org.apache.shiro.util.Factory;\n    import org.slf4j.Logger;\n    import org.slf4j.LoggerFactory;\n    \n    /**\n     * 简单的快速入门应用程序，演示如何使用Shiro的API。\n     *\n     * @since 0.9 RC2\n     */\n    public class Quickstart {\n    \n      private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class);\n    \n      public static void main(String[] args) {\n    \n        // 创建具有配置的领域、用户、角色和权限的Shiro SecurityManager的最简单方法是使用简单的INI配置。\n        // 我们将使用一个工厂来实现这一点，该工厂可以接收一个.ini文件并返回一个SecurityManager实例：\n        Factory<SecurityManager> factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");\n        SecurityManager securityManager = factory.getInstance();\n    \n        // 对于这个简单的示例quickstart，将SecurityManager作为JVM单例进行访问。\n        // 大多数应用程序不会这样做，而是依赖其容器配置或web.xml来实现webapps。\n        // 这超出了这个简单快速启动的范围，所以我们只做最简单的工作，这样您就可以继续对事物有感觉。\n        SecurityUtils.setSecurityManager(securityManager);\n    \n        // 现在设置了一个简单的Shiro环境，让我们看看您可以做什么：\n    \n        // 获取当前正在执行的用户Subject：\n        Subject currentUser = SecurityUtils.getSubject();\n    \n        // 用会话做一些事情（不需要web或EJB容器！！！）\n        //获取Session的方式：Subject的 getSession 方法\n        Session session = currentUser.getSession();\n        //检测Session是否管用：通过往Session中放数据，然后再获取这个数据。比较放入后数据有没有发生改变。\n        session.setAttribute(\"someKey\", \"aValue\");\n        String value = (String) session.getAttribute(\"someKey\");\n        if (value.equals(\"aValue\")) {\n          log.info(\"Retrieved the correct value! [\" + value + \"]\");\n        }\n    \n        // 让我们登录当前用户，以便检查角色和权限：\n        // isAuthenticated()：当已登录时返回true\n        if (!currentUser.isAuthenticated()) {\n          // 将用户名和密码封装成UsernamePasswordToken\n          UsernamePasswordToken token = new UsernamePasswordToken(\"lonestarr\", \"vespa\");\n          // RememberMe：记住我。设置为true\n          token.setRememberMe(true);\n          try {\n            //执行登录\n            currentUser.login(token);\n          } catch (UnknownAccountException uae) { // 此异常表示为：没有当前用户\n            log.info(\"There is no user with username of \" + token.getPrincipal());\n          } catch (IncorrectCredentialsException ice) { // 此异常表示为：密码不正确\n            log.info(\"Password for account \" + token.getPrincipal() + \" was incorrect!\");\n          } catch (LockedAccountException lae) { // 此异常表示为：用户被锁定\n            log.info(\"The account for username \" + token.getPrincipal() + \" is locked.  \" +\n                     \"Please contact your administrator to unlock it.\");\n          }\n          // ... 在这里捕获更多异常（可能是特定于您的应用程序的自定义异常？)\n          catch (AuthenticationException ae) { // 此异常表示为：验证失败异常。此异常是所有认证异常的父类。\n            //unexpected condition?  error?\n          }\n        }\n    \n        // say who they are:\n        //print their identifying principal (in this case, a username):\n        log.info(\"User [\" + currentUser.getPrincipal() + \"] logged in successfully.\");\n    \n        // 测试当前用户是否有此角色。\n        if (currentUser.hasRole(\"schwartz\")) {\n          log.info(\"May the Schwartz be with you!\");\n        } else {\n          log.info(\"Hello, mere mortal.\");\n        }\n    \n        // 测试当前用户是否有某一个权限（非实例级）\n        if (currentUser.isPermitted(\"lightsaber:weild\")) {\n          log.info(\"You may use a lightsaber ring.  Use it wisely.\");\n        } else {\n          log.info(\"Sorry, lightsaber rings are for schwartz masters only.\");\n        }\n    \n        // a (very powerful) Instance Level permission:\n        //测试当前用户是否具有 “winnebago:drive:eagle5“ 的权限\n        if (currentUser.isPermitted(\"winnebago:drive:eagle5\")) {\n          log.info(\"You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'.  \" +\n                   \"Here are the keys - have fun!\");\n        } else {\n          log.info(\"Sorry, you aren't allowed to drive the 'eagle5' winnebago!\");\n        }\n    \n        //全部完成-退出/注销/登出！\n        currentUser.logout();\n    \n        System.exit(0);\n      }\n    }\n    ```\n\n  * 第四步：启动即可。\n  \n* 对HelloWorld的执行过程的思考：\n\n  * 当请求发送到后端时，先获取当前后端线程的\n\n\n\n# 集成Spring\n\n* 搭建框架：\n\n  * 第一步：创建Javaweb项目。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210528180207-4.png)\n\n  * 第二步：导入Spring,SpringMVC的jar包。\n\n  * 第三步：配置Spring,和SpringMVC的配置。\n\n    * web.xml\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n             version=\"4.0\">\n      <!--引入Spring配置-->\n      <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:applicationContext.xml</param-value>\n      </context-param>\n      <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n      </listener>\n      <!--引入SpringMVC配置-->\n      <servlet>\n        <servlet-name>springMVC</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n          <param-name>contextConfigLocation</param-name>\n          <param-value>classpath:springmvc-config.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n      </servlet>\n      <servlet-mapping>\n        <servlet-name>springMVC</servlet-name>\n        <url-pattern>/</url-pattern>\n      </servlet-mapping>\n    </web-app>\n    ```\n\n    * spring的applicationContext.xml\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xmlns:context=\"http://www.springframework.org/schema/context\"\n           xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n           http://www.springframework.org/schema/beans/spring-beans.xsd\n           http://www.springframework.org/schema/context \n           http://www.springframework.org/schema/context/spring-context.xsd\">\n      <context:component-scan base-package=\"com.lc\" use-default-filters=\"true\">\n        <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n        <context:exclude-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.ControllerAdvice\"/>\n      </context:component-scan>\n    </beans>\n    ```\n\n    * springmvc的springmvc-config.xml\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xmlns:context=\"http://www.springframework.org/schema/context\"\n           xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n           xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n           http://www.springframework.org/schema/beans/spring-beans.xsd\n           http://www.springframework.org/schema/context \n           http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n      <context:component-scan base-package=\"com.lc\" use-default-filters=\"false\">\n        <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n        <context:include-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.ControllerAdvice\"/>\n      </context:component-scan>\n    \n      <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/views/\"/>\n        <property name=\"suffix\" value=\".jsp\"/>\n      </bean>\n    \n      <!--mvc的两个基本配置-->\n      <mvc:annotation-driven></mvc:annotation-driven>\n      <mvc:default-servlet-handler></mvc:default-servlet-handler>\n    </beans>\n    ```\n\n  * 第四步：启动项目。如果项目跑起来了，表示搭建没有出错。\n\n  * 第五步：导入Shiro的jar包。\n\n  * 第六步：参照件shiro-root-1.3.2\\samples\\spring\\src\\main\\webapp\\WEB-INF下的配置文件对项目进行整改。\n\n    * web.xml的修改\n\n    ```xml\n    <!-- Shiro过滤器在spring应用程序上下文中定义： -->\n    <filter>\n      <filter-name>shiroFilter</filter-name>\n      <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n      <init-param>\n        <param-name>targetFilterLifecycle</param-name>\n        <param-value>true</param-value>\n      </init-param>\n    </filter>\n    \n    <filter-mapping>\n      <filter-name>shiroFilter</filter-name>\n      <url-pattern>/*</url-pattern>\n    </filter-mapping>\n    ```\n\n    * applicationContext.xml的修改\n\n    ```xml\n    <!-- =========================================================\n           Shiro核心组件 - Not Spring Specific\n           ========================================================= -->\n    <!-- 配置securityManager，安全管理器（当没有web环境时，使用DefaultSecurityManager）-->\n    <bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n      <property name=\"cacheManager\" ref=\"cacheManager\"/>\n      <!-- 单一领域应用程序。如果您有多个领域，请改用'realms'属性。 -->\n      <property name=\"sessionMode\" value=\"native\"/>\n      <property name=\"realm\" ref=\"jdbcRealm\"/>\n    </bean>\n    \n    <!--让我们使用一些企业缓存支持来获得更好的性能。您可以用您喜欢的任何企业缓存框架实现（Terracotta+Ehcache、Coherence、GigaSpaces等）来代替它 -->\n    <!--配置cacheManager，缓存管理器-->\n    <bean id=\"cacheManager\" class=\"org.apache.shiro.cache.ehcache.EhCacheManager\">\n      <!-- 如果已经有net.sf.ehcache.CacheManager实例，请在此处设置。否则，将使用默认配置创建新配置：\n             <property name=\"cacheManager\" ref=\"ehCacheManager\"/> -->\n      <!-- 如果没有要注入的预构建net.sf.ehcache.CacheManager实例，但希望使用特定的ehcache配置，请在此处指定。否则，将使用默认值：-->\n    \n      <property name=\"cacheManagerConfigFile\" value=\"classpath:ehcache.xml\"/>\n    </bean>\n    \n    <!-- 由SecurityManager用于访问安全数据（用户、角色等）。也可以使用许多其他领域实现（PropertiesRealm、LdapRealm等）。 -->\n    <!--<bean id=\"jdbcRealm\" class=\"org.apache.shiro.samples.spring.realm.SaltAwareJdbcRealm\">\n        <property name=\"name\" value=\"jdbcRealm\"/>\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <property name=\"credentialsMatcher\">\n          &lt;!&ndash; 'bootstrapDataPopulator'Sha256散列密码（使用用户名作为salt），然后base64对其进行编码：&ndash;&gt;\n          <bean class=\"org.apache.shiro.authc.credential.HashedCredentialsMatcher\">\n            <property name=\"hashAlgorithmName\" value=\"SHA-256\"/>\n            &lt;!&ndash; true表示十六进制编码，false表示base64编码&ndash;&gt;\n            <property name=\"storedCredentialsHexEncoded\" value=\"false\"/>\n          </bean>\n        </property>\n      </bean>-->\n    <!--自定义配置Realm。\n            1.指定自定义的Realm的实现类\n      -->\n    <bean id=\"jdbcRealm\" class=\"com.lc.bean.realm.ShiroRealm\">\n    \n    </bean>\n    \n    <!-- =========================================================\n           Shiro-Spring特定集成\n           ========================================================= -->\n    <!-- 为Spring配置的Shiro对象自动调用init（）和destroy（）方法的ost处理器，\n            这样您就不必\n                1) 为每个bean定义指定init方法和destroy方法属性\n                2) 甚至知道哪些Shiro对象需要调用这些方法。 -->\n    \n    <!--配置。可以自动的来调用配置在IOC中ShiroBean的生命周期方法-->\n    <bean id=\"lifecycleBeanPostProcessor\" class=\"org.apache.shiro.spring.LifecycleBeanPostProcessor\"/>\n    \n    <!-- 为Spring配置的bean启用Shiro注释。仅在lifecycleBeanProcessor运行后运行： -->\n    <bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"\n          depends-on=\"lifecycleBeanPostProcessor\"/>\n    <bean class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\">\n      <property name=\"securityManager\" ref=\"securityManager\"/>\n    </bean>\n    \n    <!-- 安全springremoting：确保任何springremoting方法调用都可以与一个主题相关联以进行安全检查。远程调用的使用 -->\n    <!-- <bean id=\"secureRemoteInvocationExecutor\" class=\"org.apache.shiro.spring.remoting.SecureRemoteInvocationExecutor\">\n        <property name=\"securityManager\" ref=\"securityManager\"/>\n      </bean>-->\n    \n    <!-- 在这里定义Shiro过滤器shiroFilter（作为FactoryBean），\n      而不是直接在web.xml中定义 —— web.xml中使用DelegatingFilterProxy来访问这个bean。\n      -->\n    <!--注意事项：\n        1.此处的id必须和web.xml中对应的filter-name一致。\n      -->\n    <bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n      <property name=\"securityManager\" ref=\"securityManager\"/>\n      <!--登陆页面-->\n      <property name=\"loginUrl\" value=\"/login.jsp\"/>\n      <!--登陆成功的页面-->\n      <property name=\"successUrl\" value=\"/success.jsp\"/>\n      <!--登陆后没有权限的页面-->\n      <property name=\"unauthorizedUrl\" value=\"/unauthorized.jsp\"/>\n      <!-- “filters”属性不是必需的，因为定义的任何声明的javax.servlet.Filter bean都将通过其链定义中的beanName自动获取并可用，\n        但如果您愿意，可以在此处执行重写或parentchild合并配置：-->\n      <!-- <property name=\"filters\">\n            <util:map>\n                <entry key=\"aName\" value-ref=\"someFilterPojo\"/>\n            </util:map>\n        </property> -->\n      <!--配置哪些页面需要受保护，以及访问这些页面需要的权限。\n          anon ：意为此资源可以被匿名访问。\n          authc ：表示必须认证之后才能访问。\n          /** ：表示对所有资源。\n        -->\n      <property name=\"filterChainDefinitions\">\n        <value>\n          /favicon.ico = anon\n          /logo.png = anon\n          /shiro.css = anon\n          /login.jsp = anon\n          /** = authc\n        </value>\n      </property>\n    </bean>\n    ```\n\n  * 第七步：新建login.jsp。list.jsp。unauthorized.jsp。\n\n* 与Web 集成：\n\n  * Shiro 提供了与 Web 集成的支持，其通过一个**ShiroFilter** 入口来拦截需要安全控制的URL，然后进行相应的控制。\n  * ShiroFilter 类似于如 Strut2/SpringMVC 这种web 框架的前端控制器，是安全控制的入口点，其负责读取配置（如ini 配置文件），然后判断URL是否需要登录/权限等工作。\n\n\n\n# ShiroFilter\n\n* 工作原理：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210528180207-5.png)\n\n* web.xml配置文件中的DelegatingFilterProxy：\n\n  * 作用是自动到 Spring 容器查找名字为 shiroFilter（filter-name）的 bean 并把**所有 Filter 的操作委托给它**。\n  * 如果找不到会抛出**NoSuchBeanDefinitionException异常**。\n  * 原理：DelegatingFilterProxy是Filter的代理对象，默认情况下Spring回到IOC中查找和\\<filter-name>相同的filterBean。\n  * 也可以通过配置初始化参数**targetBeanName**来配置filterBean的id名字。\n\n  ```xml\n  <init-param>\n    <param-name>targetBeanName</param-name>\n    <param-value>abc</param-value>\n  </init-param>\n  ```\n\n* 在applicationContext.xml的 filterChainDefinitions 属性的配置原理：\n\n  * [urls] 部分的配置，其格式是： “**url=拦截器[参数]**”。\n  * 拦截器也叫过滤器。\n  * 如果当前请求的 url 匹配 [urls] 部分的某个 url 模式，将会执行其配置的拦截器。 \n  * anon（anonymous） 拦截器表示匿名访问（即不需要登录即可访问） 。\n  * authc （authentication）拦截器表示需要身份认证通过后才能访问。\n\n* shiro中默认的过滤器：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210528180207-6.png)\n\n* URL 匹配模式：\n\n  * **url 模式使用 Ant 风格模式**\n  * Ant 路径通配符支持 ?、*、**，注意通配符匹配不包括目录分隔符“/”：\n    * – ?：匹配一个字符，如 /admin? 将匹配 /admin1，但不匹配 /admin 或 /admin/；\n    * *：匹配零个或多个字符串，如 /admin 将匹配 /admin、/admin123，但不匹配 /admin/1； \n    * \\**：匹配路径中的零个或多个路径，如 /admin/** 将匹配 /admin/a 或 /admin/a/b\n\n* URL 匹配顺序：\n\n  * **URL 权限采取第一次匹配优先的方式**，即从头开始使用第一个匹配的 url 模式对应的拦截器链。\n  * 如：\n  * — /bb/\\**=filter1\n  * — /bb/aa=filter2\n  * — /**=filter3\n  *  — 如果请求的url是“/bb/aa”，因为按照声明顺序进行匹配，那么将使用 filter1 进行拦截。\n\n\n\n# 认证功能\n\n\n\n## 身份认证\n\n* 身份验证：一般需要提供如身份 ID 等一些标识信息来表明登录者的身份，如提供 email，用户名/密码来证明。\n\n* 在 shiro 中，用户需要提供 **principals （身份）和 credentials（证明）**给 shiro，从而应用能验证用户身份：\n  * **principals**：身份，即**主体的标识属性**，可以是任何属性，如用户名、邮箱等，**唯一即可**。一个主体可以有多个 principals，但只有一个Primary principals，一般是用户名/邮箱/手机号。\n  * **credentials**：**证明/凭证**，即只有主体知道的安全值，如**密码/数字证书**等。\n  \n* 最常见的 principals 和 credentials 组合就是用户名/密码了\n\n* 身份验证的基本流程：\n  * 第一步：获取当前Subject。调用SecurityUtils.getSubject()方法。\n  * 第二步：测试当前的用户是否被认证，即是否已经登录。调用Subject的isAuthenticated方法。\n  * 第三步：如果没有认证。则将身份和证明封装成UsernamePasswordToken对象。\n    * 上面三步一般在Handler中实现。通过通过请求获取到用户信息。\n  * 第四步：对未认证的用户执行登录。调用Subject的login()方法。\n  \n* login()方法的实现流程：\n  * 在Subject的login()方法中调用SecurityManager的login()方法。\n  * 在SecurityManager的login()方法中调用Authenticator的authenticate()方法。\n  * 在Authenticator的authenticate()方法通过一层层子类的实现，最终调用Realm的getAuthenticationInfo()方法。\n  * Realm的getAuthenticationInfo()方法通过查询数据库，最终将结果一层层返回到Shiro中。\n  * 最后由shiro完成用户信息的比对。\n  \n* 实现登录，登出功能。\n\n  * 第一步：网页。\n\n  ```jsp\n  <form action=\"shiroLogin\" method=\"post\">\n    username:<input type=\"text\" name=\"user\"><br>\n    password:<input type=\"password\" name=\"pas\"><br>\n    <input type=\"submit\" value=\"submit\">\n  </form>\n  <a href=\"/shiroLogout\">登出</a>\n  ```\n\n  * 第二步：handler层代码。\n\n    * 登出功能不需要写对应的处理方法。\n\n    ```java\n    @RequestMapping(value = \"shiroLogin\",method = RequestMethod.POST)\n    public String login(@RequestParam(\"user\")String user,\n                        @RequestParam(\"pas\")String password){\n      Subject currentSubject = SecurityUtils.getSubject();\n      System.out.println(\"currentSubject: \"+currentSubject.hashCode());\n      //当登陆成功后，从此连接再次登录时，认证将会通过，不在查询数据库。\n      if (!currentSubject.isAuthenticated()) {\n        // 将用户名和密码封装成UsernamePasswordToken\n        UsernamePasswordToken token = new UsernamePasswordToken(user, password);\n        // RememberMe：记住我。设置为true\n        //token.setRememberMe(true);\n        try {\n          //执行登录\n          System.out.println(token.hashCode());\n          currentSubject.login(token);\n        } catch (AuthenticationException ae) {\n          System.out.println(\"exception: \" + ae.getMessage());\n        }\n      }\n    \n      return \"redirect:/list.jsp\";\n    }\n    ```\n\n  * 第三步：自定义实现Realm的子类。\n\n  ```java\n  public class ShiroRealm extends AuthenticatingRealm {\n  \n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n      System.out.println(\"访问数据库，查询数据: \" + authenticationToken.hashCode());\n      /**\n       * 通过查看AuthenticationToken的继承关系可知，AuthenticationToken是Handler中UsernamePasswordToken的父类。\n       * 又因为在handler中打印的UsernamePasswordToken的hashCode和此处AuthenticationToken的hashCode相同。\n       * 因此可以得到此处的AuthenticationToken是Handler中UsernamePasswordToken对象的引用。\n       * 就像List和ArrayList的关系\n       */\n      //第一步：把AuthenticationToken强转成UsernamePasswordToken\n      UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;\n      //第二步：从UsernamePasswordToken中获取username信息\n      String username = token.getUsername();\n      //第三步：调用数据库的方法，从数据库中查询username的信息\n      //User user = UserService.getUserByUserName();\n      //这里用静态资源处理测试\n      Map<String,String> result = new HashMap<>();\n      result.put(username,\"123456\");\n  \n      //第四步：若用户不存在，则抛出UnknownAccountException异常\n      if (result.get(username) == null){\n        throw new UnknownAccountException(\"用户不存在\");\n      }\n      //第五步：根据用户信息的情况，决定抛出其他异常\n      String password = new String(token.getPassword());\n      if (!password.equals(result.get(username))){\n        throw new IncorrectCredentialsException(\"密码错误\");\n      }\n  \n      //第六步：用户存在，且不抛出异常。则构建AuthenticationInfo对象并返回\n      /**\n       * SimpleAuthenticationInfo的三个参数说明：\n       * Object principal ：认证的实体信息，可以是username，也可以是数据库查询的结果\n       * Object credentials ：对应的凭据，比如密码。这个密码是从数据库中查询到的密码。\n       * String realmName ：当前realm的name。调用当前父类的getName()方法即可。\n       */\n      Object principal = username;\n      Object credentials = result.get(username);\n      String realmName = this.getName();\n      SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(principal,credentials,realmName);\n  \n      return info;\n    }\n  }\n  ```\n\n  * 第四步：对Spring配置文件中Shiro的拦截规则的修改。\n\n```xml\n<property name=\"filterChainDefinitions\">\n  <value>\n    /login.jsp = anon\n    /shiroLogin = anon\n    /shiroLogout = logout\n\n    /** = authc\n  </value>\n</property>\n```\n\n* 注意事项：\n  * hadler中的token和Realm中的token是同一个对象。\n  * Realm中返回值的credentials的值要从数据库中获取。\n  * 要注意修改Shiro的拦截规则，防止登录请求被拦截了。\n\n\n\n## 密码的比对\n\n* 首先：对于密码的比对不是在Realm中查询数据库后进行比对的。\n\n  * 因为在Realm中有两处存放密码的地方。doGetAuthenticationInfo()方法的参数存放了一对用户和密码信息，它的返回值也存放了一对用户和密码信息。\n\n* 真正的密码比对发生在AuthenticatingRealm类中，通过调用CredentialsMatcher对象的doCredentialsMatch()方法进行比对。\n\n* 在实际情况中，从数据库查出的信息中密码是加密后的。\n\n  * 而密码的比对需要一个规则。因此Shiro需要指定加密的方式。\n\n* **实现加密的操作**：以MD5加密为例。\n\n  * 第一步：替换当前Realm的CredentialsMatcher属性。\n  * 第二步：使用HashedCredentialsMatcher对象，并设置加密算法.\n\n  ```xml\n  <bean id=\"jdbcRealm\" class=\"com.lc.bean.realm.ShiroRealm\">\n    <!--设置加密方式-->\n    <property name=\"credentialsMatcher\">\n      <bean class=\"org.apache.shiro.authc.credential.HashedCredentialsMatcher\">\n        <!--HashedCredentialsMatcher的子实现类有6个，因此可以设置6种。具体设置值可以查看源码-->\n        <property name=\"hashAlgorithmName\" value=\"MD5\"/>\n      </bean>\n    </property>\n  </bean>\n  ```\n\n* 加密过程说明：\n\n  * 在通过Realm获取到数据库数据后，Shiro将会对token和info中的密码进行比对。\n  * 再比对先，会通过加密的方式将token中的数据进行加密。\n  * 然后将加密后的数据与info中的数据（也就是数据库中的密码）按照字节一一比对。\n  * 加密的具体方式是使用SimpleHash类。\n\n  ```java\n  //说明：hashIterations：意为加密的次数，可以通过设置HashedCredentialsMatcher的hashIterations属性来设置。\n  //salt：表示盐值。用于解决密码相同，加密后数据也相同的问题。\n  new SimpleHash(hashAlgorithmName, credentials, salt, hashIterations)\n  ```\n\n  ```xml\n  <!--指定加密的次数-->\n  <property name=\"hashIterations\" value=\"10\"/>\n  ```\n\n* 另一个问题：如果两个人的密码一样，则加密后的数据是一样的。这是不安全的。\n\n  * 因此：如何实现即使密码一样，加密后的数据也不一样呢？\n\n* **升级后的加密操作**：\n\n  * 在Relam中，返回值的创建过程中传入盐值credentialsSalt。\n\n  * 然后再密码的比过程时，对密码进行加密时就会带上这个盐值。\n\n    ```java\n    //盐值：一般设置为唯一值。这里username本身就是唯一的，因此将盐值设置为username\n    ByteSource credentialsSalt = ByteSource.Util.bytes(username);\n    SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(principal,credentials,credentialsSalt,realmName);\n    ```\n\n* 总结：在密码比对时，要设置加密策略来保证安全。同时要添加盐值以保证更安全。\n\n\n\n## 多Realm时的验证\n\n* 单Realm和多Realm的区别：\n\n  * 在login()登录时。有如下代码：\n\n  ```java\n  protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException {\n    this.assertRealmsConfigured();\n    Collection<Realm> realms = this.getRealms();\n    if(realms.size() == 1){\n      //当Realm为1时，走这个方法。\n      return this.doSingleRealmAuthentication((Realm)realms.iterator().next(), authenticationToken);\n    }else{\n      //当Realm为多个时，走这个方法。\n      return this.doMultiRealmAuthentication(realms, authenticationToken);\n    }\n  }\n  ```\n\n* 模拟两个Realm的情况：\n\n  * 第一步：创建两个Realm。配置加密分别为MD5,和SHA1。\n  * 第二步：修改applicationContext.xml文件。\n    * 需要修改securityManager。并添加一个Realm配置，\n    * 添加duoRealm的匹配器ModularRealmAuthenticator。\n\n  ```xml\n  <bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n    <property name=\"cacheManager\" ref=\"cacheManager\"/>\n    <property name=\"authenticator\" ref=\"authenticator\"/>\n  </bean>  \n  <!--配置多Realm情况下需要添加的验证器Bean-->\n  <bean id=\"authenticator\" class=\"org.apache.shiro.authc.pam.ModularRealmAuthenticator\">\n    <property name=\"realms\">\n      <list>\n        <ref bean=\"shiroRealm\"/>\n        <ref bean=\"secondRealm\"/>\n      </list>\n    </property>\n  </bean>\n  <bean id=\"secondRealm\" class=\"com.lc.bean.realm.SecondRealm\">\n    <!--设置加密方式-->\n    <property name=\"credentialsMatcher\">\n      <bean class=\"org.apache.shiro.authc.credential.HashedCredentialsMatcher\">\n        <property name=\"hashAlgorithmName\" value=\"SHA1\"/>\n        <property name=\"hashIterations\" value=\"10\"/>\n      </bean>\n    </property>\n  </bean>\n  ```\n\n* 多Realm时，对于用户的验证是按照配置中list标签的顺序进行的。\n\n  * 多Realm时，每个Realm都会对信息进行验证吗？验证策略时什么？\n\n* 多Realm的验证策略由AuthenticationStrategy指定。\n\n* AuthenticationStrategy 接口的默认实现： \n\n  * **FirstSuccessfulStrategy**：**只要有一个 Realm 验证成功即可**，只返回第一个 Realm 身份验证成功的认证信息，其他的忽略；\n  * **AtLeastOneSuccessfulStrategy**：只要有一个Realm验证成功即可，和FirstSuccessfulStrategy 不同，将**返回所有Realm身份验证成功的认证信息**；\n  * **AllSuccessfulStrategy**：**所有Realm验证成功才算成功**，且返回所有Realm身份验证成功的认证信息，如果有一个失败就失败了。\n\n* ModularRealmAuthenticator 默认是 AtLeastOneSuccessfulStrategy策略。\n\n* 细节问题：\n\n  * 在配置securityManager时会发现其属性中由Realms。而在authenticator中也会发现Realms属性。\n  * 这两个有什么区别吗？如果两个Realms一样的效果，应该配在哪里？\n  * 经实验发现。在调用Realm的时候是通过authenticator对象调用的。\n  * 但是当在securityManager中配置Realms，而在authenticator中不配置Realms时，也是通过authenticator对象调用Realm，且不报错。这是问什么呢？\n  * 这是因为在securityManager中配置Realms时，初始化的时候，会将自己的Realms传递给authenticator。\n\n  ```java\n  //如下述代码。\n  protected void afterRealmsSet() {\n    super.afterRealmsSet();\n    if (this.authenticator instanceof ModularRealmAuthenticator) {\n      ((ModularRealmAuthenticator)this.authenticator).setRealms(this.getRealms());\n    }\n  }\n  ```\n\n  * 结论：Realms一般配置在securityManager中即可。不需要在authenticator中配置。\n\n\n\n# 授权功能\n\n* 授权，也叫**访问控制，即在应用中控制谁访问哪些资源**（如访问页面/编辑数据/页面操作 等）。在授权中需了解的几个关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。\n\n* 主体(Subject)：访问应用的用户，在 Shiro 中**使用 Subject 代表该用户**。用户只有授权后才允许访问相应的资源。\n\n* 资源(Resource)：**在应用中用户可以访问的 URL**，比如访问 JSP 页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。\n\n* 权限(Permission)：**安全策略中的原子授权单位**，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。即权限表示在应用中用户能不能访问某个资源，如：访问用户列表页面查看/新增/修改/删除用户数据（即很多时候都是CRUD（增查改删）式权限控制）等。权限代表了用户有没有操作某个资源的权利，即反映在某个资源上的操作允不允许。\n\n* Shiro 支持**粗粒度权限（如用户模块的所有权限）和细粒度权限（操作某个用户的权限**，即实例级别的）。\n\n*  角色(Role)：**权限的集合**，一般情况下会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。典型的如：项目经理、技术总监、CTO、开发工程师等都是角色，不同的角色拥有一组不同的权限。\n\n* 授权方式：\n\n  * 编程式：通过写if/else 授权代码块完成 。\n  * 注解式：通过在执行的Java方法上放置相应的注解完成，没有权限将抛出相应的异常 。常用。\n  * JSP/GSP 标签：在JSP/GSP 页面通过相应的标签完成。\n\n* 默认的拦截器：\n\n  * Shiro 内置了很多默认的拦截器，比如身份验证、授权等相关的。\n  * 默认拦截器可以参考org.apache.shiro.web.filter.mgt.DefaultFilter中的枚举拦截器：\n\n  ```java\n  public enum DefaultFilter {\n    anon(AnonymousFilter.class),\n    authc(FormAuthenticationFilter.class),\n    authcBasic(BasicHttpAuthenticationFilter.class),\n    logout(LogoutFilter.class),\n    noSessionCreation(NoSessionCreationFilter.class),\n    perms(PermissionsAuthorizationFilter.class),\n    port(PortFilter.class),\n    rest(HttpMethodPermissionFilter.class),\n    roles(RolesAuthorizationFilter.class),\n    ssl(SslFilter.class),\n    user(UserFilter.class);\n  }\n  ```\n\n  * 拦截器的使用：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210530171033.png)\n\n* 权限(Permission)的说明：\n\n  * 规则：**资源标识符：操作：对象实例 ID** 。\n  * 即对哪个资源的哪个实例可以进行什么操作。其**默认支持通配符权限字符串**。\n  * \": \"表示资源/操作/实例的分割；\n  * \",\" 表示操作的分割，\n  * \"\\* 表示任意资源/操作/实例。\n  * **多层次管理**\n    * 例如：user:query、user:edit。\n      * 表示授予user角色query和edit的权限。\n    * **冒号是一个特殊字符，它用来分隔权限字符串的下一部件**：\n      * 第一部分是权限被操作的领域（打印机），\n      * 第二部分是被执行的操作。\n    * 多个值：**每个部件能够保护多个值**。因此，除了授予用户 user:query和 user:edit 权限外，也可以简单地授予他们一个：user:query, edit\n    * 还可以**用 * 号代替所有的值**，如：user:* ， 也可以写：*:query，表示某个用户在所有的领域都有 query 的权限。\n  * **实例级访问控制**\n    * 这种情况通常会使用三个部件：**域、操作、被付诸实施的实例**。如：user:edit:manager\n      * 表示授予user角色对manager对象的edit权限。\n    * 也可以**使用通配符**来定义，如：user:edit:\\*、user:\\*:\\*、user:*:manager\n    * **部分省略通配符**：缺少的部件意味着用户可以访问所有与之匹配的值，比如：user:edit 等价于 user:edit :\\*、user 等价于 user:\\*:\\*。\n    * 注意：**通配符只能从字符串的结尾处省略部件**，也就是说 user:edit 并不等价于 user:*:edit\n\n\n\n## 授权功能\n\n* 授权功能的流程：\n\n  * 第一步：调用Subject的isPermitted\\*/hasRole\\*()方法。\n\n  * 第二步：调用securityManager的hasRole()方法。实际上调用的是securityManager的父类Authorizer的hasRole()方法。\n\n  * 第三步：调用Authorizer的子类的hasRole()方法。\n\n    * 此时当Realm为1个时调用的是AuthorizingRealm的hasRole()方法。获取当前subject的权限信息。然后进行验证。\n\n    ```java\n    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {\n      //获取权限信息\n      AuthorizationInfo info = this.getAuthorizationInfo(principal);\n      return this.hasRole(roleIdentifier, info);\n    }\n    //对权限信息进行验证\n    protected boolean hasRole(String roleIdentifier, AuthorizationInfo info) {\n      return info != null && info.getRoles() != null && info.getRoles().contains(roleIdentifier);\n    }\n    ```\n\n    * 当Realm为多个时，调用ModularRealmAuthorizer的hasRole()方法。遍历当前的Realm，然后调用此Realm时的AuthorizingRealm。剩下的就和Realm为1个的情况相同。\n\n    ```java\n    public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {\n      //检测当前ModularRealmAuthorizer的Realms属性是否有值\n      this.assertRealmsConfigured();\n      Iterator var3 = this.getRealms().iterator();\n    \n      Realm realm;\n      do {\n        //当一个Realm验证不通过时，就全都验证不通过。\n        if (!var3.hasNext()) {\n          return false;\n        }\n    \n        realm = (Realm)var3.next();\n        //依次调用AuthorizingRealm的hasRole方法。\n      } while(!(realm instanceof Authorizer) || !((Authorizer)realm).hasRole(principals, roleIdentifier));\n    \n      return true;\n    }\n    ```\n\n* 授权功能的实现：\n\n  * 由授权流程可知：检验授权前会先获取授权信息。因此Realm需要继承AuthorizingRealm类。并实现其doGetAuthorizationInfo方法。因为这个方式会在授权时被调用。\n  * AuthorizingRealm类继承自AuthenticatingRealm，但没有实现AuthenticatingRealm中的doGetAuthenticationInfo方法。所以认证和授权只需要继承AuthorizingRealm类就可以了。\n\n  ```java\n  public class TestRealm extends AuthorizingRealm {\n    //获取用户角色信息\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n      return null;\n    }\n    //获取用户信息\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n      return null;\n    }\n  }\n  ```\n\n* 实例：\n\n  * 第一步：创建两个页面admin.jsp和user.jsp。\n  * 第二步：更改配置文件中的拦截规则。设置为对应角色才能访问。\n\n  ```xml\n  <property name=\"filterChainDefinitions\">\n    <value>\n      /login.jsp = anon\n      /shiroLogin = anon\n      /shiroLogout = logout\n      /user.jsp = roles[user]\n      /admin.jsp = roles[admin]\n  \n      /** = authc\n    </value>\n  </property>\n  ```\n\n  * 第三步：选择一个Realm，实现doGetAuthorizationInfo方法。\n\n  ```java\n  //授权功能的实现：获取用户的角色信息\n  @Override\n  protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n    // 1.利用principalCollection获取登录用户信息\n    Object principal = principalCollection.getPrimaryPrincipal();\n    // 2.利用用户信息来获取用户的角色信息。\n    // 如果principalCollection中没有角色信息，可能还需要去数据库中查找\n    Set<String> roles = new HashSet<>();\n    roles.add(\"user\");\n    if (\"admin\".equals(principal)){\n      roles.add(\"admin\");\n    }\n  \n    // 3.创建返回值对象，并设置其roles属性。\n    SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(roles);\n  \n    return info;\n  }\n  ```\n\n  * 效果：当登录用户为admin时，两个页面都能访问。当登录用户为user时，只能访问user.jsp页面，访问另一个页面时会跳转到unauthorized.jsp页面。unauthorized.jsp页面意为没有权限访问的页面。\n\n\n\n## Shiro标签\n\n* Shiro 提供了 JSTL 标签用于在 JSP 页面进行权限控制，如根据登录用户显示相应的页面按钮。 \n\n  ```jsp\n  <%@ taglib prefix=\"shiro\" uri=\"http://shiro.apache.org/tags\" %>\n  ```\n\n* guest 标签：用户**没有身份验证时**显示相应信息，即游客访问信息：\n\n  ```jsp\n  <shiro:guest>\n    欢迎游客访问，<a href=\"/login.jsp\">登录</a>\n  </shiro:guest>\n  ```\n\n* user 标签：用户已经**经过认证/记住我登录**后显示相应的信息。\n\n  ```jsp\n  <shiro:user>\n    欢迎[<shiro:principal/>]登录，<a href=\"shiroLogout\">登出</a>\n  </shiro:user>\n  ```\n\n* authenticated 标签：用户已经身份验证通过，即Subject.login登录成功，**不是记住我登录的**\n\n  ```jsp\n  <shiro:authenticated>\n    用户[<shiro:principal/>]已身份验证通过\n  </shiro:authenticated>\n  ```\n\n* notAuthenticated 标签：用户未进行身份验证，即**没有调用Subject.login进行登录**，**包括记住我自动登录的也属于未进行身份验证**。\n\n  ```jsp\n  <shiro:notAuthenticated>\n    未验证身份(包括记住我登录的)\n  </shiro:notAuthenticated>\n  ```\n\n* pincipal 标签：**显示用户身份信息**，默认调用Subject.getPrincipal() 获取，即 Primary Principal。\n\n  ```jsp\n  <%--当为一个实体类对象时，使用property可以显示的指明要显示哪一个--%>\n  <shiro:principal property=\"username\"/>\n  ```\n\n* hasRole 标签：如果当前 Subject 有角色将显示 body 体内容：\n\n  ```jsp\n  <shiro:hasRole name=\"admin\">\n    用户[<shiro:principal/>]拥有角色admin<br>\n  </shiro:hasRole>\n  ```\n\n* hasAnyRoles 标签：如果当前Subject有任意一个角色（或的关系）将显示body体内容\n\n  ```jsp\n  <shiro:hasAnyRoles name=\"admin,user\">\n    用户[<shiro:principal/>]拥有角色admin或user<br>\n  </shiro:hasAnyRoles>\n  ```\n\n* lacksRole：如果当前 Subject 没有角色将显示 body 体内容\n\n  ```jsp\n  <shiro:lacksRole name=\"admin\">\n    用户[<shiro:principal/>]没有角色admin<br>\n  </shiro:lacksRole>\n  ```\n\n* hasPermission：如果当前 Subject 有权限将显示 body 体内容\n\n  ```jsp\n  <shiro:hasPermission name=\"user:create\">\n    用户[<shiro:principal/>]拥有权限user:create<br>\n  </shiro:hasPermission>\n  ```\n\n* lacksPermission：如果当前Subject没有权限将显示body体内容。\n\n  ```jsp\n  <shiro:lacksPermission name=\"user:create\">\n    用户[<shiro:principal/>]没有权限user:create<br>\n  </shiro:lacksPermission>\n  ```\n\n\n\n## 权限注解\n\n* 权限注解：表示为此方法执行需要当前用户具有什么权限。\n* @RequiresAuthentication：表示当前Subject已经通过login 进行了身份验证；**即 Subject. isAuthenticated() 返回 true**。\n* @RequiresUser：表示当前 Subject 已经**身份验证或者通过记住我登录的**。 \n* @RequiresGuest：表示当前Subject没有身份验证或通过记住我登录过，即是**游客身份**。\n* @RequiresRoles(value={“admin”, “user”}, logical= Logical.AND)：表示当前 Subject **需要角色** admin 和user\n* @RequiresPermissions (value={“user:a”, “user:b”}, logical= Logical.OR)：表示当前 Subject **需要权限** user:a 或user:b。\n\n```java\n//表示当前testShiro()方法只有admin角色的用户才能访问。\n@RequiresRoles(value = {\"admin\"})\npublic void testShiro(){\n  System.out.println(new Date().toString());\n}\n```\n\n* 当没有权限的用户访问此方法时会抛出org.apache.shiro.authz.UnauthorizedException异常。\n  * 此时就可以使用Spring的声明时异常处理，将此异常转到一个错误页面即可。\n* 此注解既可以用在Handler层，也可以用在service层。\n  * 但是service层代码一般都会加事务注解，让service层的类生成代理类。此时在加上权限注解，有可能出现类型转换异常。\n  * 因此。权限注解建议添加在handler层，即控制层。\n\n\n\n## 自定义拦截器\n\n* 通过自定义拦截器可以扩展功能，例如：动态url\\-角色/权限访问控制的实现、根据 Subject 身份信息获取用户信息绑定到 Request（即设置通用数据）、验证码验证、在线用户信息的保存等。\n\n* 配置自定义拦截器，就可以将配置文件中的拦截规则动态的添加。\n\n* 步骤：\n\n  * 第一步：配置文件中注释调拦截规则，配置filterChainDefinitionMap属性。\n\n  ```xml\n  <bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n    <property name=\"securityManager\" ref=\"securityManager\"/>\n    <property name=\"loginUrl\" value=\"/login.jsp\"/>\n    <property name=\"successUrl\" value=\"/list.jsp\"/>\n    <property name=\"unauthorizedUrl\" value=\"/unauthorized.jsp\"/>\n  \n    <!--通过设置此属性来动态的添加映射规则。此属性实际上是一个map-->\n    <property name=\"filterChainDefinitionMap\" ref=\"filterChainDefinitionMap\"/>\n  \n    <!--   <property name=\"filterChainDefinitions\">\n        <value>\n          /login.jsp = anon\n          /shiroLogin = anon\n          /shiroLogout = logout\n          /user.jsp = roles[user]\n          /admin.jsp = roles[admin]\n  \n          /** = authc\n        </value>\n      </property>-->\n  </bean>\n  ```\n\n  * 第二步：创建自定义拦截器。\n\n  ```java\n  public class FilterChainDefinitionMapBuilder {\n    public LinkedHashMap<String,String> builderFilterChainDefinitionMap() {\n      LinkedHashMap<String,String> filterChainDefinitionMap = new LinkedHashMap<>();\n      //在此处定义拦截规则。此处的添加的顺序按照优先匹配原则\n      filterChainDefinitionMap.put(\"/login.jsp\", \"anon\");\n      filterChainDefinitionMap.put(\"/shiroLogin\", \"anon\");\n      filterChainDefinitionMap.put(\"/shiroLogout\", \"logout\");\n      filterChainDefinitionMap.put(\"/user.jsp\", \"roles[user]\");\n      filterChainDefinitionMap.put(\"/admin.jsp\", \"roles[admin]\");\n      filterChainDefinitionMap.put(\"/**\", \"authc\");\n  \n      return filterChainDefinitionMap;\n    }\n  }\n  ```\n\n  * 第三步：配置自定义拦截器到filterChainDefinitionMap属性。\n\n  ```xml\n  <!--配置filterChainDefinitionMap的bean。其值通过实例工厂的方式进行注入-->\n  <bean id=\"filterChainDefinitionMap\" factory-bean=\"filterChainDefinitionMapBuilder\" factory-method=\"builderFilterChainDefinitionMap\"></bean>\n  <bean id=\"filterChainDefinitionMapBuilder\" class=\"com.lc.bean.builders.FilterChainDefinitionMapBuilder\"></bean>\n  ```\n\n\n\n# 会话管理\n\n* Shiro 提供了完整的企业级会话管理功能，**不依赖于底层容器**（如web容器tomcat），**不管 JavaSE 还是 JavaEE 环境都可以使用**，提供了会话管理、会话事件监听、会话存储/持久化、容器无关的集群、失效/过期支持、对Web 的透明支持、SSO 单点登录的支持等特性。\n\n* 会话相关的API\n\n  * Subject.getSession()：即可获取会话；\n    * 其等价于Subject.getSession(true)，即如果当前没有创建 Session 对象会创建一个；\n    * Subject.getSession(false)，如果当前没有创建 Session 则返回null\n  * session.getId()：获取当前会话的唯一标识\n  * session.getHost()：获取当前Subject的主机地址\n  * session.getTimeout() & session.setTimeout(毫秒)：获取/设置当前Session的过期时间\n  * session.getStartTimestamp() & session.getLastAccessTime()：获取会话的启动时间及最后访问时间；\n    * 如果是 JavaSE 应用需要自己定期调用 session.touch() 去更新最后访问时间；\n    * 如果是 Web 应用，每次进入 ShiroFilter 都会自动调用 session.touch() 来更新最后访问时间。\n  * session.touch() & session.stop()：更新会话最后访问时间及销毁会话；当Subject.logout()时会自动调用 stop 方法来销毁会话。如果在web中，调用 HttpSession. invalidate() 也会自动调用Shiro Session.stop 方法进行销毁Shiro 的会 话\n  * session.setAttribute(key, val) & session.getAttribute(key) & session.removeAttribute(key)：\n    * 设置/获取/删除会话属性；在整个会话范围内都可以对这些属性进行操作\n\n* 会话监听器用于监听会话创建、过期及停止事件：\n\n  ```java\n  public interface SessionListener {\n    void onStart(Session var1);\n  \n    void onStop(Session var1);\n  \n    void onExpiration(Session var1);\n  }\n  ```\n\n* Shiro的Session的应用：\n\n  * 在handler层伪码一般都是用HttpSession。如果在service层也想使用Session。此时就可以使用Shiro的Session.\n  * 对于没有服务器的项目即SE项目，Shiro可以提供Session的使用。\n\n* 实例：\n\n  ```java\n  @RequestMapping(\"/testAnnotation\")\n  public String testAnnotation(HttpSession session){\n    session.setAttribute(\"key\", \"1234\");\n    shiroService.testShiro();\n    return \"main\";\n  }\n  @Service\n  public class ShiroService {\n    //表示当前testShiro()方法只有admin角色的用户才能访问。\n    @RequiresRoles(value = {\"admin\"})\n    public void testShiro(){\n      System.out.println(new Date().toString());\n  \n      //通过Subject获取的Shiro的Session可以拿到在HttpSession中的数据\n      Subject subject = SecurityUtils.getSubject();\n      Session session = subject.getSession();\n      Object key = session.getAttribute(\"key\");\n      System.out.println(key); //此时输出的是1234\n    }\n  }\n  ```\n\n\n\n## SessionDao\n\n* SessionDao的目的是将Session保存在数据库中，并以此对Session进行CRUD操作。\n\n* SessionDao的继承树：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210530171033-1.png)\n\n  * AbstractSessionDAO 提供了 SessionDAO 的**基础实现**，如生成会话ID等 。\n  * CachingSessionDAO 提供了对开发者透明的**会话缓存的功能**，需要设置相应的 CacheManager\n  * MemorySessionDAO 直接在**内存中进行会话维护**。\n  * EnterpriseCacheSessionDAO 提供了缓存功能的会话维护，**默认情况下使用 MapCache 实现**，内部使用**ConcurrentHashMap 保存缓存的会话**。\n\n* SessionDao的配置：\n\n  ```xml\n  <!--SessionDao的配置。最终的sessionManager需要注入到securityManager中-->\n  <!--************************************************-->\n  <!--Session ID生成器-->\n  <bean id=\"sessionIdGenerator\" class=\"org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator\"/>\n  \n  <!--Session Dao 继承EnterpriseCacheSessionDAO-->\n  <bean id=\"sessionDao\" class=\"com.lc.bean.daos.MySessionDao\">\n    <!--使用的缓存策略。比如这里使用Ehcache的一个缓存配置-->\n    <property name=\"activeSessionsCacheName\" value=\"shiro-ActiveSessionsCache\"/>\n    <property name=\"sessionIdGenerator\" ref=\"sessionIdGenerator\"/>\n  </bean>\n  \n  <!--Session管理器-->\n  <bean id=\"sessionManager\" class=\"org.apache.shiro.session.mgt.DefaultSessionManager\">\n    <property name=\"globalSessionTimeout\" value=\"100000\"/>\n    <property name=\"deleteInvalidSessions\" value=\"true\"/>\n    <property name=\"sessionValidationSchedulerEnabled\" value=\"true\"/>\n    <property name=\"sessionDAO\" ref=\"sessionDao\"/>\n  </bean>\n  \n  <!--************************************************-->\n  ```\n\n  * 缓存的配置\n\n  ```xml\n  <!--Session Dao的缓存策略-->\n  <cache name=\"shrio-ActiveSessionsCache\"\n         maxEntriesLocalHeap=\"10000\"\n         overflowToDisk=\"false\"\n         enternal=\"false\"\n         diskPersistent=\"false\"\n         timeToLiveSeconds=\"0\"\n         timeToIdleSeconds=\"0\"\n         statistics=\"true\"/>\n  ```\n\n  * 自定义的SessionDao\n\n  ```JAVA\n  public class MySessionDao extends EnterpriseCacheSessionDAO {\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n  \n    @Override\n    protected Serializable doCreate(Session session) {\n      Serializable sessionId = super.doCreate(session);\n  \n      String sql = \"insert into sessions(id,session) values(?,?)\";\n  \n      jdbcTemplate.update(sql,sessionId, SerializableUtils.serialize(session));\n  \n      return session.getId();\n    }\n  \n    @Override\n    protected Session doReadSession(Serializable sessionId) {\n  \n      String sql = \"select session from sessions where id=?\";\n      List<String> sessionList = jdbcTemplate.queryForList(sql,String.class,sessionId);\n      if (sessionList.size() == 0){\n        return null;\n      }\n  \n      return SerializableUtils.deserialize(sessionList.get(0));\n    }\n  \n    @Override\n    protected void doUpdate(Session session) {\n      if (session instanceof ValidatingSession && !((ValidatingSession)session).isValid()){\n        return;\n      }\n      String sql = \"update sessions set session=? where id=?\";\n      jdbcTemplate.update(sql,SerializableUtils.serialize(session),session.getId());\n  \n    }\n  \n    @Override\n    protected void doDelete(Session session) {\n      String sql = \"delete from sessions where id=?\";\n      jdbcTemplate.update(sql,session.getId());\n      super.doDelete(session);\n    }\n  }\n  ```\n\n  * 对应的数据表\n\n  ```MYSQL\n  create table sessions (\n    id varchar(200),\n    session varchar(2000), # 长文本\n    constraint pk_sessions primary key(id)\n  ) charset=utf8 ENGINE=InnoDB;\n  ```\n\n  * 对应的工具类\n\n  ```java\n  public class SerializableUtils {\n    //将Session对象序列化\n    public static String serialize(Session session) {\n      ByteArrayOutputStream baos = null;\n      ObjectOutputStream oos = null;\n      try {\n        baos = new ByteArrayOutputStream();\n        oos = new ObjectOutputStream(baos);\n        oos.writeObject(session);\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      return Base64.encodeToString(baos.toByteArray());\n    }\n  \n    //将Session对象反序列化\n    public static Session deserialize(String sessionStr) {\n      try {\n        ByteArrayInputStream bais = null;\n        bais = new ByteArrayInputStream(Base64.decode(sessionStr));\n        ObjectInputStream ois = new ObjectInputStream(bais);\n        return (Session) ois.readObject();\n      } catch (IOException e) {\n        e.printStackTrace();\n      } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n      }\n      return null;\n    }\n  \n  }\n  ```\n\n\n\n## Session验证\n\n* Shiro 提供了**会话验证调度器，用于定期的验证会话是否已过期**，如果过期将停止会话。\n* 出于性能考虑，一般情况下都是获取会话时来验证会话是否过期并停止会话的；但是如在 **web 环境中**，如果用户不主动退出是不知道会话是否过期的，因此需要定期的检测会话是否过期，Shiro 提供了会话验证调度器**SessionValidationScheduler**。\n* Shiro 也提供了使用Quartz会话验证调度器：**QuartzSessionValidationScheduler**。\n* 会话验证需要单独开线程进行验证，可能会占用CPU。\n\n\n\n# 缓存\n\n* CacheManagerAware 接口：\n  * Shiro 内部相应的组件（DefaultSecurityManager）会自动检测相应的对象（如Realm）**是否实现了CacheManagerAware 并自动注入相应的CacheManager**。\n* Realm 缓存：\n  * Shiro 提供了 CachingRealm，其实现了CacheManagerAware 接口，提供了缓存的一些基础实现；\n  * **AuthenticatingRealm 及 AuthorizingRealm** 也分别提供了对AuthenticationInfo 和 AuthorizationInfo 信息的缓存。\n* Session 缓存：\n  * 如 SecurityManager 实现了 SessionSecurityManager， 其会判断 SessionManager 是否实现了CacheManagerAware 接口，如果实现了会把CacheManager 设置给它。 \n  * SessionManager 也会判断相应的 SessionDAO（如继承自CachingSessionDAO）是否实现了\n    CacheManagerAware，如果实现了会把 CacheManager设置给它 。\n  * 设置了缓存的 SessionManager，查询时会先查缓存，如果找不到才查数据库。\n\n\n\n# RememberMe\n\n* Shiro 提供了记住我（RememberMe）的功能，比如访问如淘宝等一些网站时，关闭了浏览器，下次再打开时还是能记住你是谁，下次访问时无需再登录即可访问，基本流程如下：\n\n  * 1、首先在登录页面选中 RememberMe 然后登录成功；如果是浏览器登录，一般会把 RememberMe 的Cookie 写到客户端并保存下来； \n  * 2、关闭浏览器再重新打开；会发现浏览器还是记住你的；\n  * 3、访问一般的网页服务器端还是知道你是谁，且能正常访问；\n  * 4、但是比如我们访问淘宝时，如果要查看我的订单或进行支付时，此时还是需要再进行身份认证的，以确保当前用户还是你。\n\n* 认证和记住我的区别：\n\n  * subject.isAuthenticated() 表示用户进行了**身份验证登录**的，即使有 **Subject.login** 进行了登录；\n  * subject.isRemembered()：表示用户是**通过记住我登录**的，此时**可能并不是真正的你**（如你的朋友使用你的电脑，或者你的cookie 被窃取）在访问的。\n  * **两者二选一**，即 subject.isAuthenticated()==true，则subject.isRemembered()==false；反之一样。\n\n* 建议：\n\n  * **访问一般网页**：如**个人在主页之类的，我们使用user 拦截器即可**，user 拦截器只要用户登录\n    (isRemembered() || isAuthenticated())过即可访问成功；\n  * **访问特殊网页**：如我的订单，**提交订单页面，我们使用authc 拦截器即可**，authc 拦截器会判断用户是否是通过Subject.login（isAuthenticated()==true）登录的，如果是才放行，否则会跳转到登录页面叫你重新登录。\n\n* 实现：\n\n  * 如果要自己做RememeberMe，需要在登录之前这样创建TokenUsernamePasswordToken(用户名，密码，是否记住我)，且调用UsernamePasswordToken 的：**token.setRememberMe(true);** 方法\n  * 修改过滤规则\n\n  ```java\n  //对于user.jsp，admin.jsp页面，需要认证后才能访问\n  filterChainDefinitionMap.put(\"/user.jsp\", \"authc,roles[user]\");\n  filterChainDefinitionMap.put(\"/admin.jsp\", \"authc,roles[admin]\");\n  //对于list.jsp页面，只要登录就能访问\n  filterChainDefinitionMap.put(\"/list.jsp\", \"user\");\n  ```\n\n* 对于记住我的设置：\n\n  * 方式一：在securityManager中直接设置\n\n  ```xml\n  <bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n    <property name=\"cacheManager\" ref=\"cacheManager\"/>\n    <property name=\"authenticator\" ref=\"authenticator\"/>\n    <property name=\"realms\">\n      <list>\n        <ref bean=\"shiroRealm\"/>\n        <ref bean=\"secondRealm\"/>\n      </list>\n    </property>\n    <property name=\"sessionManager\" ref=\"sessionManager\"/>\n    <!--设置cookie的有效期 单位：秒-->\n    <property name=\"rememberMeManager\">\n      <bean class=\"org.apache.shiro.web.mgt.CookieRememberMeManager\">\n        <property name=\"cookie.maxAge\" value=\"10\"/>\n      </bean>\n    </property>\n  </bean>\n  ```\n\n  * 方式二：设置Cookie的管理器。\n\n  ```xml\n  <bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n    <property name=\"cacheManager\" ref=\"cacheManager\"/>\n    <property name=\"authenticator\" ref=\"authenticator\"/>\n    <property name=\"realms\">\n      <list>\n        <ref bean=\"shiroRealm\"/>\n        <ref bean=\"secondRealm\"/>\n      </list>\n    </property>\n    <property name=\"sessionManager\" ref=\"sessionManager\"/>\n    <property name=\"rememberMeManager\" ref=\"rememberMeManager\"/>\n  </bean>\n  <!--对于记住我的Cookie的时效的设置-->\n  <bean id=\"cookie\" class=\"org.apache.shiro.web.servlet.SimpleCookie\">\n    <!--cookie的名字的设置-->\n    <constructor-arg value=\"remembeeeeerMe\"/>\n    <property name=\"httpOnly\" value=\"true\"/>\n    <!--30天-->\n    <property name=\"maxAge\" value=\"2592000\"/>\n  </bean>\n  <!--rememberMe管理器-->\n  <bean id=\"rememberMeManager\" class=\"org.apache.shiro.web.mgt.CookieRememberMeManager\">\n    <property name=\"cipherKey\" value=\"#{T(org.apache.shiro.codec.Base64).decode('4AvVhmFLUs0KTA3Kprsdag')}\"/>\n    <property name=\"cookie\" ref=\"cookie\"/>\n  </bean>\n  ```","categories":["Java学习","JavaEE框架"]},{"title":"SSSP整合","url":"/2021/05/22/尚硅谷说Java/项目/sssp整合/","content":"\n涉及技术：\n\n​\tSpringMVC、Spring、SpringData\\JPA 整合完成 CRUD、翻页。\n\n​\t基于Restful 风格的请求URL。\n\n​\t使用 @ResponseBody 注解完成 Ajax。\n\n​\tSpringData使用JPA的二级缓存。\n\n<!--more-->\n\n\n\n# 搭建项目\n\n* 第一步：创建java web项目。导入下列jar包。\n\n  * jar包下载地址：https://plumriver.lanzoui.com/iJCUvpbwsij\n\n* 第二步：配置各种配置文件。\n\n  * web.xml配置文件\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n           version=\"4.0\">\n  \n    <!--配置启动IOC容器的Listener-->\n    <context-param>\n      <param-name>contextConfigLocation</param-name>\n      <param-value>classpath:applicationContext.xml</param-value>\n    </context-param>\n    <listener>\n      <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n    <!--配置字符编码过滤器-->\n    <!--字符编码过滤器必须配置在所有过滤器的最前面-->\n    <filter>\n      <filter-name>characterEncodingFilter</filter-name>\n      <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n      <init-param>\n        <param-name>encoding</param-name>\n        <param-value>UTF-8</param-value>\n      </init-param>\n    </filter>\n    <filter-mapping>\n      <filter-name>characterEncodingFilter</filter-name>\n      <url-pattern>/*</url-pattern>\n    </filter-mapping>\n    <!--配置将请求转换成Restful请求的过滤器-->\n    <filter>\n      <filter-name>hiddenHttpMethodFilter</filter-name>\n      <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n    </filter>\n    <filter-mapping>\n      <filter-name>hiddenHttpMethodFilter</filter-name>\n      <url-pattern>/*</url-pattern>\n    </filter-mapping>\n  \n    <!--配置SpringMVC的DispatcherServlet-->\n    <servlet>\n      <servlet-name>dispatcherServlet</servlet-name>\n      <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n      <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:springMVC-config.xml</param-value>\n      </init-param>\n      <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n      <servlet-name>dispatcherServlet</servlet-name>\n      <url-pattern>/</url-pattern>\n    </servlet-mapping>\n  </web-app>\n  ```\n\n  * db.properties配置文件\n\n  ```properties\n  jdbc.user=root\n  jdbc.password=root\n  jdbc.driver=com.mysql.jdbc.Driver\n  jdbc.url=jdbc:mysql:///sssp\n  ```\n\n  * applicationContext.xml配置文件\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <beans xmlns=\"http://www.springframework.org/schema/beans\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xmlns:aop=\"http://www.springframework.org/schema/aop\"\n         xmlns:tx=\"http://www.springframework.org/schema/tx\"\n         xmlns:context=\"http://www.springframework.org/schema/context\"\n         xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n         xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n         http://www.springframework.org/schema/beans/spring-beans.xsd \n         http://www.springframework.org/schema/aop \n         http://www.springframework.org/schema/aop/spring-aop.xsd \n         http://www.springframework.org/schema/tx \n         http://www.springframework.org/schema/tx/spring-tx.xsd \n         http://www.springframework.org/schema/context \n         http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n    <!--配置自动扫描的包-->\n    <context:component-scan base-package=\"com.lc\" use-default-filters=\"false\">\n      <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n      <context:include-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.ControllerAdvice\"/>\n    </context:component-scan>\n    <!--配置视图解析器-->\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n      <property name=\"prefix\" value=\"/WEB-INF/views/\"/>\n      <property name=\"suffix\" value=\".jsp\"/>\n    </bean>\n    <mvc:default-servlet-handler/>\n    <mvc:annotation-driven></mvc:annotation-driven>\n  </beans>\n  ```\n\n  * springMVC-config.xml配置文件\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <beans xmlns=\"http://www.springframework.org/schema/beans\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xmlns:aop=\"http://www.springframework.org/schema/aop\"\n         xmlns:tx=\"http://www.springframework.org/schema/tx\"\n         xmlns:context=\"http://www.springframework.org/schema/context\"\n         xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n         xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n         http://www.springframework.org/schema/beans/spring-beans.xsd \n         http://www.springframework.org/schema/aop \n         http://www.springframework.org/schema/aop/spring-aop.xsd \n         http://www.springframework.org/schema/tx \n         http://www.springframework.org/schema/tx/spring-tx.xsd \n         http://www.springframework.org/schema/context \n         http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n    <!--配置自动扫描的包-->\n    <context:component-scan base-package=\"com.lc\" use-default-filters=\"false\">\n      <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n      <context:include-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.ControllerAdvice\"/>\n    </context:component-scan>\n    <!--配置视图解析器-->\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n      <property name=\"prefix\" value=\"/WEB-INF/views/\"/>\n      <property name=\"suffix\" value=\".jsp\"/>\n    </bean>\n    <mvc:default-servlet-handler/>\n    <mvc:annotation-driven></mvc:annotation-driven>\n  </beans>\n  ```\n\n\n\n# 实体类&数据表之间的关系\n\n* 实体类关系图：\n\n  ![](E:\\Markdown笔记\\尚硅谷说Java\\项目\\photo\\sssp的实体类关系图.png)\n\n* 数据表关系图：\n\n  ![](E:\\Markdown笔记\\尚硅谷说Java\\项目\\photo\\sssp的数据表关系图.png)\n\n* 创建实体类，然后让JPA生成对应的数据表即可。\n\n  ```java\n  public void testJPA(){\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n    System.out.println(context.getBean(DataSource.class).getConnection());\n  }\n  ```\n\n\n\n# 查询操作\n\n* Dao 层：\n\n  * 不带查询查询条件的分页，所以可以直接调用 PagingAndSortingRepository# findAll(Pageable pageable) 返回 Page 对象。\n\n  ```java\n  public interface EmployeeRepository extends JpaRepository<Employee,Integer> {\n  }\n  ```\n\n* Service 层：\n\n  * 没有业务逻辑。\n  * 把 Controller 传入的 pageNo 和 pageSize 封装为 Pageable 对象。注意：Pageable 的 pageNo 是从 0 开始的。\n  * 调用 Dao 层的方法即可。\n\n  ```java\n  public interface EmployeeService {\n    Page<Employee> getPage(int pageNo, int pageSize);\n  }\n  @Service\n  public class EmployeeServiceImpl implements EmployeeService {\n    @Autowired\n    private EmployeeRepository employeeRepository;\n    @Override\n    @Transactional(readOnly = true)\n    public Page<Employee> getPage(int pageNo,int pageSize){\n      PageRequest pageRequest = new PageRequest(pageNo-1, pageSize);\n      return employeeRepository.findAll(pageRequest);\n    }\n  }\n  ```\n\n* Controller 层：\n\n  * 获取 pageNo，并对 pageNo 进行校验。\n  * 调用 Service 方法返回 Page 对象。\n  * 把 Page 对象放入到 request 中。\n  * 转发页面。\n\n  ```java\n  @Controller\n  public class EmployeeController {\n    @Autowired\n    private EmployeeService employeeService;\n  \n    @RequestMapping(value = \"/emps\",method = RequestMethod.GET)\n    public String toList(\n        @RequestParam(value = \"pageNo\",\n            required = false,\n            defaultValue = \"1\") String pageNoStr,\n        Map<String,Object> map) {\n      int pageNo = 1;\n      try{\n        //对pageNoStr的校验。\n        //如果pageNoStr出错的话，pageNo默认值为1.\n        pageNo = Integer.parseInt(pageNoStr);\n        if (pageNo < 1){\n          pageNo = 1;\n        }\n      }catch (Exception e){\n      }\n  \n      Page<Employee> page = employeeService.getPage(pageNo,5);\n      map.put(\"page\",page);\n      return \"emp/list\";\n    }\n  }\n  ```\n\n* JSP 页面：使用 JSTL 来显示页面。\n\n  ```jap\n  <%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n  <%@ page isELIgnored=\"false\" %>\n  <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n  <%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %>\n  <html>\n  <head>\n    <title>显示页面</title>\n  </head>\n  <body>\n    <c:if test=\"${page == null || page.numberOfElements == 0}\">\n      没有任何记录\n    </c:if>\n    <c:if test=\"${page != null && page.numberOfElements > 0}\">\n      <table border=\"1\" cellpadding=\"5\" cellspacing=\"5\">\n        <tr>\n          <th>ID</th>\n          <th>LastName</th>\n          <th>Email</th>\n          <th>Birth</th>\n          <th>CreateTime</th>\n          <th>Department</th>\n  \n          <th>Edit</th>\n          <th>Delete</th>\n        </tr>\n        <c:forEach items=\"${page.content}\" var=\"emp\">\n          <tr>\n            <td>${emp.id}</td>\n            <td>${emp.lastName}</td>\n  \n            <td>${emp.email}</td>\n            <td>\n              <fmt:formatDate value=\"${emp.birth}\" pattern=\"yyyy-MM-dd\"/>\n            </td>\n  \n            <td>\n              <fmt:formatDate value=\"${emp.createTime}\" pattern=\"yyyy-MM-dd hh:mm:ss\"/>\n            </td>\n            <td>${emp.department.departmentName}</td>\n  \n            <td><a>edit</a></td>\n            <td><a>delete</a></td>\n          </tr>\n        </c:forEach>\n  \n        <tr>\n          <td colspan=\"8\">\n            共${page.totalElements}条记录\n            共${page.totalPages}页\n            当前位于第${page.number+1}页\n            <a href=\"?pageNo=${page.number+1-1}\">上一页</a>\n            <a href=\"?pageNo=${page.number+1+1}\">下一页</a>\n          </td>\n        </tr>\n      </table>\n  \n    </c:if>\n  </body>\n  </html>\n  ```\n\n* 额外的操作：\n\n  * 在Employee实体类的多对一映射中开启懒加载。\n\n    ```java\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"department_id\")\n    public Department getDepartment() {\n      return department;\n    }\n    ```\n\n  * 对于出现的异常。通过在web.xml中配置解决。\n\n    ```xml\n    <!--配置OpenEntityManagerInViewFilter，可以解决懒加载异常的情况。\n          优点：可以在查询数据时提升效率。\n          缺点：延长了Session的生命周期，在并发量大是会降低效率-->\n    <filter>\n      <filter-name>openEntityManagerInViewFilter</filter-name>\n      <filter-class>org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter</filter-class>\n    </filter>\n    <filter-mapping>\n      <filter-name>openEntityManagerInViewFilter</filter-name>\n      <url-pattern>/*</url-pattern>\n    </filter-mapping>\n    ```\n\n\n\n\n# 添加操作\n\n\n\n## 显示页面\n\n* Dao 层：\n\n  * 查询所有的 Department。\n\n  ```java\n  public interface DepartmentRepository extends JpaRepository<Department,Integer> {\n    @QueryHints({@QueryHint(name= org.hibernate.ejb.QueryHints.HINT_CACHEABLE,value=\"true\")})\n    @Query(\"from Department \")\n    List<Department> getAll();\n  }\n  ```\n\n  * 且需要使用 JPA 的二级缓存 。\n\n    * 添加jar包，配置JPA的二级缓存，添加ehcache配置文件。\n\n    ```xml\n    <!--JPA的二级缓存配置-->\n    <property name=\"jpaProperties\">\n      <props>\n        <!--配置Hibernate的基本属性-->\n        <prop key=\"hibernate.ejb.naming_strategy\">org.hibernate.cfg.ImprovedNamingStrategy</prop>\n        <prop key=\"hibernate.hbm2ddl.auto\">update</prop>\n        <prop key=\"hibernate.show_sql\">true</prop>\n        <prop key=\"hibernate.format_sql\">true</prop>\n        <prop key=\"hibernate.dialect\">org.hibernate.dialect.MySQL5InnoDBDialect</prop>\n        <!--配置开启二级缓存-->\n        <prop key=\"hibernate.cache.use_second_level_cache\">true</prop>\n        <prop key=\"hibernate.cache.region.factory_class\">org.hibernate.cache.ehcache.EhCacheRegionFactory</prop>\n        <prop key=\"hibernate.cache.use_query_cache\">true</prop>\n      </props>\n    </property>\n    <!--识别添加了@Cacheable注解的类才使用二级缓存-->\n    <property name=\"sharedCacheMode\" value=\"ENABLE_SELECTIVE\"/>\n    ```\n\n    ```xml\n    <!--ehcache.xml配置文件-->\n    <ehcache>\n      <diskStore path=\"java.io.tmpdir\"/>\n      <defaultCache\n                    maxElementsInMemory=\"10000\"\n                    eternal=\"false\"\n                    timeToIdleSeconds=\"120\"\n                    timeToLiveSeconds=\"120\"\n                    overflowToDisk=\"true\"\n                    />\n      <cache name=\"sampleCache1\"\n             maxElementsInMemory=\"10000\"\n             eternal=\"false\"\n             timeToIdleSeconds=\"300\"\n             timeToLiveSeconds=\"600\"\n             overflowToDisk=\"true\"\n             />\n      <cache name=\"sampleCache2\"\n             maxElementsInMemory=\"1000\"\n             eternal=\"true\"\n             timeToIdleSeconds=\"0\"\n             timeToLiveSeconds=\"0\"\n             overflowToDisk=\"false\"\n             />\n    </ehcache>\n    ```\n\n    * 给Department实体类添加@Cacheable注解。\n\n    ```java\n    @Cacheable\n    @Entity\n    @Table(name = \"department\")\n    public class Department {}\n    ```\n\n    * 默认的SpringData的方法都不提供二级缓存，因此需要自己写一个查询语句。\n    * 并且参照JPA使用二级缓存的方式对查询语句添加注解。\n\n* Service 层：调用 Dao 层的方法，获取所有的 Department，返回即可。\n\n  ```java\n  @Service\n  public class DepartmentServiceImpl implements DepartmentService{\n    @Autowired\n    private DepartmentRepository departmentRepository;\n    \n    @Override\n    @Transactional(readOnly = true)\n    public List<Department> getAll(){\n      return departmentRepository.getAll();\n    }\n  }\n  ```\n\n* Controller 层：\n\n  * 调用 Service 层，获取所有的 Department，并放入到 request 中。\n  * 创建一个新的 Employee 对象，放入到 request 中。且其键和表单的 modelAttribute 属性值一致。\n  * 转发页面。\n\n  ```java\n  @Autowired\n  private DepartmentService departmentService;\n  \n  @RequestMapping(value = \"/toEmp\",method = RequestMethod.GET)\n  public String getAll(Map<String,Object> map){\n    map.put(\"departments\", departmentService.getAll());\n    map.put(\"employee\", new Employee());\n    return \"emp/input\";\n  }\n  ```\n\n* JSP 页面：\n\n  * 需要使用 SpringMVC 的表单标签来显示表单页面。\n\n  ```jsp\n  <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %>\n  <form:form action=\"${pageContext}/emp\" method=\"post\" modelAttribute=\"employee\">\n    LastName:<form:input path=\"lastName\"/><br>\n    Email:<form:input path=\"email\"/><br>\n    Birth:<form:input path=\"birth\"/><br>\n    Department:\n    <form:select path=\"department.id\"\n                 items=\"${departments}\"\n                 itemLabel=\"departmentName\"\n                 itemValue=\"id\">\n    </form:select>\n    <br>\n    <input type=\"submit\" value=\"添加\">\n  </form:form>\n  ```\n\n* 注意：form:form 标签必须设置一个 modelAttribute 属性，以从 request 中获取对应的 bean，要求该 bean 的属性和表单字段是一一对应的。\n\n* **二级缓存的体现**：当在添加页面时。点击刷新的话不会重复查询部门信息。因为部门信息被缓存到二级缓存中去了。\n\n\n\n## Ajax验证用户可用性\n\n* Dao 层：\n  \n  * 根据 lastName 查询对应的 Employee，若存在返回 Employee 对象，若不存在则返回 null。\n  \n  ```java\n  Employee getByLastName(String lastName);\n  ```\n  \n* Service 层：直接调用 Dao 方法返回结果即可。\n\n  ```java\n    @Override\n    @Transactional(readOnly = true)\n    public Employee getEmployeeByName(String lastName) {\n      return employeeRepository.getByLastName(lastName);\n    }\n  ```\n\n* Controller 层：\n  * 获取请求参数。\n  * 调用 Service 层验证 lastName 对应的 Employee 是否存在。\n  * 若存在则返回 “1”，若不存在则返回 “0”。 需要使用 @ResponseBody 注解。\n  \n  ```java\n    @ResponseBody\n    @RequestMapping(value = \"/validateLastName\",method = RequestMethod.POST)\n    public String getEmployee(@RequestParam(value = \"lastName\") String lastName){\n      Employee employee = employeeService.getEmployeeByName(lastName);\n      if (null == employee){\n        return \"0\";\n      }else{\n        return \"1\";\n      }\n    }\n  ```\n  \n* JSP 页面：使用 jQuery 完成 Ajax 的发送，和结果的响应。\n  * 导入jquery的js文件。\n  \n  ```jsp\n  <%--注意这里的script要写成双标签形式，否则引入js后可能不起作用--%>\n  <script type=\"text/javascript\" src=\"${pageContext.request.contextPath}/static/jquery-1.9.1.min.js\"></script>\n  <script type=\"text/javascript\">\n  \n    $(function () {\n      $(\"#lastName\").change(function () {\n        var lastName = $(this).val();\n        lastName = $.trim(lastName);\n        $(this).val(lastName);\n        var url = \"${pageContext.request.contextPath}/validateLastName\";\n        var args = {\"lastName\":lastName,\"date\":new Date()};\n        $.post(url,args,function (data) {\n          if (data == \"0\"){\n            alert(\"lastName 可用！\");\n          }else if (data == \"1\"){\n            alert(\"lastName 不可用！\");\n          }else {\n            alert(\"网络错误\");\n          }\n        });\n      });\n    });\n  </script>\n  ```\n  \n* 注意事项：在引入js文件时，script标签必须写成双标签形式。\n\n\n\n## 完成添加\n\n* 确定开发目标：\n\n* Dao 层：不需要定义任何方法，直接使用 JpaRepository 或其父接口提供的 save 方法即可。\n\n* Service 层：需要调用 Dao 层的方法。注意：需要设置 createTime 属性。\n\n  ```java\n  @Override\n  @Transactional\n  public void saveEmployee(Employee employee) {\n    employee.setCreateTime(new Date());\n    employeeRepository.saveAndFlush(employee);\n  }\n  ```\n\n* Controller 层：调用 Service 层的方法，重定向到显示所有员工的页面。\n\n  ```java\n  @RequestMapping(value = \"emp\",method = RequestMethod.POST)\n  public String saveEmployee(Employee employee){\n    employeeService.saveEmployee(employee);\n    return \"redirect:/emps\";\n  }\n  ```\n\n* 注意：如何把页面上**输入的字符串转为 Date 类型**。\n\n  * 使用**@DateTimeFormat 注解**添加在实体类的属性上。\n\n  ```java\n  @DateTimeFormat(pattern = \"yyyy-MM-dd\")\n  private Date birth;\n  ```\n\n\n\n# 修改操作\n\n\n\n## 表单回显\n\n* 确定开发目标：\n\n* SpringMVC 表单回显的原理：\n\n  * 实际上表单的回显是由 SpringMVC 的 form 标签完成的\n  * 在 Handler 方法中，向 request  中添加一个属性。键：SpringMVC form:form 标签 modelAttribute 属性值，值：包含了回显信息的一个 bean 对象\n\n* URL：/emp/{id}，method：GET\n\n* Dao 层：直接调用方法，根据 id 来获取对应的 bean。\n\n* Service 层：调用 Dao 层的方法，返回 bean 对象。\n\n  ```java\n    @Override\n    public Employee getEmployeeById(Integer id) {\n      return employeeRepository.findOne(id);\n    }\n  ```\n\n* Controller 层：\n\n  * 获取 id\n  * 调用 Service 方法，得到 bean 的对象\n  * 获取全部的 Department，并放入到 request 中。\n  * 把 bean 对象放入到 request 中，键为：form:form 标签的 modelAttribute 属性值\n  * 转发页面\n\n  ```java\n    @RequestMapping(value = \"emp/{id}\",method = RequestMethod.GET)\n    public String input(@PathVariable(\"id\")Integer id,Map<String,Object> map){\n      map.put(\"employee\", employeeService.getEmployeeById(id));\n      map.put(\"departments\", departmentService.getAll());\n      return \"emp/input\";\n    }\n  ```\n\n\n\n## 修改状态下 Ajax 验证用户名可用性\n\n* 确定开发目标：\n* 和 添加状态下 Ajax 验证的区别：若修改后当前的 lastName没变化，则不应该再发送任何 Ajax 请求，而直接 alert：用户名可用。\n* JSP 页面：修改 JS 的 Ajax 请求逻辑：若修改回之前的 lastName 则不发送任何请求，直接弹出 “用户名可用”。\n\n```jsp\n<!-- \n      //修改时对新name和老name的验证\n      var oldLastName = $(\"#oldLastName\").val();\n      oldLastName = $.trim(oldLastName);\n      if (oldLastName != null && oldLastName != \"\" && oldLastName == lastName){\n        alert(\"lastName 可用！\");\n        return;\n      }\n-->\n<c:if test=\"${employee.id != null}\">\n  <input type=\"hidden\" id=\"oldLastName\" value=\"${employee.lastName}\">\n</c:if>\n```\n\n\n\n## 修改功能\n\n* 确定开发目标：\n\n* URL：emp/{id}，method：PUT\n\n* Dao 层：继续使用 saveAndFlush 方法即可\n\n* Service 层：\n\n  * 不需要设置 createTime 属性\n  * 判定添加和修改的标准：传入的 bean 的 id 是否为 null\n\n  ```java\n    @Override\n    @Transactional\n    public void saveEmployee(Employee employee) {\n      if (employee.getId() == null){\n        employee.setCreateTime(new Date());\n      }\n      employeeRepository.saveAndFlush(employee);\n    }\n  ```\n\n* Cotroller 层：\n\n  * 新建 @ModelAttribute 注解修饰的方法，在其中利用 id 获取对应的 bean，并把该 bean 放入到 map 中，键为：Employee 类名第一个字母小写\n  * 在 @ModelAttribute 方法中，把关联的 department 置为 null\n  * 调用 Service 的方法进行更新\n  * 重定向到：/emps\n\n  ```java\n  @ModelAttribute\n  public void getEmployee(@RequestParam(value = \"id\",required = false) Integer id,\n                          Map<String,Object> map){\n    if (id != null){\n      Employee employee = employeeService.getEmployeeById(id);\n      employee.setDepartment(null);\n      map.put(\"employee\", employee);\n    }\n  }\n  \n  @RequestMapping(value = \"emp/{id}\",method = RequestMethod.PUT)\n  public String updateEmployyee(Employee employee){\n    employeeService.saveEmployee(employee);\n    return \"redirect:/emps\";\n  }\n  ```\n\n* JSP 页面：id 和 _method 加入到隐藏域中。\n\n  ```jsp\n  <c:set value=\"${pageContext.request.contextPath }/emp\" var=\"url\"></c:set>\n  <c:if test=\"${employee.id != null }\">\n    <c:set value=\"${pageContext.request.contextPath }/emp/${employee.id}\" var=\"url\"></c:set>\n  </c:if>\n  \n  <form:form action=\"${url}\" method=\"post\" modelAttribute=\"employee\">\n    <c:if test=\"${employee.id != null}\">\n      <input type=\"hidden\" id=\"oldLastName\" value=\"${employee.lastName}\">\n      <form:hidden path=\"id\"/>\n      <input type=\"hidden\" name=\"_method\" value=\"PUT\">\n    </c:if>\n    <!--....-->\n  </form:form>\n  ```\n\n\n\n# 删除操作\n\n* 确定开发目标：\n\n* URL：emp/{id}、method：DELETE\n\n* Dao 层：直接使用 SpringData 已经自带的 delete 方法即可\n\n* Service 层：直接调用 Dao 方法即可\n\n  ```java\n  @Override\n  @Transactional\n  public void delete(Integer id) {\n    employeeRepository.delete(id);\n  }\n  ```\n\n* Controller 层：\n\n  * 直接调用 Service 方法\n  * 重定向到 /emps \n\n  ```java\n  @RequestMapping(value=\"/emp/{id}\",method=RequestMethod.DELETE)\n  public String delete(@PathVariable(\"id\") Integer id){\n    employeeService.delete(id);\n    return \"redirect:/emps\";\n  }\n  ```\n\n* JSP 页面：\n\n  * 使用 JS confirm：确定要删除 xx 的信息吗 \n  * 把超链接的 GET 请求转为 POST 请求，且携带 _method=DELETE 的请求参数\n\n  ```jsp\n  <script type=\"text/javascript\" src=\"${pageContext.request.contextPath }/static/jquery-1.9.1.min.js\"></script>\n  <script type=\"text/javascript\">\n    $(function(){\n      $(\".delete\").click(function(){\n        var label = $(this).next(\":hidden\").val();\n        var flag = confirm(\"确定要删除\" + label + \"的信息吗?\");\n        if(flag){\n          var url = $(this).attr(\"href\");\n  \n          $(\"#_form\").attr(\"action\", url);\n          $(\"#_method\").val(\"DELETE\");\n          $(\"#_form\").submit();\n        }\n  \n        return false;\n      });\n    })\n  </script>\n  <body>\n    <form action=\"\" method=\"POST\" id=\"_form\">\n      <input type=\"hidden\" id=\"_method\" name=\"_method\"/>\n    </form>     \n    <td>\n      <a href=\"${pageContext.request.contextPath }/emp/${emp.id}\" class=\"delete\">Delete</a>\n      <input type=\"hidden\" value=\"${emp.lastName }\"/>\n    </td>\n  </body>\n  ```\n\n\n\n# 注意事项\n\n* 对于级联数据。\n  * 不开启懒加载时，可以直接通过EL表达式的级联显示数据。但会降低效率。\n  * 开启懒加载时，可能会出现懒加载异常。\n    * 解决方式：在web.xml文件中配置。","categories":["Java学习","项目"]},{"title":"SpringData的学习","url":"/2021/05/21/尚硅谷说Java/JavaEE框架/SpringData/","content":"\n主要内容为SpringData和JPA的整合使用。包含Hibernate。\n\n<!--more-->\n\n\n\n# 概述\n\n* Spring Data : Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。\n* SpringData 项目所支持 NoSQL 存储：\n  * MongoDB （文档数据库）\n  * Neo4j（图形数据库）\n  * Redis（键/值存储）\n  * Hbase（列族数据库）\n* SpringData 项目所支持的关系数据存储技术：\n  * JDBC\n  * JPA\n* JPA Spring Data : 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，**就只是声明持久层的接口**，其他都交给 Spring Data JPA 来帮你完成！\n* 框架怎么可能代替开发者实现业务逻辑呢？\n  * 比如：当有一个 UserDao.findUserById()  这样一个方法声明，大致应该能判断出这是根据给定条件的 ID 查询出满足条件的 User  对象。Spring Data JPA 做的便是规范方法的名字，**根据符合规范的名字来确定方法需要实现什么样的逻辑**。\n\n\n\n# HelloWorld\n\n* 使用 Spring Data JPA 进行持久层开发需要的四个步骤：\n\n  * 配置 **Spring 整合 JPA**。\n  * 在 **Spring 配置文件中配置 Spring Data**，让 Spring 为声明的接口创建代理对象。配置了 \\<jpa:repositories> 后，Spring 初始化容器时将会扫描 base-package  指定的包目录及其子目录，为继承 Repository 或其子接口的接口创建代理对象，并将代理对象注册为 Spring Bean，业务层便可以通过 Spring 自动封装的特性来直接使用该对象。\n  * **声明持久层的接口，该接口继承  Repository**，Repository 是一个标记型接口，它不包含任何方法，如必要，Spring Data 可实现 Repository 其他子接口，其中定义了一些常用的增删改查，以及分页相关的方法。\n  * **在接口中声明需要的方法**。Spring Data 将根据给定的策略（具体策略稍后讲解）来为其生成实现代码。\n\n* 具体过程：\n\n  * 第一步：创建Java项目，导入相关的jar包。\n\n    * jar包下载地址：https://plumriver.lanzoui.com/iVI65pbdqej\n    * jar包包含Spring,SpringData,JPA,Hibernate,Mysql驱动，C3P0连接池等等。\n    * 说明：Commons 是 Spring Data 的基础包。\n\n  * 第二步：配置配置文件。\n\n    * 数据库配置db.properties文件：\n\n    ```properties\n    jdbc.user=root\n    jdbc.password=root\n    jdbc.driver=com.mysql.jdbc.Driver\n    jdbc.url=jdbc:mysql:///jpa\n    ```\n\n    * spring配置applicationContext.xml文件：\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n           xmlns:jpa=\"http://www.springframework.org/schema/data/jpa\"\n           xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans.xsd\n           http://www.springframework.org/schema/context\n           http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\">\n      <!--1.配置数据连接池-->\n      <context:property-placeholder location=\"classpath:db.properties\"/>\n      <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n        <property name=\"user\" value=\"${jdbc.user}\"/>\n        <property name=\"password\" value=\"${jdbc.password}\"/>\n        <property name=\"driverClass\" value=\"${jdbc.driver}\"/>\n        <property name=\"jdbcUrl\" value=\"${jdbc.url}\"/>\n      </bean>\n      <!--2.配置JPA的EntityManagerFactory-->\n      <bean id=\"managerFactory\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <property name=\"jpaVendorAdapter\">\n          <bean class=\"org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter\"/>\n        </property>\n        <property name=\"packagesToScan\" value=\"com.lc\"/>\n        <property name=\"jpaProperties\">\n          <props>\n            <!--生成数据表的列的映射策略-->\n            <prop key=\"hibernate.ejb.naming_strategy\">org.hibernate.cfg.ImprovedNamingStrategy</prop>\n            <!--hibernate的基本属性-->\n            <prop key=\"hibernate.dialect\">org.hibernate.dialect.MySQL5InnoDBDialect</prop>\n            <prop key=\"hibernate.show_sql\">true</prop>\n            <prop key=\"hibernate.format_sql\">true</prop>\n            <prop key=\"hibernate.hbm2ddl.auto\">update</prop>\n          </props>\n        </property>\n      </bean>\n      <!--3.配置事务管理器-->\n      <bean id=\"transactionManager\" class=\"org.springframework.orm.jpa.JpaTransactionManager\">\n        <property name=\"entityManagerFactory\" ref=\"managerFactory\"/>\n      </bean>\n      <!--4.配置支持注解的事务-->\n      <tx:annotation-driven transaction-manager=\"transactionManager\"/>\n      <!--5.配置SpringData-->\n      <!--加入jpa的命名空间-->\n      <!--base-package：会扫描Repository Bean 所在的package-->\n      <jpa:repositories base-package=\"com.lc\"\n                        entity-manager-factory-ref=\"managerFactory\"\n                        transaction-manager-ref=\"transactionManager\"/>\n    </beans>\n    ```\n\n  * 第三步：创建实体类：\n\n  ```java\n  import javax.persistence.*;\n  import java.util.Date;\n  @Entity\n  @Table(name = \"persons\")\n  public class Person {\n    private Integer id;\n    private String perName;\n    private Date birth;\n    @Id\n    @GeneratedValue\n    public Integer getId() {\n      return id;\n    }\n  \n    public void setId(Integer id) {\n      this.id = id;\n    }\n    @Column(name = \"per_name\")\n    public String getPerName() {\n      return perName;\n    }\n  \n    public void setPerName(String perName) {\n      this.perName = perName;\n    }\n    @Temporal(TemporalType.TIMESTAMP)\n    public Date getBirth() {\n      return birth;\n    }\n  \n    public void setBirth(Date birth) {\n      this.birth = birth;\n    }\n  \n    @Override\n    public String toString() {\n      return \"Person{\" +\n          \"id=\" + id +\n          \", perName='\" + perName + '\\'' +\n          \", birth=\" + birth +\n          '}';\n    }\n  }\n  ```\n\n  * 第四步：创建repository子接口：\n\n  ```java\n  import com.lc.bean.Person;\n  import org.springframework.data.repository.Repository;\n  import java.io.Serializable;\n  \n  public interface PersonRepository extends Repository<Person, Integer> {\n    //根据name获取person\n    Person getByPerName(String perName);\n  }\n  ```\n\n  * 第四步：测试代码：\n\n  ```java\n  public class MainTest {\n    private ApplicationContext context;\n    {\n      context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n    }\n    @Test\n    public void testDataSource() throws SQLException {\n      DataSource dataSource = context.getBean(DataSource.class);\n      System.out.println(dataSource.getConnection());\n    }\n    @Test\n    public void testJPA(){\n      //创建一个实体类。然后运行。\n      //查看数据库中是否已经生成表了\n  \n    }\n    @Test\n    public void testHelloSpringData(){\n      PersonRepository personRepository = context.getBean(PersonRepository.class);\n      Person person = personRepository.getByPerName(\"aa\");\n      System.out.println(person);\n    }\n  }\n  ```\n\n\n\n# Repository 接口\n\n* Repository 接口是 Spring Data 的一个核心接口，它不提供任何方法，开发者需要在自己定义的接口中声明需要的方法 。\n\n  ```java\n  public interface Repository<T, ID extends Serializable> {\n  }\n  ```\n\n* Spring Data可以让我们只定义接口，只要**遵循 Spring Data的规范**，就无需写实现类。 \n\n* 与继承 Repository 等价的另一种方式，就是在持久层接口上**使用 @RepositoryDefinition 注解**，并为其**指定 domainClass 和 idClass 属性**。\n\n  ```java\n  /**\n   * 1.Repository是一个空接口，也是一个标记接口\n   * 2.若我们定义的接口继承了Repository，则我们定义的接口会被容器识别为一个Repository Bean\n   *   进而纳入到IOC容器中。\n   * 3.通过再此接口中声明一些遵循规范的方法。Repository会自动帮我们实现其对应的业务。\n   * 4.\n   */\n  public interface PersonRepository extends Repository<Person, Integer> {\n    //根据name获取person\n    Person getByPerName(String perName);\n  }\n  //方式二\n  @RepositoryDefinition(domainClass = Student.class,\n      idClass = Integer.class)\n  public interface StudentRepository {\n  }\n  ```\n\n* 基础的 Repository 提供了最基本的数据访问功能，其几个子接口则扩展了一些功能。它们的继承关系如下： \n\n  * Repository： 仅仅是一个标识，表明任何继承它的均为仓库接口类。\n  * CrudRepository： 继承 Repository，实现了一组 **CRUD 相关的方法** 。\n  * PagingAndSortingRepository： 继承 CrudRepository，实现了一组**分页排序相关**的方法 。\n  * JpaRepository： 继承 PagingAndSortingRepository，实现一组 JPA 规范相关的方法 。\n  * 自定义的 XxxxRepository 需要继承 JpaRepository，这样的 XxxxRepository 接口就具备了通用的数据访问控制层的能力。\n  * **JpaSpecificationExecutor**： **不属于Repository体系**，**实现一组 JPA Criteria 查询**相关的方法 。\n  * Repository接口的继承图如下：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210521170351.png)\n\n\n\n# 方法定义规范\n\n* 简单条件查询：\n\n  * 简单条件查询: 查询某一个实体类或者集合 。\n\n  * 按照 Spring Data 的规范，**查询方法以 find | read | get 开头**， \n\n  * 涉及条件查询时，**条件的属性用条件关键字连接**，要注意的是：**条件属性以首字母大写**。 \n\n  * **条件的属性名称与个数要与参数的位置与个数一一对应** 。\n\n  * 例如：定义一个 Entity 实体类 。\n\n    ```java\n    class User｛ \n      private String firstName; \n      private String lastName; \n    ｝ \n    //使用And条件连接时，应这样写：\n    //   findByLastNameAndFirstName(String lastName,String firstName);\n    ```\n\n* 支持的关键字:\n\n  * 直接在接口中定义查询方法，如果是符合规范的，可以不用写实现，目前支持的关键字写法如下：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210521170351-1.png)\n\n* 支持**级联属性查询**。\n\n  * 在使用级联属性时，方法的定义上要将级联属性使用下划线(_)隔开。\n\n  ```java\n  List<Person> readByAddress_id(Integer add_id);\n  ```\n\n* 查询方法解析流程：\n\n  * 假如创建如下的查询：findByUserDepUuid()，框架在解析该方法时，首先剔除 findBy，然后对剩下的属性进行解析，假设查询实体为Doc。\n    * 先判断 userDepUuid （根据 POJO 规范，首字母变为小写）是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，继续第二步；\n    * 从右往左截取第一个大写字母开头的字符串(此处为Uuid)，然后检查剩下的字符串是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，则重复第二步，继续从右往左截取；最后假设 user 为查询实体的一个属性；\n    * 接着处理剩下部分（DepUuid），先判断 user 所对应的类型是否有depUuid属性，如果有，则表示该方法最终是根据 “ Doc.user.depUuid” 的取值进行查询；否则继续按照步骤 2 的规则从右往左截取，最终表示根据 “Doc.user.dep.uuid” 的值进行查询。\n    * 可能会存在一种特殊情况，比如 Doc包含一个 user 的属性，也有一个 userDep 属性，此时会存在混淆。可以明确在属性之间加上 \"_\" 以显式表达意图，比如 \"findByUser_DepUuid()\" 或者 \"findByUserDep_uuid()\"。\n\n* **特殊的参数**： 还可以直接在方法的参数上加入分页或排序的参数，比如：\n\n  ```java\n  Page<UserModel> findByName(String name, Pageable pageable);\n  List<UserModel> findByName(String name, Sort sort);\n  ```\n\n\n\n# @Query 注解\n\n* 使用@Query自定义查询：\n\n  * 这种查询可以声明在 Repository 方法中，**摆脱像命名查询那样的约束**，将查询直接在相应的接口方法中声明，结构更为清晰，这是 Spring data 的特有实现。\n\n  ```java\n  //查询id值最大的student的数据\n  //@Query注解中的语句类似与JPQL语句，是面向对象的SQL语句\n  @Query(\"select s from Student s where s.id = (select max(s2.id) from Student s2)\")\n  Student getMaxIdStudent();\n  ```\n\n* 索引参数与命名参数：\n\n  * 索引参数如下所示，索引值从1开始，查询中 ”?X” 个数需要与方法定义的参数个数相一致，并且顺序也要一致 。\n\n  ```java\n  //查询id小于，且名字中含有的student数据\n  @Query(\"select s from Student s where s.id < ?1 and s.name like ?2\")\n  List<Student> getresult(Integer id,String name);\n  ```\n\n  * 命名参数（推荐使用这种方式）：可以定义好参数名，**赋值时采用@Param(\"参数名\")**，而不用管顺序。\n\n  ```java\n  //查询id小于，且名字中含有的student数据\n  @Query(\"select s from Student s where s.id < :ID and s.name like :NAME\")\n  List<Student> getResult2(@Param(\"ID\") Integer id, @Param(\"NAME\") String name);\n  ```\n\n  * 如果是 @Query 中有 LIKE 关键字，后面的参数需要前面或者后面加 %，这样在传递参数值的时候就可以不加 %：\n\n  ```java\n  @Query(\"select o from UserModel o where o.name like ?1%\")\n  public List<UserModel> findByUuidOrAge(String name);\n  @Query(\"select o from UserModel o where o.name like %?1\")\n  public List<UserModel> findByUuidOrAge(String name);\n  @Query(\"select o from UserModel o where o.name like %?1%\")\n  public List<UserModel> findByUuidOrAge(String name);\n  ```\n\n* 用@Query来指定本地SQL查询：\n\n  * 还可以使用@Query来指定本地sql查询，只需要设置nativeQuery属性为true。\n  * 本地sql指使用原生的Mysql等语句。\n\n  ```java\n  //使用mysql规则进行查询\n  @Query(value = \"select * from student where id = ?1\", nativeQuery = true)\n  Student getById(Integer id);\n  ```\n\n\n\n# @Modifying 注解和事务\n\n* @Query 与 @Modifying 这两个 annotation一起声明，可**定义个性化更新操作**，例如只涉及某些字段更新时最为常用。\n\n* @Modifying：可以表明这个方法是一个修改的方法。修改包括删除和更新操作。\n\n* 使用时注意：\n\n  * 方法的返回值应该是 int，表示更新语句所影响的行数。\n  * 在**调用的地方必须加事务**，没有事务不能正常执行。\n    * 即在调用带@Modifying 注解的方法时，必须声明为事务。\n\n  ```java\n  @RepositoryDefinition(domainClass = Student.class,\n      idClass = Integer.class)\n  public interface StudentRepository {\n    //更新操作\n    @Modifying\n    @Query(\"update Student s set s.name = :name where s.id = :id\")\n    Integer updateName(@Param(\"name\")String name,@Param(\"id\")Integer id);\n  }\n  @Service\n  public class StudentService {\n    @Autowired\n    private StudentRepository studentRepository;\n  \n    @Transactional\n    public Integer updateStudent(String name,Integer id){\n      return studentRepository.updateName(name, id);\n    }\n  }\n  ```\n\n* Spring Data 提供了默认的事务处理方式，即**所有的查询均声明为只读事务**。\n\n* 对于自定义的方法，如需改变 Spring Data 提供的事务默认方式，可以在方法上注解 @Transactional 声明 。\n\n* 进行多个 Repository 操作时，也应该使它们在同一个事务中处理，按照分层架构的思想，这部分属于业务逻辑层，因此，**需要在 Service 层实现对多个 Repository 的调用，并在相应的方法上声明事务**。\n\n* 总结：\n\n  * @Query注解只支持查询。当需要更新和删除操作时，需要添加上@Modifying。\n  * @Modifying修饰的方法被调用时，调用方必须添加@Transactional注解声明事务。\n\n\n\n# CrudRepository 接口\n\n* CrudRepository 接口继承了Repository 接口。\n* CrudRepository 接口提供了最基本的对实体类的添删改查操作 。\n  * T save(T entity);    //保存单个实体。 \n  * Iterable\\<T> save(Iterable<? extends T> entities);    //保存集合。        \n  * T findOne(ID id);    //根据id查找实体。         \n  * boolean exists(ID id);    //根据id判断实体是否存在。         \n  * Iterable\\<T> findAll();    //查询所有实体,不用或慎用!         \n  * long count();    //查询实体数量。         \n  * void delete(ID id);    //根据Id删除实体 。     \n  * void delete(T entity);     //删除一个实体 。\n  * void delete(Iterable<? extends T> entities);     //删除一个实体的集合。\n  * void deleteAll();    //删除所有实体,不用或慎用! \n\n```java\npublic interface AddressRepository extends CrudRepository<Address,Integer> {\n}\n@Service\npublic class AddressService {\n  @Autowired\n  private AddressRepository addressRepository;\n\n  @Transactional\n  public void save(Address address){\n    addressRepository.save(address);\n  }\n}\n@Test\npublic void testCRUDRepository(){\n  AddressService service = context.getBean(AddressService.class);\n  Address address = new Address();\n  address.setCity(\"北京\");\n  service.save(address);\n}\n```\n\n\n\n# PagingAndSortingRepository接口\n\n* 该接口继承了CrudRepository 接口。\n* 该接口提供了分页与排序功能 。\n  * Iterable\\<T> findAll(Sort sort);    //排序 。\n  * Page\\<T> findAll(Pageable pageable);    //分页查询（含排序功能）。\n* 该接口提供的两个功能都是只读操作。\n* 该接口可以实现通用的分页功能。但是无法实现带查询的分页，比如搜索后的分页。\n* Pageable 中包含了Sort。因此以Pageable 为例。\n\n```java\npublic interface TeacherRepository extends PagingAndSortingRepository<Teacher,Integer> {\n}\npublic void testPagingAndSortingRepository(){\n  TeacherRepository teacherRepository = context.getBean(TeacherRepository.class);\n  //PageRequest为Pageable的实现类，其封装了需要分页的信息\n  //pageNo是从0开始算的\n  int pageNo = 1 - 1; //第1页\n  int pageSize = 5; // 一页5条数据\n\n  //排序相关的\n  //按照id降序，按照date升序\n  Sort.Order order1 = new Sort.Order(Sort.Direction.DESC,\"id\");\n  Sort.Order order2 = new Sort.Order(Sort.Direction.ASC,\"date\");\n  Sort sort = new Sort(order1,order2);\n\n  PageRequest pageRequest = new PageRequest(pageNo, pageSize,sort);\n\n  Page<Teacher> teacherPage = teacherRepository.findAll(pageRequest);\n  //结果是先排序后分页查询\n  System.out.println(\"总记录数：\"+teacherPage.getTotalElements());\n  System.out.println(\"当前位于第几页：\"+teacherPage.getNumber());\n  System.out.println(\"总页数：\"+teacherPage.getTotalPages());\n  System.out.println(\"当前页面的list：\"+teacherPage.getContent());\n  System.out.println(\"当前页面的记录数：\"+teacherPage.getNumberOfElements());\n}\n```\n\n\n\n# JpaRepository接口\n\n* JpaRepository接口继承了PagingAndSortingRepository接口。\n* 该接口提供了JPA的相关功能 。\n  * List\\<T> findAll();     //查找所有实体 。\n  * List\\<T> findAll(Sort sort);     //排序、查找所有实体 。\n  * List\\<T> save(Iterable<? extends T> entities);    //保存集合 。\n  * void flush();    //执行缓存与数据库同步 。\n  * T saveAndFlush(T entity);    //强制执行持久化 。相当于JPA的merge方法。\n  * void deleteInBatch(Iterable\\<T> entities);    //删除一个实体集合 。\n\n\n\n# JpaSpecificationExecutor接口\n\n* 此接口不属于Repository体系，定义了一组 JPA Criteria 查询相关的方法。\n\n  ```java\n  public interface JpaSpecificationExecutor<T> {\n    //根据条件查询单个数据\n    T findOne(Specification<T> var1);\n  \t//根据条件查询\n    List<T> findAll(Specification<T> var1);\n  \t//根据条件查询，然后分页\n    Page<T> findAll(Specification<T> var1, Pageable var2);\n  \t//根据条件查询，然后排序\n    List<T> findAll(Specification<T> var1, Sort var2);\n  \t//根据条件进行统计\n    long count(Specification<T> var1);\n  }\n  ```\n\n* 此接口可以实现带查询的分页操作。\n\n* Specification：封装  JPA Criteria 查询条件。通常使用**匿名内部类的方式来创建该接口的对象**。\n\n```java\n  /**\n   * 目标：实现带查询条件的分页。条件为id > 5\n   * 通过JpaSpecificationExecutor的findAll(Specification<T> var1, Pageable var2)方法实现。\n   * Specification：封装了JPA Criteria查询的条件\n   * Pageable：封装了请求分页的信息。例如pageNo,pageSize,Sort\n   */\n  @Test\n  public void testJpaSpecificationExecutor(){\n    PersonRepository personRepository = context.getBean(PersonRepository.class);\n\n    int pageNo = 1-1;\n    int pageSize = 5;\n    PageRequest pageRequest = new PageRequest(pageNo, pageSize);\n    //通常使用匿名内部类的方式实现Specification\n    Specification<Person> specification = new Specification<Person>() {\n      /**\n       *\n       * @param root: 代表查询的实体类.\n       * @param criteriaQuery: 可以从中可到 Root 对象, 即告知 JPA Criteria 查询要查询哪一个实体类. 还可以\n       * 来添加查询条件, 还可以结合 EntityManager 对象得到最终查询的 TypedQuery 对象. 不常用。\n       * @param criteriaBuilder: CriteriaBuilder 对象. 用于创建 Criteria 相关对象的工厂. 当然可以从中获取到 Predicate 对象\n       * @return: Predicate 类型, 代表一个查询条件.\n       */\n      @Override\n      public Predicate toPredicate(Root<Person> root, CriteriaQuery<?> criteriaQuery, CriteriaBuilder criteriaBuilder) {\n        //从root中获取属性名为id的路径\n        Path path = root.get(\"id\");\n        //条件为path代表的属性大于5\n        Predicate predicate = criteriaBuilder.gt(path, 5);\n        return predicate;\n      }\n    };\n\n    Page<Person> page = personRepository.findAll(specification, pageRequest);\n\n    System.out.println(\"总记录数\"+page.getTotalElements());\n    System.out.println(\"列表\"+page.getContent());\n  }\n\n  /**\n   * 获取地址为上海的person信息，并分页显示\n   */\n  @Test\n  public void testJpaSpecificationExecutor2(){\n    PersonRepository personRepository = context.getBean(PersonRepository.class);\n    int pageNo = 1-1;\n    int pageSize = 5;\n    PageRequest pageRequest = new PageRequest(pageNo, pageSize);\n    Specification<Person> specification = new Specification<Person>() {\n      @Override\n      public Predicate toPredicate(Root<Person> root, CriteriaQuery<?> criteriaQuery, CriteriaBuilder criteriaBuilder) {\n        //从root中获取属性名为address.name的路径\n        Path path = root.get(\"address\").get(\"city\");\n        //条件path执行的属性值等于 \"上海\"\n        Predicate predicate = criteriaBuilder.equal(path,\"上海\");\n        return predicate;\n      }\n    };\n\n    Page<Person> page = personRepository.findAll(specification, pageRequest);\n\n    System.out.println(\"总记录数\"+page.getTotalElements());\n    System.out.println(\"列表\"+page.getContent());\n  }\n```\n\n\n\n# 自定义 Repository 方法\n\n* 为**某一个 Repository** 上添加自定义方法。以SchoolRepository为例。\n\n  * 步骤：\n\n    * 第一步：自定义一个接口: 声明自定义方法。接口名为SchoolDao。\n    * 第二步：提供该接口的实现类: 实现接口的方法。**实现类名必须是SchoolRepositoryImpl**。\n      * 实现类的类名格式是：XxxRepository+Impl。\n    * 第三步：让SchoolRepository接口继承 第一步定义的接口即可。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210521170351-2.png)\n\n  * 说明：前两步就已经自定义好Repository 接口了。第三步是如何使用自定义的Repository 接口。\n\n  ```java\n  public interface SchoolDao {\n    void test();\n  }\n  public class SchoolRepositoryImpl implements SchoolDao{\n    @PersistenceContext\n    private EntityManager entityManager;\n    @Override\n    public void test() {\n      //此处可以来连接数据库，进行各种操作\n      System.out.println(\"自定义的Repository方法\" + entityManager);\n    }\n  }\n  @RepositoryDefinition(domainClass = School.class,idClass = Integer.class)\n  public interface SchoolRepository extends SchoolDao{\n  }\n  ```\n\n  * 注意事项：\n    * 默认情况下, Spring Data 会在 base-package 中**查找 \"接口名Impl\" 作为实现类**。\n    * 也可以通过修改<jpa:repositories /> 节点的repository-impl-postfix属性来声明后缀。\n\n* 为所有的 Repository 都添加自实现的方法。\n\n  * 步骤：\n    * 声明一个接口, 在该接口中声明需要自定义的方法, 且该接口需要继承 Spring Data 的 Repository。\n    * 提供 1) 所声明的接口的实现类. 且继承 SimpleJpaRepository, 并提供方法的实现。\n    * 定义 JpaRepositoryFactoryBean 的实现类, 使其生成 1) 定义的接口实现类的对象。\n    * 修改 <jpa:repositories /> 节点的 factory-class 属性指向 3) 的全类名。\n  * 注意: 全局的扩展实现类不要用 Imp 作为后缀名, 或为全局扩展接口添加 @NoRepositoryBean 注解告知  Spring Data: Spring Data 不把其作为 Repository。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["Java学习","JavaEE框架"]},{"title":"JPA的学习","url":"/2021/05/20/尚硅谷说Java/JavaEE框架/JPA/","content":"\nJPA的学习。基于IDEA，HIbernate。包含与Spring的整合。\n\nJPA相当于hibernate的上层统一接口层协议。\n\n<!--more-->\n\n# JPA规范\n\n* Java Persistence API：用于对象持久化的 API。\n\n* Java EE 5.0 平台标准的 ORM 规范，使得应用程序以统一的方式访问持久层。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210520191105.png)\n\n* JPA和Hibernate的关系：\n\n  * JPA 是 hibernate 的一个抽象（就像JDBC和JDBC驱动的关系）：\n    * JPA 是**规范**：JPA 本质上就是一种  ORM 规范，不是ORM 框架 —— 因为 JPA 并未提供 ORM 实现，它只是制订了一些规范，**提供了一些编程的 API 接口**，但具体实现则由 ORM 厂商提供实现。\n    * Hibernate 是实现：Hibernate 除了作为 ORM 框架之外，它也是一种 JPA 实现。\n  * 从功能上来说， **JPA 是 Hibernate 功能的一个子集**。\n\n* JPA 的供应商：\n\n  * JPA 的目标之一是**制定一个可以由很多供应商实现的 API**，目前Hibernate 3.2+、TopLink 10.1+ 以及 OpenJPA 都提供了 JPA 的实现。\n  * Hibernate：\n    * JPA 的始作俑者就是 Hibernate 的作者。\n    * Hibernate 从 3.2 开始兼容 JPA。\n  * OpenJPA：\n    * OpenJPA  是 Apache 组织提供的开源项目。\n  * TopLink：\n    * TopLink 以前需要收费，如今开源了。\n\n* JPA的优势：\n\n  * **标准化**：提供相同的 API，这保证了基于JPA 开发的企业应用能够经过少量的修改就能够在不同的 JPA 框架下运行。\n  * **简单易用，集成方便**： JPA 的主要目标之一就是提供更加简单的编程模型，在 JPA 框架下创建实体和创建 Java  类一样简单，只需要使用 javax.persistence.Entity 进行注释；JPA 的框架和接口也都非常简单。\n  * **可媲美JDBC的查询能力**： JPA的查询语言是面向对象的，JPA定义了独特的**JPQL**，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。\n  * **支持面向对象的高级特性**：JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，最大限度的使用面向对象的模型。\n\n* JPA的3方面技术：\n\n  * ORM  映射元数据：JPA 支持 **XML 和  JDK 5.0 注解**两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中。  \n  * JPA 的 API：用来操作实体对象，执行CRUD操作，框架在后台完成所有的事情，开发者从繁琐的 JDBC和 SQL代码中解脱出来。  \n  * **查询语言（JPQL）**：这是持久化操作中很重要的一个方面，通过面向对象而非面向数据库的查询语言查询数据，避免程序和具体的  SQL 紧密耦合。\n\n\n\n# Hello World\n\n* 使用JPA持久化对象的步骤：\n\n  * 创建 persistence.xml, 在这个文件中配置持久化单元：\n    * 需要指定跟哪个数据库进行交互。\n    * 需要指定 JPA 使用哪个持久化的框架以及配置该框架的基本属性。\n  * 创建实体类, **使用 annotation 来描述实体类跟数据库表之间的映射关系**。\n  * 使用 JPA API 完成数据增加、删除、修改和查询操作：\n    * 创建 **EntityManagerFactory** (对应 Hibernate 中的 SessionFactory);\n    * 创建 **EntityManager** (对应 Hibernate 中的Session);\n\n* 第一步：使用IDEA创建Java项目。\n\n* 第二步：在项目下创建lib文件。放入下载的jar包。然后将所有的jar包添加到项目库中。\n\n  * jar包下载地址：\n\n* 第三步：在src目录下创建META-INF目录，然后再此目录下创建persistence.xml文件。\n\n  * persistence.xml文件为JPA的配置文件。\n  * persistence.xml文件的文件名不能随意起名。且此配置文件一定要放在src/META-INF目录下。\n  * 文件示例：\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <persistence version=\"2.0\"\n               xmlns=\"http://java.sun.com/xml/ns/persistence\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n               xsi:schemaLocation=\"http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd\">\n    <!--transaction-type：表示事务方式。RESOURCE_LOCAL表示使用本地事务。JTA表示使用分布式事务-->\n    <!--name 属性用于定义持久化单元的名字, 必写-->\n    <persistence-unit name=\"jpa-1\" transaction-type=\"RESOURCE_LOCAL\">\n  \n      <!--\n      配置使用什么 ORM 产品来作为 JPA 的实现\n        1. 实际上配置的是  javax.persistence.spi.PersistenceProvider 接口的实现类\n        2. 若 JPA 项目中只有一个 JPA 的实现产品, 则也可以不配置该节点.\n      -->\n      <provider>org.hibernate.ejb.HibernatePersistence</provider>\n  \n      <!--添加持久化类-->\n      <class>com.lc.bean.Customer</class>\n  \n      <properties>\n        <!--配置连接数据库基本信息-->\n        <property name=\"javax.persistence.jdbc.driver\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"javax.persistence.jdbc.url\" value=\"jdbc:mysql:///jpa\"/>\n        <property name=\"javax.persistence.jdbc.user\" value=\"root\"/>\n        <property name=\"javax.persistence.jdbc.password\" value=\"root\"/>\n        <!--配置实现JPA的产品的基本属性，即Hibernate的基本配置-->\n        <property name=\"hibernate.format_sql\" value=\"true\"/>\n        <property name=\"hibernate.show_sql\" value=\"true\"/>\n        <property name=\"hibernate.hbm2ddl.auto\" value=\"update\"/>\n        <!--      &lt;!&ndash;配置Hibernate的二级缓存&ndash;&gt;\n        <property name=\"hibernate.cache.use_second_level_cache\" value=\"true\"/>\n        <property name=\"hibernate.cache.region.factory_class\" value=\"org.hibernate.cache.ehcache.EhCacheRegionFactory\"/>\n        <property name=\"hibernate.cache.use_query_cache\" value=\"true\"/>-->\n      </properties>\n    </persistence-unit>\n  </persistence>\n  ```\n\n* 第三步：创建实体类，并添加对应的注解以映射数据库的表。\n\n  ```java\n  import javax.persistence.*;\n  //@Table(name = \"customer\")表示此类对应的表名为customer\n  @Table(name = \"customer\")\n  @Entity\n  public class Customer {\n    private Integer id;\n    private String lastName;\n    private String email;\n    private Integer age;\n  \n    /**\n     * 注解需要写在get方法上。\n     * Column(name = \"id\")表示对应表中此属性对应的字段名\n     * Column：不具体指定字段名时，默认属性名作为字段名。\n     * strategy：表示选择主键生成策略。AUTO表示使用数据库生成策略\n     */\n    @Column(name = \"id\")\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    @Id\n    public Integer getId() {\n      return id;\n    }\n  \n    public void setId(Integer id) {\n      this.id = id;\n    }\n    @Column(name = \"last_name\")\n    public String getLastName() {\n      return lastName;\n    }\n    public void setLastName(String lastName) {\n      this.lastName = lastName;\n    }\n    public String getEmail() {\n      return email;\n    }\n    public void setEmail(String email) {\n      this.email = email;\n    }\n    public Integer getAge() {\n      return age;\n    }\n    public void setAge(Integer age) {\n      this.age = age;\n    }\n  }\n  ```\n\n* 第五步：编写测试代码。\n\n  ```java\n  public static void main(String[] args) {\n    //1.创建对象\n    //此处的persistenceUnitName值是JPA配置文件中的persistence-unit元素的name属性的值\n    String persistenceUnitName = \"jpa-1\";\n    EntityManagerFactory factory = Persistence.createEntityManagerFactory(persistenceUnitName);\n    //2.创建对象\n    EntityManager manager = factory.createEntityManager();\n    //3.开启事务\n    EntityTransaction transaction = manager.getTransaction();\n    transaction.begin();\n  \n    //4.保存数据\n    Customer customer = new Customer();\n    customer.setLastName(\"asd\");\n    customer.setEmail(\"111@163.com\");\n    customer.setAge(18);\n  \n    manager.persist(customer);\n    //5.提交事务\n    transaction.commit();\n    //6.关闭对象\n    manager.clear();\n    //7.关闭对象\n    factory.close();\n  }\n  ```\n\n* 总结：\n\n  * 总体项目结构如下：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210519192134.png)\n\n  * 在执行测试代码后。会打印出insert语句。且数据库中会创建好customer表。数据也被插入进去了。\n\n\n\n# 基本注解\n\n\n\n## @Entity\n\n* @Entity 标注用于实体类声明语句之前，指出该Java 类为实体类，将映射到指定的数据库表。如声明一个实体类 Customer，它将映射到数据库中的 customer 表上。\n* 此时的实体类对应的表明就是类名。\n\n\n\n## @Table\n\n* 当**实体类与其映射的数据库表名不同名**时需要使用 @Table 标注说明，该标注**与 @Entity 标注并列使用**，置于实体类声明语句之前，可写于单独语句行，也可与声明语句同行。\n* @Table 标注的常用选项是 **name，用于指明数据库的表名**。\n* @Table标注还有一个两个选项 catalog 和 schema 用于设置表所属的数据库目录或模式，通常为数据库名。uniqueConstraints 选项用于设置约束条件，通常不须设置。\n\n\n\n## @Id\n\n* @Id 标注用于声明一个实体类的属性映射为**数据库的主键列**。该属性通常置于属性声明语句之前，可与声明语句同行，也可写在单独行上。\n* @Id标注也可**置于属性的getXxx方法之前**。\n\n\n\n## @GeneratedValue\n\n* @GeneratedValue  用于**标注主键的生成策略**，**通过 strategy 属性指定**。\n* 默认情况下，JPA 自动选择一个最适合底层数据库的主键生成策略：**SqlServer 对应 identity，MySQL 对应 auto increment**。\n* 在 javax.persistence.GenerationType 中定义了以下几种可供选择的策略：\n  * IDENTITY：采用**数据库 ID自增长**的方式来自增主键字段，Oracle 不支持这种方式；\n  * AUTO： JPA自动选择合适的策略，是**默认选项**；\n  * SEQUENCE：通过**序列产生主键**，通过 **@SequenceGenerator 注解**指定序列名，MySql 不支持这种方式。\n  * TABLE：通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植。\n\n\n\n## @Basic\n\n* @Basic 表示一个**简单的属性到数据库表的字段的映射,**\n* 对于没有任何注解标注的 getXxx() 方法,默认注解为@Basic。\n  * fetch: 表示该属性的读取策略,有 EAGER 和 LAZY 两种,分别表示主支抓取和延迟加载,默认为 EAGER。\n  * optional:表示该属性是否允许为null, 默认为true。\n\n\n\n## @Column\n\n* 当**实体的属性与其映射的数据库表的列不同名时**需要使用@Column 标注说明，该属性通常置于实体的属性声明语句之前，还可与 @Id 标注一起使用。\n* @Column 标注的常用属性是 **name，用于设置映射数据库表的列名**。此外，该标注还包含其它多个属性，如：unique 、nullable、length 等。\n* @Column 标注的 **columnDefinition** 属性: 表示该字段在数据库中的实际类型.\n  * 通常 ORM 框架可以根据属性类型自动判断数据库中字段的类型,但是对于Date类型仍无法确定数据库中字段类型究竟是DATE,TIME还是TIMESTAMP.\n  * 此外,String的默认映射类型为VARCHAR, 如果要将 String 类型映射到特定数据库的 BLOB 或TEXT 字段类型。\n* @Column标注也可置于属性的getter方法之前。\n\n\n\n## @Transient\n\n* 表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。\n* 如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。\n* 对于一个getXxx方法.如果不需要映射为字段，则添加此注解。\n\n```java\n//此方法只是用来获取信息的，不需要在数据库中添加此字段。\n//又因为它是一个get方法。因此需要添加Transient注解，防止其映射到数据库的字段\n@Transient\npublic void getInfo(){\n  System.out.println(this.lastName + \" : \" +  this.email);\n}\n```\n\n\n\n## @Temporal\n\n* 在核心的 Java API 中并没有定义 Date 类型的精度(temporal precision).  \n* 而在数据库中,表示 Date 类型的数据有 DATE, TIME, 和 TIMESTAMP 三种精度(即单纯的日期,时间,或者两者 兼备)。\n* 在进行属性映射时可**使用@Temporal注解来调整精度**。\n\n```java\n//Temporal用来注解时间类型的属性和字段的关联。\n//TIMESTAMP：表示精确到秒。对应数据库的datetime类型\n//DATE：表示精确到日。对应数据库的date类型\n@Temporal(TemporalType.DATE)\npublic Date getTime() {\n  return time;\n}\n```\n\n\n\n## 用 table 来生成主键详解\n\n* 即将主键的信息存放在另一个表中。每次添加信息时，都从这个表中读取应该生成的主键的信息。\n* 将当前主键的值单独保存到一个数据库的表中，主键的值每次都是从指定的表中查询来获得。\n* 这种方法生成主键的策略可以适用于任何数据库，不必担心不同数据库不兼容造成的问题。\n* 表的举例：\n  * 这个表必须有两个字段pk_name和pk_value。\n  * pk_name字段的值由两部分组成=表名+表的主键id名。\n  * pk_value表示此次连接后，下一次生成的id值。\n  \n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210520191105-1.png)\n  ```java\n  /**\n     * generator：表示生成主键的策略。跟 TableGenerator注解 的name值相对应\n     */\n  @TableGenerator(name = \"id_generator\",\n                  table = \"idgenerator\", //对应主键表的表名。\n                  allocationSize = 1, //表示pk_value字段的值递增的增量。\n                  initialValue = 1, //表示第一次pk_value字段的初始值。\n                  pkColumnName = \"pk_name\", //\n                  pkColumnValue = \"orders_id\", //表示pk_name字段的值\n                  valueColumnName = \"pk_value\") //\n  @GeneratedValue(strategy = GenerationType.TABLE,generator = \"id_generator\")\n  @Id\n  public Integer getId() {\n    return id;\n  }\n  ```\n\n\n\n## @TableGenerator\n\n* 用于配置表生成策略的配置。\n* **name 属性**：表示该主键生成策略的名称，它被引用在@GeneratedValue中设置的generator 值中。\n* table： 属性表示表生成策略所持久化的表名。\n* pkColumnName： 属性的值表示在持久化表中，该主键生成策略所对应键值的名称。\n* valueColumnName： 属性的值表示在持久化表中，该主键当前所生成的值，它的值将会随着每次创建累加。\n* pkColumnValue： 属性的值表示在持久化表中，该生成策略所对应的主键。\n* allocationSize：表示每次主键值增加的大小, 默认值为 50。\n\n\n\n# API的使用\n\n\n\n## Persistence\n\n* Persistence  类是**用于获取 EntityManagerFactory 实例**。该类包含一个名为 createEntityManagerFactory 的 **静态方法** 。\n\n* createEntityManagerFactory 方法有如下两个重载版本。\n\n  * 带有一个参数的方法以 JPA 配置文件 persistence.xml 中的**持久化单元名**为参数。\n  * 带有两个参数的方法：前一个参数含义相同，后一个**参数 Map类型，用于设置 JPA 的相关属性**，这时将忽略其它地方设置的属性。**Map 对象的属性名必须是 JPA 实现库提供商的名字空间约定的属性名**。\n\n  ```java\n  //1.创建对象\n  String persistenceUnitName = \"jpa-1\";\n  Map<String,Object> properties = new HashMap<>();\n  //此设定会覆盖掉配置文件中的设置\n  properties.put(\"hibernate.show_sql\", false);\n  //    factory = Persistence.createEntityManagerFactory(persistenceUnitName);\n  factory = Persistence.createEntityManagerFactory(persistenceUnitName,properties);\n  ```\n\n\n\n## EntityManagerFactory\n\n* EntityManagerFactory 接口主要**用来创建 EntityManager 实例**。该接口约定了如下4个方法：\n\n  * createEntityManager()：用于创建实体管理器对象实例。\n  * createEntityManager(Map map)：用于创建实体管理器对象实例的重载方法，Map 参数用于提供 EntityManager 的属性。\n  * isOpen()：检查 EntityManagerFactory 是否处于打开状态。实体管理器工厂创建后一直处于打开状态，除非调用close()方法将其关闭。\n  * close()：关闭 EntityManagerFactory 。 \n\n* EntityManagerFactory 关闭后将释放所有资源，isOpen()方法测试将返回 false，其它方法将不能调用，否则将导致IllegalStateException异常。\n\n* EntityManagerFactory 相当于Hibernate的SessionFactory。\n\n  ```java\n  EntityManagerFactory factory = Persistence.createEntityManagerFactory(persistenceUnitName);\n  //2.创建对象\n  EntityManager manager = factory.createEntityManager();\n  ```\n\n\n\n## EntityManager\n\n* 在 JPA 规范中, EntityManager 是完成持久化操作的核心对象。实体作为普通 Java 对象，只有在调用 EntityManager 将其持久化后才会变成持久化对象。\n\n* EntityManager 对象在一组实体类与底层数据源之间进行 **O/R 映射的管理**。它可以用来管理和更新 Entity Bean, 根椐主键查找 Entity Bean, 还可以通过JPQL语句查询实体。\n\n* EntityManager 相当于Hibernate的Session一样。\n\n* 实体的状态:\n\n  * 新建状态:   新创建的对象，**尚未拥有持久性主键**。\n  * 持久化状态：已经拥有持久性主键并和**持久化建立了上下文环境**。\n  * 游离状态：**拥有持久化主键，但是没有与持久化建立上下文环境**。\n  * 删除状态:  拥有持久化主键，已经和持久化建立上下文环境，但是**从数据库中删除**。\n\n* **find** (Class<T> entityClass,Object primaryKey)：返回指定的 OID 对应的实体类对象，如果这个实体存在于当前的持久化环境，则返回一个**被缓存的对象**；否则会**创建一个新的 Entity**, 并加载数据库中相关信息；若 OID 不存在于数据库中，则返回一个 null。第一个参数为被查询的实体类类型，第二个参数为待查找实体的主键值。\n\n  * 类似于Hibernate的get方法。\n\n  ```java\n  /**\n     * find()：用于获取对象的数据。\n     * 会发现先打印查询语句，在打印分割线。因此此方法时立即查询的。\n     * 类似于Hibernate的get方法\n     */\n  @Test\n  public void testFind(){\n    Customer customer = manager.find(Customer.class, 1);\n    System.out.println(\"-----------\");\n    System.out.println(customer);\n  }\n  ```\n\n* **getReference** (Class<T> entityClass,Object primaryKey)：与find()方法类似，不同的是：如果缓存中不存在指定的 Entity, EntityManager 会创建一个 Entity 类的代理，但是不会立即加载数据库中的信息，只有第一次真正使用此 Entity 的属性才加载，所以如果此 OID 在数据库不存在，getReference() 不会返回 null 值, 而是抛出EntityNotFoundException。\n\n  ```java\n    /**\n     * getReference()：也是用于获取对象的数据。\n     * 会发现先打印分割线，再打印查询语句。因此此方法时懒加载的\n     * 类似于Hibernate的laod方法\n     */\n    @Test\n    public void testGetReference(){\n      Customer customer = manager.getReference(Customer.class, 1);\n      //此时返回的是一个代理对象\n      System.out.println(customer.getClass().getName());\n      System.out.println(\"-----------\");\n      System.out.println(customer);\n    }\n  ```\n\n* **persist** (Object entity)：用于将新创建的 Entity 纳入到 EntityManager 的管理。该方法执行后，传入 persist() 方法的 Entity 对象转换成持久化状态。\n\n  * 如果传入 persist() 方法的 Entity 对象已经处于持久化状态，则 persist() 方法什么都不做。\n  * 如果对删除状态的 Entity 进行 persist() 操作，会转换为持久化状态。\n  * 如果**对游离状态的实体执行 persist() 操作，可能会在 persist() 方法抛出 EntityExistException**(也有可能是在flush或事务提交后抛出)。\n\n  ```java\n    /**\n     * persist：用于保存对象数据至数据库。\n     * 会将对象数据由临时状态转换为持久化状态\n     * 类似于Hibernate的save方法。但又有些许不同。\n     *    若保存的对象有id值，则不能执行保存操作，会抛出PersistenceException异常。\n     *    而save方法会忽视调对象已存在的id。并把对象作为新数据插入表中\n     */\n    @Test\n    public void testPersist(){\n      Customer customer = new Customer();\n      customer.setLastName(\"bbbb\");\n      customer.setAge(10);\n      customer.setEmail(\"eqfwfdf@163.com\");\n      customer.setTime(new Date());\n      //若提前设定好id，会抛出异常\n      //customer.setId(3);\n  \n      manager.persist(customer);\n      //此时会打印出id值\n      System.out.println(customer.getId());\n    }\n  ```\n\n* **remove** (Object entity)：删除实例。如果实例是被管理的，即与数据库实体记录关联，则同时会删除关联的数据库记录。\n\n  ```java\n    /**\n     * remove：用于移除对象数据\n     * 类似于Hibernate的delete方法，但有些许不同。\n     *  此方法只能用来移除持久状态的对象。会抛出IllegalArgumentException异常\n     *  而delete方法还能移除游离对象。\n     */\n    @Test\n    public void testRemove (){\n  /*    Customer customer = new Customer();\n      customer.setId(2);\n      //此时删除是不成功的，因为customer是游离对象\n      manager.remove(customer);*/\n  \n      //正确的操作\n  /*    Customer customer = manager.find(Customer.class,1);\n      manager.remove(customer);*/\n  \n      //另一种情况\n      Customer customer = manager.find(Customer.class,1);\n      //此时虽然更改了id，但是删除的仍是id为1的对象数据\n      //这也说明了，当更改对象的属性值时，数据并不会同步到数据库中。建议不要更改数据\n      customer.setId(3);\n      manager.remove(customer);\n    }\n  ```\n\n* **merge** (T entity)：merge() 用于处理 Entity 的同步。即数据库的插入和更新操作。\n\n  * 在执行此方法后的返回值和entity对象一定是不同的两个对象。\n    * 即进去的是entity，但出来的一定是另一个对象。\n  * 执行原理\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210520191105-2.png)\n\n  * 测试代码有四种情况\n\n  ```java\n    /**\n     * 当前对象为：临时状态，没有id,缓存和数据库中都没有对应的数据。\n     * merge()作用：创建一个新对象，并把当前对象的数据复制到新对象中。\n     *    对新对象进行insert操作。并返回新对象的引用。\n     */\n    @Test\n    public void testMerge1 (){\n      Customer customer = new Customer();\n      customer.setLastName(\"zxcz\");\n      customer.setAge(1);\n      customer.setEmail(\"bcvbcv\");\n      customer.setTime(new Date());\n      Customer customer2 = manager.merge(customer);\n      System.out.println(customer.getId()); //null\n      System.out.println(customer2.getId()); //3\n    }\n  \n    /**\n     * 当前对象为：游离状态，有id,缓存和数据库中都没有id对应的数据。\n     * merge()作用：先查询缓存中有没有此id对应的数据。没有。\n     *      在查询数据库中有没有此id的属性。没有。\n     *      都没有时，创建一个新对象，并把当前对象的数据复制到新对象中。\n     *      对新对象进行insert操作。并返回新对象的引用。\n     */\n    @Test\n    public void testMerge2 (){\n      Customer customer = new Customer();\n      customer.setLastName(\"zxcz\");\n      customer.setAge(1);\n      customer.setEmail(\"bcvbcv\");\n      customer.setTime(new Date());\n      customer.setId(200);\n      //先执行select,再执行insert\n      Customer customer2 = manager.merge(customer);\n      System.out.println(customer.getId()); //200\n      System.out.println(customer2.getId()); //4\n    }\n  \n    /**\n     * 当前对象为：游离状态，有id,缓存中没有id对应的数据，数据库中有id对应的数据\n     * merge()作用：先查询缓存中有没有此id对应的数据。没有\n     *      在查询数据库中有没有此id的属性。有。\n     *      从数据库中加载此id对应的对象。然后将当前对象的数据拷贝到此对象中。\n     *      对此对象进行update操作。并返回此对象的引用。\n     */\n    @Test\n    public void testMerge3 (){\n      Customer customer = new Customer();\n      customer.setLastName(\"zz\");\n      customer.setAge(50);\n      customer.setEmail(\"bcv\");\n      customer.setTime(new Date());\n      customer.setId(4);\n      //先执行select。然后再提交事务时执行更新语句\n      Customer customer2 = manager.merge(customer);\n      System.out.println(customer.getId()); //4\n      System.out.println(customer2.getId()); //4\n    }\n    /**\n     * 当前对象为：游离状态，有id,缓存中有id对应的数据，数据库中有id对应的数据\n     * merge()作用：先查询缓存中有没有此id对应的数据。有。\n     *      取出缓存中的对象。并比较缓存的对象和当前对象的数据。\n     *        如果数据有不相同的，则将当前对象的数据拷贝到缓存对象中。\n     *          然后对缓存对象进行update操作。并返回缓存对象的引用。\n     *        如果数据相同，则返回缓存对象的引用。不执行update语句\n     */\n    @Test\n    public void testMerge4 (){\n      Customer customer1 = manager.find(Customer.class,4);\n      System.out.println(\"-----------------\");\n      Customer customer2 = new Customer();\n      customer2.setLastName(\"dfgdf\");\n      customer2.setAge(100);\n      customer2.setEmail(\"sdfv\");\n      customer2.setTime(new Date());\n      customer2.setId(4);\n      //只有当事务提交时，才执行update语句\n      Customer customer3 = manager.merge(customer2);\n      System.out.println(customer1.hashCode()); //4\n      System.out.println(customer2.hashCode()); //4\n      System.out.println(customer3.hashCode()); //4\n    }\n  ```\n\n* **flush** ()：同步持久上下文环境，即将持久上下文环境的所有未保存实体的状态信息保存到数据库中。\n\n* **setFlushMode** (FlushModeType flushMode)：设置持久上下文环境的Flush模式。参数可以取2个枚举\n\n  * FlushModeType.AUTO ：为自动更新数据库实体，\n  * FlushModeType.COMMIT ：为直到提交事务时才更新数据库记录。默认配置。\n\n* **getFlushMode** ()：获取持久上下文环境的Flush模式。返回FlushModeType类的枚举值。\n\n* **refresh** (Object entity)：用**数据库实体记录的值更新实体对象的状态**，即更新实例的属性值。\n\n* **clear** ()：清除持久上下文环境，断开所有关联的实体。如果这时还有**未提交的更新则会被撤消**。\n\n* **contains** (Object entity)：判断一个实例是否属于当前持久上下文环境管理的实体。\n\n* **isOpen** ()：判断当前的实体管理器是否是打开状态。\n\n* **getTransaction** ()：返回资源层的事务对象。EntityTransaction实例可以用于开始和提交多个事务。\n\n* **close** ()：关闭实体管理器。之后若调用实体管理器实例的方法或其派生的查询对象的方法都将抛出 IllegalstateException 异常，除了getTransaction 和 isOpen方法(返回 false)。不过，当与实体管理器关联的事务处于活动状态时，调用 close 方法后持久上下文将仍处于被管理状态，直到事务完成。\n\n* **createQuery** (String qlString)：创建一个查询对象。\n\n* **createNamedQuery** (String name)：根据命名的查询语句块创建查询对象。参数为命名的查询语句。\n\n* **createNativeQuery** (String sqlString)：使用标准 SQL语句创建查询对象。参数为标准SQL语句字符串。\n\n* **createNativeQuery** (String sqls, String resultSetMapping)：使用标准SQL语句创建查询对象，并指定返回结果集 Map的 名称。\n\n\n\n## EntityTransaction\n\n* EntityTransaction 接口用来管理资源层实体管理器的事务操作。通过调用实体管理器的getTransaction方法 获得其实例。\n\n  ```java\n  //3.开启事务\n  EntityTransaction transaction = manager.getTransaction();\n  transaction.begin();\n  ```\n\n* **begin** ()：用于启动一个事务，此后的多个数据库操作将作为整体被提交或撤消。若这时事务已启动则会抛出 IllegalStateException 异常。\n\n* **commit** ()：用于提交当前事务。即将事务启动以后的所有数据库更新操作持久化至数据库中。\n\n* **rollback** ()：撤消(回滚)当前事务。即撤消事务启动后的所有数据库更新操作，从而不对数据库产生影响。\n\n* **setRollbackOnly** ()：使当前事务只能被撤消。\n\n* **getRollbackOnly** ()：查看当前事务是否设置了只能撤消标志。\n\n* **isActive** ()：查看当前事务是否是活动的。\n\n  * 如果返回true则不能调用begin方法，否则将抛出 IllegalStateException 异常；\n  * 如果返回 false 则不能调用 commit、rollback、setRollbackOnly 及 getRollbackOnly 方法，否则将抛出 IllegalStateException 异常。\n\n\n\n# 映射关联关系\n\n\n\n## 映射单向多对一的关联关系\n\n* 设计：多个员工可以在一个部门。\n\n* 员工代码：\n\n  ```java\n  @Entity\n  @Table(name = \"staffs\")\n  public class Staff {\n    private Integer id;\n    private String staName;\n    private Department department;\n    @Id\n    @GeneratedValue\n    public Integer getId() {\n      return id;\n    }\n  \n    public void setId(Integer id) {\n      this.id = id;\n    }\n    @Column(name=\"sta_name\")\n    public String getStaName() {\n      return staName;\n    }\n  \n    public void setStaName(String staName) {\n      this.staName = staName;\n    }\n  \n    /**\n     * ManyToOne 表示单向多对一的映射\n     *    fetch：表示设置加载机制\n     * JoinColumn 表示映射到外键列的列名\n     *\n     */\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"dep_id\")\n    public Department getDepartment() {\n      return department;\n    }\n  \n    public void setDepartment(Department department) {\n      this.department = department;\n    }\n  }\n  ```\n\n* 部门代码：\n\n  ```java\n  @Entity\n  @Table(name = \"departments\")\n  public class Department {\n    private Integer id;\n    private String depNmae;\n  \n    @Id\n    @GeneratedValue\n    public Integer getId() {\n      return id;\n    }\n  \n    public void setId(Integer id) {\n      this.id = id;\n    }\n    @Column(name = \"dep_name\")\n    public String getDepNmae() {\n      return depNmae;\n    }\n  \n    public void setDepNmae(String depNmae) {\n      this.depNmae = depNmae;\n    }\n  }\n  ```\n\n* 生成的数据库表：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210520191105-3.png)\n\n* 测试代码：\n\n  ```java\n  @Test\n  public void testManyToOneSave(){\n    Department department = new Department();\n    Staff staff1 = new Staff();\n    Staff staff2 = new Staff();\n    department.setDepNmae(\"d\");\n    staff1.setStaName(\"sta1-d\");\n    staff2.setStaName(\"sta2-d\");\n    staff1.setDepartment(department);\n    staff2.setDepartment(department);\n  \n    //先保存1的一端即deparment。在保存多的一端staff。会执行三条插入语句\n    manager.persist(department);\n    manager.persist(staff1);\n    manager.persist(staff2);    \n  \n    //先保存多的一端staff。在保存1的一端即deparment。会执行三条插入语句和两个更新\n    manager.persist(staff1);\n    manager.persist(staff2);\n    manager.persist(department);\n  }\n  @Test\n  public void testManyToOneDelete(){\n    //删除时：先删除staff时，可以删除。\n    //但是先删除department时会抛MySQLIntegrityConstraintViolationException异常。\n    // 因为staff表有外键引用department\n    Department department = manager.find(Department.class, 3);\n    manager.remove(department);\n  }  \n  @Test\n  public void testManyToOneSelect(){\n    //查询时。默认是立即查询。通过左外连接的方式加载department数据\n    //当设置fetch属性为懒加载时，对于department属性会先生成代理对象。\n    Staff staff = manager.find(Staff.class, 5);\n    System.out.println(staff.getStaName());\n    System.out.println(\"------------\");\n    System.out.println(staff.getDepartment().getDepNmae());\n  }\n  ```\n\n* 总结：\n\n  * 需要在多的一端设置1的一端的属性。\n  * 通过@ManyToOne注解表示其为多对一的关系。\n  * 通过@JoinColumn注解将其属性值映射为外键。\n\n\n\n## 映射单向一对多的关联关系\n\n* 设计：一个学校可以有多个学生\n\n* 学校代码：\n\n  ```java\n  @Entity\n  @Table(name = \"schools\")\n  public class School {\n    private Integer id;\n    private String schName;\n    private Set<Student> students = new HashSet<>();\n    @Id\n    @GeneratedValue\n    public Integer getId() {\n      return id;\n    }\n  \n    public void setId(Integer id) {\n      this.id = id;\n    }\n    @Column(name = \"sch_name\")\n    public String getSchName() {\n      return schName;\n    }\n  \n    public void setSchName(String schName) {\n      this.schName = schName;\n    }\n  \n    /**\n     * OneToMany：表示一对多的关系\n     * JoinColumn：表示给 多的一端对的表 设定外键\n     * @return\n     */\n    @OneToMany(fetch = FetchType.EAGER,cascade = {CascadeType.REMOVE})\n    @JoinColumn(name = \"sch_id\")\n    public Set<Student> getStudents() {\n      return students;\n    }\n  \n    public void setStudents(Set<Student> students) {\n      this.students = students;\n    }\n  }\n  ```\n\n* 学生代码：\n\n  ```java\n  @Entity\n  @Table(name = \"students\")\n  public class Student {\n    private Integer id;\n    private String stuName;\n  \n    @Id\n    @GeneratedValue\n    public Integer getId() {\n      return id;\n    }\n  \n    public void setId(Integer id) {\n      this.id = id;\n    }\n    @Column(name = \"stu_name\")\n    public String getStuName() {\n      return stuName;\n    }\n  \n    public void setStuName(String stuName) {\n      this.stuName = stuName;\n    }\n  }\n  ```\n\n* 数据库结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210520191105-4.png)\n\n* 测试代码：\n\n  ```java\n  @Test\n  public void testOneToNSave(){\n    School school = new School();\n    school.setSchName(\"清华\");\n    Student studentA = new Student();\n    Student studentB = new Student();\n    studentA.setStuName(\"李四\");\n    studentB.setStuName(\"张三\");\n    //设置关联关系\n    school.getStudents().add(studentA);\n    school.getStudents().add(studentB);\n    //先保存1，在保存多。总共三条插入和两条更新\n    /*    manager.persist(school);\n      manager.persist(studentA);\n      manager.persist(studentB); */\n  \n    //先保存多，在保存1。也是三条插入和两条更新\n    manager.persist(studentA);\n    manager.persist(studentB);\n    manager.persist(school);\n  }\n  @Test\n  public void testOneToNDelete(){\n    //默认情况下，在删除多的一端数据时，会先将1的一端的外键置空，然后再删除多的一端数据。\n    //这个置空操作可以变成其他方式。比如通过设置cascade属性为 CascadeType.REMOVE 可以达到级联删除的操作\n    School school = manager.find(School.class, 1);\n    manager.remove(school);\n  }\n  @Test\n  public void testOneToNSelect(){\n    //当查询多的一方时，默认使用懒加载策略。\n    //可以通过修改 OneToMany注解 的 fetch属性 来修改加载策略\n    School school = manager.find(School.class, 1);\n    System.out.println(school.getSchName());\n    System.out.println(school.getStudents().size());\n  }\n  \n  ```\n\n* 总结：\n\n  * 需要在1的一端添加对多的一端的集合。集合可以在定义时就被初始化。\n  * 通过@OneToMany注解表示其为一对多的关系。\n  * 通过@JoinColumn注解在多的一端设置外键，并映射到1的一端的集合上。\n\n\n\n## 映射双向多对一或一对多的关联关系\n\n* 设计：一个老板有很多下属，多个下属只有一个老板。\n\n* 老板代码：\n\n  ```java\n  @Entity\n  @Table(name = \"boss\")\n  public class Boss {\n    private Integer id;\n    private String boName;\n    private Set<Subordinate> subordinates = new HashSet<>();\n  \n    @Id\n    @GeneratedValue\n    public Integer getId() {\n      return id;\n    }\n  \n    public void setId(Integer id) {\n      this.id = id;\n    }\n    @Column(name = \"bo_name\")\n    public String getBoName() {\n      return boName;\n    }\n  \n    public void setBoName(String boName) {\n      this.boName = boName;\n    }\n    //注意设置的外键名要和另一个表设置的外键名相同\n  /*  @OneToMany()\n    @JoinColumn(name = \"boss_id\")*/\n  \n    //一般在1的一端设置维护关联关系的为n的一方\n    //当使用mappedBy时不能使用JoinColumn注解\n    //mappedBy的值为，此Subordinate类中对当前类的引用属性名。即外键映射的属性名\n    @OneToMany(mappedBy = \"boss\")\n    public Set<Subordinate> getSubordinates() {\n      return subordinates;\n    }\n  \n    public void setSubordinates(Set<Subordinate> subordinates) {\n      this.subordinates = subordinates;\n    }\n  }\n  ```\n\n* 下属代码：\n\n  ```java\n  @Entity\n  @Table(name = \"subordinate\")\n  public class Subordinate {\n    private Integer id;\n    private String suName;\n    private Boss boss;\n  \n    @Id\n    @GeneratedValue\n    public Integer getId() {\n      return id;\n    }\n  \n    public void setId(Integer id) {\n      this.id = id;\n    }\n    @Column(name = \"su_name\")\n    public String getSuName() {\n      return suName;\n    }\n  \n    public void setSuName(String suName) {\n      this.suName = suName;\n    }\n    //注意设置的外键名要和另一个表设置的外键名相同\n    @ManyToOne\n    @JoinColumn(name = \"boos_id\")\n    public Boss getBoss() {\n      return boss;\n    }\n  \n    public void setBoss(Boss boss) {\n      this.boss = boss;\n    }\n  }\n  ```\n\n* 数据库结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210520191105-5.png)\n\n* 测试代码：\n\n  ```java\n  @Test\n  public void testSave(){\n    Boss boss = new Boss();\n    Subordinate subordinateA  = new Subordinate();\n    Subordinate subordinateB  = new Subordinate();\n    boss.setBoName(\"bo-a\");\n    subordinateA.setSuName(\"su-a\");\n    subordinateB.setSuName(\"su-b\");\n    //设置关联关系\n    boss.getSubordinates().add(subordinateA);\n    boss.getSubordinates().add(subordinateB);\n    subordinateA.setBoss(boss);\n    subordinateB.setBoss(boss);\n    //先保存1的一端，在保存n的一端。在设定维护端后，只有三条插入语句\n    manager.persist(boss);\n    manager.persist(subordinateA);\n    manager.persist(subordinateB);\n  }\n  ```\n\n* 总结：\n\n  * 当不设定维护端时，在两个类中都要设置外键。\n    * 此时要注意两个类的外键设置的名字要一致。\n    * 且此时的保存操作会多出n条更新语句，效率低下。\n  * 在设定维护端时，注意mappedBy的值为外键字段映射的属性名。\n\n* 双向一对多关系中，必须**存在一个关系维护端**，在 JPA 规范中，要求  many 的一方作为关系的维护端(owner side), one 的一方作为被维护端(inverse side)。\n\n* 可以在 one 方指定 @OneToMany 注释并**设置 mappedBy 属性**，以指定它是这一关联中的被维护端，many 为维护端。\n\n* 在 many 方指定 @ManyToOne 注释，并**使用 @JoinColumn 指定外键名称**。\n\n\n\n## 映射单向一对一的关联关系\n\n* 设计：一个人只能有一张身份证。一个身份证代表一个人。\n\n* 身份证代码：\n\n  ```java\n  @Entity\n  @Table(name = \"idCards\")\n  public class IDCard {\n    private Integer id;\n    private String info;\n    private Person person;\n    @Id\n    @GeneratedValue\n    public Integer getId() {\n      return id;\n    }\n  \n    public void setId(Integer id) {\n      this.id = id;\n    }\n    @Column\n    public String getInfo() {\n      return info;\n    }\n  \n    public void setInfo(String info) {\n      this.info = info;\n    }\n    //设置另一个类为维护端\n    @OneToOne(mappedBy = \"idCard\")\n    public Person getPerson() {\n      return person;\n    }\n  \n    public void setPerson(Person person) {\n      this.person = person;\n    }\n  }\n  ```\n\n* 人代码：\n\n  ```java\n  @Entity\n  @Table(name = \"persons\")\n  public class Person {\n    private Integer id;\n    private String perName;\n    private IDCard idCard;\n    @Id\n    @GeneratedValue\n    public Integer getId() {\n      return id;\n    }\n  \n    public void setId(Integer id) {\n      this.id = id;\n    }\n    @Column(name = \"per_name\")\n    public String getPerName() {\n      return perName;\n    }\n  \n    public void setPerName(String perName) {\n      this.perName = perName;\n    }\n    //设置外键，并保证外键唯一性\n    @OneToOne\n    @JoinColumn(name = \"card_id\",unique = true)\n    public IDCard getIdCard() {\n      return idCard;\n    }\n  \n    public void setIdCard(IDCard idCard) {\n      this.idCard = idCard;\n    }\n  }\n  ```\n\n* 数据库结构图:\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210520191105-6.png)\n\n* 测试代码：\n\n  ```java\n  @Test\n  public void testOneToOne(){\n    Person person = new Person();\n    person.setPerName(\"李四\");\n    IDCard idCard = new IDCard();\n    idCard.setInfo(\"李四的身份证\");\n    //设置关联关系\n    person.setIdCard(idCard);\n    idCard.setPerson(person);\n    //先保存不带外键的一方，在保存带外键的一方。只会有两条insert语句\n    manager.persist(idCard);\n    manager.persist(person);\n    //先保存带外键的一方，在保存不带外键的一方。会有两条insert语句，外加一条更新语句\n    manager.persist(person);\n    manager.persist(idCard);\n    //默认情况下，获取带外键的对象数据时，会通过左外连接加载关联的对象。\n    //我们可以设置@OneToOne注解的fetch属性为LAZY。来实现懒加载\n    Person person1 = manager.find(Person.class, 1);\n    System.out.println(person1.getPerName());\n    System.out.println(person1.getIdCard().getClass());\n    //默认情况下，获取不带外键的对象数据时，会通过左外连接加载关联的对象。\n    //但是当设置@OneToOne注解的fetch属性为LAZY。会在回去对象时发送两个查询语句，不会存在代理对象。\n    IDCard idCard1 = manager.find(IDCard.class, 1);\n    System.out.println(idCard1.getInfo());\n    System.out.println(idCard1.getPerson().getClass());\n  }\n  ```\n\n* 总结：\n\n  * 使用外键来设置一对一关联关系。\n    * 可以在任意一个类上添加@JoinColumn注解，并通过unique = true把外键设为唯一。\n    * 在另外一个类上通过mappedBy属性设置为被维护端。\n    * 当获取**不带外键的对象数据时，不存在延迟加载策略**。\n  * 使用主键来设置一对一关联关系。\n\n* 基于外键的 1-1 关联关系：在双向的一对一关联中，需要在关系被维护端(inverse side)中的 @OneToOne 注释中**指定 mappedBy**，以指定是这一关联中的被维护端。同时需要在关系维护端(owner side)**建立外键列指向关系被维护端的主键列**。\n\n\n\n## 映射双向多对多的关联关系\n\n* 设计：一本书可以有多个作者，一个作者可以有很多本书。\n\n* 主要代码：\n\n  ```java\n  //Book类\n  @ManyToMany(mappedBy = \"books\")\n  public Set<Author> getAuthors() {\n    return authors;\n  }\n  //Author类\n  /**\n     * JoinTable：表示关联一张中间表。\n     *  name：表示中间表的表名\n     *  joinColumns：关联外键。外键名为author_id，关联到当前表的id\n     *  inverseJoinColumns：反向关联的外键。外键名为book_id，关联到另一个表的id\n     */\n  @ManyToMany\n  @JoinTable(name = \"author_book\",\n             joinColumns = {\n               @JoinColumn(name = \"author_id\",referencedColumnName = \"id\")\n             },\n             inverseJoinColumns = {\n               @JoinColumn(name = \"book_id\",referencedColumnName = \"id\")\n             }\n            )\n  public Set<Book> getBooks() {\n    return books;\n  }\n  ```\n\n* 数据库结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210520191105-7.png)\n\n* 测试代码：\n\n  ```java\n  @Test\n  public void testNtoN(){\n    Book bookA = new Book();\n    Book bookB = new Book();\n    bookA.setBoName(\"book-a\");\n    bookB.setBoName(\"book-b\");\n  \n    Author authorA = new Author();\n    Author authorB = new Author();\n    authorA.setAuName(\"author-a\");\n    authorB.setAuName(\"author-b\");\n  \n    //设置关联关系\n    bookA.getAuthors().add(authorA);\n    bookA.getAuthors().add(authorB);\n    bookB.getAuthors().add(authorA);\n    bookB.getAuthors().add(authorB);\n  \n    authorA.getBooks().add(bookA);\n    authorA.getBooks().add(bookB);\n    authorB.getBooks().add(bookA);\n    authorB.getBooks().add(bookB);\n  \n    //总共发送8条insert语句\n    manager.persist(bookA);\n    manager.persist(bookB);\n    manager.persist(authorA);\n    manager.persist(authorB);\n  \n    //获取数据时，默认使用懒加载方式\n  }\n  ```\n\n* 在双向多对多关系中，我们必须指定一个关系维护端(owner side),可以通过 @ManyToMany 注释中指定 mappedBy 属性来标识其为关系维护端。\n\n\n\n# 二级缓存\n\n* 使用方式和Hibernate的方式一样。以ehcache为例。\n\n  * 开启Hibernate的二级缓存配置。\n\n  ```xml\n  <property name=\"hibernate.cache.use_second_level_cache\" value=\"true\"/>\n  <property name=\"hibernate.cache.region.factory_class\" value=\"org.hibernate.cache.ehcache.EhCacheRegionFactory\"/>\n  <property name=\"hibernate.cache.use_query_cache\" value=\"true\"/>\n  ```\n\n  * 导入ehcache相关的包。\n\n  * 导入ehcache的配置ehcache.xml文件。\n\n  * 开启JPA的二级缓存配置。\n\n    ```xml\n    <!--开启二级缓存。ENABLE_SELECTIVE表示标识@Cacheable(true)注解的实体类将被缓存-->\n    <shared-cache-mode>ENABLE_SELECTIVE</shared-cache-mode>\n    ```\n\n  * 在使用缓存的类上添加@Cacheable(value = true)注解。以开启二级缓存。\n\n  ```java\n  public void test(){\n    Customer customer = manager.find(Customer.class, 1);\n    System.out.println(customer.getLastName());\n  \n    transaction.commit();\n    manager.close();\n  \n    manager = factory.createEntityManager();\n    transaction = manager.getTransaction();\n    transaction.begin();\n  \n    Customer customer2 = manager.find(Customer.class, 1);\n    System.out.println(customer2.getLastName());\n  }\n  ```\n\n* \\<shared-cache-mode> 节点：若 JPA 实现支持二级缓存，该节点可以配置在当前的持久化单元中是否启用二级缓存，可配置如下值：\n\n  * ALL：所有的实体类都被缓存。\n  * NONE：所有的实体类都不被缓存。\n  * ENABLE_SELECTIVE：标识 @Cacheable(true) 注解的实体类将被缓存。\n  * DISABLE_SELECTIVE：缓存除标识 @Cacheable(false) 以外的所有实体类。\n  * UNSPECIFIED：默认值，JPA 产品默认值将被使用。\n\n\n\n# JPQL\n\n* JPQL语言，即 Java Persistence Query Language 的简称。JPQL 是一种和 SQL 非常类似的**中间性和对象化查询语言**，它最终会被编译成针对不同底层数据库的 SQL 查询，从而**屏蔽不同数据库的差异**。\n* JPQL语言的语句可以是 **select** 语句、**update** 语句或**delete**语句，它们都**通过 Query 接口封装**执行。\n\n\n\n## Query的认识\n\n* Query接口封装了执行数据库查询的相关方法。调用 EntityManager 的 **createQuery**、**createNamedQuery** 及 **createNativeQuery** 方法可以获得查询对象，进而可调用 Query 接口的相关方法来执行查询操作。\n\n* Query接口的主要方法：\n\n* int **executeUpdate**()\n\n  * 用于执行update或delete语句。\n\n* List **getResultList**()\n\n  * 用于执行select语句并返回结果集实体列表。\n\n* Object **getSingleResult**()\n\n  * 用于执行只返回单个结果实体的select语句。\n\n* Query **setFirstResult**(int startPosition)\n\n  * 用于设置从哪个实体记录开始返回查询结果。\n\n* Query **setMaxResults**(int maxResult) \n\n  * 用于设置返回结果实体的最大数。与setFirstResult结合使用可实现分页查询。\n\n* Query **setFlushMode**(FlushModeType flushMode) \n\n  * 设置查询对象的Flush模式。参数可以取2个枚举值：FlushModeType.AUTO 为自动更新数据库记录，FlushMode Type.COMMIT 为直到提交事务时才更新数据库记录。\n\n* **setHint**(String hintName, Object value) \n\n  * 设置与查询对象相关的特定供应商参数或提示信息。参数名及其取值需要参考特定 JPA 实现库提供商的文档。如果第二个参数无效将抛出IllegalArgumentException异常。\n\n* **setParameter**(int position, Object value) \n\n  * 为查询语句的指定位置参数赋值。Position 指定参数序号，value 为赋给参数的值。\n\n* **setParameter**(int position, Date d, TemporalType type) \n\n  * 为查询语句的指定位置参数赋 Date 值。Position 指定参数序号，value 为赋给参数的值，temporalType 取 TemporalType 的枚举常量，包括 DATE、TIME 及 TIMESTAMP 三个，，用于将 Java 的 Date 型值临时转换为数据库支持的日期时间类型（java.sql.Date、java.sql.Time及java.sql.Timestamp）。\n\n* **setParameter**(int position, Calendar c, TemporalType type) \n\n  * 为查询语句的指定位置参数赋 Calenda r值。position 指定参数序号，value 为赋给参数的值，temporalType 的含义及取舍同前。\n\n* **setParameter**(String name, Object value) \n\n  * 为查询语句的指定名称参数赋值。\n\n* **setParameter**(String name, Date d, TemporalType type) \n\n  * 为查询语句的指定名称参数赋 Date 值。用法同前。\n\n* **setParameter**(String name, Calendar c, TemporalType type) \n\n  * 为查询语句的指定名称参数设置Calendar值。name为参数名，其它同前。该方法调用时如果参数位置或参数名不正确，或者所赋的参数值类型不匹配，将抛出 IllegalArgumentException 异常。\n\n* select语句：\n\n  * select语句用于执行查询。其语法可表示为：\n\n  ```sql\n  select_clause \n  form_clause \n  [where_clause] \n  [groupby_clause] \n  [having_clause]\n  [orderby_clause]\n  ```\n\n* select-from 子句：\n\n  * from 子句是查询语句的必选子句。\n    * Select 用来指定查询返回的结果实体或实体的某些属性\n    * From 子句声明查询源实体类，并**指定标识符变量**（相当于SQL表的别名）。\n  * 如果不希望返回重复实体，可使用**关键字 distinct** 修饰。select、from 都是 JPQL 的关键字，通常全大写或全小写，建议不要大小写混用。\n\n* 查询单个实体：\n\n  * 查询所有实体的 JPQL 查询字串很简单，例如：\n    * select o from Order o 或  select o from Order as o\n  * **关键字 as** 可以省去。\n  * 标识符变量的命名规范与 Java 标识符相同，且区分大小写。\n\n* 查询所有实体：\n\n  * 调用 EntityManager 的 createQuery() 方法可创建查询对象，接着调用 Query 接口的 getResultList() 方法就可获得查询结果集。\n\n* where子句：\n\n  * where子句用于指定查询条件，where跟条件表达式。\n\n  ```sql\n  select o from Orders o where o.id = 1\n  select o from Orders o where o.id > 3 and o.confirm = 'true'\t\n  select o from Orders o where o.address.streetNumber >= 123\n  ```\n\n  * JPQL也支持包含参数的查询，例如：\n    * 注意：参数名前必须冠以**冒号**(:)，执行查询前须使用Query.setParameter(name, value)方法给参数赋值。\n\n  ```sql\n  select o from Orders o where o.id = :myId\n  select o from Orders o where o.id = :myId and o.customer = :customerName\n  ```\n\n  * 也可以不使用参数名而使用参数的序号，例如：\n    * 其中 ?1 代表第一个参数，?2 代表第一个参数。在执行查询之前需要使用重载方法Query.setParameter(pos, value) 提供参数值。\n\n  ```sql\n  select o from Order o where o.id = ?1 and o.customer = ?2\n  ```\n\n* where条件表达式中可用的运算符基本上与SQL一致，包括：\n\n  * 算术运算符：+　-　*　/　+(正)　-(负)\n  * 关系运算符：==　<>　>　>=　<　<=　between…and　like　in　is null 等\n  * 逻辑运算符： and　or 　not\n\n* 下面是一些常见查询表达式示例：\n\n  ```sql\n  // 以下语句查询 Id 介于 100 至 200 之间的订单。\n  select o from Orders o where o.id between 100 and 200\n  // 以下语句查询国籍为的 'US'、'CN'或'JP' 的客户。\n  select c from Customers c where c.county in ('US','CN','JP')\n  // 以下语句查询手机号以139开头的客户。%表示任意多个字符序列，包括0个。\n  select c from Customers c where c.phone like '139%'\n  // 以下语句查询名字包含4个字符，且234位为ose的客户。_表示任意单个字符。\n  select c from Customers c where c.lname like '_ose' \n  // 以下语句查询电话号码未知的客户。Nul l用于测试单值是否为空。\n  select c from Customers c where c.phone is null\n  // 以下语句查询尚未输入订单项的订单。empty用于测试集合是否为空。\n  select o from Orders o where o.orderItems is empty\n  ```\n\n* 查询部分属性：\n\n  * 如果只须查询实体的部分属性而不需要返回整个实体。例如：\n\n  ```sql\n  select o.id, o.customerName, o.address.streetNumber from Order o order by o.id\n  ```\n\n  * 执行该查询返回的不再是Orders实体集合，而是一个对象数组的集合(Object[])，集合的每个成员为一个对象数组，可通过数组元素访问各个属性。\n\n* 示例：\n\n  * createQuery的使用\n\n  ```java\n    /**\n     * 查询全部实体\n     */\n    @Test\n    public void test1(){\n      String jpql = \"from Customer c where c.age > ?\";\n      Query query = manager.createQuery(jpql);\n      //注意：此处的参数下标是从1开始的\n      query = query.setParameter(1, 15);\n      List<Customer> resultList = query.getResultList();\n      System.out.println(resultList.size());\n    }\n  \n    /**\n     * 查询部分属性。\n     *  默认的返回值列表的元素类型为数组类型。\n     *  如果通过构造器的方式可以将数据类型数据封装成对象\n     */\n    @Test\n    public void testPartlyProperties(){\n      //String jpql = \"select c.lastName,c.age from Customer c where c.age > 20\";\n      //通过构造器对其进行封装\n      String jpql = \"select new Customer(c.lastName,c.age) from Customer c where c.age > 20\";\n  \n      List result = manager.createQuery(jpql).getResultList();\n      System.out.println(result);\n    }\n  ```\n\n  * createNamedQuery的使用：\n\n    * 首先在类的上面可以自定义给一个sql语句。\n\n    ```java\n    @NamedQuery(name = \"testNameQuery\",query = \"from Customer c where c.id = ?\")\n    public class Customer {}\n    ```\n\n    * 测试代码：\n\n    ```java\n      /**\n       * createNamedQuery的使用。\n       *  先通过@NamedQuery注解预先设定好语句。然后通过标识符创建query对象。进而查询数据库\n       */\n      @Test\n      public void testNameQuery(){\n        Query nameQuery = manager.createNamedQuery(\"testNameQuery\");\n        Customer customer = (Customer) nameQuery.setParameter(1, 1).getSingleResult();\n        System.out.println(customer);\n      }\n    ```\n\n  * createNativeQuery的使用：\n\n  ```java\n    /**\n     * createNativeQuery的使用。\n     *  通过传入原生的sql语句，进而创建query对象。\n     */\n    @Test\n    public void testNativeQuery(){\n      String sql = \"select * from customer where id = ?\";\n      Object result  =  manager.createNativeQuery(sql).setParameter(1, 3).getSingleResult();\n      System.out.println(result.toString());\n    }\n  ```\n\n\n\n## 查询缓存\n\n* 原理是使用Hibernate的查询缓存。前提条件是配置条件中配置的Hibernate的查询缓存。\n\n  * Hibernate的查询缓存的配置:\n\n  ```xml\n  <property name=\"hibernate.cache.use_query_cache\" value=\"true\"/>\n  ```\n\n* 测试代码：\n\n  ```java\n  /**\n     * 测试查询缓存\n     *  原理是使用Hibernate的查询缓存。前提条件是配置条件中配置的Hibernate的查询缓存\n     */\n  @Test\n  public void testQueryCache(){\n    String jpql = \"from Customer c where c.id = ?\";\n    Query query = manager.createQuery(jpql).setHint(QueryHints.HINT_CACHEABLE, true);\n    Customer customer = (Customer) query.setParameter(1, 4).getSingleResult();\n    System.out.println(customer.toString());\n    //再查一次。默认情况下会发送两条SQL语句。\n    //当添加.setHint(QueryHints.HINT_CACHEABLE, true)以后。只会发送一条语句\n    Query query2 = manager.createQuery(jpql).setHint(QueryHints.HINT_CACHEABLE, true);\n    Customer customer2 = (Customer) query.setParameter(1, 4).getSingleResult();\n    System.out.println(customer2.toString());\n  }\n  ```\n\n\n\n## ORDER BY 和 GROUP BY\n\n* order by子句：\n\n  * order by子句用于对查询结果集进行排序。和SQL的用法类似，可以用 “asc“ 和 \"desc“ 指定升降序。如果不显式注明，默认为升序。\n  * 常见的sql语句：\n\n  ```sql\n  select o from Orders o order by o.id\n  select o from Orders o order by o.address.streetNumber desc\n  select o from Orders o order by o.customer asc, o.id desc\n  ```\n\n* group by子句与聚合查询：\n\n  * group by 子句用于对查询结果分组统计，通常需要使用聚合函数。常用的聚合函数主要有 AVG、SUM、COUNT、MAX、MIN 等，它们的含义与SQL相同。\n  * 没有 group by 子句的查询是基于整个实体类的，使用聚合函数将返回单个结果值，可以使用Query.getSingleResult()得到查询结果。\n\n  ```java\n  public void testGroupBy(){\n    String jpql = \"SELECT o.customer FROM Order o \"\n      + \"GROUP BY o.customer \"\n      + \"HAVING count(o.id) >= 2\";\n    List<Customer> customers = entityManager.createQuery(jpql).getResultList();\n  \n    System.out.println(customers);\n  }\n  ```\n\n* having子句：\n\n  * Having 子句用于对 group by 分组设置约束条件，用法与where 子句基本相同，不同是 where 子句作用于基表或视图，以便从中选择满足条件的记录；having 子句则作用于分组，**用于选择满足条件的组，其条件表达式中通常会使用聚合函数**。\n\n  * 例如，以下语句用于查询订购总数大于100的商家所售商品及数量：\n\n    ```sql\n    select o.seller, o.goodId, sum(o.amount) from V_Orders o group by \n    o.seller, o.goodId having sum(o.amount) > 100\n    ```\n\n  * having子句与where子句一样都可以使用参数。\n\n\n\n## 关联查询\n\n* 在JPQL中，很多时候都是通过在实体类中配置实体关联的类属性来实现隐含的关联(join)查询。\n\n* 在某些情况下可能仍然需要对关联做精确的控制。为此，JPQL 也支持和 SQL 中类似的关联语法。\n\n* 比如：\n\n  * left out join / left join \n  * inner join \n  * left join / inner join fetch \n  * 其中，left join和left out join等义，都是允许符合条件的右边表达式中的实体为空。\n\n* 例如，以下外关联查询可以找出所有客户实体记录，即使它未曾订货：\n\n  ```sql\n  select c from Customers c left join c.orders o\n  ```\n\n* 以下内关联查询只找出所有曾订过商品的客户实体记录：\n\n  ```sql\n  select c from Customers c inner join c.orders o\n  ```\n\n* 如果001号客户下过5次订单的话，以下fetch关联查询将得到 5个客户实体的引用，并且执行了 5 个订单的查询：\n\n  ```sql\n  select c from Customers c left join fetch c.orders o where c.id=001\n  ```\n\n* 测试代码：\n\n  * 再单向一对多的映射条件下。一个学校有很多的学生。学生表有外键，外键对应学校的id。\n\n```java\n  public void testLeftJoin(){\n    //对应的查询语句\n    /**\n     *     select\n     *         school0_.id as id1_9_0_,\n     *         students1_.id as id1_11_1_,\n     *         school0_.sch_name as sch_name2_9_0_,\n     *         students1_.stu_name as stu_name2_11_1_,\n     *         students1_.sch_id as sch_id3_9_0__,\n     *         students1_.id as id1_11_0__ \n     *     from\n     *         schools school0_ \n     *     left outer join\n     *         students students1_ \n     *             on school0_.id=students1_.sch_id \n     *     where\n     *         school0_.id=?\n     */\n    String jpql = \"from School s left outer join fetch s.students where s.id = ?\";\n    School school = (School) manager.createQuery(jpql).setParameter(1,1).getSingleResult();\n    System.out.println(school.getSchName());\n    System.out.println(school.getStudents().size());\n  }\n```\n\n\n\n## 子查询 和 JPQL 函数\n\n* JPQL也支持子查询，在 where 或 having 子句中可以包含另一个查询。当子查询返回多于 1 个结果集时，它常出现在 any、all、exist s表达式中用于集合匹配查询。它们的用法与SQL语句基本相同。\n\n  ```java\n    public void testSubQuery(){\n      //查询语句为：\n      /**\n       *     select\n       *         staff0_.id as id1_10_,\n       *         staff0_.dep_id as dep_id3_10_,\n       *         staff0_.sta_name as sta_name2_10_ \n       *     from\n       *         staffs staff0_ \n       *     where\n       *         staff0_.dep_id=(\n       *             select\n       *                 department1_.id \n       *             from\n       *                 departments department1_ \n       *             where\n       *                 department1_.id=?\n       *         )\n       */\n      String jpql = \"select s from Staff s \" +\n          \"where s.department = (select d from Department d where d.id = ?)\";\n      List<Staff> staffs= manager.createQuery(jpql).setParameter(1,1).getResultList();\n      System.out.println(staffs.toString());\n    }\n  ```\n\n* JPQL提供了以下一些内建函数，包括字符串处理函数、算术函数和日期函数。\n\n* **字符串处理函数**主要有：\n\n  * concat(String s1, String s2)：字符串合并/连接函数。\n  * substring(String s, int start, int length)：取字串函数。\n  * trim([leading|trailing|both,] [char c,] String s)：从字符串中去掉首/尾指定的字符或空格。\n  * lower(String s)：将字符串转换成小写形式。\n  * upper(String s)：将字符串转换成大写形式。\n  * length(String s)：求字符串的长度。\n  * locate(String s1, String s2[, int start])：从第一个字符串中查找第二个字符串(子串)出现的位置。若未找到则返回0。\n\n* **算术函数**主要有 abs、mod、sqrt、size 等。Size 用于求集合的元素个数。\n\n* **日期函数**主要为三个，即 current_date、current_time、current_timestamp，它们不需要参数，返回服务器上的当前日期、时间和时戳。\n\n```java\npublic void testJpqlFunction(){\n  String jpql = \"SELECT lower(c.email) FROM Customer c\";\n\n  List<String> emails = entityManager.createQuery(jpql).getResultList();\n  System.out.println(emails);\n}\n```\n\n\n\n## UPDATE 和 DELETE\n\n* update语句用于执行数据更新操作。主要用于针对单个实体类的批量更新。\n* delete语句用于执行数据更新操作。\n\n```java\npublic void testExecuteUpdate(){\n  String jpql = \"UPDATE Customer c SET c.lastName = ? WHERE c.id = ?\";\n  Query query = entityManager.createQuery(jpql).setParameter(1, \"YYY\").setParameter(2, 12);\n\n  query.executeUpdate();\n}\n```\n\n\n\n# 与Spring整合\n\n* 三种整合方式：\n\n  * LocalEntityManagerFactoryBean：适用于那些仅使用 JPA 进行数据访问的项目，该 FactoryBean 将根据JPA PersistenceProvider 自动检测配置文件进行工作，一般从“META-INF/persistence.xml”读取配置信息，这种方式最简单，但**不能设置 Spring 中定义的DataSource，且不支持 Spring 管理的全局事务**。\n  * 从JNDI中获取：用于从 **Java EE 服务器获取指定的EntityManagerFactory**，这种方式在进行 Spring 事务管理时**一般要使用 JTA(分布式) 事务管理**。\n  * **LocalContainerEntityManagerFactoryBean**：适用于所有环境的 FactoryBean，能全面控制 EntityManagerFactory 配置,如指定 Spring 定义的 DataSource 等等。\n\n* 以**LocalContainerEntityManagerFactoryBean**为例：\n\n  * 第一步：新建java工程。导入Spring的jar包和JPA的jar包和Hibernate的jar包。\n\n    * jar包下载地址：https://plumriver.lanzoui.com/iwpX7pawnwh\n\n  * 第二步：新建各种配置文件。\n\n    * spring配置文件：\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xmlns:tx=\"http://www.springframework.org/schema/tx\"\n           xmlns:context=\"http://www.springframework.org/schema/context\"\n           xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n           http://www.springframework.org/schema/beans/spring-beans.xsd \n           http://www.springframework.org/schema/tx \n           http://www.springframework.org/schema/tx/spring-tx.xsd \n           http://www.springframework.org/schema/context \n           http://www.springframework.org/schema/context/spring-context.xsd\">\n      <!--配置Spring的自动扫描包功能-->\n      <context:component-scan base-package=\"com.lc\"/>\n    \n      <!--配置C3P0数据源-->\n      <context:property-placeholder location=\"classpath:db.properties\"/>\n      <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n        <property name=\"user\" value=\"${jdbc.user}\"/>\n        <property name=\"password\" value=\"${jdbc.password}\"/>\n        <property name=\"driverClass\" value=\"${jdbc.driver}\"/>\n        <property name=\"jdbcUrl\" value=\"${jdbc.url}\"/>\n      </bean>\n    \n      <!--配置EntityManagerFactory-->\n      <bean id=\"entityManagerFactory\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <!--配置JPA提供商的适配器。可以通过内部bean的方式配置-->\n        <property name=\"jpaVendorAdapter\">\n          <bean class=\"org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter\"/>\n        </property>\n        <!--配置实体类所在的包路径-->\n        <property name=\"packagesToScan\" value=\"com.lc.entities\"/>\n        <!--配置JPA的基本属性。例如JPA实现产品的属性-->\n        <property name=\"jpaProperties\">\n          <props>\n            <prop key=\"hibernate.show_sql\">true</prop>\n            <prop key=\"hibernate.format_sql\">true</prop>\n            <prop key=\"hibernate.hbm2ddl.auto\">update</prop>\n          </props>\n        </property>\n      </bean>\n      <!--配置JPA的事务管理器-->\n      <bean id=\"transactionManager\" class=\"org.springframework.orm.jpa.JpaTransactionManager\">\n        <property name=\"entityManagerFactory\" ref=\"entityManagerFactory\"/>\n      </bean>\n      <!--配置支持注解的事务配置-->\n      <tx:annotation-driven transaction-manager=\"transactionManager\"/>\n    </beans>\n    ```\n\n    * 数据库配置文件：\n\n    ```properties\n    jdbc.user=root\n    jdbc.password=root\n    jdbc.driver=com.mysql.jdbc.Driver\n    jdbc.url=jdbc:mysql:///jpa\n    ```\n\n  * 第三步：编写dao层和servic层代码。\n\n  ```java\n  @Repository\n  public class PersonDao {\n    //如何获取到和当前事务关联的EntityManager对象？\n    //PersistenceContext：可以标记成员变量\n    @PersistenceContext\n    private EntityManager entityManager;\n  \n    public void save(Person person){\n      entityManager.persist(person);\n    }\n  }\n  @Service\n  public class PersonService {\n    @Autowired\n    private PersonDao personDao;\n    @Transactional\n    public void savePersons(Person person1, Person person2){\n      personDao.save(person1);\n  \n      //测试事务回滚功能\n      int i = 10/0;\n  \n      personDao.save(person2);\n    }\n  }\n  ```\n\n  * 第四步：测试代码\n\n  ```java\n  public class JPATest {\n    private ApplicationContext context = null;\n    private PersonService personService = null;\n    {\n      context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n      personService = context.getBean(PersonService.class);\n    }\n  \n    @Test\n    public void testDataSource() throws SQLException {\n      DataSource dataSource = context.getBean(DataSource.class);\n      System.out.println(dataSource.getConnection());\n    }\n  \n    @Test\n    public void testPersonService() {\n      Person person1 = new Person();\n      person1.setPerName(\"per-1\");\n      Person person2 = new Person();\n      person2.setPerName(\"per-2\");\n  \n      //如果打印出的是代理对象，说明事务已经启动了\n      System.out.println(personService.getClass().getName());\n      personService.savePersons(person1,person2);\n    }\n  }\n  ```\n\n* 总结：\n\n  * 需要注意配置文件中配置的entityManagerFactory和transactionManager。\n  * 以及dao层获取EntityManager的@PersistenceContext注解。\n\n* 项目总体样式：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210520191105-8.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["Java学习","JavaEE框架"]},{"title":"Hibernate的学习","url":"/2021/05/18/尚硅谷说Java/JavaEE框架/Hibernate/","content":"\n* Hibernate官网：http://hibernate.org/\n* 基于Hibernate4版本学习。工具为Eclipse\n\n<!--more-->\n\n# Hibernate入门\n\n* Hibernate是一个开放源代码的**对象关系映射**框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个**全自动的orm框架**，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。\n\n* 对象的持久化：\n\n  * 狭义的理解，“持久化”仅仅指把对象永久保存到数据库中。\n  * 广义的理解，“持久化”包括和数据库相关的各种操作：\n    * 保存：把对象永久保存到数据库中。\n    * 更新：更新数据库中对象(记录)的状态。\n    * 删除：从数据库中删除一个对象。\n    * 查询：根据特定的查询条件，把符合查询条件的一个或多个对象从数据库加载到内存中。\n    * 加载：根据**特定的OID**，把一个对象从数据库加载到内存中。\n  * 为了在系统中能够找到所需对象，需要为每一个对象分配一个唯一的标识号。在关系数据库中称之为主键，而在对象术语中，则叫做对象标识(Object identifier-OID).\n\n* ORM：\n\n  * ORM(Object/Relation Mapping): 对象/关系映射。\n  * ORM 主要解决对象-关系的映射\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710.png)\n\n  * ORM的思想：将关系数据库中表中的记录映射成为对象，以对象的形式展现，程序员可以把对数据库的操作转化为对对象的操作。\n  * ORM 采用元数据来描述对象-关系映射细节, 元数据通常采用 XML 格式, 并且存放在专门的对象-关系映射文件中。\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-1.png)\n\n  * 流行的ORM框架：\n    * Hibernate:\n      * 非常优秀、成熟的 ORM 框架。\n      * 完成对象的持久化操作。\n      * Hibernate 允许开发者采用面向对象的方式来操作关系数据库。\n      * 消除那些针对特定数据库厂商的 SQL 代码。\n    * myBatis：\n      * 相比 Hibernate 灵活高，运行速度快。\n      * 开发速度慢，不支持纯粹的面向对象操作，需熟悉sql语句，并且熟练使用sql语句优化功能。\n    * TopLink\n    * OJB\n\n* Hibernate与JDBC的代码比较：完成添加数据的操作：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-2.png)\n\n* eclipse安装Hibernate插件。为了方便开发。\n\n  * 1.点击Help --> 选择Install New Software...\n  * 2.输入：https://download.jboss.org/jbosstools/photon/stable/updates/。然后按回车。\n    * 此网址可以在hibernate官网上的工具下载里面找。\n  * 3.选中hibernate tools。如下图。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-3.png)\n\n  * 4.一直点击下一步即可。\n  * 5.重启eclipse即可。\n\n* 使用IDEA搭建Hibernate\n\n  * 第一步：创建Java Enterprise项目。导入jar包。\n\n  ```\n  所有jar包下载地址：https://plumriver.lanzoui.com/inBJCp536ji\n  antlr-2.7.7.jar\n  c3p0-0.9.2.1.jar\n  dom4j-1.6.1.jar\n  hibernate-c3p0-4.2.4.Final.jar\n  hibernate-commons-annotations-4.0.2.Final.jar\n  hibernate-core-4.2.4.Final.jar\n  lib\\hibernate-jpa-2.0-api-1.0.1.Final.jar\n  javassist-3.15.0-GA.jar\n  jboss-logging-3.1.0.GA.jar\n  jboss-transaction-api_1.1_spec-1.0.1.Final.jar\n  mchange-commons-java-0.2.3.4.jar\n  mysql-connector-java-5.1.7-bin.jar\n  ```\n\n  * 第二步：配置Hibernate配置文件。文件名为：hibernate.xfg.xml。\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <!DOCTYPE hibernate-configuration SYSTEM\n        \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\">\n    <hibernate-configuration>\n      <session-factory>\n        <!--配置链接数据库的基本信息-->\n        <property name=\"connection.username\">root</property>\n        <property name=\"connection.password\">root</property>\n        <property name=\"connection.driver_class\">com.mysql.jdbc.Driver</property>\n        <property name=\"connection.url\">jdbc:mysql:///hibernate</property>\n        <!--配置hibernate的基本信息-->\n        <!--1.指定使用的数据库方言。此方言根据数据库不同，版本不同，驱动不同。则方言也不同-->\n        <property name=\"dialect\">org.hibernate.dialect.MySQL5InnoDBDialect</property>\n        <!--2.指定操作数据库时，是否在控制台打印SQL语句-->\n        <property name=\"show_sql\">true</property>\n        <!--3.是否对SLQ进行格式化-->\n        <property name=\"format_sql\">true</property>\n        <!--4.指定自动生成数据表的策略-->\n        <property name=\"hibernate.hbm2ddl.auto\">update</property>\n        <!--指定关联的hbm.xml文件以及对应的实体类对象。在IDEA中这个信息可以自动生成-->\n        <mapping resource=\"com/lc/bean/News.hbm.xml\"/>\n        <mapping class=\"com.lc.bean.News\"/>\n      </session-factory>\n    </hibernate-configuration>\n    ```\n\n  * 第三步：创建持久化类。即实体类。\n\n  ```java\n  import java.util.Date;\n  /**\n   * 新闻实体类\n   */\n  public class News {\n    private Integer id;\n    private String title;\n    private String author;\n    private Date date;\n    /**\n     * 无参构造方法，有参构造方法，\n     * 所有属性的get，set方法\n     * 重写equals方法和hashcode方法\n     */\n  }\n  ```\n\n  * 第四步：创建对象-关系映射文件\n\n    * IDEA使用根据数据库的方式创建。即先有数据库中的表，然后自动生成实体类以及映射文件。\n    * 首先使用IDEA的Database功能连接mysql数据库。\n    * IDEA左下角点击persistence。右击hibernate，选中最下方的genreate mapping。\n    * 然后点击by database，然后填写信息即可。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-4.png)\n\n    * 对应的配置文件信息：\n\n    ```xml\n    <?xml version='1.0' encoding='utf-8'?>\n    <!DOCTYPE hibernate-mapping PUBLIC\n        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n        \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n    <hibernate-mapping>\n    \n      <class name=\"com.lc.bean.News\" table=\"news\" schema=\"hibernate\">\n        <id name=\"id\" column=\"ID\">\n          <!--指定主键的生成方式。native表示使用数据库本地的方式-->\n          <generator class=\"native\"/>\n        </id>\n        <property name=\"title\" column=\"TITLE\"/>\n        <property name=\"author\" column=\"AUTHOR\"/>\n        <property name=\"date\" column=\"DATE\"/>\n      </class>\n    </hibernate-mapping>\n    ```\n\n  * 第五步：编写测试代码：\n\n    ```java\n    public static void main(String[] args){\n      // 1.创建SessionFactory对象\n      // 1.1 创建Configuration对象：对应hibernate的基本配置信息，以及对象映射信息\n      // configure()方法可以指明配置文件信息。默认加载名为“hibernate.cfg.xml”的配置文件\n      Configuration configuration = new Configuration().configure();\n      // 1.2 创建ServiceRegistry对象：在4.0以后开始出现此对象。\n      //   功能：hibernate 的任何配置和服务都需要在该对象中注册后才能有效.\n      ServiceRegistry serviceRegistry =\n        new ServiceRegistryBuilder().applySettings(configuration.getProperties())\n        .buildServiceRegistry();\n      // 1.3 创建SessionFactory对象\n      SessionFactory sessionFactory = configuration.buildSessionFactory(serviceRegistry);\n      // 2.创建Session对象\n      Session session = sessionFactory.openSession();\n      // 3.开启事务\n      Transaction transaction = session.beginTransaction();\n      // 4.执行保存操作\n      News news = new News(\"hibernate测试\",\"hibernate\" , new Date());\n      session.save(news);\n      // 5.提交事务\n      transaction.commit();\n      // 6.关闭Session对象\n      session.clear();\n      // 7.关闭SessionFactory对象\n      sessionFactory.close();\n    }\n    ```\n\n* 说明：\n\n  * 持久化类的说明：\n    * 提供一个无参的构造器:使Hibernate可以使用Constructor.newInstance() 来实例化持久化类。\n    * 提供一个标识属性(identifier property): **通常映射为数据库表的主键字段**. 如果没有该属性，一些功能将不起作用，如：Session.saveOrUpdate()\n    * 为类的持久化类字段声明访问方法(get/set): Hibernate对JavaBeans 风格的属性实行持久化。\n    * 使用非 final 类: 在运行时**生成代理**是 Hibernate 的一个重要的功能. 如果持久化类没有实现任何接口, Hibnernate 使用 CGLIB 生成代理. 如果使用的是 final 类, 则无法生成 CGLIB 代理。\n    * **重写 eqauls 和 hashCode 方法**: 如果需要把持久化类的实例放到 Set 中(当需要进行关联映射时), 则应该重写这两个方法。\n  * 对象-关系映射文件说明：\n    * Hibernate 采用 XML 格式的文件来指定对象和关系数据之间的映射. 在运行时 Hibernate 将根据这个映射文件来生成各种 SQL 语句。\n    * 映射文件的扩展名为 .hbm.xml。\n  * 配置文件说明：\n    * Hibernate 从其配置文件中读取和数据库连接的有关信息, 这个文件应该位于应用的 classpath 下。\n\n* 使用 Hibernate 进行数据持久化操作，通常有如下步骤：\n\n  * 编写持久化类： POJO + 映射文件\n  * 获取 Configuration 对象。\n  * 获取 SessionFactory 对象。\n  * 获取 Session，打开事务。\n  * 用面向对象的方式操作数据库。\n  * 关闭事务，关闭 Session。\n\n* Configuration 类：\n\n  * Configuration 类负责管理 Hibernate 的配置信息。包括如下内容：\n    * Hibernate 运行的底层信息：数据库的URL、用户名、密码、JDBC驱动类，数据库Dialect,数据库连接池等（对应 hibernate.cfg.xml 文件）。\n    * 持久化类与数据表的映射关系（*.hbm.xml 文件）。\n  * 创建 Configuration 的两种方式：\n    * 属性文件（hibernate.properties）:\n      * Configuration cfg = new Configuration();\n    * Xml文件（hibernate.cfg.xml）\n      * Configuration cfg = new Configuration().configure();\n    * Configuration 的 configure 方法还支持带参数的访问：\n      * File file = new File(“simpleit.xml”);\n      * Configuration cfg = new Configuration().configure(file);\n\n* SessionFactory 接口：\n\n  * 针对单个数据库映射关系经过编译后的内存镜像，是线程安全的。 \n  * SessionFactory 对象一旦构造完毕，即被赋予特定的配置信息\n  * SessionFactory是生成Session的工厂\n  * 构造 SessionFactory 很消耗资源，一般情况下一个应用中只初始化一个 SessionFactory 对象。\n  * Hibernate4 新增了一个 ServiceRegistry 接口，所有基于 Hibernate 的配置或者服务都必须统一向这个 ServiceRegistry  注册后才能生效。\n\n* Session 接口：\n\n  * Session 是应用程序与数据库之间交互操作的一个单线程对象，是 Hibernate 运作的中心，所有持久化对象必须在 session 的管理下才可以进行持久化操作。此对象的生命周期很短。\n  * Session 对象有一个一级缓存，显式执行 flush 之前，所有的持久层操作的数据都缓存在 session 对象处。相当于 JDBC 中的 Connection。\n  * 持久化类与 Session 关联起来后就具有了持久化的能力。\n  * Session 类的方法：\n    * 取得持久化对象的方法： get() load()\n    * 持久化对象都得保存，更新和删除：save(),update(),saveOrUpdate(),delete()\n    * 开启事务: beginTransaction().\n    * 管理 Session 的方法：isOpen(),flush(), clear(), evict(), close()等\n\n* Transaction(事务)：\n\n  * 代表一次原子操作，它具有数据库事务的概念。所有持久层都应该在事务管理下进行，即使是只读操作。 \n    * Transaction tx = session.beginTransaction();\n  * 常用方法:\n    * commit():提交相关联的session实例。\n    * rollback():撤销事务操作。\n    * wasCommitted():检查事务是否提交。\n\n* Hibernate 配置文件的两个配置项：\n\n  * hbm2ddl.auto：该属性可帮助程序员实现正向工程, 即由 java 代码生成数据库脚本, 进而生成具体的表结构. 。取值 create | update | create-drop | validate。\n    * create : 会根据 .hbm.xml  文件来生成数据表, 但是每次运行都会**删除上一次的表** ,重新生成表, 哪怕二次没有任何改变 。\n    * create-drop : 会根据 .hbm.xml 文件生成表,但是SessionFactory一关闭, **表就自动删除** 。\n    * update : **最常用的属性值**，也会根据 .hbm.xml 文件生成表, 但若 .hbm.xml  文件和数据库中对应的数据表的表结构不同, Hiberante  将更新数据表结构，但**不会删除已有的行和列** 。\n    * validate : 会和数据库中的表进行比较, 若 .hbm.xml 文件中的列在数据表中不存在，则抛出异常。\n  * format_sql：是否将 SQL 转化为格式良好的 SQL . 取值 true | false\n\n\n\n# Session概述\n\n* Session 接口是 Hibernate 向应用程序提供的操纵数据库的最主要的接口, 它提供了基本的**保存, 更新, 删除和加载 Java 对象**的方法。\n\n* Session 具有一个缓存空间, 位于**缓存中的对象**称为持久化对象, 它和数据库中的相关记录对应. Session 能够在某些时间点, 按照缓存中对象的变化来执行相关的 SQL 语句, 来同步更新数据库, 这一过程被称为刷新缓存(flush)。\n\n* 站在持久化的角度, Hibernate 把对象分为 4 种状态: 持久化状态, 临时状态, 游离状态, 删除状态. Session 的特定方法能使对象从一个状态转换到另一个状态.。\n\n* **Session 缓存**\n\n  * 在 Session 接口的实现中包含一系列的 Java 集合, 这些 Java 集合构成了 Session 缓存. 只要 Session 实例没有结束生命周期, 且没有清理缓存，则存放在它缓存中的对象也不会结束生命周期。\n  * Session缓存也被称为一级缓存。\n  * Session 缓存可减少 Hibernate 应用程序访问数据库的频率。\n  * 例如下面代码：在同一个Session中查询了两次数据，但实际上Session只发送了一条查询语句。\n\n  ```java\n  public class SessionCacheTest {\n    private SessionFactory sessionFactory;\n    private Session session;\n    private Transaction transaction;\n    @Before\n    public void befor(){\n      Configuration configuration = new Configuration().configure();\n      ServiceRegistry serviceRegistry = new ServiceRegistryBuilder()\n          .applySettings(configuration.getProperties())\n          .buildServiceRegistry();\n      this.sessionFactory = configuration.buildSessionFactory(serviceRegistry);\n      this.session = sessionFactory.openSession();\n      this.transaction = this.session.beginTransaction();\n    }\n    @After\n    public void after(){\n      transaction.commit();\n      session.close();\n      sessionFactory.close();\n    }\n    @Test\n    public void operation(){\n      //get方法获取的是缓存中数据的引用，当对对象进行修改时，相当于修改缓存中的数据，\n      News news1 = (News) session.get(News.class,1);\n      System.out.println(news1);\n      News news2 = (News) session.get(News.class,1);\n      System.out.println(news2);\n      System.out.println(news1 == news2);\n    }\n  }\n  ```\n\n  * 结果为：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-5.png)\n\n* Session缓存的操作;\n\n  * Hibernate提供了三个操作Session缓存的方式。分别是flush(),reflush(),clear()。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-6.png)\n\n* flush()方法;\n\n  * flush：Session 按照缓存中对象的属性变化来同步更新数据库。\n  * 默认情况下 Session 在以下时间点刷新缓存：\n    * 显式调用 Session 的 flush() 方法。\n    * 当应用程序调用 Transaction 的 **commit（）**方法的时, 该方法**先 flush** ，然后在向数据库提交事务。\n    * 当应用程序执行一些**查询(HQL, Criteria)操作**时，如果缓存中持久化对象的属性已经发生了变化，会先 flush 缓存，以保证查询结果能够反映持久化对象的**最新状态**。\n  * flush 缓存的**例外情况**: 如果对象使用 **native 生成器**生成 OID, 那么当调用 Session 的 save() 方法保存对象时, 会立即执行向数据库插入该实体的 insert 语句。\n  * commit() 和 flush() 方法的区别：flush 执行一系列 sql 语句，**但不提交事务**；commit 方法先调用flush() 方法，然后提交事务. 意味着提交事务意味着对数据库操作永久保存下来。\n\n  ```java\n  public void testFlush(){\n    //get方法获取的是缓存中数据的引用，当对对象进行修改时，相当于修改缓存中的数据，\n    News news = (News)session.get(News.class, 1);\n    System.out.println(news.toString());\n    news.setAuthor(\"asd\");\n    //QBC查询案例\n    News news1 = (News) session.createCriteria(News.class).uniqueResult();\n    System.out.println(news1.toString());\n    //session.flush();\n  }\n  ```\n\n* reflush()方法：\n\n  * reflush：执行此方法时，会强制发送一条查询语句，以看缓存中的数据和数据库的数据是否一致。如果不一致则会更新缓存中的数据。\n  * 注意：此方法的执行成功想要设置数据库的隔离级别在READ COMMITED。\n  * 在 Hibernate 的配置文件中可以显式的设置隔离级别. 每一个隔离级别都对应一个整数:\n    * READ UNCOMMITED：1\n    * READ COMMITED：2\n    * REPEATABLE READ：4\n    * SERIALIZEABLE：8\n  * Hibernate 通过为 Hibernate 映射文件指定 hibernate.connection.isolation 属性来设置事务的隔离级别。\n\n  ```java\n  //修改配置\n  //<property name=\"connection.isolation\">2</property>\n  //测试代码\n  public void testReflush(){\n    News news = (News)session.get(News.class, 1);\n    System.out.println(news.toString());\n    //如果此时修改了数据库中的数据。这样数据库数据和缓存数据就会不同。\n    //使用reflush()方法强制更新缓存中的哪一条数据\n    session.refresh(news);\n    System.out.println(news.toString());\n  }\n  ```\n\n* clear()：清除缓存中的数据。\n\n\n\n# 持久化对象的四种状态\n\n* 站在持久化的角度, Hibernate 把对象分为 4 种状态: 持久化状态, 临时状态, 游离状态, 删除状态. Session 的特定方法能使对象从一个状态转换到另一个状态。\n\n* 临时对象（Transient）: \n\n  * 在使用代理主键的情况下, OID 通常为 null。\n  * 不处于 Session 的缓存中。\n  * 在数据库中没有对应的记录。\n\n* 持久化对象(也叫”托管”)（Persist）：\n\n  * OID 不为 null。\n  * 位于 Session 缓存中。\n  * 若在数据库中已经有和其对应的记录, 持久化对象和数据库中的相关记录对应。\n  * Session 在 flush 缓存时, 会根据持久化对象的属性变化, 来同步更新数据库。\n  * 在同一个 Session 实例的缓存中, 数据库表中的每条记录只对应唯一的持久化对象。\n\n* 删除对象(Removed)\n\n  * 在数据库中没有和其 OID 对应的记录\n  * 不再处于 Session 缓存中。\n  * 一般情况下, 应用程序不该再使用被删除的对象。\n\n* 游离对象(也叫”脱管”) （Detached）：\n\n  * OID 不为 null。\n  * 不再处于 Session 缓存中。\n  * 一般情况需下, 游离对象是由持久化对象转变过来的, 因此在数据库中可能还存在与它对应的记录。\n\n* 四种状态的改变：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-7.png)\n\n* 临时状态 --> 持久化状态：\n\n  * Session 的 save() 方法使一个临时对象转变为持久化对象\n  * Session 的 save() 方法完成以下操作:\n    * 把 News 对象加入到 Session 缓存中, 使它进入持久化状态\n    * 选用映射文件指定的标识符生成器, 为持久化对象分配**唯一的 OID**。\n    * 在**使用代理主键**的情况下, setId() 方法为 News 对象设置 OID 使无效的。\n    * 计划执行一条 insert 语句：在 flush 缓存的时候\n  * Hibernate 通过持久化对象的 OID 来维持它和数据库相关记录的对应关系. 当 News 对象处于持久化状态时, 不允许程序随意修改它的 ID\n  * persist() 和 save() 区别：\n    * 当对一个 OID 不为 Null 的对象执行 save() 方法时, 会把该对象以一个新的 oid 保存到数据库中;  但执行 persist() 方法时会抛出一个PersistentObjectException异常。\n\n  ```java\n  public void TransientToPersist(){\n    News news = new News(\"c++\", \"c\", new Date());\n    news.setId(100);\n    session.persist(news); //此时会报错，因为设置的id。\n    //    session.save(news);\n    //    System.out.println(news); //由于设置的ID策略为native,此时输出的数据中id对应的是数据库的id\n  }\n  ```\n\n* 直接变成持久化状态：\n\n  * get()和load()方法：都可以根据跟定的 OID 从数据库中加载一个持久化对象。\n  * 区别：\n    * 当数据库中不存在与 OID 对应的记录时, load() 方法抛出 ObjectNotFoundException 异常, 而 get() 方法返回 null。\n    * 两者采用不同的延迟检索策略：load 方法支持延迟加载策略。而 get 不支持。\n      * 因为load()方法执行后并不执行sql语句，而且返回的是一个代理对象。当代理对象被使用到时才会执行sql语句。\n    * 当执行完get()或load()方法后，关闭session对象，此时再使用获得的数据。get可以正常使用。load汇报LazyInitializationException异常。\n\n  ```java\n  public void ToPersist(){\n    /*    News news1 = (News) session.get(News.class, 1);\n      session.close();\n      System.out.println(news1);*/\n  \n    News news2 = (News) session.load(News.class, 1);\n    //session.close();\n    //此时汇报LazyInitializationException异常\n    System.out.println(news2.getClass().getName());\n    System.out.println(news2);\n  }\n  ```\n\n* 游离态 --> 持久态\n\n  * update()方法：\n\n    * 当更新一个持久化对象时，不需要显示的写出update()方法。\n\n    * Session 的 update() 方法使一个游离对象转变为持久化对象, 并且计划执行一条 update 语句。\n\n    * 若希望 Session 仅当修改了 News 对象的属性时, 才执行 update() 语句, 可以把映射文件中 \\<class> 元素的 select-before-update 设为 true. 该属性的默认值为 false。\n\n      * 即希望再更新前先查一遍，如果数据相同则不更新。\n\n      ```xml\n      <class name=\"com.lc.bean.News\" table=\"news\" schema=\"hibernate\" select-before-update=\"true\">\n      ```\n\n    * 当 update() 方法关联一个游离对象时, 如果在 Session 的缓存中已经存在相同 OID 的持久化对象, 会抛出NonUniqueObjectException异常。\n\n    * 当 update() 方法关联一个游离对象时, 如果在数据库中不存在相应的记录, 也会抛出StaleStateException异常。\n\n    ```java\n    public void DetachedToPersist(){\n      News news1 = (News) session.get(News.class, 1);\n      transaction.commit();\n      session.close();\n      //此时开启的session已经是一个新的session了。此时的news1对象就是一个游离状态。\n      session = sessionFactory.openSession();\n      transaction = session.beginTransaction();\n      //1.此时会发送更新语句，将此对象由游离状态变成持久状态\n      //session.update(news1);\n      //2.此时会抛出StaleStateException异常，因为数据库中不存在此对象。\n      //news1.setId(100);\n      //session.update(news1);\n      //3.此时会抛出NonUniqueObjectException异常，因为缓存中不能存在两个相同QID的对象。news1和news2的QID相同\n      News news2 = (News) session.get(News.class, 1);\n      session.update(news1);\n    }\n    ```\n\n  * saveOrUpdate() 方法：\n\n    * Session 的 saveOrUpdate() 方法同时包含了 save() 与 update() 方法的功能。\n\n      ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-8.png)\n\n    * 判定对象为临时对象的标准\n\n      * Java 对象的 OID 为 null。\n      * 映射文件中为 \\<id> 设置了 unsaved-value  属性, 并且 Java 对象的 OID 取值与这个 unsaved-value 属性值匹配。\n\n      ```xml\n      <id name=\"id\" column=\"ID\" unsaved-value=\"-1\">\n        <!--指定主键的生成方式。native表示使用数据库本地的方式-->\n        <generator class=\"native\"/>\n      </id>\n      ```\n\n    ```java\n    @Test\n    public void DetachedToPersist2(){\n      News news = new News(\"asas\", \"dsds\", new Date());\n      //1.由于没有id,此时发送的insert语句\n      session.saveOrUpdate(news);\n      //2.有id，且数据库中有此id，则发送update语句\n      news.setId(1);\n      session.saveOrUpdate(news);\n      //3.有id，但数据库中没有此id，会执行更新操作，但是没有id,则抛出异常\n      news.setId(100);\n      session.saveOrUpdate(news);\n      //4.有id.且id和映射文件中设置的id的unsaved-value属性值相同，则发送insert语句\n      news.setId(-1);\n      session.saveOrUpdate(news);\n    }\n    ```\n\n  * merge()方法：\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-9.png)\n\n* 到删除状态：\n\n  * Session 的 delete() 方法既可以删除一个游离对象, 也可以删除一个持久化对象。\n  * Session 的 delete() 方法处理过程\n    * 计划执行一条 delete 语句。\n    * 把对象从 Session 缓存中删除, 该对象进入删除状态。\n    * 默认删除后对象的数据不变。\n\n  ```java\n  public void ToDelete(){\n    News news = new News();\n    /*    news.setId(3);\n      session.delete(news);\n      System.out.println(news);*/\n    //如果删除的id不存在，则抛出StaleStateException异常\n    news.setId(100);\n    session.delete(news);\n  }\n  ```\n\n  * 如果删除的对象再数据库中不存在，则抛StaleStateException异常。\n\n  * Hibernate 的 cfg.xml 配置文件中有一个 hibernate.use_identifier_rollback 属性, 其默认值为 false, 若把它设为 true, 将改变 delete() 方法的运行行为: \n\n    * 即delete() 方法会把持久化对象或游离**对象的 OID 设置为 null**, 使它们变为临时对象。\n\n    ```xml\n    <property name=\"hibernate.use_identifier_rollback\">true</property>\n    ```\n\n* 持久状态 --> 游离状态\n\n  * evict()方法：从Session缓存中把指定持久态对象移除。\n\n  ```java\n  public void PersistToDetached(){\n    News news = (News) session.get(News.class, 4);\n    news.setAuthor(\"xzczczx\");\n    //从缓存中移除此对象后，更新操作将不再执行。\n    session.evict(news);\n  }\n  ```\n\n* 通过Hibernate 调用存储过程。\n\n  * Work 接口: 直接通过 JDBC API 来访问数据库的操作。\n\n  ```java\n  public void jdbcTest(){\n    Work work = new Work() {\n      @Override\n      public void execute(Connection connection) throws SQLException {\n        //此时就能获取到connection对象。就能编写调用存储过程的代码了\n      }\n    };\n    session.doWork(work);\n  }\n  ```\n\n  * Session 的 doWork(Work) 方法用于执行 Work 对象指定的操作, 即调用 Work 对象的 execute() 方法。\n  * Session 会把当前使用的数据库连接传递给 execute() 方法。\n\n* Hibernate 与触发器协同工作：\n  * 出现的问题：\n    * 触发器使 Session 的缓存中的持久化对象与数据库中对应的**数据不一致**:触发器运行在数据库中, 它执行的操作对 Session 是透明的。\n    * Session 的 update() 方法**盲目地激发触发器**: 无论游离对象的属性是否发生变化, 都会执行 update 语句, 而 update 语句会激发数据库中相应的触发器。\n  * 解决方案：\n    * 在执行完 Session 的相关操作后, 立即调用 Session 的 flush() 和 refresh() 方法, 迫使 Session 的缓存与数据库同步(refresh() 方法重新从数据库中加载对象)。\n    * 在映射文件的的 \\<class> 元素中设置 select-before-update 属性: \n    * 当 Session 的 update 或 saveOrUpdate() 方法更新一个游离对象时, 会先执行 Select 语句, 获得当前游离对象在数据库中的最新数据, 只有在不一致的情况下才会执行 update 语句。\n\n\n\n# 配置文件详解\n\n* Hibernate 配置文件主要用于配置数据库连接和 Hibernate 运行时所需的各种属性。\n\n* 每个 Hibernate 配置文件对应一个 Configuration 对象。\n\n* Hibernate配置文件可以有两种格式:\n\n  * hibernate.properties\n  * hibernate.cfg.xml \n\n* JDBC 连接属性\n\n  * connection.url：数据库URL 。\n  * connection.username：数据库用户名。\n  * connection.password：数据库用户密码 。\n  * connection.driver_class：数据库JDBC驱动 。\n  * dialect：配置数据库的方言，根据底层的数据库不同产生不同的 sql 语句，Hibernate 会针对数据库的特性在访问时进行优化。\n\n* C3P0 数据库连接池属性\n\n  * hibernate.c3p0.max_size: 数据库连接池的最大连接数。\n  * hibernate.c3p0.min_size: 数据库连接池的最小连接数。\n  * hibernate.c3p0.timeout:   数据库连接池中连接对象在多长时间没有使用过后，就应该被销毁。\n  * hibernate.c3p0.max_statements:  缓存 Statement 对象的数量。\n  * hibernate.c3p0.idle_test_period:  表示连接池检测线程多长时间检测一次池内的所有链接对象是否超时. 连接池本身不会把自己从连接池中移除，而是专门有一个线程按照一定的时间间隔来做这件事，这个线程通过比较连接对象最后一次被使用时间和当前时间的时间差来和 timeout 做对比，进而决定是否销毁这个连接对象。 \n  * hibernate.c3p0.acquire_increment: 当数据库连接池中的连接耗尽时, 同一时刻获取多少个数据库连接。\n\n  ```xml\n  <!--c3p0连接池配置-->\n  <property name=\"c3p0.max_size\">32</property>\n  <property name=\"c3p0.min_size\">4</property>\n  <property name=\"c3p0.timeout\">2000</property>\n  <property name=\"c3p0.max_statements\">32</property>\n  <property name=\"c3p0.acquire_increment\">2</property>\n  <property name=\"c3p0.idle_test_period\">2000</property>\n  ```\n\n* show_sql：是否将运行期生成的SQL输出到日志以供调试。取值 true | false \n\n* format_sql：是否将 SQL 转化为格式良好的 SQL . 取值 true | false\n\n* hbm2ddl.auto：在启动和停止时自动地创建，更新或删除数据库模式。取值 create | update | create-drop | validate\n\n* hibernate.jdbc.fetch_size：实质是调用 Statement.setFetchSize() 方法设定 JDBC 的 Statement 读取数据的时候每次从数据库中取出的记录条数。\n\n  * 例如一次查询1万条记录，对于Oracle的JDBC驱动来说，是不会 1 次性把1万条取出来的，而只会取出 fetchSize 条数，当结果集遍历完了这些记录以后，再去数据库取 fetchSize 条数据。因此大大节省了无谓的内存消耗。\n  * Fetch Size设的越大，读数据库的次数越少，速度越快；Fetch Size越小，读数据库的次数越多，速度越慢。Oracle数据库的JDBC驱动默认的Fetch Size = 10，是一个保守的设定，根据测试，当Fetch Size=50时，性能会提升1倍之多，当 fetchSize=100，性能还能继续提升20%，Fetch Size继续增大，性能提升的就不显著了。\n  * 并不是所有的数据库都支持Fetch Size特性，例如**MySQL就不支持**。\n\n* hibernate.jdbc.batch_size：设定对数据库进行批量删除，批量更新和批量插入的时候的批次大小，类似于设置缓冲区大小的意思。batchSize 越大，批量操作时向数据库发送sql的次数越少，速度就越快。\n\n  * 测试结果是当Batch Size=0的时候，使用Hibernate对Oracle数据库删除1万条记录需要25秒，Batch Size = 50的时候，删除仅仅需要5秒！Oracle数据库 batchSize=30 的时候比较合适。\n\n* \n\n\n\n# 映射文件详解\n\n* POJO 类和关系数据库之间的映射可以用一个XML文档来定义。\n\n* 通过 POJO 类的数据库映射文件，Hibernate可以理解持久化类和数据表之间的对应关系，也可以理解持久化。\n\n* 类属性与数据库表列之间的对应关系。\n\n* 在运行时 Hibernate 将根据这个映射文件来生成各种 SQL 语句。\n\n* 映射文件的扩展名为 .hbm.xml。\n\n* 映射文件的标签层次\n\n  ```\n  hibernate-mapping\n   类层次：class\n      主键：id\n      基本类型:property\n      实体引用类: many-to-one  |  one-to-one\n      集合:set | list | map | array\n        one-to-many\n        many-to-many\n      子类:subclass | joined-subclass\n      其它:component | any 等\n    查询语句:query（用来放置查询语句，便于对数据库查询的统一管理和优化）\n  ```\n\n* 每个Hibernate-mapping中可以同时定义多个类. 但更推荐为每个类都创建一个单独的映射文件。\n\n* hibernate-mapping标签属性说明：hibernate-mapping 是 hibernate 映射文件的根元素。\n\n  * schema：指定所映射的数据库schema的名称。若指定该属性, 则表明会自动添加该 schema 前缀\n  * catalog：指定所映射的数据库catalog的名称。  \n  * *default-cascade*(默认为 none)：设置hibernate默认的级联风格. 若配置 Java 属性, 集合映射时没有指定 cascade 属性, 则 Hibernate 将采用此处指定的级联风格.   \n  * *default-access* (默认为 property)：指定 Hibernate 的默认的属性访问策略。默认值为 property, 即使用 getter, setter 方法来访问属性. 若指定 access, 则 Hibernate 会忽略 getter/setter 方法, 而通过反射访问成员变量.\n  * *default-lazy*(默认为 true)：设置 Hibernat morning的延迟加载策略. 该属性的默认值为 true, 即启用延迟加载策略. 若配置 Java 属性映射, 集合映射时没有指定 lazy 属性, 则 Hibernate 将采用此处指定的延迟加载策略 \n  * auto-import (默认为 true)：指定是否可以在查询语言中使用非全限定的类名（仅限于本映射文件中的类）。 \n  * **package (可选)**：指定一个包前缀，如果在映射文档中没有指定全限定的类名， 就使用这个作为包名。 \n\n* class标签属性说明：class 元素用于指定类和表的映射。\n\n  * **name**：指定该持久化类映射的持久化类的类名。\n  * **table**：指定该持久化类映射的表名, Hibernate 默认以持久化类的类名作为表名。\n  * **dynamic-inser**t：若设置为 true, 表示当保存一个对象时, 会动态生成 insert 语句, insert 语句中仅包含所有取值不为 null 的字段. 默认值为 false。\n  * **dynamic-update**：若设置为 true, 表示当更新一个对象时, 会动态生成 update 语句, update 语句中仅包含所有取值需要更新的字段. 默认值为 false。\n  * **select-before-update**：设置 Hibernate 在更新某个持久化对象之前是否需要先执行一次查询. 默认值为 false。\n  * *batch-size*：指定根据 OID 来抓取实例时每批抓取的实例数。\n  * *lazy*：指定是否使用延迟加载。\n  * *mutable*：若设置为 true, 等价于所有的 \\<property> 元素的 update 属性为 false, 表示整个实例不能被更新. 默认为 true。\n  * *discriminator-value*：指定区分不同子类的值. 当使用 \\<subclass/> 元素来定义持久化类的继承关系时需要使用该属性。\n\n* id标签属性说明：设定持久化类的 OID 和表的主键的映射\n\n  * Hibernate 使用对象标识符(OID) 来建立内存中的对象和数据库表中记录的对应关系. 对象的 OID 和数据表的主键对应. **Hibernate 通过标识符生成器来为主键赋值**。\n  * Hibernate 推荐在数据表中使用**代理主键**, 即**不具备业务含义**的字段. 代理主键通常为**整数类型**, 因为整数类型比字符串类型要节省更多的数据库空间.\n  * 在对象-关系映射文件中,\\<id> 元素用来设置对象标识符. \\<generator> 子元素用来设定标识符生成器。\n  * Hibernate 提供了**标识符生成器接口**: *IdentifierGenerator*, 并提供了各种内置实现。\n  * **name**：标识持久化类 OID 的属性名。\n  * **column**：设置标识属性所映射的数据表的列名(主键字段的名字)。\n  * **unsaved-value**：若设定了该属性, Hibernate 会通过比较持久化类的 OID 值和该属性值来区分当前持久化类的对象是否为临时对象。\n  * **type**：指定 Hibernate 映射类型. Hibernate 映射类型是 Java 类型与 SQL 类型的桥梁. 如果没有为某个属性显式设定映射类型, Hibernate 会运用反射机制先识别出持久化类的特定属性的 Java 类型, 然后自动使用与之对应的默认的 Hibernate 映射类型。\n  * Java 的基本数据类型和包装类型对应相同的 Hibernate 映射类型. 基本数据类型无法表达 null, 所以对于持久化类的 OID 推荐使用包装类型。\n\n* generator标签属性说明：设定持久化类设定标识符生成器。\n\n  * class: 指定使用的标识符生成器全限定类名或其缩写名。\n\n* Property标签属性说明：property 元素用于指定类的属性和表的字段的映射。\n\n  * **name**：指定该持久化类的属性的名字\n  * **column**：指定与类的属性映射的表的字段名. 如果没有设置该属性, Hibernate 将直接使用类的属性名作为字段名. \n  * **type**：指定 Hibernate 映射类型. Hibernate 映射类型是 Java 类型与 SQL 类型的桥梁. 如果没有为某个属性显式设定映射类型, Hibernate 会运用反射机制先识别出持久化类的特定属性的 Java 类型, 然后自动使用与之对应的默认的 Hibernate 映射类型.\n  * **not-null**：若该属性值为 true, 表明不允许为 null, 默认为 false\n  * **access**：指定 Hibernate 的默认的属性访问策略。默认值为 property, 即使用 getter, setter 方法来访问属性. 若指定 field, 则 Hibernate 会忽略 getter/setter 方法, 而通过反射访问成员变量\n  * **unique**：设置是否为该属性所映射的数据列添加唯一约束. \n  * **index**：指定一个字符串的索引名称. 当系统需要 Hibernate 自动建表时, 用于为该属性所映射的数据列创建索引, 从而加快该数据列的查询.\n  * **length**：指定该属性所映射数据列的字段的长度\n  * **scale**：指定该属性所映射数据列的小数位数, 对 double, float, decimal 等类型的数据列有效.\n  * **formula**：设置一个 SQL 表达式, Hibernate 将根据它来计算出派生属性的值. \n  * **派生属性**：并不是持久化类的所有属性都直接和表的字段匹配, 持久化类的有些属性的值必须在运行时通过计算才能得出来, 这种属性称为派生属性。\n\n* **派生属性**：并不是持久化类的所有属性都直接和表的字段匹配, 持久化类的有些属性的值必须在运行时通过计算才能得出来, 这种属性称为派生属性。\n\n  * 使用 formula 属性时：\n    * formula=“(sql)” 的英文括号不能少。\n    * Sql 表达式中的列名和表名都应该和数据库对应, 而不是和持久化对象的属性对应。\n    * 如果需要在 formula 属性中使用参数, 这直接使用 where cur.id=id 形式, 其中 id 就是参数，表示外表的id字段的值, 和当前持久化对象的 id 属性对应的列的 id 值将作为参数传入。\n\n  ```xml\n  <!--映射派生属性：nums属性的值为表中数据的数量-->\n  <property name=\"nums\" formula=\"(select count(*))\"/>\n  ```\n\n\n\n# 标识符生成器详解\n\n* Hibernate提供的内置标识符生成器：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210515152901.png)\n\n* increment 标识符生成器：\n\n  * increment 标识符生成器由 Hibernate 以递增的方式为代理主键赋值。\n  * Hibernate 会先读取 NEWS 表中的主键的最大值, 而接下来向 NEWS 表中插入记录时, 就在 max(id) 的基础上递增, 增量为 1。\n  * 适用范围:\n    * 由于 increment 生存标识符机制不依赖于底层数据库系统, 因此它**适合所有的数据库系统**。\n    * 适用于只有**单个 Hibernate 应用进程**访问同一个数据库的场合, 在集群环境下不推荐使用它。\n    * OID 必须为 long, int 或 short 类型, 如果把 OID 定义为 byte 类型, 在运行时会抛出异常。\n\n* identity 标识符生成器：\n\n  * identity 标识符生成器由底层数据库来负责生成标识符, 它要求底层数据库把主键定义为自动增长字段类型\n  * 适用范围:\n    * 由于 identity 生成标识符的机制依赖于底层数据库系统, 因此, 要求底层数据库系统必须**支持自动增长字段类型**. 支持自动增长字段类型的数据库包括: DB2, Mysql, MSSQLServer, Sybase 等\n    * OID 必须为 long, int 或 short 类型, 如果把 OID 定义为 byte 类型, 在运行时会抛出异常\n\n* sequence 标识符生成器：\n\n  * sequence  标识符生成器利用底层数据库提供的序列来生成标识符。\n  * Hibernate 在持久化一个 News 对象时, 先从底层数据库的 news_seq 序列中获得一个唯一的标识号, 再把它作为主键值。\n\n  ```xml\n  <id name=\"id\" column=\"ID\" unsaved-value=\"-1\">\n    <generator class=\"sequence\">\n      <param name=\"sequence\">news_seq</param>\n    </generator>\n  </id>\n  ```\n\n  * 适用范围:\n    * 由于 sequence 生成标识符的机制依赖于底层数据库系统的序列, 因此, 要求底层数据库系统**必须支持序列**. 支持序列的数据库包括: DB2, Oracle 等。\n    * OID 必须为 long, int 或 short 类型, 如果把 OID 定义为 byte 类型, 在运行时会抛出异常。\n\n* hilo 标识符生成器：\n\n  * hilo 标识符生成器由 Hibernate 按照一种 high/low 算法生成标识符, 它从数据库的特定表的字段中获取 high 值。\n  * Hibernate 在持久化一个 News 对象时, 由 Hibernate 负责生成主键值. hilo 标识符生成器在生成标识符时, **需要读取并修改 HI_TABLE 表中的 NEXT_VALUE 值**。\n\n  ```xml\n  <id name=\"id\" column=\"ID\" unsaved-value=\"-1\">\n    <generator class=\"hilo\">\n      <param name=\"table\">Hi_Table</param>\n      <param name=\"column\">next_value</param>\n      <param name=\"max_lo\">10</param>\n    </generator>\n  </id>\n  ```\n\n  * 适用范围:\n    * 由于 hilo 生存标识符机制不依赖于底层数据库系统, 因此它适合所有的数据库系统。\n    * OID 必须为 long, int 或 short 类型, 如果把 OID 定义为 byte 类型, 在运行时会抛出异常。\n\n* native 标识符生成器：\n\n  * native 标识符生成器依据底层数据库对自动生成标识符的支持能力, 来选择使用 identity, sequence 或 hilo 标识符生成器。\n  * 当数据库支持底层生成标识符时，由数据库生成。不支持时使用hilo生成器。\n  * 适用范围:\n    * 由于 native 能根据底层数据库系统的类型, 自动选择合适的标识符生成器, 因此很**适合于跨数据库平台开发。**\n    * OID 必须为 long, int 或 short 类型, 如果把 OID 定义为 byte 类型, 在运行时会抛出异常。\n\n\n\n# 类型之间的映射关系\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-10.png)\n\n* 以下情况下必须显式指定 Hibernate 映射类型:\n  * 一个 Java 类型可能对应多个 Hibernate 映射类型. 例如: 如果持久化类的属性为 java.util.Date 类型, 对应的 Hibernate 映射类型可以是 date, time 或 timestamp. 此时必须根据对应的数据表的字段的 SQL 类型, 来确定 Hibernate 映射类型. 如果字段为 DATE 类型, 那么 Hibernate 映射类型为 date; 如果字段为 TIME 类型, 那么 Hibernate 映射类型为 time; 如果字段为 TIMESTATMP 类型, 那么 Hibernate 映射类型为timestamp。\n\n\n\n## 日期类型的映射\n\n* 在 Java 中, 代表时间和日期的类型包括: java.util.Date 和 java.util.Calendar。\n\n* 此外, 在 JDBC API 中还提供了 3 个扩展了 java.util.Date 类的子类: java.sql.Date, java.sql.Time 和 java.sql.Timestamp, 这三个类分别和标准 SQL 类型中的 DATE, TIME 和 TIMESTAMP 类型对应。\n\n* 在标准 SQL 中, DATE 类型表示日期, TIME  类型表示时间, TIMESTAMP 类型表示时间戳, 同时包含日期和时间信息。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-11.png)\n\n* 总结：\n\n  * 在Java类当中，对于日期类型的数据，建议选用java.util.Date类型。因为它能兼容sql的三种类型。\n  * 在数据库中，日期类型可以自由选择。\n  * 在对象-数据映射文件中。设置的type属性。需要按照上表中的映射类型进行区分。\n\n  ```xml\n  <!--对应对象类型为util.date。字段类型为DATE-->\n  <property name=\"date\" column=\"date\"/>\n  <!--对应对象类型为util.date。字段类型为TIME-->\n  <property name=\"date\" column=\"time\"/>\n  <!--对应对象类型为util.date。字段类型为TIMESTAMP-->\n  <property name=\"date\" column=\"timestamp\"/>\n  ```\n\n\n\n## 大对象类型映射\n\n* 在 Java 中, java.lang.String 可用于表示长字符串(长度超过 255), 字节数组 byte[] 可用于存放图片或文件的二进制数据. 此外, 在 JDBC API 中还提供了 java.sql.Clob 和 java.sql.Blob 类型, 它们分别和标准 SQL 中的 CLOB 和 BLOB 类型对应. CLOB 表示字符串大对象(Character Large Object), BLOB表示二进制对象(Binary Large Object)。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-12.png)\n\n* Mysql 不支持标准 SQL 的 CLOB 类型, 在 Mysql 中, 用 TEXT, MEDIUMTEXT 及 LONGTEXT 类型来表示长度操作 255 的长文本数据。\n\n* 在持久化类中, 二进制大对象可以声明为 byte[] 或 java.sql.Blob 类型; 字符串可以声明为 java.lang.String 或 java.sql.Clob。\n\n* 实际上在 Java 应用程序中处理长度超过 255 的字符串, 使用 java.lang.String 比 java.sql.Clob 更方便。\n\n* 若希望精确映射到数据库的类型。则可以使用sql-type属性。\n\n  ```xml\n  <!--映射大对象-->\n  <property name=\"author\">\n    <!--此处精确映射数据库中context属性为mediumtext-->\n    <column name=\"context\" sql-type=\"mediumtext\"/>\n  </property>\n  ```\n\n\n\n\n## 组成关系映射\n\n* 当有两个类，一个类聚合另一个类时。在数据库表的设计上偏向于只设计成一张表即可。\n\n  * 例如如下图：有两个类Worker,Pay。但在表中只存在一张表。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-13.png)\n\n* 域模型就是描述这种关系的模型： 由程序代码组成, 通过细化持久化类的的粒度可提高代码的可重用性, 简化编程。\n\n* 从数据库方向看：在没有数据冗余的情况下, 应该尽可能**减少表的数目**, 简化表之间的参照关系, 以便提高数据的访问速度。\n\n* Hibernate 把持久化类的属性分为两种: \n\n  * 值(value)类型: 没有 OID, 不能被单独持久化, 生命周期依赖于所属的持久化类的对象的生命周期。比如上面的Pay类。\n  * 实体(entity)类型: 有 OID, 可以被单独持久化, 有独立的生命周期。比如上面的Worker类。\n\n* 此时在对象映射文件中无法使用property标签来正常的映射属性和字段。\n\n* Hibernate 使用 \\<component> 元素来映射**组成关系**, 该元素表名 pay 属性是 Worker 类一个组成部分, 在 Hibernate 中称之为组件。\n\n  ```xml\n  <!--组件映射关系-->\n  <!--说明：有两个类，worker和pay。worker类中有pay类型的属性。这两个类的数据在数据库中只对应一张表-->\n  <class name=\"Worker\" table=\"worker\" schema=\"hibernate\">\n    <id name=\"id\" column=\"id\" >\n      <generator class=\"native\"></generator>\n    </id>\n    <property name=\"name\" column=\"name\"/>\n    <property name=\"age\" column=\"age\"/>\n    <!--对于组件的映射。name：组件的属性名。class：组件的类型-->\n    <component name=\"pay\" class=\"Pay\">\n      <property name=\"monthlyPay\" column=\"monthly_pay\"/>\n      <property name=\"yearPay\" column=\"year_pay\"/>\n      <property name=\"vocationWithPay\" column=\"vocation_with_pay\"/>\n    </component>\n  </class>\n  ```\n\n* component组件的说明：\n\n  * \\<component> 元素来映射组成关系\n    * class：设定组成关系属性的类型, 此处表明 pay 属性为 Pay 类型\n  * \\<parent> 元素指定组件属性所属的整体类\n    * name：整体类在组件类中的属性名\n\n\n\n# 一对多关系\n\n* 在领域模型中, 类与类之间最普遍的关系就是关联关系.\n\n* 在 UML 中, 关联是有方向的.\n\n  * 以 Customer 和 Order 为例： 一个用户能发出多个订单, 而一个订单只能属于一个客户. 从 Order 到 Customer 的关联是多对一关联; 而从 Customer 到 Order 是一对多关联。\n\n* 单向关联\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-14.png)\n\n* 双向关联\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-15.png)\n\n\n\n## 单向n对1\n\n* 单向 n-1 关联只需从 n 的一端可以访问 1 的一端。\n\n* 域模型: 从 Order 到 Customer 的多对一单向关联需要在Order 类中定义一个 Customer 属性, 而在 Customer 类中无需定义存放 Order 对象的集合属性。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-16.png)\n\n  ```java\n  //1的一端\n  public class Customer {\n    private Integer customerId;\n    private String customerName;\n  }\n  //n的一端\n  public class Order {\n    private Integer orderId;\n    private String orderNumber;\n    //保证可以从n访问到1\n    private Customer customer;\n  }\n  ```\n\n* 关系数据模型:ORDERS 表中的 CUSTOMER_ID 参照 CUSTOMER 表的主键。即设计外键。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-17.png)\n\n* 映射文件的编写：\n\n  * 显然无法直接用 property 映射 customer 属性。\n  * Hibernate 使用 \\<many-to-one> 元素来映射多对一关联关系。\n\n  ```xml\n    <class name=\"Order\" table=\"order\" schema=\"hibernate\">\n      <id name=\"id\" column=\"id\">\n        <generator class=\"native\"></generator>\n      </id>\n      <property name=\"orderNumber\" column=\"order_number\"/>\n      <!--对于多以一关联映射。需要在多的一方。类中添加属性。且用many-to-one表示映射-->\n      <many-to-one name=\"customer\" class=\"Customer\" column=\"customer_id\">\n      </many-to-one>\n    </class>\n  ```\n\n*  \\<many-to-one> 元素说明：元素来映射组成关系。\n\n  * name：设定待映射的持久化类的属性的名字。\n  * column：设定和持久化类的属性对应的表的外键。\n  * class：设定待映射的持久化类的属性的类型。\n\n* 测试代码：\n\n  ```java\n  public void n21Test(){\n    /*    Customer customer = new Customer();\n      customer.setCustomerName(\"12\");\n      Order order = new Order();\n      order.setOrderNumber(\"a1\");\n      order.setCustomer(customer);\n      //当先插入1的一端，在插入n的一端。总共是2条插入语句。\n      //当先插入n的一端，在插入1的一端时。会有2条插入语句，外加一条更新语句。\n      //因为在插入多的一端时，无法得知外键的值，因此在少的一端插入后再更新多的一端的数据。\n      session.save(customer);\n      session.save(order);*/\n  \n    /*    //此时的查询只查询了Order的数据，而对于Customer的数据采用的但是懒加载查询\n      Order order1 = (Order) session.get(Order.class, 1);\n      System.out.println(order1);\n      //当使用到customer数据时，才发送查询语句。此时要注意懒加载的异常情况\n      System.out.println(order1.getCustomer().toString());*/\n  \n    //在不设定级联关系时，当n的一端对1的一端有引用时，删除1的一端的数据会抛出ConstraintViolationException异常\n    Customer customer = (Customer) session.get(Customer.class,1);\n    session.delete(customer);\n  }\n  ```\n\n\n\n## 双向1对n\n\n* 双向 1-n 与 双向 n-1 是完全相同的两种情形\n\n* 双向 1-n 需要在 1 的一端可以访问 n 的一端, 反之依然\n\n* 域模型:从 Order 到 Customer 的多对一双向关联需要在Order 类中定义一个 Customer 属性, 而在 Customer 类中需定义存放 Order 对象的集合属性。\n\n  * 只是在1的那端多了个集合。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-18.png)\n\n  ```java\n  //1的一端\n  public class Customer {\n    private Integer customerId;\n    private String customerName;\n    //在1的一端设定一个集合。集合属性建议使用接口类型。集合可以设定一个空实现。\n    private Set<Order> orders = new HashSet<>();\n  }\n  //n的一端\n  public class Order {\n    private Integer orderId;\n    private String orderNumber;\n    private Customer customer;\n  }\n  ```\n\n* 关系数据模型:ORDERS 表中的 CUSTOMER_ID 参照 CUSTOMER 表的主键。和单向一对多的相同。\n\n* 类中集合属性的说明：\n\n  * 当 Session 从数据库中加载 Java 集合时, 创建的是 Hibernate 内置集合类的实例, 因此在持久化类中定义集合属性时必须把属性声明为 **Java 接口类型**。\n    * Hibernate 的内置集合类具有集合代理功能, **支持延迟检索策略**。\n    * 事实上, Hibernate 的内置集合类封装了 JDK 中的集合类, 这使得 Hibernate 能够对缓存中的集合对象进行脏检查, 按照集合对象的状态来同步更新数据库。\n  * 在定义集合属性时, 通常把它**初始化为集合实现类**的一个实例. 这样可以提高程序的**健壮性**, **避免应用程序访问取值为 null 的集合的方法抛出 NullPointerException**。\n\n* 映射文件的编写：\n\n  * Hibernate 使用 \\<set> 元素来映射 set 类型的属性。\n\n  ```xml\n  <class name=\"Customer\" table=\"customers\" schema=\"hibernate\">\n    <id name=\"customerId\" column=\"customer_id\">\n      <generator class=\"native\"></generator>\n    </id>\n    <property name=\"customerName\" column=\"customer_name\"/>\n    <!--集合属性的映射。首先order需要有多对一的映射。-->\n    <!-- inverse=\"false\"：表示customer为被动方，所以由Order来维护数据 -->\n    <set name=\"orders\" table=\"orders\" inverse=\"false\">\n      <!--这个键是Order表中的哪个外键的字段名-->\n      <key column=\"customer_id\"></key>\n      <!--从customer端来看，是1到多的方向，因此要指定多的类型-->\n      <one-to-many class=\"Order\"></one-to-many>\n    </set>\n  </class>\n  <class name=\"Order\" table=\"orders\" schema=\"hibernate\">\n    <id name=\"orderId\" column=\"order_id\">\n      <generator class=\"native\"></generator>\n    </id>\n    <property name=\"orderNumber\" column=\"order_number\"/>\n    <!--对于多以一关联映射。需要在多的一方。类中添加属性。且用many-to-one表示映射-->\n    <many-to-one name=\"customer\" class=\"Customer\" column=\"customer_id\">\n    </many-to-one>\n  </class>\n  ```\n\n* 标签说明：\n\n  * \\<set> 元素来映射持久化类的 set 类型的属性\n    * name: 设定待映射的持久化类的属性的\n  * \\<key> 元素设定与所关联的持久化类对应的表的外键\n    * column: 指定关联表的外键名\n  * \\<one-to-many> 元素设定集合属性中所关联的持久化类\n    * class: 指定关联的持久化类的类名\n\n* \\<set>元素的inverse属性：\n\n  * 在hibernate中通过对 inverse 属性的来决定是由双向关联的哪一方来维护表和表之间的关系。\n    * 设置inverse = false 的为主动方，设置inverse = true 的为被动方。\n    * 最后是由主动方负责维护关联关系。\n  * 在**没有设置 inverse的情况**下，父子两边都维护父子关系 。\n  * 在 1-n 关系中，将 n 方设为主控方将有助于性能改善(如果要国家元首记住全国人民的名字，不是太可能，但要让全国人民知道国家元首，就容易的多)\n  * 在 1-N 关系中，若将 1 方设为主控方\n    * 会额外多出 update 语句。\n    * 插入数据时无法同时插入外键列，因而无法为外键列添加非空约束。\n\n* \\<set>元素的cascade属性：\n\n  * cascade：意为级联。\n  * 在对象 – 关系映射文件中, 用于映射持久化类之间关联关系的元素, \\<set>, \\<many-to-one> 和 \\<one-to-one> 都有一个 cascade 属性, 它用于指定如何操纵与当前对象关联的其他对象。\n  * 举例：设定属性为delete时，删除一个customer对象，这个对象中还含有两个order属性。则在删除customer对象的数据时，也会删除对应的order对象的数据。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517135139.png)\n\n* 在数据库中对集合排序：\n\n  * \\<set> 元素有一个 **order-by 属性**, 如果设置了该属性, 当 Hibernate 通过 select 语句到数据库中检索集合对象时, 利用 order by 子句进行排序。\n  * order-by 属性中还可以加入 SQL 函数。\n\n  ```xml\n  <!--集合属性的映射。首先order需要有多对一的映射。-->\n  <!-- inverse=\"false\"：表示customer为被动方，所以由Order来维护数据 -->\n  <!--cascade=\"delete\"：表示删除当前对象时，和当前对象相关的数据对象也会被删除。即级联删除-->\n  <!--order-by=\"order_number\"：表示根据order_number排序。注意order_number是表的字段名-->\n  <set name=\"orders\" table=\"orders\" inverse=\"false\" cascade=\"delete\" order-by=\"order_number\">\n    <!--这个键是Order表中的哪个外键的字段名-->\n    <key column=\"customer_id\"></key>\n    <!--从customer端来看，是1到多的方向，因此要指定多的类型-->\n    <one-to-many class=\"Order\"></one-to-many>\n  </set>\n  ```\n\n\n\n# 一对一关系\n\n* 域模型：一个部门对应一个经理，一个经理对应一个部门。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-19.png)\n\n* 关系数据模型：有两种方式\n\n  * 按照外键映射：通过外键设置关联，但设定外键为唯一约束。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-20.png)\n\n  * 按照主键映射：\n\n  ![]()\n\n* 按照外键映射：\n\n  * 对于基于外键的1-1关联，其外键可以存放在**任意一边**，在需要**存放外键一端**，增加**many-to-one元素**。为many-to-one元素增加**unique=“true”** 属性来表示为1-1关联。\n  * 另一端需要使用**one-to-one元素**，该元素使用 **property-ref 属性指定使用被关联实体主键以外的字段作为关联字段**。\n  * 测试代码\n\n  ```java\n  public void oneToOne(){\n    /*    Department department = new Department();\n      department.setDepName(\"dep-A\");\n      Manager manager = new Manager();\n      manager.setManName(\"man-A\");\n      manager.setManAge(12);\n      manager.setDepartment(department);\n      department.setManager(manager);\n  \n      //建议先保存没有外键列的数据对象。这样可以减少sql语句的发送\n      session.save(manager);\n      session.save(department);*/\n  \n    /*    //查询时，对于关联属性会使用懒加载机制。\n      Department department = (Department) session.get(Department.class, 1);\n      System.out.println(department.getDepName());\n      //懒加载的查询语句有问题：\n        //首先懒加载使用是左外连接。问题是做连接条件是dep的id和man的id进行连接。这是错误的。\n      //解决方法是，在one-to-one链接时，添加property-ref属性\n      Manager manager = department.getManager();\n      System.out.println(manager.getManName());*/\n    //在查询没有外键的对象时，如何获取到关联对象的数据呢？\n    //答案：在查询时直接使用左外连接查询关联对象数据。而不使用懒加载机制\n    Manager manager = (Manager) session.get(Manager.class, 1);\n  }\n  ```\n\n  ```xml\n  <class name=\"Department\" table=\"departments\">\n    <id name=\"depId\" column=\"DEP_ID\">\n      <generator class=\"native\"></generator>\n    </id>\n    <property name=\"depName\" column=\"DEP_NAME\">\n    </property>\n    <!--1对1的关联映射：首先使用many-to-one在一个表中设定一个外键。外键unique属性为true-->\n    <many-to-one name=\"manager\" column=\"MANAGER_ID\" class=\"Manager\" unique=\"true\"/>\n  </class>\n  <class name=\"Manager\" table=\"MANAGERS\">\n    <id name=\"manId\" column=\"MAN_ID\">\n      <generator class=\"native\"></generator>\n    </id>\n    <property name=\"manAge\" column=\"MAN_AGE\">\n    </property>\n    <property name=\"manName\" column=\"MAN_NAME\">\n    </property>\n    <!--1对1映射：由于已经设置外键了，因此此处只需使用one-to-one关联即可-->\n    <!--property-ref=\"manager\"：该属性指定使用哪个字段进行关联字段。-->\n    <one-to-one name=\"department\" class=\"Department\" property-ref=\"manager\"/>\n  </class>\n  ```\n\n* 按照主键映射：\n\n  * 基于主键的映射策略:指一端的**主键生成器使用 foreign 策略**,表明根据”对方”的主键来生成自己的主键，自己并不能独立生成主键. **\\<param> 子元素**指定使用当前持久化类的哪个属性作为 “对方”。\n  * 采用foreign主键生成器策略的一端增加 one-to-one 元素映射关联属性，其one-to-one属性还应增加 **constrained=“true” 属性**；另一端增加one-to-one元素映射关联属性。\n  * constrained(约束)：指定为当前持久化类对应的数据库表的**主键添加一个外键约束**，引用被关联的对象(“对方”)所对应的数据库表主键。\n  * 测试代码：\n\n  ```xml\n  <class name=\"Department\" table=\"departments\">\n    <id name=\"depId\" column=\"DEP_ID\">\n      <!--注意此处-->\n      <generator class=\"foreign\">\n        <param name=\"property\">manager</param>\n      </generator>\n    </id>\n    <property name=\"depName\" column=\"DEP_NAME\">\n    </property>\n    <!--1对1映射。不设中主键。注意主键生成策略。和constrained属性-->\n    <one-to-one name=\"manager\" class=\"Manager\" constrained=\"true\"/>\n  </class>\n  <class name=\"Manager\" table=\"MANAGERS\">\n    <id name=\"manId\" column=\"MAN_ID\">\n      <generator class=\"native\"></generator>\n    </id>\n    <property name=\"manAge\" column=\"MAN_AGE\">\n    </property>\n    <property name=\"manName\" column=\"MAN_NAME\">\n    </property>\n    <!--1对1映射。不设中主键-->\n    <one-to-one name=\"department\" class=\"Department\"/>\n  </class>\n  ```\n\n\n\n# 多对多关系\n\n\n\n## 单向n对n\n\n* 域模型：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655.png)\n\n* 关系数据模型：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-1.png)\n\n* 映射文件配置：\n\n  ```xml\n  <class name=\"Category\" table=\"categorys\">\n    <id name=\"cgyId\" column=\"cgy_id\">\n      <generator class=\"native\"></generator>\n    </id>\n    <property name=\"cgyName\" column=\"cgy_name\"/>\n    <!--对集合属性进行映射。映射多对多关系-->\n    <!--table：指定中间表的表名-->\n    <set name=\"items\" table=\"categorys_items\">\n      <!--指定一个字段作为主键。这个字段默认对应当前类的id-->\n      <key column=\"category_id\"></key>\n      <!--指定集合的属性，以及在中间表对应的字段名。字段值对应集合的id值-->\n      <!--指定集合中的持久化类在中间表的外键列的名称-->\n      <many-to-many class=\"Item\" column=\"item_id\"></many-to-many>\n    </set>\n  </class>\n  <class name=\"Item\" table=\"items\">\n    <id name=\"itId\" column=\"it_id\">\n      <generator class=\"native\"></generator>\n    </id>\n    <property name=\"itName\" column=\"it_name\"/>\n  </class>\n  ```\n\n* 说明：\n\n  * n-n 的关联必须使用**连接表**。一个类设定集合即可。\n  * 与 1-n 映射类似，必须为 set 集合元素添加 key 子元素，指定 CATEGORIES_ITEMS 表(中间表)中参照 CATEGORIES 表的外键为 CATEGORIY_ID。\n  * 与 1-n 关联映射不同的是，建立 n-n 关联时, 集合中的元素使用 many-to-many. many-to-many 子元素的 class 属性指定 items 集合中存放的是 Item 对象, column 属性指定  CATEGORIES_ITEMS 表中参照 ITEMS 表的外键为 ITEM_ID。\n\n* 测试代码：\n\n  ```java\n  public void nToNTest(){\n    /*    Category category1 = new Category();\n      Category category2 = new Category();\n      category1.setCgyName(\"cat-A\");\n      category2.setCgyName(\"cat-B\");\n  \n      Item item1 = new Item();\n      Item item2 = new Item();\n      item1.setItName(\"it-A\");\n      item2.setItName(\"it-B\");\n      //设定关联关系\n      category1.getItems().add(item1);\n      category1.getItems().add(item2);\n      category2.getItems().add(item1);\n      category2.getItems().add(item2);\n  \n      //执行了8条插入语句，categorys表两条，items表两条，中间表4条\n      session.save(category1);\n      session.save(category2);\n      session.save(item1);\n      session.save(item2);*/\n  \n    Category category = (Category) session.get(Category.class,1);\n    System.out.println(category.getCgyName());\n    //对于集合属性的数据采用了懒加载机制。在查询时使用inner join连接查询\n    Set<Item> items = category.getItems();\n    System.out.println(items.size());\n  }\n  ```\n\n\n\n## 双向n对n\n\n* 域模型和关系数据模型与单向的n对n的基本相同。不同在于Item类中有一个set集合。\n\n* 映射文件配置：不同之处：Category映射文件一模一样。Item映射文件加了一些。\n\n  ```xml\n  <class name=\"Item\" table=\"items\">\n    <id name=\"itId\" column=\"it_id\">\n      <generator class=\"native\"></generator>\n    </id>\n    <property name=\"itName\" column=\"it_name\"/>\n    <!--注意table的值要和另一个映射文件的值相同。即使用同一个中间表。-->\n    <!--inverse=\"true\"属性必须写。只能是一个持久化类维护中间表-->\n    <set name=\"categories\" table=\"categorys_items\" inverse=\"true\">\n      <!--这里的字段名也要和另一个映射文件的字段名一一对应。-->\n      <key column=\"item_id\"></key>\n      <many-to-many column=\"category_id\" class=\"Category\"/>\n    </set>\n  </class>\n  ```\n\n* 说明：\n\n  * 双向 n-n 关联需要**两端都使用集合属性**。双向n-n关联必须使**用连接表**。\n  * 集合属性应增加 key 子元素用以映射外键列, 集合元素里还应增加many-to-many子元素关联实体类。\n  * 在双向 n-n 关联的两边**都需指定连接表的表名及外键列的列名**。两个集合元素 set 的 table 元素的值必须指定，而且**必须相同**。\n  * set元素的两个子元素：key 和 many-to-many 都必须指定 column 属性，其中，key 和 many-to-many 分别指定本持久化类和关联类在连接表中的外键列名，因此两边的 key 与 many-to-many 的**column属性交叉相同**。\n  * 也就是说，一边的set元素的key的 cloumn值为a,many-to-many 的 column 为b；则另一边的 set 元素的 key 的 column 值 b,many-to-many的 column 值为 a。\n  * 对于双向 n-n 关联, 必须把其中一端的 **inverse 设置为 true**, 否则两端都维护关联关系可能**会造成主键冲突**。\n\n\n\n# 对象继承关系映射\n\n* 对于面向对象的程序设计语言而言，继承和多态是两个最基本的概念。\n\n* Hibernate 的继承映射可以理解持久化类之间的继承关系。\n\n* 例如：人和学生之间的关系。学生继承了人，可以认为学生是一个特殊的人，如果对人进行查询，学生的实例也将被得到。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-2.png)\n\n* Hibernate支持三种继承映射策略：\n\n  * 使用 **subclass** 进行映射：将域模型中的每一个实体对象映射到一个独立的表中，也就是说不用在关系数据模型中考虑域模型中的继承关系和多态。 \n  * 使用 **joined-subclass** 进行映射： 对于继承关系中的子类使用同一个表，这就需要在数据库表中增加额外的区分子类类型的字段。 \n  * 使用  **union-subclass** 进行映射：域模型中的每个类映射到一个表，通过关系数据模型中的外键来描述表之间的继承关系。这也就相当于按照域模型的结构来建立数据库中的表，并通过外键来建立表之间的继承关系。\n\n\n\n## subclass 进行映射\n\n* 采用 subclass 的继承映射可以实现对于继承关系中**父类和子类使用同一张表**。\n\n* 因为父类和子类的实例全部保存在同一个表中，因此需要在该表内增加一列，使用该列来**区分每行记录到低是哪个类的实例**----这个列被称为辨别者列(discriminator)。\n\n* 在这种映射策略下，使用 subclass 来映射子类，使用 class 或 subclass 的 **discriminator-value 属性指定辨别者列的值**。\n\n* **所有子类定义的字段都不能有非空约束**。如果为那些字段添加非空约束，那么父类的实例在那些列其实并没有值，这将引起数据库完整性冲突，导致父类的实例无法保存到数据库中。\n\n* 关系数据模型：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-3.png)\n\n* 映射文件：只需要父类一个映射文件即可。\n\n  ```xml\n  <class name=\"Person\" table=\"persons\" discriminator-value=\"person\">\n    <id name=\"perId\" column=\"per_id\">\n      <generator class=\"native\"></generator>\n    </id>\n    <!--添加辨别者列字段。并设定两个类的辨别者标识-->\n    <discriminator column=\"type\" />\n  \n    <property name=\"perName\" column=\"per_name\"/>\n    <property name=\"perAge\" column=\"per_age\"/>\n    <!--使用映射继承关系-->\n    <subclass name=\"Student\" discriminator-value=\"student\">\n      <property name=\"school\" column=\"school\"/>\n    </subclass>\n  </class>\n  ```\n\n* 测试代码：\n\n  ```java\n  public void subclassTest(){\n    /*    Person person = new Person();\n      person.setPerName(\"per-A\");\n      person.setPerAge(10);\n  \n      Student student = new Student();\n      student.setPerName(\"stu-A\");\n      student.setPerAge(18);\n      student.setSchool(\"请阿虎\");\n      //SQL语句：insert into persons (per_name, per_age, type) values (?, ?, 'person')\n      session.save(person);\n      //SQL语句：insert into persons (per_name, per_age, school, type) values (?, ?, ?, 'student')\n      session.save(student);*/\n  \n    //from Peoson：表示查询Person类型数据。\n    List<Person> persons = session.createQuery(\"FROM Person\").list();\n    System.out.println(persons.size());\n    //from Student：表示查询Student类型数据。\n    List<Student> students = session.createQuery(\"FROM Student\").list();\n    System.out.println(students.size());\n  }\n  ```\n\n* 总结：\n\n  * 对于父类记录，插入只需要插入一张表中，查询也只需要查询一张表。\n  * 对于子类记录，插入只需要插入一张表中，查询也只需要查询一张表。\n\n* 缺点：\n\n  * 需要添加辨别者列。\n  * 子类的数据可以设置为空。\n  * 若几继承关系很深的话，表的字段数量会变很大。\n\n\n\n##  joined-subclass 进行映射\n\n* 采用 joined-subclass 元素的继承映射可以实现**每个子类一张表**.\n\n* 采用这种映射策略时，父类实例保存在父类表中，**子类实例由父类表和子类表共同存储**。因为子类实例也是一个特殊的父类实例，因此必然也包含了父类实例的属性。于是将子类和父类共有的属性保存在父类表中，子类增加的属性，则保存在子类表中。\n\n* 在这种映射策略下，无须使用鉴别者列，但需要为**每个子类使用 key 元素映射共有主键**。\n\n* **子类增加的属性可以添加非空约束**。因为子类的属性和父类的属性没有保存在同一个表中\n\n* 关系数据模型:\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-4.png)\n\n* 映射文件：\n\n  ```xml\n  <class name=\"Person\" table=\"persons\">\n    <id name=\"perId\" column=\"per_id\">\n      <generator class=\"native\"></generator>\n    </id>\n    <property name=\"perName\" column=\"per_name\"/>\n    <property name=\"perAge\" column=\"per_age\"/>\n    <!--使用joined-subclass映射继承关系-->\n    <joined-subclass name=\"Student\" table=\"students\">\n      <!--column对应的字段值是父类的主键的值-->\n      <key column=\"person_id\"></key>\n      <property name=\"school\" column=\"school\"/>\n    </joined-subclass>\n  </class>\n  ```\n\n* 测试代码：\n\n  ```java\n  public void joinedSubclassTest(){\n    /*    Person person = new Person();\n      person.setPerName(\"per-A\");\n      person.setPerAge(10);\n  \n      Student student = new Student();\n      student.setPerName(\"stu-A\");\n      student.setPerAge(18);\n      student.setSchool(\"请阿虎\");\n      //执行一条insert语句\n      session.save(person);\n      //执行两条insert语句\n      session.save(student);*/\n  \n    //查询两张表。使用左外连接\n    List<Person> persons = session.createQuery(\"FROM Person\").list();\n    System.out.println(persons.size());\n    //查询两张表。使用内连接\n    List<Student> students = session.createQuery(\"FROM Student\").list();\n    System.out.println(students.size());\n  }\n  ```\n\n* 总结：\n\n  * 查询时：父类使用左外连接查询两张表，子类使用内连接查询两张表。\n  * 插入时：父类只插入一张表中，子类需要插入两张表。\n\n* 优点：\n\n  * 不需要使用辨别者字段。\n  * 子类可以添加非空约束。\n  * 每个类一个表，没有冗余的字段。\n\n\n\n##  union-subclass 进行映射\n\n* 采用 union-subclass 元素可以实现将**每一个实体对象映射到一个独立的表中**。\n\n* **子类增加的属性可以有非空约束** --- 即父类实例的数据保存在父表中，而子类实例的数据保存在子类表中。\n\n* 子类实例的数据**仅保存在子类表中**, 而在父类表中没有任何记录。\n\n* 在这种映射策略下，**子类表的字段会比父类表的映射字段要多**,因为子类表的字段等于父类表的字段、加子类增加属性的总和。\n\n* 在这种映射策略下，既不需要使用鉴别者列，也无须使用 key 元素来映射共有主键。\n\n* 使用 union-subclass 映射策略是**不可使用 identity 的主键生成策略**, 因为同一类继承层次中所有实体类都需要使用同一个主键种子, 即多个持久化实体对应的记录的**主键应该是连续的**. 受此影响, **也不该使用 native 主键生成策略**, 因为 native 会根据数据库来选择使用 identity 或 sequence。\n\n* 关系数据模型：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-5.png)\n\n* 映射文件：\n\n  ```xml\n  <class name=\"Person\" table=\"persons\">\n    <id name=\"perId\" column=\"per_id\">\n      <!--注意这里的主键生成策略-->\n      <generator class=\"increment\"></generator>\n    </id>\n    <property name=\"perName\" column=\"per_name\"/>\n    <property name=\"perAge\" column=\"per_age\"/>\n    <!--使用union-subclass映射继承关系-->\n    <union-subclass name=\"Student\" table=\"students\">\n      <property name=\"school\" column=\"school\"/>\n    </union-subclass>\n  </class>\n  ```\n\n* 测试代码：\n\n  ```java\n  public void unionSubclassTest(){\n    /*    Person person = new Person();\n      person.setPerName(\"per-A\");\n      person.setPerAge(10);\n  \n      Student student = new Student();\n      student.setPerName(\"stu-A\");\n      student.setPerAge(18);\n      student.setSchool(\"请阿虎\");\n      //会先执行一条查询最大id的语句\n      //执行一条insert语句\n      session.save(person);\n      //执行一条insert语句\n      session.save(student);*/\n  \n    /*    //查询两张表。先内连接查询两张表，然后在查询连接后的表\n      List<Person> persons = session.createQuery(\"FROM Person\").list();\n      System.out.println(persons.size());\n      //查询一张表。\n      List<Student> students = session.createQuery(\"FROM Student\").list();\n      System.out.println(students.size());*/\n  \n    //更新父类的数据时。会先查询所有的父类信息，然后依次更新。\n    //更新语句是针对数据对象的更新。是HQL语句\n    String hql = \"update Person p set p.perAge = 20\";\n    session.createQuery(hql).executeUpdate();\n  }\n  ```\n\n* 总结：\n\n  * 插入时：首先会查询最大的id。然后父类只会插入一张表，子类也是。\n  * 查询时：父类会进行内连接查询然后再查询。子类只会查询一张表。\n  * 更新时：父类会先查询对象数据，然后再依次更新。\n\n* 优点：\n\n  * 没有辨别者字段。\n  * 子类可以添加非空约束。\n\n* 缺点：\n\n  * 存在冗余的字段。因为子类的表和父类的表存在相同的字段。\n  * 更新的效率较低。\n\n\n\n## 三种继承映射方式的比较\n\n* 推荐使用joined-subclass和union-class的方式。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-6.png)\n\n\n\n# 检索策略\n\n* 检索数据时的 2 个问题：\n  * **不浪费内存**：当 Hibernate 从数据库中加载 Customer 对象时, 如果同时加载所有关联的 Order 对象, 而程序实际上仅仅需要访问 Customer 对象, 那么这些关联的 Order 对象就白白浪费了许多内存。\n  * **更高的查询效率**：发送尽可能少的 SQL 语句。\n\n\n\n## 类级别的检索策略\n\n* 类级别可选的检索策略包括立即检索和延迟检索, 默认为延迟检索\n  * 立即检索: 立即加载检索方法指定的对象。\n  * 延迟检索: 延迟加载检索方法指定的对象。在使用具体的属性时，再进行加载。\n* 类级别的检索策略可以通过 \\<class> 元素的 lazy 属性进行设置\n* 如果程序加载一个对象的目的是为了访问它的属性, 可以采取立即检索. \n* 如果程序加载一个持久化对象的目的是仅仅为了获得它的引用, 可以采用延迟检索。**注意出现懒加载异常！**\n* 无论 \\<class> 元素的 lazy 属性是 true 还是 false, Session 的 get() 方法及 Query 的 list() 方法在**类级别总是使用立即检索策略**。\n* 若 \\<class> 元素的 lazy 属性为 true 或取默认值, Session 的 **load() 方法**不会执行查询数据表的 SELECT 语句, 仅返回代理类对象的实例, 该代理类实例有如下特征:\n  * 由 Hibernate 在运行时采用 CGLIB 工具动态生成。\n  * Hibernate 创建代理类实例时, 仅初始化**其 OID 属性**。\n  * 在应用程序第一次访问代理类实例的非 OID 属性时, Hibernate 会初始化代理类实例。\n\n\n\n## 一对多和多对多的检索策略\n\n* 在映射文件中, 用 \\<set> 元素来配置一对多关联及多对多关联关系. \\<set> 元素有 lazy 和 fetch 属性\n\n  * lazy: 主要决定 orders 集合被**初始化的时机**。 即到底是在加载 Customer 对象时就被初始化, 还是在程序访问 orders 集合时被初始化。\n  * fetch: 取值为 “select” 或 “subselect” 时, 决定**初始化 orders 的查询语句的形式**;  若取值为”join”, 则决定 orders 集合被初始化的时机。\n  * 若把 fetch 设置为 “join”, lazy 属性将被忽略。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-7.png)\n\n* \\<set> 元素的 batch-size 属性：用来为延迟检索策略或立即检索策略**设定批量检索的数量**. 批量检索能减少 SELECT 语句的数目, 提高延迟检索或立即检索的运行性能。\n\n  * batch-size 属性也可以设定在\\<class>元素中。不过要设置在1的那一端。\n\n  ```xml\n  <!--batch-size=\"5\"：表示初始化集合的数据时，一次性初始5条数据-->\n  <set name=\"items\" table=\"categorys_items\" batch-size=\"5\"></set>\n  ```\n\n* 在延迟检索(**lazy 属性值为 true**) 集合属性时, Hibernate 在以下情况下**初始化集合代理类实例** \n\n  * 应用程序第一次访问集合属性: iterator(), size(), isEmpty(), contains() 等方法。\n  * 通过 Hibernate.initialize() 静态方法显式初始化。\n\n* 增强延迟检索(**lazy 属性为 extra**): 与 lazy=“true” 类似. 主要区别是增强延迟检索策略能进一步延迟 Customer 对象的 orders 集合代理实例的初始化时机：\n\n  * 当程序第一次访问 orders 属性的 iterator() 方法时, 会导致 orders 集合代理类实例的初始化\n  * 当程序第一次访问 order 属性的 size(), contains() 和 isEmpty() 方法时, Hibernate 不会初始化 orders 集合类的实例, 仅**通过特定的 select 语句查询必要的信息**, 不会检索所有的 Order 对象。\n\n* 当 fetch 属性为 “**select**” 时：\n\n  * 集合的数据是使用一个初始化一个。\n\n* 当 fetch 属性为 “**subselect**” 时：\n\n  * 假定 Session 缓存中有 n 个 orders 集合代理类实例没有被初始化, Hibernate 能够通过带子查询的 select 语句, 来**批量初始化 n 个 orders 集合代理类实例**。\n  * **batch-size 属性将被忽略**。\n  * 子查询中的 select 语句为通过查询CUSTOMERS 表 OID进而查询集合数据的 SELECT 语句。\n\n* 当 fetch 属性为 “**join**” 时：\n\n  * 检索 Customer 对象时, 会**采用迫切左外连接**(通过左外连接加载与检索指定的对象关联的对象)**策略来检索所有关联的 Order 对象**。\n  * **lazy 属性将被忽略**。\n  * <font color=\"red\">但是当使用Query 的list() 方法会忽略映射文件中配置的迫切左外连接检索策略, 而依旧采用延迟加载策略。</font>\n\n\n\n## 多对一和一对一的检索策略\n\n* 和 \\<set> 一样, \\<many-to-one> 元素也有一个 lazy 属性和 fetch 属性。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-8.png)\n\n  * 若 fetch 属性设为 join, 那么 lazy 属性被忽略。\n  * 迫切左外连接检索策略的优点在于比立即检索策略使用的 SELECT 语句更少。\n  * 无代理延迟检索需要增强持久化类的字节码才能实现。\n\n* Query 的 **list 方法会忽略**映射文件配置的**迫切左外连接**检索策略, 而采用延迟检索策略。\n\n* 如果在关联级别使用了延迟加载或立即加载检索策略, 可以**设定批量检索的大小**, 以帮助提高延迟检索或立即检索的运行性能。\n\n* Hibernate 允许在应用程序中覆盖映射文件中设定的检索策略。\n\n\n\n## 检索策略总结\n\n* 类级别和关联级别可选的检索策略及默认的检索策略：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-9.png)\n\n* 3 种检索策略的运行机制：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-10.png)\n\n* 映射文件中用于设定检索策略的几个属性：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-11.png)\n\n* 比较 Hibernate 的三种检索策略：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-12.png)\n\n\n\n# 检索方式\n\n* Hibernate 提供了以下几种检索对象的方式：\n  * 导航对象图检索方式:  根据已经加载的对象导航到其他对象。\n  * OID 检索方式:  按照对象的 OID 来检索对象。\n  * **HQL 检索方式**: 使用**面向对象**的 HQL 查询语言。\n  * **QBC 检索方式**: 使用 QBC(Query By Criteria) API 来检索对象. 这种 API 封装了**基于字符串形式的查询语句**, 提供了更加面向对象的查询接口。\n  * 本地 SQL 检索方式: 使用本地数据库的 SQL 查询语句。\n\n\n\n## HQL检索方式\n\n* HQL(Hibernate Query Language) 是**面向对象的查询语言**, 它和 SQL 查询语言有些相似。\n\n* 在Hibernate 提供的各种检索方式中, HQL 是使用最广的一种检索方式. 它有如下功能:\n\n  * 在查询语句中设定各种查询条件\n  * 支持投影查询, 即仅检索出对象的部分属性。\n  * 支持分页查询。\n  * 支持连接查询。\n  * 支持分组查询, 允许使用 HAVING 和 GROUP BY 关键字。\n  * 提供内置聚集函数, 如 sum(), min() 和 max()。\n  * 支持子查询。\n  * 支持动态绑定参数。\n  * 能够调用用户定义的 SQL 函数或标准的 SQL 函数。\n\n* HQL 检索方式包括以下步骤:\n\n  * 通过 Session 的 createQuery() 方法创建一个 Query 对象, 它包括一个 HQL 查询语句。HQL 查询语句中可以包含命名参数。\n  * 动态绑定参数。\n  * 调用 Query 相关方法执行查询语句。\n\n* Qurey 接口**支持方法链编程风格**, 它的 setXxx() 方法返回自身实例, 而不是 void 类型。\n\n* HQL vs SQL：\n\n  * HQL 查询语句是面向对象的, **Hibernate 负责解析 HQL 查询语句**, 然后根据对象-关系映射文件中的映射信息, **把 HQL 查询语句翻译成相应的 SQL 语句**. HQL 查询语句中的**主体是域模型中的类及类的属性**。\n  * SQL 查询语句是与关系数据库绑定在一起的. SQL 查询语句中的主体是数据库表及表的字段。\n\n* 绑定参数：\n\n  * Hibernate 的参数绑定机制**依赖于 JDBC API 中的 PreparedStatement 的预定义 SQL** 语句功能。\n\n  * HQL 的参数绑定由两种形式:\n\n    * 按**参数名字**绑定: 在 HQL 查询语句中定义命名参数, 命名参数以 “:” 开头。\n    * 按**参数位置**绑定: 在 HQL 查询语句中用 “?” 来定义参数位置\n\n  * 相关方法:\n\n    * setEntity(): 把参数与一个持久化类绑定。\n    * setParameter(): 绑定任意类型的参数. 该方法的第三个参数显式指定 Hibernate 映射类型。\n\n  * 参数的类型：\n\n    * 基本数据类型。\n    * 自定义类型的对象。\n\n  * 实例：\n\n    * 按**参数名字**绑定\n\n    ```java\n    public void testHQL2(){\n      //1.创建Query对象\n      //设定了两个参数名sal和eml\n      String sql = \"from Employee e where e.salary > :sal and e.email LIKE :eml\";\n      Query query = session.createQuery(sql);\n      //2.绑定参数\n      //通过链式操作绑定参数。\n      query.setFloat(\"sal\",6000)\n        .setString(\"eml\",\"%qq%\");\n      //3.执行查询\n      List<Employee> employees = query.list();\n      System.out.println(employees.size());\n    }\n    ```\n\n    * 按**参数位置**绑定\n\n    ```java\n    public void testHQL1(){\n      //1.创建Query对象\n      //说明：查询Employee类的数据对象，当salary属性大于?且email像?并且dept等于?时。结果按照salary排序。\n      String sql = \"from Employee e where e.salary > ? and e.email LIKE ? AND e.dept = ?\" +\n        \"ORDER BY e.salary\";\n      Query query = session.createQuery(sql);\n      //2.绑定参数\n      Department dep =  new Department();\n      dep.setId(10);\n      //通过链式操作绑定参数。第三个绑定的是对象类型的参数\n      query.setFloat(0,6000)\n        .setString(1,\"%qq%\")\n        .setEntity(2,dep);\n      //3.执行查询\n      List<Employee> employees = query.list();\n      System.out.println(employees.size());\n    }\n    ```\n\n* HQL 采用 ORDER BY 关键字对查询结果排序。\n\n\n\n## HQL检索的其他方式\n\n* 分页查询：\n\n  * setFirstResult(int firstResult): 设定**从哪一个对象开始检索**, 参数 firstResult 表示这个对象在查询结果中的索引位置。\n    * 索引位置的起始值为 0。默认情况下, Query 从查询结果中的第一个对象开始检索。\n  * setMaxResults(int maxResults): 设定一次**最多检索出的对象的数目**。\n    * 在默认情况下, Query 和 Criteria 接口检索出查询结果中所有的对象。\n\n  ```java\n  public void testPaging(){\n    String hql = \"FROM Employee\";\n    Query query = session.createQuery(hql);\n    //pageNo：第几页。pageSize：一页多少条数据\n    int pageNo = 1;\n    int pageSize = 5;\n  \n    List<Employee> emps =\n      query.setFirstResult((pageNo - 1) * pageSize)\n      .setMaxResults(pageSize)\n      .list();\n    System.out.println(emps);\n  }\n  ```\n\n* 命名查询语句：\n\n  * Hibernate 允许在映射文件中定义字符串形式的查询语句。\n  * \\<query> 元素用于定义一个 HQL 查询语句, 它和 \\<class> 元素并列。\n\n  ```xml\n  <!--自定义查询语句。CDATA格式可以转义特殊符号-->\n  <query name=\"salaryEmps\"><![CDATA[FROM Employee e WHERE e.salary > :minSal AND e.salary < :maxSal]]></query>\n  ```\n\n  * 在程序中通过 Session 的 getNamedQuery() 方法获取查询语句对应的 Query 对象。\n\n  ```java\n  public void testNameQuery(){\n    //获取映射文件中的sql元素的查询语句\n    Query query = session.getNamedQuery(\"salaryEmps\");\n  \n    List<Employee> emps = query.setFloat(\"minSal\", 5000)\n      .setFloat(\"maxSal\", 10000)\n      .list();\n  \n    System.out.println(emps.size());\n  }\n  ```\n\n* 投影查询：\n\n  * 投影查询: 查询结果仅包含实体的部分属性. 通过 SELECT 关键字实现。\n  * Query 的 list() 方法返回的集合中包含的是数组类型的元素, 每个对象数组代表查询结果的一条记录。\n  * 可以在持久化类中定义一个对象的构造器来包装投影查询返回的记录, 使程序代码能完全运用面向对象的语义来访问查询结果集。\n  * 可以通过 DISTINCT 关键字来保证查询结果不会返回重复元素。\n  * 默认情况查询返回数组：\n\n  ```java\n  public void testFieldQuery() {\n    String hql = \"SELECT e.email, e.salary, e.dept FROM Employee e WHERE e.dept = :dept\";\n    Query query = session.createQuery(hql);\n  \n    Department dept = new Department();\n    dept.setId(80);\n    //默认情况下list()方法返回的集合中的数据是数组类型的。但是我们可以封装成对象类型\n    List<Object[]> result = query.setEntity(\"dept\", dept)\n      .list();\n  \n    for(Object [] objs: result){\n      System.out.println(Arrays.asList(objs));\n    }\n  }\n  ```\n\n  * 通过构造器让数组转换成对象：\n\n  ```java\n  public void testFieldQuery2() {\n    //此时需要保证Employee类中有此构造器的情况下才行\n    String hql = \"SELECT new Employee(e.email, e.salary, e.dept) \"\n      + \"FROM Employee e \"\n      + \"WHERE e.dept = :dept\";\n    Query query = session.createQuery(hql);\n  \n    Department dept = new Department();\n    dept.setId(80);\n    //查询语句通过构造器进行了封装\n    List<Employee> result = query.setEntity(\"dept\", dept)\n      .list();\n  \n    for(Employee emp: result){\n      System.out.println(emp.getId() + \", \" + emp.getEmail()\n                         + \", \" + emp.getSalary() + \", \" + emp.getDept());\n    }\n  }\n  ```\n\n* 报表查询：\n\n  * 报表查询用于对数据分组和统计, 与 SQL 一样, HQL 利用 GROUP BY 关键字对数据分组, 用 HAVING 关键字对分组数据设定约束条件。\n  * 在 HQL 查询语句中可以调用以下聚集函数：\n    * count()；min()；max()；sum()；avg()。\n\n  ```java\n  public void testGroupBy(){\n    String hql = \"SELECT min(e.salary), max(e.salary) \"\n      + \"FROM Employee e \"\n      + \"GROUP BY e.dept \"\n      + \"HAVING min(salary) > :minSal\";\n  \n    Query query = session.createQuery(hql)\n      .setFloat(\"minSal\", 8000);\n  \n    List<Object []> result = query.list();\n    for(Object [] objs: result){\n      System.out.println(Arrays.asList(objs));\n    }\n  }\n  ```\n\n* 左外连接：\n\n  * 迫切左外连接:\n\n    * LEFT JOIN **FETCH 关键字**表示迫切左外连接检索策略。\n    * list() 方法返回的集合中存放**实体对象的引用**, 每个 Department 对象关联的 Employee  集合都被初始化, 存放所有关联的 Employee 的实体对象。\n    * 查询结果中**可能会包含重复元素**, 可以通过一个 HashSet 来过滤重复元素。\n    * 去重可以使用DISTINCT关键字。\n\n    ```java\n    public void testLeftJoinFetch(){\n      //\t\tString hql = \"SELECT DISTINCT d FROM Department d LEFT JOIN FETCH d.emps\";\n      String hql = \"FROM Department d INNER JOIN FETCH d.emps\";\n      Query query = session.createQuery(hql);\n    \n      List<Department> depts = query.list();\n      depts = new ArrayList<>(new LinkedHashSet(depts));\n      System.out.println(depts.size());\n    \n      for(Department dept: depts){\n        System.out.println(dept.getName() + \"-\" + dept.getEmps().size());\n      }\n    }\n    ```\n\n  * 左外连接:\n\n    * LEFT JOIN 关键字表示左外连接查询。\n    * list() 方法返回的集合中存放的是**对象数组类型**。\n    * 此时**根据配置文件来决定 Employee 集合的检索策略**。\n    * 如果希望 list() 方法返回的集合中仅包含 Department 对象, 可以在HQL 查询语句中使用 SELECT 关键字。\n\n    ```java\n    public void testLeftJoin(){\n      String hql = \"SELECT DISTINCT d FROM Department d LEFT JOIN d.emps\";\n      Query query = session.createQuery(hql);\n    \n      List<Department> depts = query.list();\n      System.out.println(depts.size());\n    \n      for(Department dept: depts){\n        //此时的dept对象的Employee数据是根据配置文件的设定初始化的。默认懒加载\n        System.out.println(dept.getName() + \", \" + dept.getEmps().size());\n      }\n    \n      //\t\tList<Object []> result = query.list();\n      //\t\tresult = new ArrayList<>(new LinkedHashSet<>(result));\n      //\t\tSystem.out.println(result);\n      //\n      //\t\tfor(Object [] objs: result){\n      //\t\t\tSystem.out.println(Arrays.asList(objs));\n      //\t\t}\n    }\n    ```\n\n* 内连接：\n\n  * 与左外连接的区别：不返回左表不符合的记录\n\n  * 迫切内连接:\n\n    * INNER JOIN **FETCH 关键**字表示迫切内连接, 也可以省略 INNER 关键字。\n    * list() 方法返回的集合中**存放 Department 对象的引用**, 每个 Department 对象的 Employee 集合都被初始化, 存放所有关联的 Employee 对象。\n\n  * 内连接:\n\n    * INNER JOIN 关键字表示内连接, 也可以省略 INNER 关键字。\n    * list() 方法的集合中存放的每个元素对应查询结果的一条记录, 每个元素都是**对象数组类型**。\n    * 如果希望 list() 方法的返回的集合仅包含 Department  对象, 可以在 HQL 查询语句中使用 SELECT 关键字。\n\n    ```java\n    public void testInnerJoinFetch2(){\n      String hql = \"SELECT e FROM Employee e INNER JOIN e.dept\";\n      Query query = session.createQuery(hql);\n    \n      List<Employee> emps = query.list();\n      System.out.println(emps.size());\n    \n      for(Employee emp: emps){\n        System.out.println(emp.getName() + \", \" + emp.getDept().getName());\n      }\n    }\n    ```\n\n* 关联级别运行时的检索策略：\n\n  * 如果在 HQL 中没有显式指定检索策略, 将使用映射文件配置的检索策略。\n  * **HQL 会忽略映射文件中设置的迫切左外连接检索策略**, 如果希望 HQL 采用迫切左外连接策略, 就必须在 HQL 查询语句中**显式的指定它**。\n  * 若在 HQL 代码中显式指定了检索策略, 就会**覆盖映射文件中配置的检索策略**。\n\n  ```java\n  query.setFetchSize();\n  ```\n\n\n\n## QBC检索\n\n* QBC 查询就是通过使用 Hibernate 提供的 Query By **Criteria** API 来查询对象，这种 API 封装了 SQL 语句的动态拼装，对查询提供了更加面向对象的功能接口。\n\n* 基本使用：\n\n  ```java\n  public void testQBC(){\n    //1. 创建一个 Criteria 对象\n    Criteria criteria = session.createCriteria(Employee.class);\n  \n    //2. 添加查询条件: 在 QBC 中查询条件使用 Criterion 来表示\n    //Criterion 可以通过 Restrictions 的静态方法得到\n    criteria.add(Restrictions.eq(\"email\", \"SKUMAR\"));\n    criteria.add(Restrictions.gt(\"salary\", 5000F));\n  \n    //3. 执行查询\n    Employee employee = (Employee) criteria.uniqueResult();\n    System.out.println(employee);\n  }\n  ```\n\n* or和and的使用：\n\n  ```java\n  public void testQBC2(){\n    Criteria criteria = session.createCriteria(Employee.class);\n  \n    //1. AND: 使用 Conjunction 表示\n    //Conjunction 本身就是一个 Criterion 对象\n    //且其中还可以添加 Criterion 对象\n    Conjunction conjunction = Restrictions.conjunction();\n    conjunction.add(Restrictions.like(\"name\", \"a\", MatchMode.ANYWHERE));\n    Department dept = new Department();\n    dept.setId(80);\n    conjunction.add(Restrictions.eq(\"dept\", dept));\n    System.out.println(conjunction);\n  \n    //2. OR：使用 Disjunction 表示\n    //Disjunction 本身也是一个 Criterion 对象\n    Disjunction disjunction = Restrictions.disjunction();\n    disjunction.add(Restrictions.ge(\"salary\", 6000F));\n    disjunction.add(Restrictions.isNull(\"email\"));\n  \n    criteria.add(disjunction);\n    criteria.add(conjunction);\n  \n    criteria.list();\n  }\n  ```\n\n* 统计查询的使用：\n\n  ```java\n  public void testQBC3(){\n    Criteria criteria = session.createCriteria(Employee.class);\n  \n    //统计查询: 使用 Projection 来表示: 可以由 Projections 的静态方法得到\n    criteria.setProjection(Projections.max(\"salary\"));\n  \n    System.out.println(criteria.uniqueResult());\n  }\n  ```\n\n* 排序查询的使用：\n\n  ```java\n  public void testQBC4(){\n    Criteria criteria = session.createCriteria(Employee.class);\n  \n    //1. 添加排序：使用 Order 来表示\n    criteria.addOrder(Order.asc(\"salary\"));\n    criteria.addOrder(Order.desc(\"email\"));\n  \n    //2. 添加翻页方法\n    int pageSize = 5;\n    int pageNo = 3;\n    criteria.setFirstResult((pageNo - 1) * pageSize)\n      .setMaxResults(pageSize)\n      .list();\n  }\n  ```\n\n\n\n## 本地检索\n\n* 本地SQL查询来完善HQL不能涵盖所有的查询特性。\n\n  * 比如复杂的添加，更新，删除操作。\n\n* 添加操作：\n\n  ```java\n  public void testNativeSQL(){\n    String sql = \"INSERT INTO gg_department VALUES(?, ?)\";\n    Query query = session.createSQLQuery(sql);\n  \n    query.setInteger(0, 280)\n        .setString(1, \"ATGUIGU\")\n        .executeUpdate();\n  }\n  ```\n\n* 删除操作：\n\n  ```java\n  public void testHQLUpdate(){\n    String hql = \"DELETE FROM Department d WHERE d.id = :id\";\n  \n    session.createQuery(hql).setInteger(\"id\", 280)\n        .executeUpdate();\n  }\n  ```\n\n\n\n# 二级缓存\n\n* 缓存(Cache): 计算机领域非常通用的概念。它介于应用程序和永久性数据存储源(如硬盘上的文件或者数据库)之间，其作用是降低应用程序直接读写永久性数据存储源的频率，从而提高应用的运行性能。缓存中的数据是数据存储源中数据的拷贝。缓存的物理介质通常是内存。\n\n* Hibernate中提供了两个级别的缓存：\n\n  * 第一级别的缓存是 Session 级别的缓存，它是属于**事务范围的缓存**。这一级别的缓存由 hibernate 管理的。\n  * 第二级别的缓存是 SessionFactory 级别的缓存，它是属于**进程范围的缓存**。\n\n* SessionFactory 的缓存可以分为两类:\n\n  * 内置缓存: **Hibernate 自带的**, 不可卸载. 通常在 **Hibernate 的初始化阶段**, Hibernate 会把映射元数据和预定义的 SQL 语句放到 SessionFactory 的缓存中, \n    * 映射元数据是映射文件中数据（.hbm.xml 文件中的数据）的复制. 该内置缓存是**只读的**。\n  * 外置缓存(**二级缓存**): **一个可配置的缓存插件**. 在**默认情况下, SessionFactory 不会启用**这个缓存插件。\n    * 外置缓存中的数据是**数据库数据的复制**, **外置缓存的物理介质可以是内存或硬盘**。\n\n* 适合放入二级缓存中的数据:\n\n  * 很少被修改。\n  * 不是很重要的数据, 允许出现偶尔的并发问题。\n\n* 不适合放入二级缓存中的数据:\n\n  * 经常被修改。\n  * 财务数据, 绝对不允许出现并发问题。\n  * 与其他应用程序共享的数据。\n\n* 二级缓存架构\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-13.png)\n\n* 二级缓存的并发访问策略：\n\n  * 两个并发的事务同时访问持久层的缓存的相同数据时, 也有可能出现各类并发问题。\n  * 二级缓存可以设定以下 4 种类型的并发访问策略, **每一种访问策略对应一种事务隔离级别**。\n    * 非严格读写(Nonstrict-read-write): 不保证缓存与数据库中数据的一致性. **提供 Read Uncommited 事务隔离级别**, 对于极少被修改, 而且允许脏读的数据, 可以采用这种策略。\n    * 读写型(Read-write): **提供 Read Commited 数据隔离级别**.对于经常读但是很少被修改的数据, 可以采用这种隔离类型, 因为它可以防止脏读。\n    * 事务型(Transactional): 仅在受管理环境下适用. 它**提供了 Repeatable Read 事务隔离级别**. 对于经常读但是很少被修改的数据, 可以采用这种隔离类型, 因为它可以防止脏读和不可重复读。\n    * 只读型(Read-Only):**提供 Serializable 数据隔离级别**, 对于从来不会被修改的数据, 可以采用这种访问策略。\n\n* 管理 Hibernate 的二级缓存：\n\n  * Hibernate 的二级缓存是进程或集群范围内的缓存。\n  * 二级缓存是可配置的的插件, Hibernate 允许选用以下类型的缓存插件:\n    * EHCache: 可作为进程范围内的缓存, 存放数据的物理介质可以使内存或硬盘, 对 Hibernate 的查询缓存提供了支持。\n    * OpenSymphony OSCache:可作为进程范围内的缓存, 存放数据的物理介质可以使内存或硬盘, 提供了丰富的缓存数据过期策略, 对 Hibernate 的查询缓存提供了支持。\n    * SwarmCache: 可作为集群范围内的缓存, 但不支持 Hibernate 的查询缓存。\n    * JBossCache:可作为集群范围内的缓存, 支持 Hibernate 的查询缓存。\n  * 4 种缓存插件支持的并发访问策略(x 代表支持, 空白代表不支持)。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-14.png)\n\n* 配置进程范围内的二级缓存：\n\n  * 选择合适的缓存插件: EHCache(jar 包和 配置文件), 并编译器配置文件。\n\n    * jar包：https://plumriver.lanzoui.com/iXN2sp8q5xc\n\n  * 在 Hibernate 的配置文件中启用二级缓存并指定和 EHCache 对应的缓存适配器。\n\n    ```xml\n    <!--启用二级缓存-->\n    <property name=\"cache.use_second_level_cache\">true</property>\n    <!--配置二级缓存插件-->\n    <property name=\"hibernate.cache.region.factory_class\">\n      org.hibernate.cache.ehcache.EhCacheRegionFactory\n    </property>\n    ```\n\n  * 选择需要使用二级缓存的持久化类, 设置它的二级缓存的并发访问策略。\n\n    * \\<class> 元素的 cache 子元素表明 Hibernate 会缓存对象的简单属性, 但不会缓存集合属性, 若希望缓存集合属性中的元素, 必须在\\<set> 元素中加入 \\<cache> 子元素。\n\n    ```xml\n    <!--方式一：在具体类的映射文件中配置此类开启缓存-->\n    <class name=\"Customer\" table=\"customers\" schema=\"hibernate\">\n      <cache usage=\"read-write\"/> \n      <set name=\"orders\" table=\"orders\" inverse=\"false\" cascade=\"delete\" order-by=\"order_number\">\n        <!--对集合进行缓存-->\n        <cache usage=\"read-write\"/>\n        <key column=\"customer_id\"></key>\n        <one-to-many class=\"Order\"></one-to-many>\n      </set>\n    </class>\n    ```\n\n    * 在 hibernate 配置文件中通过\\<class-cache/> 节点配置使用缓存。\n\n    ```xml\n    <!--方式二：在hibernate配置文件中指明对哪个类启用二级缓存-->\n    <!--class-cache：是类级别的缓存，只针对这个类缓存，对于类中的集合属性数据不进行缓存-->\n    <class-cache class=\"com.lc.relation.oneTon.Customer\" usage=\"read-write\"/>\n    <!--collection-cache：集合类型的缓存。会缓存这个集合的ID，但不会缓存集合的数据-->\n    <collection-cache collection=\"com.lc.relation.oneTon.Customer.orders\" usage=\"read-write\"/>\n    <!--因此对于集合，我们不仅要缓存集合，也要缓存集合元素-->\n    <class-cache class=\"com.lc.relation.oneTon.Order\" usage=\"read-write\"/>\n    ```\n\n  * 测试：\n\n  ```java\n  public void test(){\n    Customer customer = (Customer) session.get(Customer.class, 1);\n    System.out.println(customer.toString());\n    System.out.println(customer.getOrders().size());\n    transaction.commit();\n    session.close();\n    session = sessionFactory.openSession();\n    transaction = session.beginTransaction();\n    //由于有二级缓存，因此在同一进程中，此查询的数据已经在二级缓存中存在了。\n    //因此这次不会执行查询语句\n    Customer customer1 = (Customer) session.get(Customer.class, 1);\n    System.out.println(customer1.toString());\n    //由于对集合和集合的元素都进行了缓存，因此这次也不会查询数据\n    System.out.println(customer1.getOrders().size());\n  }\n  ```\n\n* 配置缓存的文件ehcache.xml：\n\n  * \\<diskStore>: 指定一个目录：当 EHCache 把数据写到硬盘上时, 将把数据写到这个目录下。\n  * \\<defaultCache>: 设置缓存的**默认数据过期策略** 。\n  * \\<cache> 设定具体的**命名缓存的数据过期策略**。每个命名缓存代表一个缓存区域。\n  * 缓存区域(region)：一个具有名称的缓存块，可以给每一个缓存块设置不同的缓存策略。如果没有设置任何的缓存区域，则所有被缓存的对象，都将使用默认的缓存策略。即：<defaultCache.../>。\n  * Hibernate在不同的缓存区域保存不同的类/集合。\n    * 对于类而言，区域的名称是类名。如:com.bean.Customer。\n    * 对于集合而言，区域的名称是类名加属性名。如com.bean.Customer.orders。\n\n  ```xml\n  <!-- 你的缓存配置如下 -->\n  <cache name=\"com.lc.relation.oneTon.Customer\"\n         maxElementsInMemory=\"10000\"\n         eternal=\"false\"/>\n  <cache name=\"com.lc.relation.oneTon.Customer.orders\"\n         maxElementsInMemory=\"10000\"\n         eternal=\"false\"/>\n  ```\n\n* ehcache.xml文件实例：\n\n  ```xml\n  <ehcache>\n  \n    <!-- 设置创建cache.data文件的目录的路径。\n         如果路径是一个Java系统属性，则在运行的VM中用它的值替换它。\n         将转换以下属性：\n         user.home - 用户的主目录\n         user.dir - 用户当前工作目录\n         java.io.tmpdir - 默认临时文件路径 -->\n  <!--  <diskStore path=\"java.io.tmpdir\"/>-->\n    <!--自定义缓存文件路径-->\n    <diskStore path=\"d://chcache\"/>\n    <!--默认缓存配置。这些将应用于通过CacheManager以编程方式创建的缓存。\n        defaultCache需要以下属性：\n        maxInMemory       - 设置将在内存中创建的最大对象数\n        eternal           - 设置元素是否永恒。如果是永恒的，则会忽略超时，并且元素永远不会过期。\n        timeToIdleSeconds - 设置元素过期前的空闲时间。仅当元素不是永恒的时才使用。空闲时间现在是-上次访问时间\n        timeToLiveSeconds - 设置元素过期前的生存时间。仅当元素不是永恒的时才使用。TTL现在是创建时间\n        overflowToDisk    - 设置当内存缓存达到maxInMemory限制时，元素是否可以溢出到磁盘。\n        -->\n    <defaultCache\n        maxElementsInMemory=\"10000\"\n        eternal=\"false\"\n        timeToIdleSeconds=\"120\"\n        timeToLiveSeconds=\"120\"\n        overflowToDisk=\"true\"\n    />\n  \n    <!--自定义缓存。在此处添加缓存配置设置。如果没有自定义缓存的配置，则在启动CacheManager时使用默认缓存配置\n        Cache需要以下属性：\n        name              - 设置缓存的名称。这用于标识缓存。它必须是独一无二的。\n        maxInMemory       - 设置将在内存中创建的最大对象数\n        eternal           - 设置元素是否永恒。如果是永恒的，则会忽略超时，并且元素永远不会过期。永恒的表示在缓存中永远存在\n        timeToIdleSeconds - 设置元素过期前的空闲时间。仅当元素不是永恒的时才使用。空闲时间指：现在时间-上次访问时间。\n                            以秒为单位。超过空闲时间，数据将被清除。此值为0表示对象永远处于空闲时间。\n        timeToLiveSeconds - 设置元素过期前的生存时间。仅当元素不是永恒的时才使用。生存时间指：现在时间-创建时间。\n                            以秒为单位。超过空闲时间，数据将被清除。此值为0表示对象永远处于生存时间。\n        overflowToDisk    - 设置当内存缓存达到maxInMemory限制时，元素是否可以溢出到磁盘。\n             设置基于内存的缓存中的对象数目达到上限后,是否把溢出的对象写到基于硬盘的缓存中\n        -->\n  \n    <!-- 名为sampleCache1的示例缓存此缓存在内存中最多包含10000个元素，\n         如果某个元素空闲超过5分钟并且生存时间超过10分钟，则该元素将过期。\n         如果有超过10000个元素，它将溢出到磁盘缓存，\n         在这个配置中，磁盘缓存将到达系统上定义java.io.tmp的任何地方。在标准Linux系统上，这将是tmp“\n        -->\n    <cache name=\"sampleCache1\"\n           maxElementsInMemory=\"10000\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"300\"\n           timeToLiveSeconds=\"600\"\n           overflowToDisk=\"true\"\n    />\n    <!-- 名为sampleCache2的示例缓存此缓存包含1000个元素。元素将永远保存在内存中。它们没有过期。 -->\n    <cache name=\"sampleCache2\"\n           maxElementsInMemory=\"1000\"\n           eternal=\"true\"\n           timeToIdleSeconds=\"0\"\n           timeToLiveSeconds=\"0\"\n           overflowToDisk=\"false\"\n    />\n    <!-- 你的缓存配置如下 -->\n    <!--通常name的命名规则如下\n    对于类而言，区域的名称是类名。\n    对于集合而言，区域的名称是类名加属性名。\n    -->\n    <cache name=\"com.lc.relation.oneTon.Customer\"\n           maxElementsInMemory=\"10000\"\n           eternal=\"false\"/>\n    <cache name=\"com.lc.relation.oneTon.Customer.orders\"\n           maxElementsInMemory=\"10000\"\n           eternal=\"false\"/>\n  \n  </ehcache>\n  ```\n\n* 查询缓存：\n\n  * 对于**经常使用的查询语句**, 如果启用了查询缓存, 当第一次执行查询语句时, Hibernate 会把**查询结果存放在查询缓存中**. 以后再次执行该查询语句时, 只需从缓存中获得查询结果, 从而提高查询性能。\n\n  * 查询缓存使用于如下场合:\n\n    * 应用程序运行时经常使用查询语句。\n    * 很少对与查询语句检索到的数据进行插入, 删除和更新操作。\n\n  * 启用查询缓存的步骤\n\n    * 配置二级缓存, 因为查询缓存依赖于二级缓存。\n    * 在 hibernate 配置文件中启用查询缓存。\n\n    ```xml\n    <!--启用查询缓存-->\n    <property name=\"cache.use_query_cache\">true</property>\n    ```\n\n    * 对于希望启用查询缓存的查询语句, 调用 Query 的 setCacheable() 方法。\n\n    ```java\n    public void queryCacheTest() {\n      Query query = session.createQuery(\"from Order\");\n      //设定此查询使用查询缓存\n      query.setCacheable(true);\n      List<Order> orders = query.list();\n      System.out.println(orders.size());\n    }\n    ```\n\n* 时间戳缓存区域：\n\n  * 时间戳缓存区域存放了对于查询结果相关的表进行插入, 更新或删除操作的时间戳。\n  * Hibernate 通过时间戳缓存区域来判断被缓存的查询结果是否过期, 其运行过程如下:\n  * T1 时刻执行查询操作, 把查询结果存放在 QueryCache 区域, 记录该区域的时间戳为 T1。\n  * T2 时刻对查询结果相关的表进行更新操作, Hibernate 把 T2 时刻存放在UpdateTimestampCache 区域。\n  * T3 时刻执行查询结果前, 先比较 QueryCache 区域的时间戳和 UpdateTimestampCache 区域的时间戳, \n    * 若 T2 >T1, 那么就丢弃原先存放在 QueryCache 区域的查询结果, **重新到数据库中查询数据**, 再把结果存放到 QueryCache 区域。\n    * 若 T2 < T1, **直接从 QueryCache 中获得查询结果**。\n\n  ```java\n  public void timeCacheTest() {\n    Query query = session.createQuery(\"from Order\");\n    //设定此查询使用查询缓存\n    query.setCacheable(true);\n    List<Order> orders = query.list();\n    System.out.println(orders.size());\n  \n    Order order = (Order) session.get(Order.class, 1);\n    order.setOrderNumber(\"vbm\");\n    //由于时间戳缓存的存在，导致查询缓存区域和时间戳缓存区域数据不一致。此时会再执行一次查询\n    orders = query.list();\n    System.out.println(orders.size());\n  }\n  ```\n\n* Query 接口的 iterate() 方法：\n\n  * Query 接口的 iterator() 方法。\n    * 同 list() 一样也能执行查询操作。\n    * list() 方法执行的 SQL 语句包含实体类对应的数据表的所有字段。\n    * Iterator() 方法执行的SQL 语句中仅包含实体类对应的数据表的 ID 字段。\n    * 当遍历访问结果集时, 该方法先到 Session 缓存及二级缓存中查看是否存在特定 OID 的对象。\n      *  如果存在, 就直接返回该对象。\n      * 如果不存在该对象就通过相应的 SQL Select 语句到数据库中加载特定的实体对象。\n  * 大多数情况下, 应考虑使用 list() 方法执行查询操作。\n  * iterator() 方法仅在满足以下条件的场合, 可以**稍微提高**查询性能:\n    * 要查询的数据表中包含大量字段。\n    * 启用了二级缓存, 且二级缓存中可能已经包含了待查询的对象。\n\n\n\n# Session管理和批量操作\n\n* 管理 Session\n\n  * Hibernate  自身提供了三种管理 Session 对象的方法\n    * Session 对象的生命周期与本地线程绑定.\n    * Session 对象的生命周期与 JTA 事务绑定。\n    * Hibernate 委托程序管理 Session 对象的生命周期。\n  * 在 Hibernate 的配置文件中, hibernate.current_session_context_class 属性用于指定 Session 管理方式。可选值包括\n    * thread: Session 对象的生命周期与本地线程绑定。\n    * jta*: Session 对象的生命周期与 JTA 事务绑定。\n    * managed: Hibernate 委托程序来管理 Session 对象的生命周期。\n\n* Session 对象的生命周期与本地线程绑定：\n\n  * 如果把 Hibernate 配置文件的 hibernate.current_session_context_class 属性值设为 thread, Hibernate 就会按照与本地线程绑定的方式来管理 Session。\n\n  ```xml\n  <!--配置管理Session-->\n  <property name=\"hibernate.current_session_context_class\">thread</property>\n  ```\n\n  * Hibernate 按一下规则把 Session 与本地线程绑定：\n\n    * 当一个线程(threadA)第一次调用 SessionFactory 对象的 **getCurrentSession()** 方法时, 该方法会创建一个新的 Session(sessionA) 对象, 把该对象与 threadA 绑定, 并将 sessionA 返回 。\n    * 当 threadA 再次调用 SessionFactory 对象的 getCurrentSession() 方法时, 该方法将返回 sessionA 对象。\n    * 当 threadA **提交 sessionA 对象关联的事务时**, Hibernate 会自动flush sessionA 对象的缓存, 然后提交事务, **关闭 sessionA 对象**. 当 threadA 撤销 sessionA 对象关联的事务时, 也会自动关闭 sessionA 对象。\n    * 若 threadA 再次调用 SessionFactory 对象的 getCurrentSession() 方法时, 该方法会又创建一个新的 Session(sessionB) 对象, 把该对象与 threadA 绑定, 并将 sessionB 返回 。\n\n    ```java\n    public void testManageSession(){\n    \n      //获取 Session\n      //开启事务\n      Session session = HibernateUtils.getInstance().getSession();\n      System.out.println(\"-->\" + session.hashCode());\n      Transaction transaction = session.beginTransaction();\n    \n      DepartmentDao departmentDao = new DepartmentDao();\n    \n      Department dept = new Department();\n      dept.setName(\"ATGUIGU\");\n    \n      departmentDao.save(dept);\n      departmentDao.save(dept);\n      departmentDao.save(dept);\n    \n      //若 Session 是由 thread 来管理的, 则在提交或回滚事务时, 已经关闭 Session 了. \n      transaction.commit();\n      System.out.println(session.isOpen()); \n    }\n    ```\n\n* 批量处理数据：\n\n  * 批量处理数据是指在一个事务中处理大量数据.\n  * 在应用层进行批量操作, 主要有以下方式:\n    * 通过 Session 。\n    * 通过 HQL 。\n    * 通过 StatelessSession 。\n    * 通过 JDBC API。\n\n* 通过JDBC API进行批量操作：\n\n  * 效率是最高的。推荐使用这种方式。\n\n  ```java\n  public void testBatch(){\n    session.doWork(new Work() {\t\t\t\n      @Override\n      public void execute(Connection connection) throws SQLException {\n        //通过 JDBC 原生的 API 进行操作, 效率最高, 速度最快!\n      }\n    });\n  }\n  ```\n\n* 通过 Session 来进行批量操作：\n\n  * Session 的 save() 及 update() 方法都会把处理的对象存放在自己的缓存中. 如果通过一个 Session 对象来处理大量持久化对象, 应该**及时从缓存中清空已经处理完毕并且不会再访问的对象**。\n\n  * 具体的做法是在**处理完一个对象或小批量对象后, 立即调用 flush() 方法刷新缓存, 然后在调用 clear() 方法清空缓存**。\n\n  * 通过 Session 来进行处理操作会受到以下约束。\n\n    * 需要在  Hibernate 配置文件中设置 JDBC 单次批量处理的数目, 应保证每次向数据库发送的批量的 SQL 语句数目与 batch_size 属性一致。\n    * 若对象采用 “identity” 标识符生成器, 则 Hibernate 无法在 JDBC 层进行批量插入操作。\n    * 进行批量操作时, 建议关闭 Hibernate 的二级缓存。\n\n  * 批量插入数据：\n\n    ```java\n    News news = null;\n    for (int i = 0; i < 100; i++) {\n      news = new News();\n      news.setTitle(\"--\" + i);\n      session.save(news);\n      //定时清理session缓存\n      if ((i+1)%20 == 0){\n        session.flush();\n        session.close();\n      }\n    }\n    ```\n\n  * 批量更新数据：\n\n    * 批量更新: 在进行批量更新时, 如果一下子把所有对象都加载到 Session 缓存, 然后再缓存中一一更新, 显然是不可取的。\n    * 使用可滚动的结果集 org.hibernate.ScrollableResults, **该对象中实际上并不包含任何对象, 只包含用于在线定位记录的游标**. 只有当程序遍历访问 ScrollableResults 对象的特定元素时, 它才会到数据库中加载相应的对象。\n    * org.hibernate.ScrollableResults 对象由 Query 的 scroll 方法返回。\n\n    ```java\n    ScrollableResults sr = session.createQuery(\"from news\").scroll();\n    int count = 0;\n    while (sr.next()){\n      News news1 = (News) sr.get(0);\n      news1.setTitle(\"==\"+count);\n      //定时清理缓存\n      if ((count+1)%20 == 0){\n        session.flush();\n        session.close();\n      }\n    }\n    ```\n\n* 通过HQL进行批量操作：\n\n  * 注意: HQL 只支持 INSERT INTO … SELECT 形式的插入语句, 但不支持 INSERT INTO … VALUES 形式的插入语句. 所以使用 HQL 不能进行批量插入操作。\n\n* 通过StatelessSession来进行批量操作:\n\n  * 从形式上看，StatelessSession与session的用法类似。\n  * StatelessSession与session相比，有以下区别:\n    * StatelessSession没有缓存，通过StatelessSession来加载、保存或更新后的对象处于游离状态。\n    * StatelessSession不会与Hibernate的第二级缓存交互。\n    * 当调用StatelessSession的save()、update()或delete()方法时，这些方法会立即执行相应的SQL语句，而不会仅计划执行一条SQL语句\n    * StatelessSession不会进行脏检查，因此修改了Customer对象属性后，还需要调用\n    * StatelessSession的update()方法来更新数据库中数据。\n    * StatelessSession不会对关联的对象进行任何级联操作。\n    * 通过同一个StatelessSession对象两次加载OID为1的Customer对象，得到的两个对象内存地址不同。\n    * StatelessSession所做的操作可以被Interceptor拦截器捕获到，但是会被Hibernate的事件处理系统忽略掉。","categories":["Java学习","JavaEE框架"]},{"title":"设计模式之行为型","url":"/2021/05/14/尚硅谷说Java/设计模式/设计模式之行为型/","content":"\n包含单例模式，工厂模式，策略模式，适配器模式，观察者模式，装饰器模式等。\n\n<!--more-->\n\n* 行为型：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。\n* 行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。\n* 由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。\n* 行为型模式中除了模板方法模式和**解释器模式**是类行为型模式，其他的全部属于对象行为型模式。\n\n\n\n## 模板方法模式\n\n* 模板方法模式（Template Method Pattern），又叫模板模式(Template Pattern)，在一个抽象类公开定义了执行 它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。 \n\n* 简单说，模板方法模式 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一 个算法的结构，就可以重定义该算法的某些特定步骤。\n\n* 应用实现：\n\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210513095137.png)\n\n  * 角色说明：\n    * 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。\n    * 抽象方法：在抽象类中声明，由具体子类实现。\n    * 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。\n\n  * 代码：\n\n  ```java\n  //抽象类\n  public abstract class AbstractClass {\n    public void TemplateMethod(){\n      //模板方法：定义了对于功能实现，执行的顺序\n      SpecificMethod();\n      abstractMethod1();\n      abstractMethod2();\n    }\n    public void SpecificMethod(){\n      //具体方法：右父类实现，不需要子类实现的，一般是固定的。\n      System.out.println(\"具体方法被调用\");\n    }\n    //抽象方法1\n    abstract void abstractMethod2();\n    //抽象方法2\n    abstract void abstractMethod1();\n  }\n  //具体子类：重写实现父类中的抽象方法\n  public class ConcreteClass extends AbstractClass {\n    @Override\n    void abstractMethod2() {\n      System.out.println(\"抽象方法2被调用了\");\n    }\n  \n    @Override\n    void abstractMethod1() {\n      System.out.println(\"抽象方法1被调用了\");\n  \n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      AbstractClass template = new ConcreteClass();\n      template.TemplateMethod();\n    }\n  }\n  \n  ```\n\n* **钩子模型**\n\n  * 定义：在模板方法模式的父类中，我们可以定义一个**普通方法**，它**默认不做任何事**，子类可以视情况要不要覆盖它，该方法称为“钩子”。\n  * 举例：在上述代码的基础上进行修改。\n\n  ```java\n  //抽象类\n  public abstract class AbstractClass {\n    public void TemplateMethod(){\n      //模板方法：定义了对于功能实现，执行的顺序\n      SpecificMethod();\n      abstractMethod1();\n      //根据钩子方法的结果来改变某个方法是否被调用\n      if (hookMethod()){\n        abstractMethod2();\n      }\n    }\n    //.....代码与上述代码相同\n    //钩子方法。\n    boolean hookMethod(){\n      return true;\n    }\n  }\n  //具体子类\n  public class ConcreteClass extends AbstractClass {\n    //....代码与上述代码相同\n    @Override\n    boolean hookMethod() {\n      //重写钩子方法，改变模板方法的执行顺序\n      return  false;\n    }\n  }\n  ```\n\n* 源代码应用：在Spring IOC容器初始化时运用到了模板方法模式\n\n  ```java\n  //首先找到ConfigurableApplicationContext接口，其中的refresh()方法是模板方法\n  public interface ConfigurableApplicationContext{\n    void refresh() throws BeansException, IllegalStateException;\n  }\n  //然后看这个接口的实现类AbstractApplicationContext，这个抽象类就是模板方法的抽象类，在模板方法中定义了模板的执行顺序，\n  public abstract class AbstractApplicationContext implements ConfigurableApplicationContext{\n    //模板方法\n    @Override\n    public void refresh() throws BeansException, IllegalStateException {\n      synchronized (this.startupShutdownMonitor) {\n        StartupStep contextRefresh = this.applicationStartup.start(\"spring.context.refresh\");\n        prepareRefresh();\n        // 这里的obtainFreshBeanFactory()方法中使用了两个抽象方法，这两个抽象发法是在这个抽象类中的。\n        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n        prepareBeanFactory(beanFactory);\n        try {\n          // 这个是个钩方法\n          postProcessBeanFactory(beanFactory);\n          StartupStep beanPostProcess = this.applicationStartup.start(\"spring.context.beans.post-process\");\n          invokeBeanFactoryPostProcessors(beanFactory);\n          registerBeanPostProcessors(beanFactory);\n          beanPostProcess.end();\n          initMessageSource();\n          initApplicationEventMulticaster();\n          //这也是个钩子方法\n          onRefresh();\n          registerListeners();\n          finishBeanFactoryInitialization(beanFactory);\n          finishRefresh();\n        }\n      }\n    }\n    protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n      //抽象方法\n      refreshBeanFactory();\n      return getBeanFactory();\n    }\n    //钩子方法：空实现，由子类决定是否重写\n    protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n    }\n    //钩子方法：空实现，由子类决定是否重写\n    protected void onRefresh() throws BeansException {\n      // For subclasses: do nothing by default.\n    }\n  }\n  ```\n\n* 总结说明：\n\n  * 基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改。\n  * 实现了**最大化代码复用**。父类的模板方法和已实现的某些步骤会被子类继承而直接使用。\n  * 既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现。\n  * 该模式的不足之处：\n    * 每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大。\n    * 由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。\n  * 一般**模板方法都加上final关键字**， 防止子类重写模板方法。\n  * 模板方法模式**使用场景**：当要完成在某个过程，该过程要执行一系列步骤 ，这一系列的步骤基本相同，但其个别步骤在实现时可能不同，通常考虑用模板方法模式来处理。\n\n\n\n## 命令模式\n\n* 命令模式（Command Pattern）：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以\n  使用命令模式来进行设计。\n\n  * 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理\n\n* 命名模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。\n\n* 在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求(即命名)，同时命令模式也支持可撤销的操作。\n\n* 通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色：将军（命令发布者）、士兵（命令的具体执行者）、命令(连接将军和士兵)。\n\n* 应用案例：\n\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210513115929.png)\n\n  * 角色说明：\n    * 抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。\n    * 具体命令类（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。\n    * 实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。\n    * 调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。\n  * 代码：\n\n  ```java\n  //抽象命令\n  public interface Command {\n     //命令的执行\n     void execute();\n     //命令的撤销\n     void revoke();\n  }\n  //具体命令的实现\n  public class ConcreteCommand implements Command{\n    //聚合接收者\n    private Receiver receiver;\n    public ConcreteCommand(Receiver receiver) {\n      this.receiver = receiver;\n    }\n    @Override\n    public void execute() {\n      //实现具体的执行命令\n      receiver.on();\n    }\n    @Override\n    public void revoke() {\n      receiver.off();\n    }\n  }\n  //空命令：不做任何实现\n  public class NoCommand implements Command{\n    @Override\n    public void execute() {\n    }\n    @Override\n    public void revoke() {\n    }\n  }\n  //调用者：发出命令\n  public class Invoke {\n    //聚合各种命令\n    private Command[] command;\n  \n    public Invoke() {\n      //默认有五种接收者\n      this.command = new NoCommand[5];\n      for (int i = 0; i<5; i ++){\n          this.command[i] = new NoCommand();\n      }\n    }\n    //no表示要将第几个命令设置为command\n    public void setCommand(int no, Command command) {\n      this.command[no] = command;\n    }\n    public void execute(int no) {\n      System.out.println(\"调用者执行命令command...\");\n      command[no].execute();\n    }\n    public void revoke(int no) {\n      System.out.println(\"调用者取消命令command...\");\n      command[no].revoke();\n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      //确定命令及对应的接收者\n      Command command = new ConcreteCommand(new Receiver());\n      //创建调用者\n      Invoke invoke = new Invoke();\n      invoke.setCommand(0,command);\n      //调用命令\n      invoke.execute(0);\n      //取消命令\n      invoke.revoke(0);\n    }\n  }\n  ```\n\n* 源码分析：Spring框架的JdbcTemplate源码中。\n\n* 总结说明：\n\n  * 将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：”请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。\n  * 容易设计一个命令队列。只要把命令对象放到列队，就可以多线程的执行命令。\n  * 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。\n  * 容易实现对请求的撤销和重做。\n  * 命令模式不足：\n    * 可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在在使用的时候要注意。\n  * 空命令也是一种设计模式，它为我们省去了判空的操作。在上面的实例中，如果没有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦。\n  * 命令模式经典的应用场景：界面的一个按钮都是一条命令、模拟CMD（DOS命令） 订单的撤销/恢复、触发-反馈机制。\n\n\n\n## 访问者模式\n\n* 访问者模式（Visitor Pattern），封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。\n\n* 主要将数据结构与数据操作分离，解决**数据结构**和**操作耦合性**问题。\n\n* 访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口。\n\n* 访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)，同时需要避免让这些操作\"污染\"这些对象的类，可以选用访问者模式解决。\n\n* 应用案例：\n\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210513142744.png)\n\n  * 角色说明：\n    * 抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。\n    * 具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。\n    * 抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。\n    * 具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。\n    * 对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。\n    * 访问者角色相当于操作数据的功能。元素具有数据对象的功能。\n\n* 举例：以男人，女人投票为例，票有成功和失败两种。\n\n  * 人作为抽象元素，男人女人为具体的元素实现。\n  * 票作为抽象访问者，成功和失败作为具体的访问者。\n\n  ```java\n  //抽象访问者\n  public abstract class Action {\n    abstract void getManResult(Man man);\n    abstract void getWomanResult(Woman man);\n  }\n  public class Success extends Action{\n    @Override\n    void getManResult(Man man) {\n      //这里第一次调用了man中的方法，相当于第一次分派\n      System.out.println(man.getMsg()+\"投了成功票\");\n    }\n  \n    @Override\n    void getWomanResult(Woman woman) {\n      System.out.println(woman.getMsg()+\"投了成功票\");\n    }\n  }\n  public class Fail extends Action {\n    @Override\n    void getManResult(Man man) {\n      System.out.println(man.getMsg() + \"投了失败票\");\n    }\n  \n    @Override\n    void getWomanResult(Woman woman) {\n      System.out.println(woman.getMsg() + \"投了失败票\");\n    }\n  }\n  //抽象元素类\n  public abstract class Person {\n    abstract String getMsg();\n    abstract void accept(Action action);\n  }\n  public class Woman extends Person{\n    @Override\n    String getMsg() {\n      return \"女生\";\n    }\n  \n    @Override\n    void accept(Action action) {\n        action.getWomanResult(this);\n    }\n  }\n  public class Man extends Person {\n    @Override\n    String getMsg() {\n      return \"男生\";\n    }\n  \n    @Override\n    void accept(Action action) {\n      //这里调用了action的方法，相当于第二次分派\n      action.getManResult(this);\n    }\n  }\n  //对象结构\n  public class ObjectStructure {\n    //维护抽象元素\n    private List<Person> people = new LinkedList<>();\n    //添加元素\n    public void attach(Person person){\n      people.add(person);\n    }\n    //删除元素\n    public void detach(Person person){\n      people.remove(person);\n    }\n    //执行对元素的操作\n    public void displa(Action action){\n      for (Person person : people) {\n        person.accept(action);\n      }\n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      ObjectStructure object = new ObjectStructure();\n      Person man = new Man();\n      Person woman = new Woman();\n      object.attach(man);\n      object.attach(woman);\n      //执行对数据的操作\n      Success success = new Success();\n      object.displa(success);\n      Fail fail = new Fail();\n      object.displa(fail);\n    }\n  }\n  ```\n\n* 总结说明：\n\n  * 双分派：\n    * 根据**对象的类型**而对**方法进行的选择**,就是分派(Dispatch)。\n    * 双分派：指访问者对元素进行了分派，在accept()方法中元素对访问者又进行了分派。\n  * 优点：\n    * 访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高。\n    * 访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统。\n  * 缺点：\n    * 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是**迪米特法则**所不建议的, 这样造成了具体元素变更比较困难。\n    * **违背了依赖倒转原则**。访问者依赖的是具体元素，而不是抽象元素。\n  * 因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的。\n\n\n\n## 迭代器模式\n\n* 如果我们的集合元素是用不同的方式实现的，有数组，还有java的集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。\n\n* 迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构。\n\n* 应用案例：\n\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210513152654.png)\n\n  * 角色说明：\n    * 抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。\n    * 具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。\n    * 抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。\n    * 具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。\n  * 代码：\n\n  ```java\n  public interface Iterator {\n    Object first();\n    Object next();\n    boolean hasNext();\n  }\n  public class ConcreteIterator implements Iterator{\n    //要被迭代的数据\n    private List<Object> list = null;\n    private int index = -1;\n  \n    public ConcreteIterator(List<Object> list) {\n      this.list = list;\n    }\n  \n    @Override\n    public Object first() {\n      index = 0;\n      return list.get(index);\n    }\n  \n    @Override\n    public Object next() {\n      Object o = null;\n      if (this.hasNext()){\n        o = list.get(++index);\n      }\n      return o;\n    }\n  \n    @Override\n    public boolean hasNext() {\n      if (index < list.size()-1){\n        return true;\n      }else {\n        return false;\n      }\n    }\n  }\n  public interface Aggregate {\n    void add(Object o);\n    void remove(Object o);\n    Iterator getIterator();\n  }\n  public class ConcreteAggregate implements Aggregate{\n    //聚合数据\n    private List<Object> list = new ArrayList<>();\n  \n    @Override\n    public void add(Object o) {\n      list.add(o);\n    }\n  \n    @Override\n    public void remove(Object o) {\n      list.remove(o);\n    }\n  \n    @Override\n    public Iterator getIterator() {\n      return new ConcreteIterator(list);\n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      Aggregate aggregate = new ConcreteAggregate();\n      aggregate.add(Integer.valueOf(1));\n      aggregate.add(Integer.valueOf(2));\n      aggregate.add(Integer.valueOf(3));\n      aggregate.add(Integer.valueOf(34));\n      Iterator iterator = aggregate.getIterator();\n      while (iterator.hasNext()){\n        System.out.println(iterator.next());\n      }\n    }\n  }\n  ```\n\n* 源码应用：JDK的ArrayList 集合中就使用了迭代器模式。\n\n  * 作为ArrayList 内部类的Itr 充当具体实现迭代器Iterator 的类。\n  * List 就是充当了聚合接口，含有一个iterator() 方法，返回一个迭代器对象。\n  * ArrayList 是实现聚合接口List 的子类，实现了iterator()。\n\n* 总结：\n\n  * 优点：\n    * 提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了。\n    * 隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成。\n    * 提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做单一责任原则）。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变的话，只影响到了迭代器。\n    * 当要展示一组相似对象，或者遍历一组相同对象时使用, 适合使用迭代器模式。\n  * 缺点：每个聚合对象都要一个迭代器，会生成多个迭代器不好管理类。\n\n\n\n## 观察者模式\n\n* 观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式.\n\n* 模式的结构和实现：\n\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210513165220.png)\n\n  * 角色说明：\n    * 抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。\n    * 具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。\n    * 抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。\n    * 具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。\n  * 代码：\n\n  ```java\n  //观察者\n  public interface Observer {\n    //感到目标变化后，应当做出的反应。\n    void response();\n  }\n  public class ConcreteObserver implements Observer{\n    @Override\n    public void response() {\n      System.out.println(\"观察者检测到目标数据变化。开始行动\");\n    }\n  }\n  //抽象目标：相当于被观察者\n  public abstract class Subject {\n    protected List<Observer> observers;\n  \n    public Subject() {\n      this.observers = new ArrayList<>();\n    }\n    //添加观察者\n    public void add(Observer observer){\n      this.observers.add(observer);\n    }\n    //删除观察者\n    public void remove(Observer observer){\n      this.observers.remove(observer);\n    }\n    //当数据改变时，通知观察者\n    public abstract void notifyObservers();\n  }\n  public class ConcreteSubject extends Subject {\n    @Override\n    public void notifyObservers() {\n      System.out.println(\"目标数据已改变，开始通知观察者\");\n      for (Observer observer : this.observers) {\n        observer.response();\n      }\n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      Observer observer = new ConcreteObserver();\n      Subject subject = new ConcreteSubject();\n      //添加观察者\n      subject.add(observer);\n      //模仿数据改变\n      subject.notifyObservers();\n    }\n  }\n  ```\n\n* 源码分析：在JDK中有两个类Observer，Observable。用的就是观察者模式。\n\n  * Observable 的作用和地位等价于 我们前面讲过Subject。\n  * Observable类中已经实现了核心的方法 ,即管理Observer的方法 add.. delete .. notify...\n  * Observer 的作用和地位等价于我们前面讲过的 Observer, 有update\n\n* 总结：\n\n  * 优点：\n    * 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。\n    * 目标与观察者之间建立了一套触发机制。\n  * 缺点：\n    * 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。\n    * 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。\n\n\n\n## 中介者模式\n\n* 中介者模式（Mediator Pattern），用一个中介对象来封装一系列的对象交互。\n\n* 中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n\n* 比如MVC模式，C（Controller控制器）是M（Model模型）和V（View视图）的中介者，在前后端交互时起到了中间人的作用。\n\n* 模式的结构和应用：\n\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210513174311.png)\n\n  * 角色说明：\n    * 抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。\n    * 具体中介者（Concrete Mediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。\n    * 抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。\n    * 具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。\n  * 代码：可以以电话薄联想下面的代码。\n\n  ```java\n  //抽象中介者。中介\n  public abstract class Mediator {\n    abstract void register(Colleague colleague);\n    abstract void relay(Colleague colleague);\n  }\n  public class ConcreteMediator extends Mediator{\n    //聚合同事类对象，即当前同时通过中介者能够联系的其他同事。\n    private List<Colleague> colleagues = new ArrayList<>();\n    @Override\n    void register(Colleague colleague) {\n      //给当前同事注册其他同事的信息。\n      if (!colleagues.contains(colleague)){\n        this.colleagues.add(colleague);\n        //注意这一步：此时将这份联系也传给了其他同事。\n        //相当于告诉其他同事 当前同事能联系的同事。\n        colleague.setMediator(this);\n      }\n    }\n  \n    @Override\n    void relay(Colleague colleague) {\n      for (Colleague co : colleagues) {\n        //联系方式中除了自己其他的都联系\n        if (!colleague.equals(co)){\n          co.receive();\n        }\n      }\n    }\n  }\n  //抽象同事类\n  public abstract class Colleague {\n    protected Mediator mediator;\n    void setMediator(Mediator mediator){\n     this.mediator = mediator;\n    }\n    abstract void receive();\n    abstract void send();\n  }\n  public class ConcreteColleague1 extends Colleague{\n    @Override\n    void receive() {\n      System.out.println(\"同事1收到消息\");\n    }\n  \n    @Override\n    void send() {\n      System.out.println(\"同事1发送请求\");\n      //让中介转发这条请求给其他联系人。\n      mediator.relay(this);\n    }\n  }\n  public class ConcreteColleague2 extends Colleague{\n    @Override\n    void receive() {\n      System.out.println(\"同事2收到消息\");\n    }\n  \n    @Override\n    void send() {\n      System.out.println(\"同事2发送请求\");\n      //让中介转发这条请求给其他联系人。\n      mediator.relay(this);\n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      //相当于一份通信薄\n      Mediator mediator = new ConcreteMediator();\n      Colleague colleague1 = new ConcreteColleague1();\n      Colleague colleague2 = new ConcreteColleague2();\n      mediator.register(colleague1);\n      mediator.register(colleague2);\n      //colleague1发送请求，此时colleague2会收到消息\n      colleague1.send();\n      //colleague2发送请求，此时colleague1会收到消息\n      colleague2.send();\n    }\n  }\n  ```\n\n* 总结：\n\n  * 多个类相互耦合，会形成网状结构, 使用中介者模式将网状结构分离为星型结构，进行解耦。\n  * 减少类间依赖，降低了耦合，符合迪米特原则。\n  * 中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响。\n  * 如果设计不当，中介者对象本身变得过于复杂，这点在实际使用时，要特别注意。\n\n\n\n## 备忘录模式\n\n* 备忘录模式（Memento Pattern）在不破坏封装性的前提下，捕获一个对象的内部状态，并在**该对象之外**保存这个状态。这样以后就可将该对象恢复到原先保存的状态\n\n* 可以这里理解备忘录模式：现实生活中的备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作\n\n* 模型结构和代码：\n\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210514160312.png)\n\n  * 角色说明：\n    * 发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。\n    * 备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。\n    * 管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。\n  * 代码：\n\n  ```java\n  //发起人\n  public class Originator {\n    private String state;\n  \n    public String getState() {\n      return state;\n    }\n  \n    public void setState(String state) {\n      this.state = state;\n    }\n    //备份当前状态至备忘录\n    public Memento createMemento(){\n      return new Memento(state);\n    }\n    //从备忘录恢复状态\n    public void restoreMementor(Memento memento){\n      setState(memento.getState());\n    }\n  }\n  //备忘录模型\n  public class Memento {\n    private String state;\n  \n    public Memento(String state) {\n      this.state = state;\n    }\n  \n    public String getState() {\n      return state;\n    }\n  }\n  //管理者\n  public class Caretaker {\n    //聚合备忘录对像，以方便管理\n    private List<Memento> mementos = new ArrayList<>();\n    //添加备忘录对象\n    public void add(Memento memento){\n      this.mementos.add(memento);\n    }\n    //获取备忘录对象\n    public Memento get(int index){\n      return this.mementos.get(index);\n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      //创建发起人和管理者\n      Originator originator = new Originator();\n      Caretaker caretaker = new Caretaker();\n      originator.setState(\"状态1\");\n      //保存当前状态\n      caretaker.add(originator.createMemento());\n      //状态1变成了状态2\n      originator.setState(\"状态2\");\n      //恢复状态\n      originator.restoreMementor(caretaker.get(0));\n    }\n  }\n  \n  ```\n\n* 源码应用：\n\n  * Spring Webflow 中 DefaultMessageContext 类实现了 StateManageableMessageContext 接口，查看其源码可以发现其主要逻辑就相当于给 Message 备份。\n\n* 总结：\n\n  * 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。\n  * 实现了信息的封装，使得用户不需要关心状态的保存细节。\n  * 如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存, 这个需要注意。\n  * 适用的应用场景：\n    * 1、后悔药。 \n    * 2、打游戏时的存档。 \n    * 3、Windows 里的 ctri + z。 \n    * 4、IE 中的后退。 \n    * 5、数据库的事务管理。\n  * 为了节约内存，备忘录模式可以和原型模式配合使用。\n\n\n\n## 解释器模式\n\n* 在编译原理中，一个算术表达式通过**词法分析器**形成词法单元，而后这些词法单元再通过**语法分析器**构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解释器\n\n* 解释器（Interpreter）模式的定义：给**分析对象**定义一个语言，并定义该语言的**文法表示**，再设计一个解析器来**解释语言中的句子**。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的**上下文**。\n\n  * “文法”指语言的语法规则，而“句子”是语言集中的元素。\n\n* 文法：\n\n  * 文法是用于描述语言的语法结构的形式规则。\n  * 例如，中文中的“句子”的文法如下。\n  * 这里的符号“::=”表示“定义为”的意思，用“〈”和“〉”括住的是非终结符，没有括住的是终结符。\n\n  ```\n  〈句子〉::=〈主语〉〈谓语〉〈宾语〉\n  〈主语〉::=〈代词〉|〈名词〉\n  〈谓语〉::=〈动词〉\n  〈宾语〉::=〈代词〉|〈名词〉\n  〈代词〉你|我|他\n  〈名词〉7大学生I筱霞I英语\n  〈动词〉::=是|学习\n  ```\n\n* 句子：\n\n  * 句子是语言的基本单位，是语言集中的一个元素，它由终结符构成，能由“文法”推导出。\n  * 例如，上述文法可以推出“我是大学生”，所以它是句子。\n\n* 语法树：\n\n  * 语法树是句子结构的一种树型表示，它代表了句子的推导结果，它有利于理解句子语法结构的层次。\n  * 下图所示是“我是大学生”的语法树。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210514164943.png)\n\n* 模式结构：\n\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210514165003.png)\n\n  * 角色说明：\n    * 抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。\n    * 终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。\n    * 非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。\n    * 环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。\n    * 客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。\n\n* 案例实现：设计一个公交车卡的读卡器程序。\n\n  * 说明：假如公交车读卡器可以判断乘客的身份，如果是“北京” “上海”的“老人” “妇女”“儿童”就可以免费乘车，其他人员乘车一次扣 2 元。\n  * 设计语法如下：\n\n  ```\n  //结束语法规则：以\"的\"区分，\n  <expression> ::= <city>的<person>\n  <city> ::= 韶关|广州\n  <person> ::= 老人|妇女|儿童\n  ```\n\n  * 结构图如下：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210514165311.png)\n\n  * 代码：\n\n  ```java\n  //抽象表达式\n  public interface Expression {\n    //解释方法\n    boolean interpret(String info);\n  }\n  //终结符表达式类\n  public class TerminalExpression implements Expression{\n    private Set<String> set = new HashSet<>();\n  \n    public TerminalExpression(String[] data) {\n      //添加文法。此例中用于同一种终结符的信息\n      for (int i = 0; i < data.length; i++) {\n        this.set.add(data[i]);\n      }\n    }\n  \n    @Override\n    public boolean interpret(String info) {\n      //如果set中存在此信息则返回true\n      if (this.set.contains(info)){\n        return true;\n      }\n      return false;\n    }\n  }\n  //非终结符表达式\n  public class AndExpression implements Expression{\n    //聚合表达式。由于此例中只有两个终结符表达式，因此只定义两个即可\n    private Expression city = null;\n    private Expression person = null;\n  \n    public AndExpression(Expression city, Expression person) {\n      this.city = city;\n      this.person = person;\n    }\n  \n    @Override\n    public boolean interpret(String info) {\n      String[] msg = info.split(\"的\");\n      //如果城市和人符合，则返回true\n      return city.interpret(msg[0]) && person.interpret(msg[1]);\n    }\n  }\n  public class Context {\n    //定义文法信息\n    private String[] citys = {\"北京\",\"上海\"};\n    private String[] persons = {\"老人\", \"妇女\", \"儿童\"};\n    private Expression cityPerson;\n  \n    public Context() {\n      //创建终结符对象\n      Expression city = new TerminalExpression(citys);\n      Expression person = new TerminalExpression(persons);\n      //创建非终结符对象\n      cityPerson = new AndExpression(city,person);\n    }\n    //对info句子进行解释\n    public void freeRide(String info){\n      if (cityPerson.interpret(info)){\n        System.out.println(\"您是\" + info + \"，您本次乘车免费！\");\n      }else {\n        System.out.println(info + \"，您不是免费人员，本次乘车扣费2元！\");\n      }\n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      Context context = new Context();\n      context.freeRide(\"北京的年轻人\");\n      context.freeRide(\"上海的年轻人\");\n      context.freeRide(\"上海的老人\");\n      context.freeRide(\"广州的老人\");\n    }\n  }\n  ```\n\n* * \n\n* 源码分析：\n\n  * Spring框架中 SpelExpressionParser就使用到解释器模式。\n\n  ```java\n  //SpelExpressionParser：意为拼接表达式解析\n  SpelExpressionParser parser = new SpelExpressionParser();\n  //获取解析后的表达式\n  Expression expression = parser.parseExpression(\"100 * (2 + 400) * 1 + 66\");\n  //得到结果\n  int result = (Integer) expression.getValue();\n  System.out.println(result);\n  ```\n\n* 总结：\n\n  * 当有一个语言需要解释执行，可将该语言中的句子表示为一个抽象语法树，就可以考虑使用解释器模式，让程序具有良好的扩展性。\n  * 应用场景：编译器、运算表达式计算、正则表达式、机器人等。\n  * 使用解释器可能带来的问题：解释器模式会引起类膨胀、解释器模式采用递归调用方法，将会导致调试非常复杂、效率可能降低。\n\n\n\n## 状态模式\n\n* 状态模式（State Pattern）：它主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换。\n\n* 当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类。\n\n* 模式的结构和实现：\n\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210514175814.png)\n\n  * 角色说明：\n    * 环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。\n    * 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。\n    * 具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。\n  * 代码：\n\n  ```java\n  //抽象的状态接口\n  public interface State {\n    //当前状态的执行功能\n    void handle(Context context);\n  }\n  public class ConcreteStateA implements State{\n    @Override\n    public void handle(Context context) {\n      System.out.println(\"当前状态是 A.\");\n      //一段逻辑之后。切换状态为B\n      context.setState(new ConcreteStateB());\n    }\n  }\n  public class ConcreteStateB implements State{\n    @Override\n    public void handle(Context context) {\n      System.out.println(\"当前状态是 B.\");\n      //一段逻辑之后。切换状态为A\n      context.setState(new ConcreteStateA());\n    }\n  }\n  //环境类\n  public class Context {\n    //状态\n    private State state;\n    public Context() {\n      //默认状态为状态A\n      this.state = new ConcreteStateA();\n    }\n    //读取状态\n    public State getState() {\n      return state;\n    }\n    //设置新状态\n    public void setState(State state) {\n      this.state = state;\n    }\n    //对请求做出处理\n    public void handle(){\n      this.state.handle(this);\n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      Context context = new Context();\n      context.handle();\n      context.handle();\n      context.handle();\n    }\n  }\n  ```\n\n* 总结：\n\n  * 代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中。\n  * 方便维护。将容易产生问题的if-else语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多if-else语句，而且容易出错。\n  * 符合“开闭原则”。容易增删状态。\n  * 会产生很多类。每个状态都要一个对应的类，当状态过多时会产生很多类，加大维护难度。\n  * 应用场景：当一个事件或者对象有很多种状态，状态之间会相互转换，对不同的状态要求有不同的行为的时候，可以考虑使用状态模式。\n\n\n\n## 策略模式\n\n* 策略模式（Strategy Pattern）中，定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。\n\n* 策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。\n\n* 模式的结构和实现：\n\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210514182119.png)\n\n  * 角色说明：\n    * 抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。\n    * 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。\n    * 环境（Context）类：持有一个策略类的引用，最终给客户端调用\n  * 代码：\n\n  ```java\n  //抽象策略类：可以定义多个以表示不同的策略\n  public interface Strategy {\n    void strategyMethod();\n  }\n  //具体策略类A：表示对此策略的一种实现方式\n  public class ConcreteStrategyA implements Strategy{\n    @Override\n    public void strategyMethod() {\n      System.out.println(\"strategy策略的A实现方式\");\n    }\n  }\n  //具体策略类B：表示对此策略的第二种实现方式\n  public class ConcreteStrategyB implements Strategy{\n    @Override\n    public void strategyMethod() {\n      System.out.println(\"strategy策略的B实现方式\");\n    }\n  }\n  //环境类：聚合多种策略。并通过选择不同策略的不同实现方式\n  public class Context {\n    private Strategy strategy;\n  \n    public Strategy getStrategy() {\n      return strategy;\n    }\n  \n    public void setStrategy(Strategy strategy) {\n      this.strategy = strategy;\n    }\n    public void strategyMethod(){\n      strategy.strategyMethod();\n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      Context context = new Context();\n      Strategy strategyA = new ConcreteStrategyA();\n      context.setStrategy(strategyA);\n      context.strategyMethod();\n      System.out.println(\"使用另一种是想方式\");\n      context.setStrategy(new ConcreteStrategyB());\n      context.strategyMethod();\n    }\n  }\n  ```\n\n* 源码分析：JDK的 Arrays 的Comparator就使用了策略模式。\n\n  * 根据不同的Comparator的实现方式，从而让数组出先不同的排列方式\n\n* 总结：\n\n  * 策略模式的关键是：分析项目中变化部分与不变部分。\n  * 策略模式的核心思想是：多用组合/聚合 少用继承；用行为类组合，而是行为的继承。更有弹性。\n  * 体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略（或者行为）即可，避免了使用多重转移语句（if..else if..else）。\n  * 提供了可以替换继承关系的办法： 策略模式将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展。\n  * 需要注意的是：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大。\n\n\n\n## 职责链模式\n\n* 职责链模式（Chain of Responsibility Pattern）, 又叫责任链模式，为请求创建了一个接收者对象的链(简单示意图)。这种模式对请求的发送者和接收者进行解耦。\n\n* 职责链模式通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。\n\n* 模式的结构和实现：\n\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210514184239.png)\n\n  * 角色分析：\n    * 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。\n    * 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。\n    * 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。\n  * 代码：\n\n  ```java\n  //抽象处理者\n  public abstract class Handler {\n    private Handler next;\n    public Handler getNext() {\n      return next;\n    }\n    public void setNext(Handler next) {\n      this.next = next;\n    }\n    //处理请求的抽象方法\n    abstract void handlerRequest(String request);\n  }\n  public class ConcreteHandlerA extends Handler{\n    @Override\n    void handlerRequest(String request) {\n      if (\"one\".equals(request)){\n        System.out.println(\"请求被A处理了\");\n      }else {\n        if (getNext() != null){\n          //让下一级进行处理\n          getNext().handlerRequest(request);\n        }else {\n          System.out.println(\"此请求无法处理\");\n        }\n      }\n    }\n  }\n  public class ConcreteHandlerB extends Handler{\n    @Override\n    void handlerRequest(String request) {\n      if (\"two\".equals(request)){\n        System.out.println(\"请求被B处理了\");\n      }else {\n        if (getNext() != null){\n          //让下一级进行处理\n          getNext().handlerRequest(request);\n        }else {\n          System.out.println(\"此请求无法处理\");\n        }\n      }\n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      //组装责任链\n      Handler handlerA = new ConcreteHandlerA();\n      Handler handlerB = new ConcreteHandlerB();\n      handlerA.setNext(handlerB);\n      //测试\n      String request = \"one\";\n      handlerA.handlerRequest(request);\n      request = \"two\";\n      handlerA.handlerRequest(request);\n      request = \"three\";\n      handlerA.handlerRequest(request);\n    }\n  }\n  ```\n\n* 源码分析：SpringMVC-HandlerExecutionChain 类就使用到职责链模式\n\n  * springmvc 请求的流程图中，执行了 拦截器相关方法 interceptor.preHandler 等等。\n  * 在处理SpringMvc请求时，使用到职责链模式还使用到适配器模式。\n  * HandlerExecutionChain 主要负责的是请求拦截器的执行和请求处理,但是他本身不处理请求，只是将请求分配给链上注册处理器执行，这是职责链实现方式,减少职责链本身与处理逻辑之间的耦合,规范了处理流程。\n  * HandlerExecutionChain 维护了 HandlerInterceptor 的集合， 可以向其中注册相应的拦截器。\n\n* 总结：\n\n  * 将请求和处理分开，实现解耦，提高系统的灵活性。\n  * 简化了对象，使对象不需要知道链的结构。\n  * 性能会受到影响，特别是在链比较长的时候，因此需**控制链中最大节点数量**，一般通过在Handler中设置一个最大节点数量，在setNext()方法中判断是否已经超过阀值，超过则不允许该链建立，避免出现超长链无意识地破坏系统性能。\n  * 调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂。\n  * 最佳应用场景：有多个对象可以处理同一个请求时，比如：多级请求、请假/加薪等审批流程、Java Web中Tomcat对Encoding的处理、拦截器。\n\n\n\n\n\n\n\n\n\n\n\n","categories":["Java学习","设计模式"]},{"title":"设计模式之结构型","url":"/2021/05/11/尚硅谷说Java/设计模式/设计模式之结构型/","content":"\n包含桥接模式，装饰者模式，组合模式，外观模式，享元模式，静态代理模式，动态代理模式，Cglib代理模式。\n\n<!--more-->\n\n* **结构型**：用于描述如何将类或对象按某种布局组成更大的结构。\n* 它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。\n* 由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。\n* 结构性模式中除了**适配器模式**分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式。\n\n\n\n## 适配器模式\n\n* 适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)。\n* 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式\n* 适配器模式工作原理：\n  * 1) 适配器模式：将一个类的接口转换成另一种接口.让**原本接口不兼容的类可以**兼容。\n  * 2) 从用户的角度看不到被适配者，是解耦的.\n  * 3) 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法。\n  * 4) 用户收到反馈结果，感觉只是和目标接口交互。\n* 个人理解：适配器相当于让一个适配者类的方法包含在目标类中。\n  * 调用适配器得到的是目标类。\n  * 使用的也是目标类。\n  * 这样适配者类的内容就是隐藏的。\n* 优点：\n  * 客户端通过适配器可以透明地调用目标接口。\n  * 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。\n  * 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。\n  * 在很多业务场景中符合开闭原则。\n* 缺点：\n  * 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。\n  * 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。\n* 适配器模式（Adapter）包含以下主要角色。\n  1. 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。\n  2. 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。\n  3. 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。\n\n\n\n### 类适配器\n\n* 介绍：\n\n* Adapter类，通过继承 Adaptee类，实现 Target类接口，完成Adaptee-dst的适配。\n\n* 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210506123941.png)\n\n* 代码：\n\n  ```java\n  //目标接口\n  interface Target{\n    public void request();\n  }\n  //适配者接口\n  class Adaptee{\n    public void specificRequest(){       \n      System.out.println(\"适配者中的业务代码被调用！\");\n    }\n  }\n  //类适配器类\n  class ClassAdapter extends Adaptee implements Target{\n    public void request(){\n      specificRequest();\n    }\n  }\n  //客户端代码\n  public class ClassAdapterTest{\n    public static void main(String[] args){\n      //调用适配器获取目标类，\n      Target target = new ClassAdapter();\n      //使用目标类时，会简接的使用适配者类。\n      target.request();\n    }\n  }\n  ```\n\n* 注意事项：\n\n  *  Java是单继承机制，所以类适配器需要继承Adaptee类这一点算是一个缺点, 因为这要求Target必须是接口，有一定局限性。\n  *  Adaptee类的方法在Adapter中都会暴露出来，也增加了使用的成本。\n  *  由于其继承了Adaptee类，所以它可以根据需求重写Adaptee类的方法，使得Adapter的灵活性增强了。\n\n\n\n### 对象适配器\n\n* 介绍：\n\n  * 基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承Adaptee类，而是持有Adaptee类的实例，以解决兼容性的问题。 即：持有Adaptee类，实现 Target 类接口，完成Adaptee\\-Target的适配\n  * 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系。\n  * 对象适配器模式是适配器模式常用的一种。\n\n* 结构图\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210506124004.png)\n\n* 代码：\n\n  ```java\n  //Adaptee和Target与类适配器的代码相同\n  //对象适配器类\n  class ObjectAdapter implements Target{\n    private Adaptee adaptee;\n    public ObjectAdapter(Adaptee adaptee){\n      this.adaptee=adaptee;\n    }\n    public void request(){\n      adaptee.specificRequest();\n    }\n  }\n  //客户端代码\n  public class ObjectAdapterTest{\n    public static void main(String[] args){\n      System.out.println(\"对象适配器模式测试：\");\n      Adaptee adaptee = new Adaptee();\n      Target target = new ObjectAdapter(adaptee);\n      target.request();\n    }\n  }\n  ```\n\n* 注意事项\n\n  * 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承Adaptee的局限性问题，也不再要求Target 必须是接口。\n  * 使用成本更低，更灵活。\n\n\n\n### 接口适配器\n\n* 介绍：\n\n  * 适配器模式(Default Adapter Pattern)或缺省适配器模式。\n  * 当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求。\n  * 适用于一个接口不想使用其所有的方法的情况。\n\n* 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210506131351.png)\n\n* 代码：\n\n  ```java\n  //适配者接口\n  interface Adaptee {\n    void method1();\n    void method2();\n    void method3();\n  }\n  //适配器抽象类，\n  public abstract class InterfaceAdapter implements Adaptee{\n    //全部默认空实现\n    @Override\n    public void method1() {\n    }\n    @Override\n    public void method2() {\n    }\n    @Override\n    public void method3() {\n    }\n  }\n  //测试\n  public class Client {\n    public static void main(String[] args) {\n      InterfaceAdapter adapter = new InterfaceAdapter(){\n        //此时实现适配者中的代码逻辑\n        @Override\n        public void method1() {\n          System.out.println(\"适配者中的业务代码被调用！\");\n        }\n      };\n      adapter.method1();\n    }\n  }\n  ```\n\n\n\n## 桥接模式\n\n* 桥接模式(Bridge模式)是指：将**实现**与**抽象**放在两个不同的类层次中，使两个层次可以独立改变。\n\n* Bridge模式基于**类的最小设计原则**，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展。\n\n* 个人理解：桥接模式将实现和抽象分成了一个二维的方向，因此可以交叉衍生出很多实体类。\n\n  * 例如不同品牌，不同样式的手机。品牌和样式就可以构成一个二维方向。\n  * 相当于：品牌(a,b,c..) * 样式(a,b,c...) = （aa,ab,ac,ba,bb,bc....）\n  * 当有多层实现时，是不是可以构建一个多维的方向？\n\n* 优点：\n\n  * 抽象与实现分离，扩展能力强\n  * 符合开闭原则\n  * 符合合成复用原则\n  * 其实现细节对客户透明\n\n* 缺点：\n\n  * 由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。\n\n* 案例实现：\n\n  * 主要角色：\n    * 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。\n    * 扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。\n    * 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。\n    * 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210506142243.png)\n\n  * 代码：\n\n  ```java\n  //实现化角色\n  interface Implementor {\n    public void OperationImpl();\n  }\n  //具体实现化角色\n  class ConcreteImplementorA implements Implementor {\n    public void OperationImpl() {\n      System.out.println(\"具体实现化(Concrete Implementor)角色被访问\");\n    }\n  }\n  //抽象化角色\n  abstract class Abstraction {\n    //通过属性，让实现层聚合到抽象层\n    //protected作用域为同包下以及子类下\n    protected Implementor imple;\n    protected Abstraction(Implementor imple) {\n      this.imple = imple;\n    }\n    public abstract void Operation();\n  }\n  //扩展抽象化角色\n  class RefinedAbstraction extends Abstraction {\n    protected RefinedAbstraction(Implementor imple) {\n      super(imple);\n    }\n    public void Operation() {\n      System.out.println(\"扩展抽象化(Refined Abstraction)角色被访问\");\n      imple.OperationImpl();\n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      //实现化方向的ConcreteImplementorA类型\n      Implementor implementor = new ConcreteImplementorA();\n      //抽象化方向的RefinedAbstraction类型，在聚合实现化方向的类型\n      Abstraction abstraction = new RefinedAbstraction(implementor);\n      //abstraction是一个既包含RefinedAbstraction又包含ConcreteImplementorA的对象\n      abstraction.operation();\n    }\n  }\n  ```\n\n  * 案例的理解：\n    * 将抽象化角色理解为品牌，扩展抽象化角色有华为，小米，苹果等。\n    * 将实现化角色理解为手机的样式，具体实现化角色有触屏，翻盖，滑盖等。\n    * 这样就建立了手机样式和品牌二维架构。\n    * 当增加一个品牌，或者增加一个手机样式时，都是极其容易的。\n\n* 注意事项：\n\n  * 实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。\n  * 对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。\n  * 桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。\n  * 桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。\n  * 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性，即需要有这样的应用场景。\n\n* 应用场景：\n\n  * 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。\n  * JDBC驱动程序 \n  * 银行转账系统\n    * 转账分类: 网上转账，柜台转账，AMT转账\n    * 转账用户类型：普通用户，银卡用户，金卡用户\n  * 消息管理\n    * 消息类型：即时消息，延时消息\n    * 消息分类：手机短信，邮件消息，QQ消息...\n\n\n\n## 装饰者模式\n\n* 装饰器（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。\n\n* 优点：\n\n  * 装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用。\n  * 通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果。\n  * 装饰器模式完全遵守开闭原则。\n\n* 缺点：\n\n  * 装饰器模式会增加许多子类，过度使用会增加程序得复杂性。\n\n* 案例实现：\n\n  * 主要角色：\n\n    * 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。\n    * 具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。\n    * 抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。\n    * 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。\n\n  * 结构图：\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210506180722.png)\n\n  * 代码：\n\n    ```java\n    //抽象构件角色\n    interface Component {\n      public void operation();\n    }\n    //具体构件角色\n    class ConcreteComponent implements Component {\n      public ConcreteComponent() {\n        System.out.println(\"创建具体构件角色\");\n      }\n      public void operation() {\n        System.out.println(\"调用具体构件角色的方法operation()\");\n      }\n    }\n    //抽象装饰角色\n    class Decorator implements Component {\n      private Component component;\n      public Decorator(Component component) {\n        this.component = component;\n      }\n      public void operation() {\n        component.operation();\n      }\n    }\n    //具体装饰角色\n    class ConcreteDecorator extends Decorator {\n      public ConcreteDecorator(Component component) {\n        super(component);\n      }\n      public void operation() {\n        super.operation();\n        addedFunction();\n      }\n      public void addedFunction() {\n        System.out.println(\"为具体构件角色增加额外的功能addedFunction()\");\n      }\n    }\n    public class Client {\n      public static void main(String[] args) {\n        //原来的构件功能\n        Component component = new ConcreteComponent();\n        component.operation();\n        System.out.println(\"-------------\");\n        //通过装饰者进行装饰\n        component = new ConcreteDecorator(component);\n        component.operation();\n      }\n    }\n    ```\n\n  * 举例：点咖啡的功能\n\n    * 抽象构件角色表示咖啡饮料。\n    * 具体构件角色表示基础的咖啡。比如无糖咖啡，有糖咖啡等。\n    * 抽象装饰角色表示咖啡装饰的抽象类。\n    * 具体装饰表示对咖啡的装饰，比如加糖，加冰等装饰。\n\n* 源码案例：\n\n  * Java的IO结构，FilterInputStream就是一个装饰者。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210506201216.png)\n\n\n\n## 组合模式\n\n* 介绍：\n\n  * 组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体\\-部分”的层次关系。\n  * 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。\n  * 这种类型的设计模式属于结构型模式。\n  * 组合模式使得用户对单个对象和组合对象的访问具有一致性，**即**：组合能让客户以一致的方式处理个别对象以及组合对象。\n\n* 组合模式原理类图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210507132251.png)\n\n  * Component：这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于**访问和管理Component 子部件**, Component 可以是抽象类或者接口。\n  * Leaf：在组合中表示叶子节点，叶子节点没有子节点。\n  * Composite：非叶子节点， 用于**存储子部件**， 在 Component 接口中实现 子部件的相关操作。\n\n* 应用案例：\n\n  * 要求：展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院， 一个学院有多个系。\n  * 类图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210507135628.png)\n\n  * 代码实现：\n\n  ```java\n  //根节点：定义对子节点的操作\n  public abstract class Component {\n    //学校的基本信息\n    private String name;\n    private String desc;\n  \n    public Component(String name, String desc) {\n      this.name = name;\n      this.desc = desc;\n    }\n  \n    public String getName() {\n      return name;\n    }\n  \n    public String getDesc() {\n      return desc;\n    }\n  \n    protected void add(Component component){\n      //默认实现，不做成抽象方法是因为叶子节点不需要实现此方法\n      throw new UnsupportedOperationException();\n    }\n    protected void remove(Component component){\n      throw new UnsupportedOperationException();\n    }\n    //此方法不论是叶子节点还是子节点都必须重写\n    public abstract void print();\n  \n  }\n  //子节点：存储叶子节点，并实现根节点的操作方法\n  public class College extends Component{\n    private List<Component> departmentList = new ArrayList<>();\n    public College(String name, String desc) {\n      super(name, desc);\n    }\n  \n    @Override\n    protected void add(Component component) {\n      departmentList.add(component);\n    }\n  \n    @Override\n    protected void remove(Component component) {\n    departmentList.remove(component);\n    }\n  \n    @Override\n    public void print() {\n      //先输出此构件的信息，\n      System.out.println(\"-----------------\" + getName() + \"----------------\");\n      // 在输出子构件的信息\n      for (Component component : departmentList) {\n        component.print();\n      }\n    }\n  }\n  //叶子节点\n  public class Department extends Component{\n    public Department(String name, String desc) {\n      super(name, desc);\n    }\n  \n    @Override\n    public void print() {\n      System.out.println(\"-----------------\" + getName() + \"----------------\");\n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      Component component = new College(\"清华大学\", \"大学\");\n      component.add(new Department(\"计算机学院\", \"学院\"));\n      component.add(new Department(\"马克思学院\", \"学院\"));\n      component.add(new Department(\"外语学院\", \"学院\"));\n      component.print();\n    }\n  }\n  \n  ```\n\n* 源码分析：Java的集合类\\-HashMap就使用了组合模式。比如Map，HashMap，Node就构成了根节点，子节点，叶子节点。\n\n* 注意事项和细节：\n\n  * 简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。\n  * 具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动。\n  * 方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构。\n  * 需要遍历组织机构，或者处理的对象具有树形结构时, 非常适合使用组合模式。\n  * 要求较高的抽象性，如果**节点和叶子有很多差异性**的话，比如很多方法和属性都不一样，不适合使用组合模式。\n\n\n\n## 外观模式\n\n* 介绍：\n\n  * 外观模式（Facade），也叫“过程模式：外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n  * 外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端需跟这个接口发生调用，而无需关心这个子系统的内部细节。\n  * 外观（Facade）模式是“迪米特法则”的典型应用。\n\n* 优点：\n\n  * 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。\n  * 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。\n  * 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。\n\n* 缺点：\n\n  * 不能很好地限制客户使用子系统类，很容易带来未知风险。\n  * 增加新的子系统可能需要修改外观类或客户端的源代码，**违背了“开闭原则”**。\n\n* 结构：\n\n  * 主要角色：\n    * 外观（Facade）角色：为多个子系统对外提供一个共同的接口。\n    * 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。\n    * 客户（Client）角色：通过一个外观角色访问各个子系统的功能。\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210507145122.png)\n\n* 个人理解：外观模式相当于给一个指挥者，你只需要调用指挥者的功能，指挥者会自动的指挥各模块完成任务。\n\n  * 向智能家居的一键开灯，一键关机。还有安装软件时只需要点击安装即可，安装的过程不需要知道。\n\n* 应用案例：智能家居的一键开灯，一键关机\n\n  ```java\n  //彩灯\n  public class ColouredLights {\n    public static ColouredLights lights = new ColouredLights();\n    public void on(){\n      System.out.println(\"打开彩灯\");\n    }\n    public void off(){\n      System.out.println(\"关闭彩灯\");\n    }\n  }\n  //小灯\n  public class LittleLamp {\n    public static LittleLamp littleLamp = new LittleLamp();\n    public void on(){\n      System.out.println(\"打开小灯\");\n    }\n    public void off(){\n      System.out.println(\"关闭小灯\");\n    }\n  }\n  //大灯\n  public class Headlamps {\n    public static Headlamps headlamps = new Headlamps();\n    public void on(){\n      System.out.println(\"打开大灯\");\n    }\n    public void off(){\n      System.out.println(\"关闭大灯\");\n    }\n  }\n  //智能机器人\n  public class Robot {\n    private ColouredLights colouredLights;\n    private LittleLamp littleLamp;\n    private Headlamps headlamps;\n  \n    public Robot() {\n      this.colouredLights = ColouredLights.lights;\n      this.littleLamp = LittleLamp.littleLamp;\n      this.headlamps = Headlamps.headlamps;\n    }\n  \n    public void on(){\n      colouredLights.on();\n      littleLamp.on();\n      headlamps.on();\n    }\n    public void off(){\n      colouredLights.off();\n      littleLamp.off();\n      headlamps.off();\n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      Robot robot = new Robot();\n      //打开所有的灯\n      robot.on();\n      //关闭所有的灯\n      robot.off();\n    }\n  }\n  ```\n\n* 注意事项和细节：\n\n  * 外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性。\n  * 外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展。\n  * 通过合理的使用外观模式，可以帮我们**更好的划分访问的层次**。\n  * 当系统需要进行分层设计时，可以考虑使用Facade模式。\n  * 在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性。\n  * 不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的。\n\n\n\n## 享元模式\n\n* 介绍：\n\n  * 享元模式（Flyweight Pattern） 也叫 蝇量模式: 运用共享技术有效地支持大量细粒度的对象。\n  * 常用于系统底层开发，解决系统的性能问题。像**数据库连接池**，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个。\n  * 享元模式能够**解决重复对象的内存浪费**的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率。\n  * 享元模式经典的应用场景就是**池技术**了，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式。\n  * 优点：\n    * 相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。\n  * 缺点：\n    * 为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。\n    * 读取享元模式的外部状态会使得运行时间稍微变长。\n  * 享元模式的定义提出了两个要求，细粒度和共享对象。因为要求细粒度，所以不可避免地会使对象数量多且性质相近，此时我们就将这些对象的信息分为两个部分：内部状态和外部状态。\n    * **内部状态**指对象共享出来的信息，**存储在享元信息内部**，并且不回随环境的改变而改变；\n    * **外部状态**指对象得以依赖的一个标记，随环境的改变而改变，不可共享。\n\n* 个人理解：\n\n* 案例：\n\n  * 主要角色：\n    * FlyWeight 是抽象的享元角色, 他是产品的抽象类, 同时定义出对象的外部状态和内部状态(后面介绍) 的接口或实现。\n    * ConcreteFlyWeight 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务。\n    * UnSharedConcreteFlyWeight 是不可共享的角色，一般不会出现在享元工厂。\n    * FlyWeightFactory 享元工厂角色，用于构建一个池容器(集合)， 同时提供从池中获取对象方法。\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210507161107.png)\n\n  * 代码：\n\n  ```java\n  //抽象享元角色\n  public abstract class FlyWeight {\n    //info表示内部状态，\n    private String info;\n  \n    public FlyWeight(String info) {\n      this.info = info;\n    }\n  \n    public String getInfo() {\n      return info;\n    }\n    //非享元角色作为参数传递进去\n    abstract void print(UnsharedConcreteFlyweight unsharedConcreteFlyweight);\n  }\n  //具体的享元角色\n  public class ConcreteFlyweight extends FlyWeight{\n    public ConcreteFlyweight(String info) {\n      super(info);\n    }\n  \n    @Override\n    void print(UnsharedConcreteFlyweight unsharedConcreteFlyweight) {\n      System.out.println(unsharedConcreteFlyweight.getName() + \"输出info = \" + getInfo());\n    }\n  }\n  //非享元角色\n  public class UnsharedConcreteFlyweight {\n    //name表示外部状态\n    private String name;\n  \n    public UnsharedConcreteFlyweight(String name) {\n      this.name = name;\n    }\n  \n    public String getName() {\n      return name;\n    }\n  }\n  //享元角色工厂\n  public class FlyweightFactory {\n    //享元角色的缓冲池，以内部状态作为唯一标识符\n    private HashMap<String,FlyWeight> cache = new HashMap<>();\n    //获取享元角色\n    public FlyWeight getFlyWeight(String info){\n      FlyWeight flyWeight = cache.getOrDefault(info, null);\n      if (null == flyWeight){\n        flyWeight = new ConcreteFlyweight(info);\n        cache.put(info,flyWeight);\n      }\n      return flyWeight;\n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      FlyweightFactory factory = new FlyweightFactory();\n      FlyWeight flyWeight1 = factory.getFlyWeight(\"博客\");\n      flyWeight1.print(new UnsharedConcreteFlyweight(\"张三\"));\n      FlyWeight flyWeight2 = factory.getFlyWeight(\"博客\");\n      flyWeight2.print(new UnsharedConcreteFlyweight(\"李四\"));\n      FlyWeight flyWeight3 = factory.getFlyWeight(\"新闻\");\n      flyWeight3.print(new UnsharedConcreteFlyweight(\"李四\"));\n      FlyWeight flyWeight4 = factory.getFlyWeight(\"文本\");\n      flyWeight4.print(new UnsharedConcreteFlyweight(\"王五\"));\n    }\n  }\n  ```\n\n* 源码分析：\n\n  * Integer中的享元模式，在Integer.valueOf()方法中就使用了缓冲机制，\n    * 如果数的大小在-128到127时，就使用缓冲中的，否则就创建对象。\n\n* 注意事项和细节：\n\n  * 享元模式其实是工厂方法模式的一个改进机制，享元模式同样要求**创建一个或一组对象**，并且就是通过工厂方法模式生成对象的，只不过享元模式为工厂方法模式**增加了缓存**这一功能。\n  * 在享元模式这样理解，“享”就表示共享，“元”表示对象。\n  * 系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式。\n  * 用**唯一标识码判断**，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable存储。\n  * 享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率。\n  * 享元模式提高了系统的复杂度。**需要分离出内部状态和外部状态**，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方。\n  * 使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。\n  * 享元模式经典的应用场景是需要缓冲池的场景，比如 String常量池、数据库连接池。\n\n\n\n## 代理模式\n\n* 代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象。这样做的好处 是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。\n\n* 被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象 。\n\n* 代理模式有不同的形式, 主要有三种 **静态代理**、**动态代理** (JDK 代理、接口代理)和 **Cglib** **代理** (可以在内存 \n\n  动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴) 。\n\n\n\n### 静态代理\n\n* 静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继 承相同父类。\n\n  * 代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法\n\n* 个人理解：相当于有两个员工，一个老员工，一个新员工，两个员工会的东西差不多，但老员工会比新员工会的多一点。\n\n  * 老员工相当于代理对象。新员工相当于被代理对象。\n  * 当你要某个东西时，不找新员工而是找老员工了。\n  * 老员工会让新员工尽他的能力做出这个东西，然后老员工在做一些补充。\n  * 最终老员工会把这个东西给你。\n\n* 案例实现：\n\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210507174057.png)\n\n  * 代码：\n\n  ```java\n  //代理的接口\n  public interface ITeacherDao {\n    void teach();\n  }\n  //被代理的对象：相当于新员工\n  public class TeacherDao implements ITeacherDao{\n    @Override\n    public void teach() {\n      System.out.println(\"教书\");\n    }\n  }\n  //代理对象：相当于老员工\n  public class TeacherDaoProxy implements ITeacherDao{\n    //聚合新员工\n    private ITeacherDao target;\n  \n    public TeacherDaoProxy(ITeacherDao target) {\n      this.target = target;\n    }\n  \n    @Override\n    public void teach() {\n      System.out.println(\"先准备\");\n      target.teach();\n      System.out.println(\"完成收尾工作\");\n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      //创建被代理对象\n      ITeacherDao teacher = new TeacherDao();\n      //创建代理对象\n      TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacher);\n      teacherDaoProxy.teach();\n    }\n  }\n  ```\n\n* 特点：\n\n  * 优点：\n    * 在不修改目标对象的功能前提下, 能通过代理对象对目标功能扩展。\n  * 缺点：\n    * 因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类。\n    * 一旦接口增加方法,目标对象与代理对象都要维护。\n\n\n\n### 动态代理\n\n* 代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理。\n\n* 代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象。\n\n* 动态代理也叫做：JDK代理、接口代理。\n\n* JDK中生成代理对象的API：\n\n  * 代理类所在包:java.lang.reflect.Proxy。\n  * JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数。参数的解析在案例代码中。\n\n* 案例实现：\n\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210507181507.png)\n\n  * 代码：\n\n  ```java\n  //接口和被代理对象的代码和静态代理的相同\n  //代理工厂\n  public class ProxyFactory {\n    private ITeacherDao target;\n  \n    public ProxyFactory(ITeacherDao target) {\n      this.target = target;\n    }\n  \n    //获取被代理对象的实例\n    public Object getProxyInstance(){\n      /** newProxyInstance()参数说明\n       * 1.ClassLoader loader：指定当前目标对象使用的类加载器, 获取加载器的方法固定。\n       * 2.Class<?>[] interfaces：目标对象实现的接口类型，使用泛型方法确认类型\n       * 3.InvocationHandler h：事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行 的目标对象方法作为参数传入\n       */\n      /** invoke()参数说明\n       * 1.Object proxy：表示代理对象的实例。\n       * 2.Method method：表示当前执行方法的实例，这个方法是目标对像的方法。\n       * 3.Object[] args：表示当前执行方法的参数列表\n       */\n       Object proxy = Proxy.newProxyInstance(target.getClass().getClassLoader(),\n           target.getClass().getInterfaces(),\n           new InvocationHandler() {\n             @Override\n             public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n               System.out.println(\"被代理对象的方法的参数：\" + args);\n               System.out.println(\"被代理函数的方法执行前\");\n               //通过反射执行目标对象的方法\n               Object returnVal = method.invoke(target,args);\n               System.out.println(\"被代理函数的方法执行后\");\n               return returnVal;\n             }\n           });\n       return proxy;\n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      //创建被代理对象\n      ITeacherDao iTeacherDao = new TeacherDao();\n      //创建代理工厂\n      ProxyFactory factory = new ProxyFactory(iTeacherDao);\n      //获取代理对象\n      ITeacherDao teacherDao  = (ITeacherDao)factory.getProxyInstance();\n      //执行方法\n      teacherDao.teach();\n    }\n  }\n  ```\n\n* 案例的整体逻辑：当执行方法时\n\n  * 首先进入到InvocationHandler.invoke()方法中，然后执行此方法中的代码。\n  * 当执行到method.invoke()时，此时会进入到被代理对像的方法。执行完后，返回值为被代理对象的返回值。\n  * 然后执行剩余的代码。直至返回。\n  * InvocationHandler.invoke()方法相当于给被代理对象的每个方法套了个管道，从管道的一端执行到另一端。\n\n\n\n### Cglib代理\n\n* 静态代理和 JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个**单独的对象**,并没**有实** \n\n  **现任何的接口**,这个时候可使用目标对象子类来实现代理。即Cglib代理。\n\n* Cglib代理也叫作**子类代理**,它是在内存中构建一个子类对象从而实现对目标对象功能扩展, 有些书也将Cglib代理归属到动态代理。\n\n* Cglib 是一个强大的高性能的代码生成包,它可以在运行期扩展 java 类与实现 java 接口.它广泛的被许多 AOP 的 框架使用,例如 Spring AOP，实现方法拦截。\n\n* 在 AOP 编程中如何选择代理模式：\n\n  * 目标对象**需要实现接口**，用 JDK 代理。\n  * 目标对象**不需要实现接口**，用 Cglib 代理 。\n\n* Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类。\n\n* 注意事项：\n\n  * cglib代理想要引入相关的依赖，或导入jar包。\n\n    ```xml\n    <dependency>\n      <groupId>cglib</groupId>\n      <artifactId>cglib</artifactId>\n      <version>3.2.4</version>\n    </dependency>\n    ```\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210507191103.png)\n\n  * cglib代理是在内存中动态构建子类，注意代理的类不能为 final，否则报错IllegalArgumentException。\n\n  * 目标对象的方法如果为 final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法。\n\n* 案例实现：\n\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210507191139.png)\n\n  * 代码：\n\n  ```java\n  //被代理的对象：相当于新员工\n  public class TeacherDao {\n    public void teach() {\n      System.out.println(\"教书\");\n    }\n  }\n  //代理工厂\n  public class ProxyFactory implements MethodInterceptor {\n    private ITeacherDao target;\n    //传入被代理对象\n    public ProxyFactory(ITeacherDao target) {\n      this.target = target;\n    }\n    //获取目标被代理对象的代理对象\n    public Object getProxyInstance(){\n      //1.创建一个工具类\n      Enhancer enhancer = new Enhancer();\n      //2.设置代理对象的父类，即被代理对象\n      enhancer.setSuperclass(target.getClass());\n      //3.设置回调函数。即this.intercept()方法\n      //   相当于JDK代理的调用invoke方法\n      enhancer.setCallback(this);\n      //4.创建代理对象\n      return enhancer.create();\n    }\n    /**\n     * 这个方法和JDK代理中的invoke()方法类似，参数多了一个而已。使用方式和invoke()方法相同\n     */\n    @Override\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n      System.out.println(\"Cglib代理开始\");\n      //转入被代理对象，以及方法的参数列表。返回值为方法的返回值\n      Object returnVal = method.invoke(target,args);\n      System.out.println(\"Cglib代理结束\");\n      return returnVal;\n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      TeacherDao teacherDao = new TeacherDao();\n      ProxyFactory factory = new ProxyFactory(teacherDao);\n      TeacherDao teacherDaoProxy = (TeacherDao)factory.getProxyInstance();\n      teacherDaoProxy.teach();\n    }\n  }\n  ```\n\n\n\n### 其他的代理方式\n\n* 防火墙代理：\n  * 内网通过代理穿透防火墙，实现对公网的访问。\n* 缓存代理 ：\n  * 比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则 ok,如果取不到资源，再到公网或者数据 库取，然后缓存。\n* 远程代理 ：\n  * 远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。 \n* 同步代理：\n  * 主要使用在多线程编程中，完成多线程间同步工作。\n\n","categories":["Java学习","设计模式"]},{"title":"六大UML类图关系","url":"/2021/05/01/尚硅谷说Java/设计模式/UML类图六大关系/","content":"\n包含依赖，泛化，实现，关联，聚合，组合关系等。\n\n<!--more-->\n\n# 简介\n\n### UML介绍\n\n* UML——Unified modeling language UML (**统一建模语言**)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果。\n* UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等。\n* 使用UML来建模，常用的工具有 Rational Rose , 也可以使用一些插件来建模。\n\n### UML图介绍\n\n* 画UML图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理，\n\n* UML图分类：\n\n  * 1) 用例图(use case)。\n  * 2) 静态结构图：类图、对象图、包图、组件图、部署图。\n  * 3) 动态行为图：交互图（时序图与协作图）、状态图、活动图。\n\n* 说明：\n\n  * 1) 类图是描述类与类之间的关系的，是UML图中最核心的。\n\n* 使用eclipse画UML图\n\n  * 第一步：exlipse点击帮助，点击安装新软件。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210430172713.png)\n\n  * 第二步：在站点输入*http://download.eclipse.org/tools/gef/updates/releases/*，并将出现的软件全部选上。然后一直点击下一步即可。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210430172954.png)\n\n  * 第三步：下载插件文件：https://plumriver.lanzous.com/iKBZfoo2xle，将解压后的文件放在eclipse安装目录下的plugs目录下。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210502095936.png)\n  \n  * 第四步：重启eclipse，在新建-》其他选项。中看到UML图文件即可。\n  \n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210502100718.png)\n  \n  * 功能说明：\n  \n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210502101141.png)\n\n### 类图\n\n* 1) 用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系。\n\n* 2) 类之间的关系：**依赖、泛化（继承）、实现、关联、聚合与组合**。\n\n* 举例：\n\n  * 类\n\n  ```java\n  public class Person {\n    private String name;\n    private Integer age;\n    public String getName() {\n      return this.name;\n    }\n    public void setName(String name) {\n      this.name = name;\n    }\n    public void setAge(Integer age) {\n      this.age = age;\n    }\n    public Integer getAge() {\n      return this.age;\n    }\n    public String toString() {\n      return \"person(name=\" + name + \",age=\" + age + \")\";\n    }\n  \n  }\n  ```\n\n  * 对应的类图\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210502104656.png)\n\n# 依赖关系\n\n* 只要是在**类中用到了对方**，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。\n\n* 总结：\n\n  * 1**)** 类中用到了对方。\n  * 2**)** 如果是类的成员属性。\n  * 3**)** 如果是方法的返回类型。\n  * 4**)** 是方法接收的参数类型。\n  * 5**)** 方法中使用到。\n\n* 案例实现：\n\n  * 代码：\n\n  ```java\n  public class PersonServiceBean {\n  \t//通过属性依赖\n  \tprivate PersonDao personDao;// 类\n  \t//通过方法参数依赖\n  \tpublic void save(Person person) {\n  \t}\n  \t//通过方法返回值依赖\n  \tpublic IDCard getIDCard(Integer personid) {\n  \t\treturn null;\n  \t}\n  \t\n  \tpublic void modify() {\n  \t\t//通过变量依赖\n  \t\tDepartment department = new Department();\n  \t}\n  }\n  \n  class PersonDao {\n  }\n  \n  class IDCard {\n  }\n  \n  class Person {\n  }\n  \n  class Department {\n  }\n  ```\n\n  * UML类图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210502111636.png)\n\n# 泛化关系\n\n* 泛化关系实际上就是继承关系，它是**依赖关系的特例**。\n\n* 总结：\n\n  * 1) 泛化关系实际上就是继承关系。\n  * 2) 如果A类继承了B类，我们就说A和B存在泛化关系。\n\n* 案例实现：\n\n  * 代码：\n\n  ```java\n  //通过继承父类来实现泛化关系\n  public class PersonServiceBean extends DaoSupport {\n  \n  }\n  \n  abstract class DaoSupport {\n  \tpublic void save(Object entity) {\n  \t}\n  \n  \tpublic void delete(Object id) {\n  \t}\n  }\n  ```\n\n  * UML类图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210502112211.png)\n\n# 实现关系\n\n* 实现关系实际上就是A类实现B接口，它也是**依赖关系的特例**。\n\n* 总结：\n\n  * 如果A类实现了B接口，我们就说A和B存在实现关系。\n\n* 案例实现：\n\n  * 代码：\n\n  ```java\n  //通过实现接口来表示实现关系\n  public class PersonServiceBean implements PersonService {\n  \n  \t@Override\n  \tpublic void delete(Integer id) {\n  \t\t// TODO 自动生成的方法存根\n  \t\t\n  \t}\n  \n  }\n  \n  interface PersonService {\n  \tvoid delete(Integer id);\n  }\n  ```\n\n  * UML类图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210502112534.png)\n\n# 关联关系\n\n* 关联关系实际上就是**类与类之间的联系**，它也是**依赖关系的特例**。\n\n* 总结：\n\n  * 关联具有**导航性**：即双向关系或单向关系。\n  * 关系具有**多重性**：\n    * 1 表示有且仅有一个。\n    * 0... 表示0个或者多个\n    * 0,1 表示0个或者一个\n    * n...m 表示n到m个都可以\n    * m... 表示至少m个\n\n* 案例实现：\n\n  * 代码：\n\n  ```java\n  public class Student {\n  \tprivate List<Teacher> teachers;\n  \tprivate List<Course> courses;\n  }\n  public class Teacher {\n  \tprivate List<Student> students;\n  }\n  public class Course {\n  \n  }\n  ```\n\n  * UML类图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210502115537.png)\n\n# 聚合关系\n\n* 聚合关系（Aggregation）表示的是**整体和部分**的关系，整体与部分可以分开。聚合关系是**关联关系的特例**，所以他具有关联的导航性与多重性。\n\n* 案例实现：\n\n  * 代码：\n\n  ```java\n  public class Computer {\n  \tprivate Mouse mouse;\n  \tprivate Monitor monitor;\n  \tpublic void setMouse(Mouse mouse) {\n  \t\tthis.mouse = mouse;\n  \t}\n  \tpublic void setMonitor(Monitor monitor) {\n  \t\tthis.monitor = monitor;\n  \t}\n  }\n  class Mouse{}\n  class Monitor{}\n  ```\n\n  * UML类图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210502120006.png)\n\n# 组合关系\n\n* 组合关系：也是整体与部分的关系，但是**整体与部分不可以分开**。 组合关系是**关联关系的特例**。\n\n* 案例实现：\n\n  * 代码：\n\n  ```java\n  public class Person {\n  \t//聚合关系\n  \tprivate IDCard card; \n  \t//组合关系\n  \tprivate Head head = new Head();\n  \tpublic void setIDCard(IDCard card) {\n  \t\tthis.card = card;\n  \t}\n  }\n  class IDCard{} \n  class Head{}\n  ```\n\n  * UML类图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210502120255.png)\n\n* 特别的：如果在程序中Person实体中定义了对IDCard进行**级联删除**，即删除Person时连同IDCard一起删除，那么IDCard 和 Person 就是组合了。\n\n# 总览\n\n* 各种关系的强弱顺序：泛化 = 实现 > 组合 > 聚合 > 关联 > 依赖。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210502141726.png)\n\n* 下面这张UML图，比较形象地展示了各种类图关系：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210502141801.png)","categories":["Java学习","设计模式"]},{"title":"设计模式之创造型","url":"/2021/05/01/尚硅谷说Java/设计模式/设计模式之创造型/","content":"\n包含单例模式，简单工厂模式，抽象工厂模式，工厂方法模式，原型模式，建造者模式。\n\n<!--more-->\n\n# 设计模式概述\n\n* 设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验。\n  * **模式不是代码，而是某类问题的通用解决方案**。\n  * 设计模式（Design pattern）代表了最佳的实践。\n  * 这些解决方案是众多软件开发人员经过相当长的 一段时间的试验和错误总结出来的。\n* 设计模式的本质：提高 **软件的维护性，通用性和扩展性，并降低软件的复杂度**。\n* 设计模式并不局限于某种语言，java，php，c++ 都有设计模式。\n* 设计模式分总共有**23种**。\n* 根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。\n  * 1) **创建型**：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。\n  * 2) **结构型**：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。\n  * 3) **行为型**：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、 解释器模式、状态模式、策略模式、职责链模式(责任链模式)。\n* 根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。\n  * 1）类模式：工厂模式、适配器模式、模板方法模式、解释器模式。\n  * 2）对象模式：单例模式、抽象工厂模式、原型模式、建造者模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式，命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、 状态模式、策略模式、职责链模式(责任链模式)。\n* **注意**：不同的书籍上对分类和名称略有差别。\n\n# 创造型\n\n* **创建型模式**的主要关注点是“怎样创建对象？”，它的**主要特点是“将对象的创建与使用分离”**。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。\n\n\n\n## 单例设计模式\n\n* 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类**只能存在一个对象实例**，并且该类只提供一个取得其对象实例的方法(静态方法)。\n* 特点：\n  * 单例类只有一个实例对象；\n  * 该单例对象必须由单例类自行创建；\n  * 单例类对外提供一个访问该单例的全局访问点。\n* 优点：\n  * 单例模式可以保证内存里只有一个实例，减少了内存的开销。\n  * 可以避免对资源的多重占用。\n  * 单例模式设置全局访问点，可以优化和共享资源的访问。\n* 缺点：\n  * 单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。\n  * 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。\n  * 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。\n* 单例模式有八种方式（加粗的表示可以使用）：\n  * 1) **饿汉式(静态常量)**\n  * 2) **饿汉式（静态代码块）**\n  * 3) 懒汉式(线程不安全)\n  * 4) 懒汉式(线程安全，同步方法)\n  * 5) 懒汉式(线程不安全，同步代码块)\n  * 6) **懒汉式（双重检查）**\n  * 7) **静态内部类**\n  * 8) **枚举**\n\n### 饿汉式(静态常量)\n\n* 步骤：\n\n  * 1) 构造器私有化 (防止 new )\n  * 2) 类的内部创建对象\n  * 3) 向外暴露一个静态的公共方法。\n\n* 示例代码：\n\n  ```java\n  public class Case1 {\n    public static void main(String[] args) {\n      Singleton1 a = Singleton1.getSingleton1();\n      Singleton1 b = Singleton1.getSingleton1();\n      System.out.println(a == b); //true\n    }\n  }\n  // 饿汉式（静态常量）\n  class Singleton1{\n    // 1.将构造器私有化\n    private Singleton1(){}\n    // 2.创建这个类的静态不可变对象实例\n    private final static Singleton1 SINGLETON_1 = new Singleton1();\n    // 3.对外提供获取这个类对象的方法\n    public static Singleton1 getSingleton1(){\n      return SINGLETON_1;\n    }\n  }\n  ```\n\n* 说明：\n\n  * 1) 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。\n  * 2) 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成**内存的浪费**。\n  * 3) 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法， 但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到lazy loading的效果。\n  * 4) 结论：这种单例模式**可用**，**可能**造成内存浪费。\n\n### 饿汉式（静态代码块）\n\n* 步骤：\n\n  * 1) 构造器私有化 (防止 new )\n  * 2) 类的内部创建对象引用。\n  * 3) 通过静态代码块创建对象实例。\n  * 4) 向外暴露一个静态的公共方法。\n\n* 示例代码：\n\n  ```\n  public class Case2 {\n    public static void main(String[] args) {\n      Singleton2 a = Singleton2.getSingleton2();\n      Singleton2 b = Singleton2.getSingleton2();\n      System.out.println(a == b); //true\n    }\n  }\n  \n  // 饿汉式（静态代码块）\n  class Singleton2{\n    // 1.将构造器私有化\n    private Singleton2(){}\n    // 2.创建这个类的静态不可变对象实例\n    private final static Singleton2 SINGLETON_2;\n    // 3.通过静态代码块创建对象实例。\n    static {\n      SINGLETON_2 = new Singleton2();\n    }\n    // 4.对外提供获取这个类对象的方法\n    public static Singleton2 getSingleton2(){\n      return SINGLETON_2;\n    }\n  }\n  ```\n\n* 说明：\n\n  * 1) 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。\n  * 2) 结论：这种单例模式可用，但是可能造成内存浪费。\n\n### 懒汉式(线程不安全)\n\n* 步骤：\n\n  * 1) 构造器私有化 (防止 new )\n  * 2) 类的内部创建对象引用。\n  * 3) 向外暴露一个静态的公共方法。此方法中创建对象。\n\n* 示例代码：\n\n  ```java\n  public class Case3 {\n    public static void main(String[] args) {\n      Singleton3 a = Singleton3.getSingleton3();\n      Singleton3 b = Singleton3.getSingleton3();\n      System.out.println(a == b); //true\n    }\n  }\n  \n  // 懒汉式(线程不安全)\n  class Singleton3{\n    // 1.将构造器私有化\n    private Singleton3(){}\n    // 2.创建这个类的静态不可变对象实例\n    private static Singleton3 SINGLETON_3;\n    // 3.对外提供获取这个类对象的方法\n    public static Singleton3 getSingleton3(){\n      if(null == SINGLETON_3){\n        //创建这个类对象的实例\n        SINGLETON_3 = new Singleton3();\n      }\n      return SINGLETON_3;\n    }\n  }\n  ```\n\n* 说明：\n\n  * 1) 起到了Lazy Loading的效果，但是只能在单线程下使用。\n  * 2) 如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。\n  * 3) 结论：在实际开发中，不要使用这种方式。\n\n### 懒汉式(线程安全，同步方法)\n\n* 步骤：\n\n  * 1) 构造器私有化 (防止 new )\n  * 2) 类的内部创建对象引用。\n  * 3) 向外暴露一个静态的公共**同步**方法。此方法中，创建对象。\n\n* 示例代码：\n\n  ```java\n  public class Case4 {\n    public static void main(String[] args) {\n      Singleton4 a = Singleton4.getSingleton4();\n      Singleton4 b = Singleton4.getSingleton4();\n      System.out.println(a == b); //true\n    }\n  }\n  \n  // 懒汉式(线程安全,同步方法)\n  class Singleton4{\n    // 1.将构造器私有化\n    private Singleton4(){}\n    // 2.创建这个类的静态不可变对象实例\n    private static Singleton4 SINGLETON_4;\n    // 3.对外提供获取这个类对象的方法。此方法加上 synchronized 关键字.\n    public static synchronized Singleton4 getSingleton4(){\n      if(null == SINGLETON_4){\n        //创建这个类对象的实例\n        SINGLETON_4 = new Singleton4();\n      }\n      return SINGLETON_4;\n    }\n  }\n  ```\n\n* 说明：\n\n  * 1) 解决了线程不安全问题。\n  * 2) **效率太低了**，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低。\n  * 3) 结论：在实际开发中，不推荐使用这种方式。\n\n### 懒汉式(线程不安全，同步代码块)\n\n* 步骤：\n\n  * 1) 构造器私有化 (防止 new )\n  * 2) 类的内部创建对象引用。\n  * 3) 向外暴露一个静态的公共方法。此方法中，**同步创建对象**。\n\n* 示例代码：\n\n  ```java\n  public class Case5 {\n    public static void main(String[] args) {\n      Singleton5 a = Singleton5.getSingleton5();\n      Singleton5 b = Singleton5.getSingleton5();\n      System.out.println(a == b); //true\n    }\n  }\n  \n  // 懒汉式(线程不安全，同步代码块)\n  class Singleton5{\n    // 1.将构造器私有化\n    private Singleton5(){}\n    // 2.创建这个类的静态不可变对象实例\n    private static Singleton5 SINGLETON_5;\n    // 3.对外提供获取这个类对象的方法。\n    public static  Singleton5 getSingleton5(){\n      if(null == SINGLETON_5){\n        //创建这个类对象的实例.同步的创建\n        synchronized (Singleton5.class){\n          SINGLETON_5 = new Singleton5();\n        }\n      }\n      return SINGLETON_5;\n    }\n  }\n  ```\n\n* 说明：\n\n  * 1) 这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为同步产生实例化的的代码块。\n  * **2)** **但是这种同步并不能起到线程同步的作用**。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。\n  * 3) 结论：在**实际开发中，不能使用这种方**式。\n\n### 懒汉式（双重检查）\n\n* 步骤：\n\n  * 1) 构造器私有化 (防止 new )\n  * 2) 类的内部创建对象引用。\n  * 3) 向外暴露一个静态的公共方法。此方法中，双重检查，**同步创建对象**。\n\n* 示例代码：\n\n  ```\n  public class Case6 {\n    public static void main(String[] args) {\n      Singleton6 a = Singleton6.getSingleton6();\n      Singleton6 b = Singleton6.getSingleton6();\n      System.out.println(a == b); //true\n    }\n  }\n  \n  // 懒汉式(线程不安全，同步代码块)\n  class Singleton6{\n    // 1.将构造器私有化\n    private Singleton6(){}\n    // 2.创建这个类的静态不可变对象实例。volatile保证此变量发生改变时，其他线程都能看到\n    private static volatile Singleton6 SINGLETON_6;\n    // 3.对外提供获取这个类对象的方法。\n    public static  Singleton6 getSingleton6(){\n      //第一重检查，能够保证实例创建后，往后的线程都不用同步。\n      if(null == SINGLETON_6){\n        //创建这个类对象的实例.同步的创建\n        synchronized (Singleton6.class){\n          //第二重检查，防止通过第一重检查的多个线程创造多个实例，\n          if (null == SINGLETON_6){\n            SINGLETON_6 = new Singleton6();\n          }\n        }\n      }\n      return SINGLETON_6;\n    }\n  }\n  ```\n\n* 说明：\n\n  * 1) Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。\n  * 2) 这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象，也避免的反复进行方法同步。\n  * 3) 线程安全；延迟加载；效率较高。\n  * 4) 结论：在实际开发中，推荐使用这种单例设计模式。\n\n### 静态内部类\n\n* 步骤：\n\n  * 1) 构造器私有化 (防止 new )\n  * 2) 静态内部类中创建类对象。\n  * 3) 向外暴露一个静态的公共方法。\n\n* 示例代码：\n\n  ```java\n  public class Case7 {\n    public static void main(String[] args) {\n      Singleton7 a = Singleton7.getInstance();\n      Singleton7 b = Singleton7.getInstance();\n      System.out.println(a == b);\n    }\n  }\n  class Singleton7{\n    // 1.构造器私有化\n    private Singleton7(){}\n    // 2.静态内部类。\n    // 当外部类加载时，内部类不会被加载。\n    // 当调用getInstance方法时，内部类才会被加载。\n    private static class SingletonInstance{\n      private static final Singleton7 SINGLETON_7 = new Singleton7();\n    }\n    // 3.对外暴露获取对象实例的方法\n    public static Singleton7 getInstance(){\n      return SingletonInstance.SINGLETON_7;\n    }\n  }\n  ```\n\n* 说明：\n\n  * 1) 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。\n  * 2) 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。\n  * 3) 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。\n  * 4) 优点：避免了**线程不安全**，利用静态内部类特点实现延迟加载，效率高\n  * 5) 结论：推荐使用。\n\n### 枚举\n\n* 示例代码：\n\n  ```java\n  public class Case8 {\n    public static void main(String[] args) {\n      Singleton8 a = Singleton8.SINGLETON_8;\n      Singleton8 b = Singleton8.SINGLETON_8;\n      System.out.println(a == b);\n    }\n  }\n  enum Singleton8{\n    SINGLETON_8;\n  }\n  ```\n\n* 说明：\n\n  * 1) 这借助**JDK1.5中**添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能**防止反序列化**重新创建新的对象。\n  * 2) 这种方式是Effective Java作者Josh Bloch 提倡的方式。\n  * 3) 结论：推荐使用。\n\n### 应用源码分析\n\n* 单例模式在JDK 应用的源码分析：\n\n  * 我们JDK中，java.lang.Runtime就是经典的单例模式(饿汉式)。\n\n  ```java\n  /*\n   * @author  unascribed\n   * @see     java.lang.Runtime#getRuntime()\n   * @since   JDK1.0\n   */\n  public class Runtime {\n    private static Runtime currentRuntime = new Runtime();\n  \n    public static Runtime getRuntime() {\n      return currentRuntime;\n    }\n  \n    private Runtime() {}\n  \n    //......\n  }\n  ```\n\n* 单例模式注意事项和细节说明：\n\n  * 1) 单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。\n  * 2) 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new。\n  * 3) 单例模式**使用的场景**：需要**频繁的进行创建和销毁的对象**、创建对象时耗时过多或耗费资源过多(即：**重量级对象**)，但又经常用到的对象、**工具类对象**、频繁访问数据库或文件的对象(比如**数据源、session工厂**等。\n\n\n\n## 工厂模式\n\n* 工厂模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。\n* 按实际业务场景划分，工厂模式有 3 种不同的实现方式，分别是**简单工厂**模式、**工厂方法**模式和**抽象工厂**模式。\n* 我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。\n\n### 简单工厂模式\n\n* 如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。\n\n* <font color=\"red\">简单工厂模式不在23种设计模式之列。</font>\n\n* 在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。\n\n* 理解：在创建产品时，创建的功能如果交给商家，在后期如果添加新商品就要修改商家的代码，会很麻烦；如果将创建的功能交给工厂，让商家去工厂拿商品。这样相当于在商家和产品之间又封装了一层。\n\n* 举例：两个具体的产品和它们的抽象类，工厂，商家。\n\n  * 结构图如下：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210502203610.png)\n\n  * 产品代码：\n\n  ```java\n  //抽象产品\n  public interface Product {\n    void show();\n  }\n  //具体的产品1\n  public class ConcreteProduct1 implements Product{\n    @Override\n    public void show() {\n      System.out.println(\"具体的产品1展示。。\");\n    }\n  }\n  //具体的产品1\n  public class ConcreteProduct1 implements Product{\n    @Override\n    public void show() {\n      System.out.println(\"具体的产品1展示。。\");\n    }\n  }\n  ```\n\n  * 工厂代码：\n\n  ```java\n  //简单的工厂\n  public class SimpleFactory {\n    public static Product makeProduct(int type){\n      switch (type){\n        case 1:\n          return new ConcreteProduct1();\n        case 2:\n          return new ConcreteProduct2();\n        default:\n          return null;\n      }\n    }\n  }\n  ```\n\n  * 商家代码：\n\n  ```java\n  //商家\n  public class Client {\n    public static void main(String[] args) {\n      Product product = SimpleFactory.makeProduct(1);\n      product.show();\n      Product product2 = SimpleFactory.makeProduct(2);\n      product2.show();\n    }\n  }\n  ```\n\n* 优点：\n\n  * 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。\n  * 客户端无需知道所创建具体产品的类名，只需知道参数即可。\n  * 也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。\n\n* 缺点：\n\n  * 简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，**违背高聚合原则**。\n  * 使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度。\n  * 系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂。\n  * 简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。\n\n* 总结：简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，**违背了“开闭原则”**。\n\n### 工厂方法模式\n\n* **工厂方法模式**：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将**对象的实例化推迟到子类**。\n\n* 个人理解：我们对于产品有一个抽象产品，那么我们也可以对生产此产品的工厂也抽象出一个抽象工厂。\n\n* 案例：抽象工厂，两个具体工厂，抽象产品，两个具体产品，商家。\n\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210502210731.png)\n\n  * 产品代码：如上简单工厂模式的代码所示。\n  * 工厂代码：\n\n  ```java\n  //抽象工厂：提供了厂品的生成方法\n  public interface AbstractFactory {\n    public Product newProduct();\n  }\n  //具体工厂1：实现了厂品的生成方法\n  public class ConcreteFactory1 implements AbstractFactory{\n    @Override\n    public Product newProduct() {\n      System.out.println(\"具体工厂1生成-->具体产品1...\");\n      return new ConcreteProduct1();\n    }\n  }\n  //具体工厂2：实现了厂品的生成方法\n  public class ConcreteFactory2 implements AbstractFactory{\n    @Override\n    public Product newProduct() {\n      System.out.println(\"具体工厂2生成-->具体产品2...\");\n      return new ConcreteProduct2();\n    }\n  }\n  ```\n\n  * 商家代码：\n\n  ```java\n  //商家\n  public class Client {\n    public static void main(String[] args) {\n      AbstractFactory factory1 = new ConcreteFactory1();\n      Product product1 = factory1.newProduct();\n      product1.show();\n      AbstractFactory factory2 = new ConcreteFactory2();\n      Product product2 = factory2.newProduct();\n      product2.show();\n    }\n  }\n  ```\n\n* 优点：\n\n  * 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。\n  * 灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。\n  * 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。\n\n* 缺点：\n\n  * 类的个数容易过多，增加复杂度\n  * 增加了系统的抽象性和理解难度\n  * **抽象产品只能生产一种产品**，此弊端可使用抽象工厂模式解决。\n\n* 总结：**工厂方法模式**只考虑生产**同等级的产品**，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。\n\n### 抽象工厂模式\n\n* 抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。\n\n* 将同一个具体工厂所生产的位于不同等级的一组产品称为一个**产品族**。\n\n* 理解：在工厂方法模式中，抽象工厂只能生产一种产品。在抽象工厂中，抽象工厂能生产多种产品。具体的生产是由子类生产的。子类只能生产同一等级的不同产品。\n\n  * 例如：以地理位置为等级区分，北京工厂能生产北京的各种产品，上海工厂能生产上海的各种产品。\n\n* 案例：抽象工厂和两个具体工厂，两种抽象产品以及它们的具体产品，商家。\n\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210502213614.png)\n\n  * 第一种产品代码：\n\n  ```java\n  //第一种产品\n  public interface Product1 {\n    void show();\n  }\n  //第一种产品的第一个产品\n  public class ConcreteProduct11 implements Product1{\n    @Override\n    public void show() {\n      System.out.println(\"第一种产品的 具体的产品1 展示。。\");\n    }\n  }\n  //第一种产品的第二个产品\n  public class ConcreteProduct12 implements Product1{\n    @Override\n    public void show() {\n      System.out.println(\"第一种产品的 具体的产品2 展示。。\");\n    }\n  }\n  ```\n\n  * 第二种产品代码：\n\n  ```java\n  //第二种产品\n  public interface Product2 {\n    void show();\n  }\n  //第二种产品的第一个产品\n  public class ConcreteProduct21 implements Product2{\n    @Override\n    public void show() {\n      System.out.println(\"第二种产品的 具体的产品1 展示。。\");\n    }\n  }\n  //第二种产品的第二个产品\n  public class ConcreteProduct22 implements Product2{\n    @Override\n    public void show() {\n      System.out.println(\"第二种产品的 具体的产品2 展示。。\");\n    }\n  }\n  ```\n\n  * 工厂代码：\n\n  ```java\n  //抽象工厂\n  public interface AbstractFactory {\n    Product1 newProduct1();\n    Product2 newProduct2();\n  }\n  //具体工厂1\n  public class ConcreteFactory1 implements AbstractFactory {\n    @Override\n    public Product1 newProduct1() {\n      System.out.println(\"具体工厂 1 生成-->具体产品 11...\");\n      return new ConcreteProduct11();\n    }\n  \n    @Override\n    public Product2 newProduct2() {\n      System.out.println(\"具体工厂 1 生成-->具体产品 21...\");\n      return new ConcreteProduct21();\n    }\n  }\n  //具体工厂2\n  public class ConcreteFactory2 implements AbstractFactory {\n    @Override\n    public Product1 newProduct1() {\n      System.out.println(\"具体工厂 2 生成-->具体产品 12...\");\n      return new ConcreteProduct12();\n    }\n  \n    @Override\n    public Product2 newProduct2() {\n      System.out.println(\"具体工厂 2 生成-->具体产品 22...\");\n      return new ConcreteProduct22();\n    }\n  }\n  ```\n\n  * 商家：\n\n  ```java\n  //商家\n  public class Client {\n    public static void main(String[] args) {\n      AbstractFactory factory1 = new ConcreteFactory1();\n      Product1 product11 = factory1.newProduct1();\n      Product2 product21 = factory1.newProduct2();\n      AbstractFactory factory2 = new ConcreteFactory2();\n      Product1 product12 = factory2.newProduct1();\n      Product2 product22 = factory2.newProduct2();\n      product11.show();\n      product21.show();\n      product12.show();\n      product22.show();\n    }\n  }\n  ```\n\n* 优点：\n\n  * 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。\n  * 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。\n  * 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。\n\n* 缺点：\n\n  * 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。\n\n* 总结：抽象工厂模式的扩展有一定的“开闭原则”倾斜性。\n\n  * 当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。\n    * 例如：Product1接口新增了一个实现类。只需要加一个具体工厂即可。\n  * 当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。\n    * 例如：新增了一个Product3时，所有的具体工厂都需要修改。\n  * 另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。\n\n### 应用源码分析\n\n* JDK 中的Calendar类中，就使用了简单工厂模式。\n\n* 源码如下\n\n  ```java\n  private static Calendar createCalendar(TimeZone zone,\n                                         Locale aLocale){\n    Calendar cal = null;\n  \n    if (aLocale.hasExtensions()) {\n      String caltype = aLocale.getUnicodeLocaleType(\"ca\");\n      if (caltype != null) {\n        //这里的switch就是根据地理位置的不同，获取不同的实例\n        switch (caltype) {\n          case \"buddhist\":\n            cal = new BuddhistCalendar(zone, aLocale);\n            break;\n          case \"japanese\":\n            cal = new JapaneseImperialCalendar(zone, aLocale);\n            break;\n          case \"gregory\":\n            cal = new GregorianCalendar(zone, aLocale);\n            break;\n        }\n      }\n    }\n    return cal;\n  }\n  ```\n\n* 工厂模式的意义：\n\n  * 将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。\n\n* 设计模式的**依赖抽象**原则：\n\n  * 创建对象实例时，不要直接 new 类, 而是把这个new 类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用。\n  * 不要让类继承具体类，而是继承抽象类或者是实现interface(接口) 。\n  * 不要覆盖基类中已经实现的方法。\n\n\n\n## 原型模式\n\n* 介绍：\n\n  * 1) 原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。\n  * 2) 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象， 无需知道如何创建的细节。\n  * 3) 工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()。\n  * 4) 形象的理解：孙大圣拔出猴毛， 变出其它孙大圣。\n  * 个人理解：即给定一个对象实例，通过原型模式的方法复制出多个实例，对复制的过程不关心。\n\n* 案例：\n\n  * 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210504102116.png)\n\n  * 代码：\n\n  ```java\n  //类需要实现Cloneable接口，并且重写clone()方法\n  public class Person implements Cloneable{\n    private String name;\n    private Integer age;\n    private Double weight;\n  \n    public Person() {\n    }\n  \n    public Person(String name, Integer age, Double weight) {\n      this.name = name;\n      this.age = age;\n      this.weight = weight;\n    }\n    /...get,set方法也需要写../\n  \n    @Override\n    protected Object clone() {\n      Person person = null;\n      try {\n        //通过默认的拷贝方法来实现person类拷贝\n        person = (Person) super.clone();\n      }catch (Exception e){\n        System.out.println(e.getMessage());\n      }\n      return person;\n    }\n  }\n  public class Client {\n    public static void main(String[] args) {\n      //已经存在的原型对象\n      Person person = new Person(\"ls\",new Integer(0),new Double(30.0));\n      //通过拷贝，创建多个原型对象，而不需要直到拷贝的细节\n      Person person1 = (Person)person.clone();\n      Person person2 = (Person)person.clone();\n      Person person3 = (Person)person.clone();\n      Person person4 = (Person)person.clone();\n    }\n  }\n  ```\n\n* 优点：\n\n  * Java自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。\n  * 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。\n\n* 缺点：\n\n  * 需要为**每一个类都配置一个 clone 方法**。\n  * clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。\n  * 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。\n\n* 源码体现：\n\n  * Spring中原型bean的创建，就是原型模式的应用。\n  * Spring中对被的配置是在xml文件中的，此时的配置可以配置类的属性。因此配置中的bean就是原型对象。\n\n  ```xml\n  <bean id=\"person\" class=\"pattern.prototype.Person\" scope=\"prototype\">\n      <property name=\"name\" value=\"ls\"/>\n      <property name=\"age\" value=\"0\"/>\n      <property name=\"weight\" value=\"30\"/>\n    </bean>\n  ```\n\n  * 在Spring中通过上下文获取Bean对象，实际上就是拷贝了bean的原型对象。\n\n  ```java\n  public static void main(String[] args) {\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"application.xml\");\n    Object person7 = applicationContext.getBean(\"person\");\n    System.out.println(person7.toString());\n  }\n  @Override\n  public Object getBean(String name) throws BeansException {\n    return doGetBean(name, null, null, false);\n  }\n  ```\n\n* 拷贝的说明：\n\n  * 浅拷贝：\n\n    * 1) 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。\n    * 2) 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。\n    * 3) Object的clone()方法默认就是使用浅拷贝。\n\n  * 深拷贝：\n\n    * 1) 复制对象的所有基本数据类型的成员变量值。\n    * 2) 为所有**引用数据类型**的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝。\n    * 3）创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。\n    * 深拷贝实现方式1：重写clone方法来实现深拷贝。\n    * 深拷贝实现方式2：通过对象序列化实现深拷贝(推荐)。\n\n    ```java\n    //引用对象：此对象需要实现相应的接口\n    public class DeepCloneableTarget implements Serializable,Cloneable {\n      public String name;\n    \n      private static final long serialVersionUID = 1L;\n    \n      public DeepCloneableTarget(String name) {\n        this.name = name;\n      }\n    \n      @Override\n      protected Object clone() throws CloneNotSupportedException {\n        //因为该类的属性都是基本数据类型和String类型，因此我们使用默认的浅拷贝即可。\n        return super.clone();\n      }\n    }\n    //要复制的对象\n    public class DeepProtoType implements Serializable, Cloneable{\n      public String na;\n      //引用类型属性\n      public DeepCloneableTarget deepCloneableTarget;\n    \n      //深拷贝的实现：方式一使用clone方法\n      @Override\n      protected Object clone() throws CloneNotSupportedException {\n        Object deep = null;\n        //这一步完成对基本数据类型和字符串的拷贝\n        deep = super.clone();\n        //单独处理引用数据类型的拷贝。\n        DeepProtoType deepProtoType = (DeepProtoType) deep;\n        deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();\n        return deepProtoType;\n      }\n      //深拷贝的实现：方式二通过对象序列化实现(推荐)\n      protected Object deepClone(){\n        //创建流对象\n        ByteArrayOutputStream baos = null;\n        ObjectOutputStream oos = null;\n        ByteArrayInputStream bais = null;\n        ObjectInputStream ois = null;\n        try{\n          /**\n           * 说明：在序列化时，内存中处理有这个对象，还有一个含有对象数据的流。\n           * 将这个流反序列化出来的对象，相当于对原有对象的拷贝。\n           */\n    \n          //序列化：将对象转换成流数据\n          baos = new ByteArrayOutputStream();\n          oos = new ObjectOutputStream(baos);\n          oos.writeObject(this);\n    \n          //反序列化：将流数据转换成对象\n          bais = new ByteArrayInputStream(baos.toByteArray());\n          ois = new ObjectInputStream(bais);\n          DeepProtoType deepProtoType = (DeepProtoType)ois.readObject();\n    \n          return deepProtoType;\n        }catch (Exception e){\n          e.printStackTrace();\n          return null;\n        }finally {\n          //关闭流\n          try {\n            baos.close();\n            bais.close();\n            oos.close();\n            ois.close();\n    \n          } catch (IOException e) {\n            e.printStackTrace();\n          }\n    \n        }\n      }\n    }\n    //测试\n      public static void main(String[] args) throws CloneNotSupportedException {\n        //深拷贝\n        DeepProtoType deep = new DeepProtoType();\n        deep.na = \"deep\";\n        deep.deepCloneableTarget = new DeepCloneableTarget(\"sad\");\n      /*  DeepProtoType depp1 = (DeepProtoType)deep.clone();\n        DeepProtoType depp2 = (DeepProtoType)deep.clone();*/\n        DeepProtoType depp1 = (DeepProtoType)deep.deepClone();\n        DeepProtoType depp2 = (DeepProtoType)deep.deepClone();\n        //深拷贝时，拷贝后的hashcode因该是不同的\n        System.out.println(depp1.deepCloneableTarget.hashCode());\n        System.out.println(depp2.deepCloneableTarget.hashCode());\n      }\n    ```\n\n  * 区别：\n\n    * 浅拷贝一般用于进本数据类型和String类型的拷贝。\n    * 深拷贝一般用于除String类型外的所有引用对象的拷贝。\n\n* 原型模式的注意事项和细节：\n\n  * 1) 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。\n  * 2) 不用重新初始化对象，而是动态地获得对象运行时的状态。\n  * 3) 如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码。\n  * 4) 在实现深克隆的时候可能需要比较复杂的代码。\n\n\n\n## 建造者模式\n\n* 建造者模式（Builder Pattern）又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。\n\n* 建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。\n\n* 个人理解：你只需要告诉老板你要怎么组装房子，老板会找对应的建造者来组装这个房子。\n\n* 建造者模式的四个角色：\n\n  * 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。\n  * 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。\n  * 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。\n  * 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。\n\n* 结构图：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210506094832.png)\n\n* 代码：\n\n  * 产品角色：包含多个组成部件的复杂对象。\n\n    ```java\n    public class Product {\n      private String partA;\n      private String partB;\n      private String partC;\n    \n      public void setPartA(String partA) {\n        this.partA = partA;\n      }\n    \n      public void setPartB(String partB) {\n        this.partB = partB;\n      }\n    \n      public void setPartC(String partC) {\n        this.partC = partC;\n      }\n      public void show(){\n        //展示产品\n        System.out.println(partA + \" \" + partB + \" \" + partC);\n      }\n    }\n    ```\n\n  * 抽象建造者：包含创建产品各个子部件的抽象方法。\n\n    ```java\n    public abstract class Builder {\n      //创建产品对象\n      protected Product product = new Product();\n      public abstract void builderPartA();\n      public abstract void builderPartB();\n      public abstract void builderPartC();\n      //返回产品对象\n      public Product getResult(){\n        return product;\n      }\n    }\n    ```\n\n  * 具体建造者：实现了抽象建造者接口。\n\n    ```java\n    public class ConcreteBuilder extends Builder{\n    \n      @Override\n      public void builderPartA() {\n        product.setPartA(\"建造 PartA\");\n      }\n    \n      @Override\n      public void builderPartB() {\n        product.setPartB(\"建造 PartB\");\n      }\n    \n      @Override\n      public void builderPartC() {\n        product.setPartC(\"建造 PartC\");\n      }\n    }\n    ```\n\n  * 指挥者：调用建造者中的方法完成复杂对象的创建。\n\n    ```java\n    public class Director {\n      private Builder builder;\n      public Director(Builder builder){\n        this.builder = builder;\n      }\n      //指挥建造者建造如何组装产品\n      public Product construct(){\n        builder.builderPartA();\n        builder.builderPartB();\n        builder.builderPartC();\n        return builder.getResult();\n      }\n    }\n    ```\n\n  * 客户类。\n\n    ```java\n    public class Client {\n      public static void main(String[] args) {\n        //你想要的组装方式\n        Builder builder = new ConcreteBuilder();\n        //把组装方式告诉指挥者\n        Director director = new Director(builder);\n        //指挥者把组装好的产品给你\n        Product product = director.construct();\n        product.show();\n      }\n    }\n    ```\n\n* 建造者模式在JDK的应用和源码分析：\n\n  * java.lang.StringBuilder中的建造者模式：\n\n    ```java\n    public final class StringBuilder extends AbstractStringBuilder {}\n    abstract class AbstractStringBuilder implements Appendable {}\n    public interface Appendable {}\n    ```\n\n  * 源码中建造者模式角色分析：\n\n    * *Appendable* 接口定义了多个append方法(抽象方法), 即**Appendable* 为抽象建造者, 定义了抽象方法。\n    * *AbstractStringBuilder* 实现了 *Appendable* 接口方法，这里的**AbstractStringBuilder* 已经是建造者，只是不能实例化。\n    * *StringBuilder* 即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由 *AbstractStringBuilder* 完成, 而**StringBuilder* 继承了*AbstractStringBuilder*。\n\n* 建造者模式的注意事项和细节：\n\n  * 1) 客户端(使用程序)**不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象**。\n  * 2) 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， **用户使用不同的具体建造者即可得到不同的产品对象**。\n  * 3) **可以更加精细地控制产品的创建过程** 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。\n  * 4) **增加新的具体建造者无须修改原有类库的代码，**指挥者类针对抽象建造者类编程，系统扩展方便，符合 “开闭原则\"。\n  * 5) 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果**产品之间的差异性很大，则不适合使用建造者模式**，因此其使用范围受到一定的限制。\n  * 6) 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式。\n  * 7) 抽象工厂模式VS建造者模式：\n    * 抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。\n    * 建造者模式唯一区别于工厂模式的是针对复杂对象的创建。也就是说，如果创建**简单对象**，通常都是使用工厂模式进行创建，而如果创建**复杂对象**，就可以考虑使用建造者模式。\n\n* 建造者模式主要适用于以下应用场景：\n\n  * 相同的方法，不同的执行顺序，产生不同的结果。\n  * 多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。\n  * 产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用。\n  * 初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。\n\n","categories":["Java学习","设计模式"]},{"title":"七大设计原则","url":"/2021/04/29/尚硅谷说Java/设计模式/设计七大原则/","content":"\n包含单一职责，接口隔离，依赖倒置，里氏替换，开闭，迪米特，合成复用原则。\n\n<!--more-->\n\n# 简介\n\n* 编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的挑战。\n* 设计模式是为了让程序(软件)，具有更好的\n  * 1) 代码重用性 (即：相同功能的代码，不用多次编写)。\n  * 2) 可读性 (即：编程规范性, 便于其他程序员的阅读和理解)。\n  * 3) 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)。\n  * 4) 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)。\n  * 5) 使程序呈现**高内聚**，**低耦合**的特性。\n* 设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即：**设计模式为什么这样设计的依据**) 。\n* **设计模式常用的七大原则有**:\n  * 1) 单一职责原则：Single Responsibility Principle\n  * 2) 接口隔离原则：Interface Segregation Principle\n  * 3) 依赖倒置(倒转)原则：Dependence Inversion Principle\n  * 4) 里氏替换原则：Liskov Substitution Principle\n  * 5) 开闭原则：Open Closed Principle\n  * 6) 迪米特法则：Law of Demeter\n  * 7) 合成复用原则：Composite Reuse Principle\n* 设计原则核心思想：\n  * 1) 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。\n  * 2) 针对接口编程，而不是针对实现编程。\n  * 3) 为了交互对象之间的松耦合设计而努力。\n\n# 单一职责原则\n\n* 介绍：\n\n  * 对类来说的，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 A1，A2。\n\n* 案例实例：\n\n  * 以交通工具为例\n  * 方案一：\n\n  ```java\n  public class Single1 {\n    public static void main(String[] args) {\n      Vehicle vehicle = new Vehicle();\n      vehicle.run(\"汽车\");\n      //下面的两个交通工具执行后会有不对\n      vehicle.run(\"轮船\");\n      vehicle.run(\"飞机\");\n    }\n  }\n  /**\n   * 方案二的分析：\n   * 方式一：\n   *  1. 在方式一的run方法中，违反了单一职责原则\n   *  2. 解决的方法：根据交通工具运行方法的不同，分解成不同类即可。\n   */\n  class Vehicle{\n    public void run(String vehicle){\n      System.out.println(vehicle + \"在公路上运行\");\n    }\n  }\n  ```\n\n  * 方案二：\n\n  ```java\n  public class Single2 {\n    public static void main(String[] args) {\n      RoadVehicle roadVehicle = new RoadVehicle();\n      roadVehicle.run(\"汽车\");\n      SeaVehicle seaVehicle = new SeaVehicle();\n      seaVehicle.run(\"轮船\");\n      SkyVehicle skyVehicle = new SkyVehicle();\n      skyVehicle.run(\"飞机\");\n    }\n  }\n  /**\n   * 方案二的分析：\n   *  1. 遵循单一职责原则\n   *  2. 但这样做的改动很大，即将类分解的同时，也会修改客户端\n   *  3. 改进：在方案一的基础上，直接修改Vehivle类，分解方法的职责，不分解类。\n   */\n  //公路的交通工具\n  class RoadVehicle{\n    public void run(String vehicle){\n      System.out.println(vehicle + \"在公路上运行\");\n    }\n  }\n  //海上的交通工具\n  class SeaVehicle{\n    public void run(String vehicle){\n      System.out.println(vehicle + \"在海上运行\");\n    }\n  }\n  //天上的交通工具\n  class SkyVehicle{\n    public void run(String vehicle){\n      System.out.println(vehicle + \"在天空上运行\");\n    }\n  }\n  ```\n\n  * 方案三：\n\n  ```java\n  public class Single3 {\n    public static void main(String[] args) {\n      Vehicle2 vehicle2 = new Vehicle2();\n      vehicle2.roadRun(\"汽车\");\n      vehicle2.seaRun(\"轮船\");\n      vehicle2.skyRun(\"飞机\");\n    }\n  }\n  /**\n   * 方案三的分析：\n   *  1. 这个方案虽然没有在类级别上遵循单一职责原则，但在方法级别上遵循了单一职责原则\n   */\n  class Vehicle2{\n    public void roadRun(String vehicle){\n      System.out.println(vehicle + \"在公路上运行\");\n    }\n    public void seaRun(String vehicle){\n      System.out.println(vehicle + \"在海上运行\");\n    }\n    public void skyRun(String vehicle){\n      System.out.println(vehicle + \"在天空上运行\");\n    }\n  }\n  ```\n\n* 说明：\n\n  * 1) 降低类的复杂度，一个类只负责一项职责。\n  * 2) 提高类的可读性，可维护性。\n  * 3) 降低变更引起的风险。\n  * 4) 通常情况下，**我们应当遵守单一职责原则**，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在**方法级别保持单一职责原则**。\n\n# 接口隔离原则\n\n* 介绍：\n  \n  * 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在**最小的接口**上。\n  \n* 案例实例：\n  * 实现：\n    * 类 A 通过接口 Interface1 依赖类 B，但只使用接口的1，2，3方法。\n    * 类 C 通过接口 Interface1 依赖类 D，但只使用接口的1，4，5方法。\n    \n  * 方案一：不遵循接口隔离原则\n  \n    * 关系图\n  \n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210429103026.png)\n  \n    * 代码：\n  \n    ```java\n    public class Segregation1 {\n        public static void main(String[] args) {\n        A a = new A();\n        //A通过接口去依赖B类\n        a.depend1(new B());\n        a.depend2(new B());\n        a.depend3(new B());\n        C c = new C();\n        //C通过接口去依赖D类\n        c.depend1(new D());\n        c.depend4(new D());\n        c.depend5(new D());\n      }\n    }\n    interface Inteface1{\n      void operation1();\n      void operation2();\n      void operation3();\n      void operation4();\n      void operation5();\n    }\n    class B implements Inteface1{\n    \n      @Override\n      public void operation1() {\n        System.out.println(\"B 实现了operation1()方法\");\n      }\n    \n      @Override\n      public void operation2() {\n        System.out.println(\"B 实现了operation2()方法\");\n      }\n    \n      @Override\n      public void operation3() {\n        System.out.println(\"B 实现了operation3()方法\");\n      }\n    \n      @Override\n      public void operation4() {\n        System.out.println(\"B 实现了operation4()方法\");\n      }\n    \n      @Override\n      public void operation5() {\n        System.out.println(\"B 实现了operation5()方法\");\n      }\n    }\n    class D implements Inteface1{\n      @Override\n      public void operation1() {\n        System.out.println(\"D 实现了operation1()方法\");\n      }\n    \n      @Override\n      public void operation2() {\n        System.out.println(\"D 实现了operation2()方法\");\n      }\n    \n      @Override\n      public void operation3() {\n        System.out.println(\"D 实现了operation3()方法\");\n      }\n    \n      @Override\n      public void operation4() {\n        System.out.println(\"D 实现了operation4()方法\");\n      }\n    \n      @Override\n      public void operation5() {\n        System.out.println(\"D 实现了operation5()方法\");\n      }\n    }\n    \n    /**\n     * A通过依赖Inteface1接口，从而使用B类，但只会使用1，2，3方法\n     */\n    class A {\n      public void depend1(Inteface1 inteface1){\n        inteface1.operation1();\n      }\n      public void depend2(Inteface1 inteface1){\n        inteface1.operation2();\n      }\n      public void depend3(Inteface1 inteface1){\n        inteface1.operation3();\n      }\n    }\n    /**\n     * A通过依赖Inteface1接口，从而使用D类，但只会使用1，4，5方法\n     */\n    class C{\n      public void depend1(Inteface1 inteface1){\n        inteface1.operation1();\n      }\n      public void depend4(Inteface1 inteface1){\n        inteface1.operation4();\n      }\n      public void depend5(Inteface1 inteface1){\n        inteface1.operation5();\n      }\n    }\n    ```\n  \n  * 方案二：遵循接口隔离原则\n  \n    * 关系图\n  \n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210429103109.png)\n  \n    * 代码：\n  \n    ```java\n    public class Segregation2 {\n      public static void main(String[] args) {\n        A a = new A();\n        //A通过接口去依赖B类\n        a.depend1(new B());\n        a.depend2(new B());\n        a.depend3(new B());\n        C c = new C();\n        //C通过接口去依赖D类\n        c.depend1(new D());\n        c.depend4(new D());\n        c.depend5(new D());\n      }\n    }\n    \n    interface Inteface1{\n      void operation1();\n    }\n    interface Inteface2{\n      void operation2();\n      void operation3();\n    }\n    interface Inteface3{\n      void operation4();\n      void operation5();\n    }\n    \n    class B implements Inteface1,Inteface2{\n    \n      @Override\n      public void operation1() {\n        System.out.println(\"B 实现了operation1()方法\");\n      }\n    \n      @Override\n      public void operation2() {\n        System.out.println(\"B 实现了operation2()方法\");\n      }\n    \n      @Override\n      public void operation3() {\n        System.out.println(\"B 实现了operation3()方法\");\n      }\n    \n    }\n    \n    class D implements Inteface1,Inteface3{\n      @Override\n      public void operation1() {\n        System.out.println(\"D 实现了operation1()方法\");\n      }\n    \n      @Override\n      public void operation4() {\n        System.out.println(\"D 实现了operation4()方法\");\n      }\n    \n      @Override\n      public void operation5() {\n        System.out.println(\"D 实现了operation5()方法\");\n      }\n    }\n    \n    /**\n     * A通过依赖Inteface1接口，从而使用B类，但只会使用1，2，3方法\n     */\n    class A {\n      public void depend1(Inteface1 inteface1){\n        inteface1.operation1();\n      }\n      public void depend2(Inteface2 inteface2){\n        inteface2.operation2();\n      }\n      public void depend3(Inteface2 inteface2){\n        inteface2.operation3();\n      }\n    }\n    \n    /**\n     * A通过依赖Inteface1接口，从而使用D类，但只会使用1，4，5方法\n     */\n    class C{\n      public void depend1(Inteface1 inteface1){\n        inteface1.operation1();\n      }\n      public void depend4(Inteface3 inteface3){\n        inteface3.operation4();\n      }\n      public void depend5(Inteface3 inteface3){\n        inteface3.operation5();\n      }\n    }\n    ```\n  \n* 方案一到方案二的改进：\n\n  * 类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。\n  * 将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。\n  * 接口Interface1中出现的方法，根据实际情况拆分为三个接口。\n\n# 依赖倒置原则\n\n* 介绍：\n\n  * 依赖倒转原则(**Dependence Inversion Principle**)是指：\n  * 1) 高层模块不应该依赖低层模块，二者都应该依赖其抽象\n  * 2) 抽象不应该依赖细节，细节应该依赖抽象。\n  * 3) 依赖倒转(倒置)的中心思想是面向接口编程。\n  * 4) 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类。\n  * 5) 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。\n\n* 案例实现：\n\n  * 实现：\n\n    * 实现person接收信息的功能\n\n  * 案例一：不遵循依赖倒转原则\n\n    ```java\n    public class Dependecy1 {\n      public static void main(String[] args) {\n        Person person = new Person();\n        person.receive(new Email());\n      }\n    }\n    class Email{\n      public String getInfo(){\n        return \"电子邮件信息：hello world\";\n      }\n    }\n    \n    /**\n     * 方式一的分析：\n     *  1. 如果person类获取的对象是微信，短信等时，或者新增类。此时的person类也要增加相应的方法\n     *  2. 解决思路：引入一个抽象的接口Recipient，表示接收者。让接收者和Person发生依赖。\n     *    这样，Email,微信，短信等都属于接收的范围，它们各自实现Recipient的接口就可以了\n     */\n    class Person{\n      public void receive(Email email){\n        System.out.println(email.getInfo());\n      }\n    }\n    ```\n\n  * 案例二：遵循依赖倒转原则\n\n    ```java\n    public class Dependecy2 {\n      public static void main(String[] args) {\n        Person person = new Person();\n        person.receive(new Email());\n        person.receive(new WeChat());\n      }\n    }\n    interface Recipient{\n      String getInfo();\n    }\n    class Email implements Recipient {\n      @Override\n      public String getInfo(){\n        return \"电子邮件信息：hello world\";\n      }\n    }\n    class WeChat implements Recipient{\n      @Override\n      public String getInfo() {\n        return \"微信信息：hello world\";\n      }\n    }\n    \n    class Person{\n      //此处使用接口的变量，表示对接口的依赖\n      public void receive(Recipient recipient){\n        System.out.println(recipient.getInfo());\n      }\n    }\n    ```\n\n* 依赖关系传递的三种方式\n\n  * 接口传递\n\n    ```java\n    public class Method1 {\n      public static void main(String[] args) {\n        ChangHong changHong = new ChangHong();\n        OpenAndClose openAndClose = new OpenAndClose();\n        openAndClose.open(changHong);\n      }\n    }\n    //方式一：通过接口传递依赖\n    \n    interface IOpenAndClose{ //开关的接口\n      public void open(ITV tv); //抽象方法,接收接口\n    }\n    interface ITV { //ITV 接口\n      public void play();\n    }\n    \n    class ChangHong implements ITV { //ITV的实现类\n      @Override\n      public void play() {\n        System.out.println(\"长虹电视机，打开\");\n      }\n    }\n    class OpenAndClose implements IOpenAndClose{ //开关的实现类\n      //通过接口作为变量传递依赖\n      @Override\n      public void open(ITV tv) {\n        tv.play();\n      }\n    }\n    ```\n\n  * 构造方法传递\n\n    ```java\n    public class Method2 {\n      public static void main(String[] args) {\n        ChangHong changHong = new ChangHong();\n        OpenAndClose openAndClose = new OpenAndClose(changHong);\n        openAndClose.open();\n      }\n    }\n    //方式二：通过构造器传递依赖\n    interface IOpenAndClose { //开关的接口\n      void open(); //抽象方法\n    }\n    \n    interface ITV { //ITV 接口\n      void play();\n    }\n    class ChangHong implements ITV { //ITV的实现类\n      @Override\n      public void play() {\n        System.out.println(\"长虹电视机，打开\");\n      }\n    }\n    class OpenAndClose implements IOpenAndClose {\n      public ITV tv; // 成员\n      //通过构造器传递依赖\n      public OpenAndClose(ITV tv) { \n        this.tv = tv;\n      }\n    \n      @Override\n      public void open() {\n        this.tv.play();\n      }\n    }\n    ```\n\n  * setter方法传递\n\n    ```java\n    public class Method3 {\n      public static void main(String[] args) {\n        ChangHong changHong = new ChangHong();\n        OpenAndClose openAndClose = new OpenAndClose();\n        openAndClose.setTv(changHong);\n        openAndClose.open();\n      }\n    }\n    //方式三：通过setter方法传递依赖\n    interface IOpenAndClose { // 开关的接口\n      void open();\n    \n      void setTv(ITV tv);\n    }\n    \n    interface ITV { // ITV 接口\n      void play();\n    }\n    \n    class OpenAndClose implements IOpenAndClose {\n      private ITV tv;\n    \n      //通过setter方法传递依赖\n      @Override\n      public void setTv(ITV tv) {\n        this.tv = tv;\n      }\n    \n      @Override\n      public void open() {\n        this.tv.play();\n      }\n    }\n    \n    class ChangHong implements ITV {\n      @Override\n      public void play() {\n        System.out.println(\"长虹电视机，打开\");\n      }\n    }\n    ```\n\n* 注意事项和说明：\n\n  * 1) 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好。\n  * 2) 变量的**声明类型尽量是抽象类或接口**, 这样我们的变量引用和实际对象间，就存在 一个**缓冲层**，利于程序扩展和优化。\n  * 3) 继承时遵循里氏替换原则。\n\n# 里氏替换原则\n\n* 问题的提出：OO中的继承性的思考和说明\n\n  * 1) 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。\n  * 2) 继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来**侵入性**，程序的**可移植性降低**，增加对象间的**耦合性**，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。\n  * 3) 问题提出：在编程中，如何正确的使用继承? => **里氏替换原则**。\n\n* 介绍\n\n  * 1) 里氏替换原则(**Liskov Substitution Principle**)在1988年，由麻省理工学院的以为姓里的女士提出的。\n  * 2) 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。\n  * 3) 在使用继承时，遵循里氏替换原则，在子类中**尽量不要重写父类的方法**。\n  * 4) 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过**聚合，组合，依赖** 来解决问题。\n\n* 案例实现\n\n  * 案例一\n\n  ```java\n  public class Case1 {\n    public static void main(String[] args) {\n      A a = new A();\n      System.out.println(\"11-3=\" + a.func1(11,3));\n  \n      System.out.println(\"----------\");\n      B b = new B();\n      //如果未发现B重写了A，此时程序员会还以为使用B调用func1方法，返回的是差\n      System.out.println(\"11-3=\" + b.func1(11,3));\n      System.out.println(\"1+5+9=\" + b.func2(1,5));\n    }\n  }\n  class A{\n    //返回两个数的差\n    public int func1(int num1,int num2){\n      return num1-num2;\n    }\n  }\n  // B继承A，\n  // B增加了一个功能:完成两个数的相加并和9求和\n  class B extends A{\n    //此处的重写可能时无意识的，应当是不对的。\n    @Override\n    public int func1(int a, int b){\n      return a+b;\n    }\n    public int func2(int a,int b){\n      return func1(a,b)+9;\n    }\n  }\n  ```\n\n  * 案例二\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210429150106.png)\n\n  ```java\n  public class Case2 {\n    public static void main(String[] args) {\n      A a = new A();\n      System.out.println(\"11-3=\" + a.func1(11,3));\n  \n      System.out.println(\"----------\");\n      B b = new B();\n      System.out.println(\"11+3=\" + b.func1(11,3));\n      System.out.println(\"1+5+9=\" + b.func2(1,5));\n      //B类使用A类的方法\n      System.out.println(\"1-3=\" + b.func3(11,3));\n    }\n  }\n  //创建一个更基础的基类\n  class Base{\n    //把更基础的方法和成员写到Base类\n  }\n  class A extends Base{\n    //返回两个数的差\n    public int func1(int num1,int num2){\n      return num1-num2;\n    }\n  }\n  //此处B继承Base类，与A类的耦合性就降低了。\n  class B extends Base {\n    public int func1(int a, int b){\n      return a+b;\n    }\n    public int func2(int a,int b){\n      return func1(a,b)+9;\n    }\n    //如果B类想使用A类的方法，就可以使用组合的方式\n    private A a = new A();\n    public int func3(int a,int b){\n      return this.a.func1(a,b);\n    }\n  }\n  ```\n\n* 案例一变成案例二的说明：\n\n  * 1) 我们发现原来运行正常的相减功能发生了错误。原因就是类B无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候。\n  * 2) 通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替。\n\n# 开闭原则\n\n* 基本介绍：\n\n  * 1) 开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则\n  * 2) 一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节。\n  * 3) 当软件需要变化时，尽量**通过扩展**软件实体的行为来实现变化，而**不是通过修改**已有的代码来实现变化。\n  * 4) 编程中遵循其它原则，以及使用设计模式的目的就是遵循**开闭原则**。\n\n* 案例实现：\n\n  * 实现：\n\n    * 实现一个画画的功能。类图如下\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210429153537.png)\n\n    * 基础代码：可以画矩形和圆形。\n\n    ```java\n    public class Case1 {\n      public static void main(String[] args) {\n        GraphicEditor editor = new GraphicEditor();\n        editor.drawShape(new Rectangle());\n        editor.drawShape(new Circle());\n      }\n    }\n    //用于绘画 的工具(使用方)\n    class GraphicEditor {\n      //接收shape对象，然后根据类型来绘制不同的图形\n      public void drawShape(Shape s) {\n        if (s.m_type == 1) {\n          drawRectangle(s);\n        } else if (s.m_type == 2) {\n          drawCircle(s);\n        }\n      }\n    \n      public void drawRectangle(Shape r) {\n        System.out.println(\"矩形\");\n      }\n    \n      public void drawCircle(Shape r) {\n        System.out.println(\"圆形\");\n      }\n    }\n    //图形的基类\n    class Shape {\n      int m_type;\n    }\n    //矩形\n    class Rectangle extends Shape {\n      Rectangle() {\n        super.m_type = 1;\n      }\n    }\n    //圆形\n    class Circle extends Shape {\n      Circle() {\n        super.m_type = 2;\n      }\n    }\n    ```\n\n  * 实现一：添加一个可以画三角形的功能\n\n    ```java\n    //用于绘画 的工具(使用方)\n    class GraphicEditor {\n      //接收shape对象，然后根据类型来绘制不同的图形\n      public void drawShape(Shape s) {\n        if (s.m_type == 1) {\n          drawRectangle(s);\n        } else if (s.m_type == 2) {\n          drawCircle(s);\n        }else if(s.m_type == 3){\n          //新增代码\n          drawTriangle(s);\n        }\n      }\n    \n      public void drawRectangle(Shape r) {\n        System.out.println(\"矩形\");\n      }\n    \n      public void drawCircle(Shape r) {\n        System.out.println(\"圆形\");\n      }\n      //新增绘画三角形\n      public void drawTriangle(Shape r) {\n        System.out.println(\"三角形\");\n      }\n    }\n    //新增三角形\n    class Triangle extends Shape{\n      Triangle(){\n        super.m_type = 3;\n      }\n    }\n    ```\n\n  * 实现二：遵循开闭原则基础上，改进实现一\n\n    ```java\n    public class Case2 {\n      public static void main(String[] args) {\n        GraphicEditor editor = new GraphicEditor();\n        editor.drawShape(new Circle());\n        editor.drawShape(new Rectangle());\n        editor.drawShape(new Triangle());\n      }\n    }\n    //用于绘画 的工具(使用方)\n    class GraphicEditor {\n      //接收shape对象，然后根据类型来绘制不同的图形\n      public void drawShape(Shape s) {\n        s.draw();\n      }\n    \n    }\n    //图形的基类\n    abstract class Shape {\n      int m_type;\n      public abstract void draw();\n    }\n    //矩形\n    class Rectangle extends Shape {\n      Rectangle() {\n        super.m_type = 1;\n      }\n    \n      @Override\n      public void draw() {\n        System.out.println(\"画距形\");\n      }\n    }\n    //圆形\n    class Circle extends Shape {\n      Circle() {\n        super.m_type = 2;\n      }\n      @Override\n      public void draw() {\n        System.out.println(\"画圆形\");\n      }\n    }\n    //只需新增一个类，不需要对原有的实现进行改变\n    class Triangle extends Shape {\n      Triangle(){\n        super.m_type = 3;\n      }\n      @Override\n      public void draw() {\n        System.out.println(\"画三角形\");\n      }\n    }\n    ```\n\n* 说明：\n\n  * 实现一：\n    * 1) 优点是比较好理解，简单易操作。 \n    * 2) 缺点是违反了设计模式的 ocp 原则，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的 时候，尽量不修改代码，或者尽可能少修改代码.。\n    * 3) 比如我们这时要新增加一个图形种类 三角形，我们需要做如下修改，修改的地方较多。\n  * 实现二：\n    * 把创建 **Shape** **类做成抽象类**，并提供一个**抽象的** **draw** 方法，让**子类去实现即可**，这样我们有新的图形 种类时，只需要让新的图形类继承 Shape，并实现 draw 方法即可，**使用方的代码就不需要修** \\-\\> 满足了开闭原则。\n\n# 迪米特原则\n\n* 基本介绍：\n\n  * 1) 一个对象应该对其他对象保持最少的了解。\n  * 2) 类与类关系越密切，耦合度越大。\n  * 3) 迪米特法则(**Demeter Principle**)又叫**最少知道原则**，即一个类**对自己依赖的类知道的越少越好**。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public 方法，不对外泄露任何信息。\n  * 4) 迪米特法则还有个更简单的定义：只与直接的朋友通信。\n  * 5) **直接的朋友**：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现**成员变量**，**方法参数**，**方法返回值**中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，**陌生的类最好不要以局部变量的形式出现在类的内部**。\n\n* 案例实现：\n\n  * 实现：\n\n    * 有一个学校，下属有各个学院和总部，现要求打印出学校总部员工ID和学院员工的id\n\n  * 实现一：不遵循迪米特法则\n\n    ```java\n    public class Case1 {\n      public static void main(String[] args) {\n        SchoolManager manager = new SchoolManager();\n        manager.printAllEmployee(new CollegeManager());\n      }\n    }\n    \n    //学校总部员工类\n    class Employee {\n      private String id;\n    \n      public void setId(String id) {\n        this.id = id;\n      }\n    \n      public String getId() {\n        return id;\n      }\n    }\n    \n    //学院的员工类\n    class CollegeEmployee {\n      private String id;\n    \n      public void setId(String id) {\n        this.id = id;\n      }\n    \n      public String getId() {\n        return id;\n      }\n    }\n    \n    //管理学院员工的管理类\n    class CollegeManager {\n      //返回学院的所有员工\n      public List<CollegeEmployee> getAllEmployee() {\n        List<CollegeEmployee> list = new ArrayList<CollegeEmployee>();\n        for (int i = 0; i < 10; i++) {\n          //这里我们增加了 10 个员工到 list\n          CollegeEmployee emp = new CollegeEmployee();\n          emp.setId(\"学院员工 id= \" + i);\n          list.add(emp);\n        }\n        return list;\n      }\n    }\n    \n    //学校管理类\n    // 分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager\n    // CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则\n    class SchoolManager {\n      //返回学校总部的员工\n      public List<Employee> getAllEmployee() {\n        List<Employee> list = new ArrayList<Employee>();\n        //这里我们增加了 5 个员工到 list\n        for (int i = 0; i < 5; i++) {\n          Employee emp = new Employee();\n          emp.setId(\"学校总部员工 id= \" + i);\n          list.add(emp);\n        }\n        return list;\n      }\n    \n      //该方法完成输出学校总部和学院员工信息(id)\n      public void printAllEmployee(CollegeManager sub) {\n        //分析问题\n        // 1. 这里的 CollegeEmployee 不是 SchoolManager 的直接朋友\n        // 2. CollegeEmployee 是以局部变量方式出现在 SchoolManager\n        //3. 违反了 迪米特法则\n        // 获取到学院员工\n        List<CollegeEmployee> list1 = sub.getAllEmployee();\n        System.out.println(\"------------学院员工------------\");\n        for (CollegeEmployee e : list1) {\n          System.out.println(e.getId());\n        }\n        //获取到学校总部员工\n        List<Employee> list2 = this.getAllEmployee();\n        System.out.println(\"------------学校总部员工------------\");\n        for (Employee e : list2) {\n          System.out.println(e.getId());\n        }\n      }\n    }\n    ```\n\n  * 实现二：遵循迪米特法则\n\n    ```java\n    //管理学院员工的管理类\n    class CollegeManager {\n      //返回学院的所有员工\n      public List<CollegeEmployee> getAllEmployee() {\n        List<CollegeEmployee> list = new ArrayList<CollegeEmployee>();\n        for (int i = 0; i < 10; i++) {\n          //这里我们增加了 10 个员工到 list\n          CollegeEmployee emp = new CollegeEmployee();\n          emp.setId(\"学院员工 id= \" + i);\n          list.add(emp);\n        }\n        return list;\n      }\n    \n      //输出学院员工的信息\n      public void printEmployee() {\n        //获取到学院员工\n        List<CollegeEmployee> list1 = getAllEmployee();\n        System.out.println(\"------------学院员工------------\");\n        for (CollegeEmployee e : list1) {\n          System.out.println(e.getId());\n        }\n      }\n    }\n    \n    //学校管理类\n    // 分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager\n    // CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则\n    class SchoolManager {\n      //返回学校总部的员工\n      public List<Employee> getAllEmployee() {\n        List<Employee> list = new ArrayList<Employee>();\n        //这里我们增加了 5 个员工到 list\n        for (int i = 0; i < 5; i++) {\n          Employee emp = new Employee();\n          emp.setId(\"学校总部员工 id= \" + i);\n          list.add(emp);\n        }\n        return list;\n      }\n    \n      //该方法完成输出学校总部和学院员工信息(id)\n      public void printAllEmployee(CollegeManager sub) {\n        //分析问题\n        //1. 将输出学院的员工方法，封装到 CollegeManager\n        sub.printEmployee();\n        //获取到学校总部员工\n        List<Employee> list2 = this.getAllEmployee();\n        System.out.println(\"------------学校总部员工------------\");\n        for (Employee e : list2) {\n          System.out.println(e.getId());\n        }\n      }\n    }\n    ```\n\n* 说明\n\n  * 1) 前面设计的问题在于SchoolManager中，CollegeEmployee类并不是SchoolManager类的直接朋友 。\n  * 2) 按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。\n\n* 注意事项\n\n  * 1) 迪米特法则的核心是**降低类之间的耦合**\n  * 2) 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， **并不是要求完全没有依赖关系**。\n\n# 合成复用原则\n\n* 要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\n\n* 如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。\n\n* 合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。\n\n* 结构图示意：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210502221606.png)\n\n# 总结\n\n|   设计原则   |                          一句话归纳                          |                    目的                    |\n| :----------: | :----------------------------------------------------------: | :----------------------------------------: |\n|   开闭原则   |                    对扩展开放，对修改关闭                    |            降低维护带来的新风险            |\n| 依赖倒置原则 |              高层不应该依赖低层，要面向接口编程              |          更利于代码结构的升级扩展          |\n| 单一职责原则 |                一个类只干一件事，实现类要单一                |         便于理解，提高代码的可读性         |\n| 接口隔离原则 |              一个接口只干一件事，接口要精简单一              |          功能解耦，高聚合、低耦合          |\n|  迪米特法则  | 不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度 | 只和朋友交流，不和陌生人说话，减少代码臃肿 |\n| 里氏替换原则 | 不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义 |                防止继承泛滥                |\n| 合成复用原则 |       尽量使用组合或者聚合关系实现代码复用，少使用继承       |                降低代码耦合                |","categories":["Java学习","设计模式"]},{"title":"Redis的使用","url":"/2021/04/24/尚硅谷说Java/数据库/redis/","content":"\nRedis命令参考文档：http://redisdoc.com/\n\n<!--more-->\n\n# 第一章：redis入门\n\n### Nosql\n\n* NoSQL：即 Not\\-Only SQL（ 泛指非关系型的数据库），作为关系型数据库的补充。\n\n* 作用：应对基于海量用户和海量数据前提下的数据处理问题。\n\n* 特征：\n\n  * 可扩容，可伸缩\n  * 大数据量下高性能\n  * 灵活的数据模型\n  * 高可用\n\n* 常见 Nosql 数据库：\n\n  * **Redis**\n  * memcache\n  * HBase\n  * MongoDB\n\n* 适用场景\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412123202.png)\n\n## 1.1 简介\n\n* Redis概念：Redis (REmote DIctionary Server) 是用 <font color=\"red\">C 语言</font>开发的一个开源的高性能键值对<font color=\"red\">（key-value）</font>数据库。\n* 特征：\n  * 1.数据间没有必然的关联关系\n  * 2.内部采用单线程机制进行工作\n  * 3.高性能。官方提供测试数据，50个并发执行100000 个请求,读的速度是110000 次/s,写的速度是81000次/s。\n  * 4.多数据类型支持\n    * 字符串类型 string\n    *  列表类型 list\n    * 散列类型 hash\n    * 集合类型 set\n    * 有序集合类型 sorted_set\n  * 5.持久化支持。可以进行数据灾难恢复。\n* Redis的应用\n  * 为热点数据加速查询（主要场景），如热点商品、热点新闻、热点资讯、推广类等高访问量信息\n  * 任务队列，如秒杀、抢购、购票排队等\n  * 即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等\n  * 时效性信息控制，如验证码控制、投票控制等\n  * 分布式数据共享，如分布式集群架构中的 session 分离\n  * 消息队列\n  * 分布式锁\n\n## 1.2 下载安装\n\n* Linux 版（适用于企业级开发）\n  * Redis 高级开始使用\n  * 以4.0 版本作为主版本\n  * 在后面讲解\n* Windows 版本\n  * Redis 入门使用\n  * 以 3.2 版本作为主版本\n  * 下载地址：https://github.com/MSOpenTech/redis/tags\n\n### 安装\n\n* 第一步：打开下载网页：https://github.com/microsoftarchive/redis/releases/tag/win-3.2.100\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412124350.png)\n\n* 第二步：解压到自己想要的位置即可\n\n* 第三步：文件内容介绍\n\n  * redis-server.exe    服务器启动命令\n  *  redis-cli.exe    命令行客户端\n  * redis.windows.conf    redis核心配置文件\n  * redis-benchmark.exe    性能测试工具\n  * redis-check-aof.exe    AOF文件修复工具\n  * redis-check-dump.exe   RDB文件检查工具（快照持久化文件）\n\n### 启动\n\n* 启动Redis服务：双击redis-server.exe即可。启动后出现如下界面\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412125102.png)\n\n* 启动Redis客户端(此处启动的是命令行式的客户端)\n\n  * 双击 redis-cli.exe 文件即可。效果如下图所示\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412125415.png)\n\n  * 既有命令行式客户端，也就有图形化式客户端。\n\n* 安装Redis图形化式客户端\n\n\n\n## 1.3 基本操作\n\n* 对于一个命令行模式的工具，一般我们想要从下面四个方面了解它\n\n  * 功能性命令\n  * 清除屏幕命令\n  * 帮助查询命令\n  * 退出命令\n\n* Redis的功能性命令(基础的)\n\n  * 信息添加操作\n    * 作用：设置key，value数据。当不存在key时添加，存在key时更新。\n    * 命令格式：set key value\n  * 信息查询操作\n    * 作用：根据 key 查询对应的 value，如果不存在，返回（nil） \n    * 命令格式：get key\n  * 示例\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412130624.png)\n\n* Redis的清除屏幕命令\n\n  * 作用：当屏幕有很多代码时，看着很烦，使用此命令能让屏幕恢复为白板状态\n  * 命令格式：clear\n\n* Reids帮助查询命令\n\n  * 作用：获取命令帮助文档，获取群组中所有命令信息。\n  * 命令格式：help 命令名称 /help @组名/ help\n  * 说明：在Redis中很多命令都在一个组中，Reids中有很多组。\n  * 示例：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412131458.png)\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412131510.png)\n\n* Redis退出客户端命令\n\n  * 作用：退出客户端模式。在cmd窗口下会退出此次客户端服务。\n  * 命令格式：quit / exit / Esc键\n\n* Redis退出服务端命令\n\n  * 作用：退出服务端\n  * 命令格式：Ctrl+c / 点击关闭按钮\n\n\n\n# 第二章：redis数据类型\n\n* 首先Redis的数据类型不是固定的。而是在根据需求确定的。\n* 经过过往的发展，目前确定Redis的基本数据类型有5种\n  * string      -->类似于Java的String\n  * hash      -->类似于Java的HashMap\n  * list      -->类似于Java的LinkedList\n  * set      -->类似于Java的HashSet\n  * sorted_set      -->类似于Java的TreeSet\n* Redis的数据存储格式：\n  * redis 自身是一个 Map，其中所有的数据都是采用 key : value 的形式存储\n  * <font color=\"red\">此章节的数据类型</font>指的是存储的数据的类型，也就是 value 部分的类型，key 部分永远都是字符串。\n\n## string类型\n\n* 存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型\n\n* 存储数据的格式：一个存储空间保存一个数据\n\n* 存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用。但实质上存储的还是字符串。\n\n* 基本操作\n\n  * 添加修改数据：*set key value*\n  * 获取数据：*get key*\n  * 删除数据：*del key*\n  * 添加修改多个数据：*mset key1 value1 key2 value2*\n  * 获取多个数据：*mget key1 key2*\n  * 获取数据字符个数(字符串长度)：*strlen key*\n  * 追加信息到原始信息后部(如果原始信息存在就追加，否则新建)：*append key value*\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412135033.png)\n\n* 单数据操作和多数据操作的选择(以三条数据为例)\n\n  * 单指令执行过程：发送三次指令+获取三次返回值+服务器执行三条数据的添加操作。\n  * 多指令执行过程：发送一次指令+获取一次返回值+服务器执行三条数据的添加操作。\n  * 由此看出多指令执行时间比单指令执行时间的区别在于发送指令的时间。\n  * 实际上，通常情况下会选择多指令执行，\n    * 对于少量数据，单指令和多指令差别并不大。\n    * 对于大量数据而言，发送一个多指令是不行的，会发送多次多指令。\n\n* 扩展操作\n\n* 场景一：\n\n  * 问题：在Mysql分表操作中，然后保证主键id的统一性？使用redis来设置主键的值。\n  * 操作一：设置数值数据增加指定范围的值。\n\n  ```shell\n  incr key           --> 将key对应的值增加一个单位的数据\n  incrby key increment --> 将key对应的值增加increment个单位的数据\n  incrbyfloat key increment  --> 将key对应的值增加increment个单位的数据\n  ```\n\n  * 操作二：设置数值数据减少指定范围的值。\n\n  ```shell\n  decr key           --> 将key对应的值增加一个单位的数据\n  decr key increment --> 将key对应的值增加increment个单位的数据\n  ```\n\n  * 说明：\n    * key对应的value必须是数值类型的数据。否则会报错。\n    * 一个单位的数据一般指1，即进行加一减一操作。\n    * increment的只可以为正为负。为负时原来的操作的意义就反过来了。\n    * incrbyfloat操作的increment必须为小数形式。此操作用于浮点数的变换。\n  * 数值操作说明：\n    * string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算。\n    * redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。\n    * 注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。\n    * 最大值为：9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）\n  * 应用场景：\n    * redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性。\n    * 此方案适用于所有数据库，且支持数据库集群。\n\n* 场景二\n\n  * 作用：设置数据具有指定的生命周期。\n\n  ```shell\n  setex key seconds value  -->设置一个key,value的存活时间为几分钟\n  psetex key milliseconds value -->设置一个key,value的存活时间为几秒\n  //例如\n  setex num 10 abc  --> 设置<key,value>为<num,abc>的数据存活时间为10分钟。\n  psetex num 10 abc  -->设置<key,value>为<num,abc>的数据存活时间为10秒\n  ```\n\n  * 说明：\n    * 当设置一个key,value后，在设置这个key的生命周期，则上一次的设置会被清除掉，即不起作用。\n  * 应用场景：\n    * redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作。\n    * 微信投票的账号时效性，热点的时效性。\n\n* 场景三：\n\n  * 问题：主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数与微博数量。\n\n  * 解决方式一：在redis中为大V用户设定用户信息，以用户主键和属性值作为key，后台设定定时刷新策略即可。\n\n    * eg:  user:id :3506728370:fans →12210947\n\n  * 解决方式二：在redis中以json格式存储大V用户信息，定时刷新（也可以使用hash类型）\n\n    * eg: user:id :3506728370 →{\"id\":3506728370,\"name\":\"春晚\",\"fans\":12210862,\"blogs\":6164, \"focus\":83}\n\n  * 说明：此处的key一般有设置的约定。即固定的格式：\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210413133611.png)\n\n  * 应用场景：\n\n    * redis应用于各种结构型和非结构型高热度数据访问加速。\n\n* 注意事项：\n\n  * 数据操作不成功的反馈与数据正常操作之间的差异\n    * 第一种：表示运行结果是否成功\n    * (integer) 0 →false   表示运行失败\n    * (integer) 1 → true   表示运行成功\n    * 第二种：表示运行结果值\n    * (integer) 3 →3   表示结果有3个 \n    * (integer) 1 →1   表示结果有1个\n  * 数据未获取到\n    * （nil）等同于null\n  * 数据最大存储量\n    * 512MB\n  * 数值计算最大范围（java中的long的最大值）\n    * 9223372036854775807\n\n## hash类型\n\n* 引入\n\n  * 上面存粉丝数量时，它的key的前几位一般都用一样。那么是否可以分开存呢？\n  * hash类型提供了这个操作。hash将前面一样的作为key，不同的作为filed，值还是value。\n  * 即原先的<key,value>格式数据变成了<key,filed,value>格式，filed是对key的再细分。\n  * 新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息。\n  * 需要的存储结构：一个存储空间(即key对应的value空间)保存多个键值对数据。\n  * hash类型：底层使用哈希表结构实现数据存储\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210413134700.png)\n\n  * hash存储结构优化：\n    * 如果field数量较少，存储结构优化为类数组结构。\n    * 如果field数量较多，存储结构使用HashMap结构。\n\n* 基本使用：\n\n  * 添加操作：*hset key field value*   ： 添加一个<key,field,value>数据\n  * 获取数据：\n    * *hget key field*   ： 获取此key对应filed再对应的value的值\n    * *hgettall key*   ：获取此key对应的所有filed和value的值\n  * 删除数据：*hdel key field1 [field2]*  ：删除此key对应的<field,value>的值。可以删除多个field。\n  * 添加/修改多个数据：*hmset key field1 value1 field2 value2 …* \n  * 获取多个数据：*hmget key field1 field2 …*\n  * 获取哈希表中字段(即field)的数量：*hlen key*\n  * 获取哈希表中是否存在指定的字段：*hexists  key field*\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210413135951.png)\n\n* 扩展操作：\n\n  * 获取哈希表中所有的字段名或字段值\n\n  ```shell\n  hkeys key  -->获取此key对应的所有的field\n  hvals key  -->获取此key对应的所有的value\n  ```\n\n  * 设置指定字段的数值数据增加指定范围的值（类比string类型的扩展操作）\n\n  ```shell\n  hincrby key field increment\n  hincrbyfloat key field increment\n  ```\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210413141004.png)\n\n* 注意事项：\n\n  * hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（nil） \n  * 每个 hash 可以存储 2^32 - 1 个键值对\n  * hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，切记不可滥用，更不可以将hash作为对象列表使用\n  * hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈\n\n* 场景一：\n\n  * 业务：电商网站购物车设计与实现\n  * 解决方案：\n    *  以客户id作为key，每位客户创建一个hash存储结构存储对应的购物车信息\n    * 将商品编号作为field，购买数量作为value进行存储\n    * 添加商品：追加全新的field与value\n    * 浏览：遍历hash\n    * 更改数量：自增/自减，设置value值 \n    * 删除商品：删除field\n    * 清空：删除key\n    * 商品详细信息作为一个独立的hash类型数据存在。\n  * 额外解决：\n    * 对于每一个用户，在添加用户购物车信息时，会添加对应商品的详细信息进到redis中。\n    * 此时从都添加到redis中，使用hset命令必定会导致重复数据的使用。\n    * **另一个命令**：*hsetnx key field value*  ：当redis的key中不存在此field时插入；存在就不插入。\n  * 应用场景：redis 应用于购物车数据存储设计。\n\n* 场景二：\n\n  * 应用场景：redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计\n\n* 额外：string存储对象（json）与hash存储对象的区别在哪？\n\n  * string存储对象。注重的是对象整体，常用来对对象的添加和删除。偏向于读。\n  * hash存储对象。注重的是对象的属性，常用来对属性的修改。偏向于写。\n\n## list类型\n\n* 数据存储需求：存储多个数据，并对数据**进入存储空间的顺序**进行区分。\n\n* 需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序。\n\n* list类型：保存多个数据，底层使用**双向链表**存储结构实现。\n\n* 基本操作\n\n  * 添加/修改数据\n\n    ```shell\n    # 往链表的头部依次插入value,value2。相当于Java的头插入\n    lpush key value1 [value2] ……\n    # 往链表的尾部依次插入value,value2。相当于Java的尾插入\n    rpush key value1 [value2] ……\n    ```\n\n  * 获取数据\n\n    ```shell\n    # 从左边读取链表，下标从start到stop。都是闭区间\n    # start取值从0开始，\n    # stop也从0开始，但有特殊情况，stop为负时表示倒数第几个。比如为-1表示倒数第一个。\n    # 通常在不知道链表的长度时可以使用lrange key 0 -1来获取链表的数据。但当链表只有一个元素时会返回一个空链表。\n    # start值大于链表长度时会返回一个空链表，start值大于stop值时会将stop的值改为最后的下标。\n    lrange key start stop\n    # 获取指定index下标位置的数据\n    lindex key index\n    # 获取此链表数据的长度\n    llen key\n    ```\n\n  * 获取并移除数据\n\n    ```shell\n    # 移除链表左边的一个数据。返回值为被删除的元素\n    lpop key\n    # 移除链表右边的一个数据。返回值为被删除的元素\n    rpop key\n    ```\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210416153009.png)\n\n* 扩展操作\n\n  * 规定时间内获取并移除数据\n\n    ```shell\n    # 阻塞指定时间内移除链表左边的一个数据。返回值为key和其被移除的数据\n    blpop key1 [key2] timeout\n    # 阻塞指定时间内移除链表左边的一个数据。返回值为key和其被移除的数据\n    brpop key1 [key2] timeout\n    brpoplpush source destination timeout\n    ```\n\n    * 说明：当链表中有数据时，直接移除数据；当链表中没有数据或没有此链表时，会等待指定的时间，如果此时间内此链表中添加了数据，则会在添加操作执行后有方向的移除数据。否则会返回空。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210416154630.png)\n\n  * 移除指定数据\n\n    ```shell\n    # 删除链表中存在的value,删除count次。\n    # count大于0表示从左边开始搜索，\n    # count小于0表示从右边开始搜索，\n    # count=0表示删除全部于value相等的值\n    lrem key count value\n    ```\n\n    * 因此redis 应用于具有操作先后顺序的数据控制\n\n* list 类型数据操作注意事项\n\n  * list中保存的数据都是string类型的，数据总容量是有限的，最多2^32 - 1 个元素 (4294967295)\n  * list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作。\n  * 获取全部数据操作结束索引设置为-1 。\n  * list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载。\n\n* list的应用场景\n\n  * twitter、新浪微博、腾讯微博中个人用户的关注列表需要按照用户的关注顺序进行展示，粉丝列表需要将最近关注的粉丝列在前面\n  * 新闻、资讯类网站如何将最新的新闻或资讯按照发生的时间顺序展示。\n  * 企业运营过程中，系统将产生出大量的运营数据，如何保障多台服务器操作日志的统一顺序输出？\n    * 依赖list的数据具有顺序的特征对信息进行管理。\n    * 使用队列模型解决多路信息汇总合并的问题。\n    * 使用栈模型解决最新消息的问题。\n  * 因此redis 可以应用于最新消息展示。\n\n## set类型\n\n* 新的存储需求：存储大量的数据，在查询方面提供更高的效率。\n\n* 需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询。\n\n* set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210416161810.png)\n\n* 基本操作\n\n  * 添加数据\n\n    ```shell\n    # member1表示数据\n    sadd key member1 [member2]\n    ```\n\n  * 获取全部数据\n\n    ```shell\n    smembers key\n    ```\n\n  * 删除数据\n\n    ```shell\n    srem key member1 [member2]\n    ```\n\n  * 获取集合数据总量\n\n    ```shell\n    scard key\n    ```\n\n  * 判断集合中是否包含指定数据\n\n    ```shell\n    sismember key member\n    ```\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210416162500.png)\n\n* 扩展操作\n\n  * 随机获取集合中指定数量的数据\n\n    ```shell\n    # count不写时，返回一个数据\n    # count大于set的数据量时，返回全部数据\n    # count小于0时，返回以count长度的数组，数组元素中可以重复。\n    srandmember key [count]\n    ```\n\n  * 随机获取集合中的某个数据并将该数据移出集合\n\n    ```shell\n    spop key [count]\n    ```\n\n  * 求两个集合的交、并、差集\n\n    ```shell\n    sinter key1 [key2] \n    sunion key1 [key2] \n    # 差集表示为key1-key2的差\n    sdiff key1 [key2]\n    ```\n\n  * 求两个集合的交、并、差集并存储到指定集合中\n\n    ```shell\n    # destination为目标集合，即要存储到哪个集合中\n    sinterstore destination key1 [key2] \n    sunionstore destination key1 [key2] \n    sdiffstore destination key1 [key2]\n    ```\n\n  * 将指定数据从原始集合中移动到目标集合中\n\n    ```shell\n    # source表示原始集合。整个作用相当于删除source中的member并将其添加到destination中\n    smove source destination member\n    ```\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210416164407.png)\n\n* 应用场景\n\n  * 每位用户首次使用今日头条时会设置3项爱好的内容，但是后期为了增加用户的活跃度、兴趣点，必须让用户对其他信息类别逐渐产生兴趣，增加客户留存度，如何实现？\n    * 系统分析出各个分类的最新或最热点信息条目并组织成set集合。\n    * 随机挑选其中部分信息。\n    * 配合用户关注信息分类中的热点信息组织成展示的全信息集合。\n  * 因此redis 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等。\n  * redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索\n  * 显示共同关注（一度）\n  * 显示共同好友（一度）\n  * 由用户A出发，获取到好友用户B的好友信息列表（一度）\n  * 由用户A出发，获取到好友用户B的购物清单列表（二度）\n  * 由用户A出发，获取到好友用户B的游戏充值列表（二度）\n  * redis 应用于同类型数据的快速去重(网站的访问量)。\n  * redis 应用于基于黑名单与白名单设定的服务控制。\n\n* set 类型数据操作的注意事项\n\n  *  set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份。\n  * set 虽然与hash的存储结构相同，但是无法启用hash中存储值的空间。\n\n## sorted_set类型\n\n* 新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式。\n* 需要的存储结构：新的存储模型，可以保存可排序的数据。\n* sorted_set类型：在set的存储结构基础上添加可排序字段。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417084422.png)\n\n* 基本操作\n\n  * 添加数据\n\n    ```shell\n    # 添加<key,member><score>格式的数据，其中member最为key的值，score作为此键值对排序的依据\n    zadd key score1 member1 [score2 member2]\n    ```\n\n  * 获取全部数据\n\n    ```shell\n    # 正向遍历sorted_set,数据结果中不含有score数据。\n    # 如果需要查看score数据，则需要加上 WITHSCORES\n    zrange key start stop [WITHSCORES]\n    # 逆向遍历sorted_set数据\n    zrevrange key start stop [WITHSCORES]\n    ```\n\n  * 删除数据\n\n    ```shell\n    # 根据<key,score>删除数据\n    zrem key member [member ...]\n    ```\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417085519.png)\n\n  * 按条件获取数据\n\n    ```shell\n    # 按照score在[min,max]之间的正向输出结果。\n    # limit和数据库的limit操作相同，格式：limit index num。表示从index开始取num个\n    zrangebyscore key min max [WITHSCORES] [LIMIT]\n    # 逆向按照score在[max,min]之间输出结果。\n    zrevrangebyscore key max min [WITHSCORES]\n    ```\n\n  * 条件删除数据\n\n    ```shell\n    # 删除索引位置在[start,stop]的数据\n    zremrangebyrank key start stop\n    # 删除score在[min,max]之间的数据\n    zremrangebyscore key min max\n    ```\n\n    * min与max用于限定搜索查询的条件(全部为闭区间)。\n    * start与stop用于限定查询范围，作用于索引，表示开始和结束索引\n    * offset与count用于限定查询范围，作用于查询结果，表示开始位置和数据总量\n\n  * 获取集合数据总量\n\n    ```shell\n    zcard key\n    # 获取集合在[min,max]之间的数据的总量\n    zcount key min max\n    ```\n\n  * 集合交、并操作\n\n    ```shell\n    # 取集合中member的交集。numkeys表示集合的个数，一定要指明。\n    # 交集后的score值默认为相加后的值，也可以改加为其他操作，比如取交集后score的最大值作为新集合的score值。\n    zinterstore destination numkeys key [key ...]\n    zunionstore destination numkeys key [key ...]\n    ```\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417092359.png)\n\n* 扩展操作\n\n  * 获取数据对应的索引（排名）\n\n    ```shell\n    # 正向获取此member的索引\n    zrank key member\n    # 逆向获取\n    zrevrank key member\n    ```\n\n  * score值获取与修改\n\n    ```shell\n    # 将member的score值加一\n    zscore key member\n    # 将member的score值加increment。increment可以是负数\n    zincrby key increment member\n    ```\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417093828.png)\n\n* 注意事项\n\n  * score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992\n  * score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时候要慎重。\n  * sorted_set 底层存储还是基于set结构的，因此数据不能重复，如果重复添加相同的数据，score值将被反复覆盖，保留最后一次修改的结果。\n\n* 应用场景\n\n  * redis 应用于定时任务执行顺序管理或任务过期管理\n  * redis 应用于即时任务/消息队列执行管理\n\n## redis的解决方案列表\n\n* Tips 1：redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性\n* Tips 2：redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作\n* Tips 3：redis应用于各种结构型和非结构型高热度数据访问加速\n* Tips 4：redis 应用于购物车数据存储设计\n* Tips 5：redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计\n* Tips 6：redis 应用于具有操作先后顺序的数据控制\n* Tips 7：redis 应用于最新消息展示\n* Tips 8：redis 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等\n* Tips 9：redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索\n* Tips 10：redis 应用于同类型不重复数据的合并、取交集操作\n* Tips 11：redis 应用于同类型数据的快速去重\n* Tips 12：redis 应用于基于黑名单与白名单设定的服务控制\n* Tips 13：redis 应用于计数器组合排序功能对应的排名\n* Tips 14：redis 应用于定时任务执行顺序管理或任务过期管理\n* Tips 15：redis 应用于及时任务/消息队列执行管理\n* Tips 16：redis 应用于按次结算的服务控制\n* Tips 17：redis 应用于基于时间顺序的数据操作，而不关注具体时间\n\n\n\n# 第三章：通用指令\n\n## key通用指令\n\n* key特征：key是一个字符串，通过key获取redis中保存的数据。\n\n* key应该设计哪些操作？\n\n  * 对于key自身状态的相关操作，例如：删除，判定存在，获取类型等\n  * 对于key有效性控制相关操作，例如：有效期设定，判定是否有效，有效状态的切换等\n  * 对于key快速查询操作，例如：按指定策略查询key\n\n* 基本操作\n\n  * 删除指定key\n\n    ```shell\n    del key\n    ```\n\n  * 获取key是否存在\n\n    ```shell\n    exists key\n    ```\n\n  * 获取key的类型\n\n    ```shell\n    type key\n    ```\n\n* 扩展操作（时效性控制）\n\n  * 为指定key设置有效期\n\n    ```shell\n    expire key seconds\n    pexpire key milliseconds\n    # timestamp表示时间戳，以秒为单位\n    expireat key timestamp\n    pexpireat key milliseconds-timestamp\n    ```\n\n  * 获取key的有效时间\n\n    ```shell\n    # 返回值有三种类型：大于0表示剩余有效时间，-1表示当前key是永久存在的，-2表示当前key不存在\n    # 返回时间以秒为单位\n    ttl key\n    # 返回时间以毫秒为单位\n    pttl key\n    ```\n\n  * 切换key从时效性转换为永久性\n\n    ```shell\n    persist key\n    ```\n\n* 扩展操作（查询模式）\n\n  ```shell\n  keys pattern\n  ```\n\n  * 查询模式规则（正则匹配）\n\n    ```shell\n    * 匹配任意数量的任意符号 \n    ? 配合一个任意符号 \n    [] 匹配一个指定符号\n    ```\n\n  * 例如\n\n    ```shell\n    keys *           查询所有\n    keys it*         查询所有以it开头\n    keys *heima      查询所有以heima结尾\n    keys ??heima     查询所有前面两个字符任意，后面以heima结尾\n    keys user:?      查询所有以user:开头，最后一个字符任意\n    keys u[st]er:1   查询所有以u开头，以er:1结尾，中间包含一个字母，s或t\n    ```\n\n* 其他操作\n\n  * 为key改名\n\n    ```shell\n    # 如果newkey已存在，则将key的数据添加到newkey中。但要注意类型匹配\n    rename key newkey\n    # 如果newkey不存在，重名名才成功\n    renamenx key newkey\n    ```\n\n  * 对key的value排序\n\n    ```shell\n    # 排序只能排list,set或sorted_set类型的数据\n    # 排序并不会影响原来key中的数据，排序后的数据会作为返回值给出\n    sort\n    ```\n\n  * key的常用操作的帮助文档\n\n    ```shell\n    help @generic\n    ```\n\n## 数据库通用指令\n\n* key重复问题\n\n  * key是由程序员定义的。\n  * redis在使用过程中，伴随着操作数据量的增加，会出现大量的数据以及对应的key。\n  * 数据不区分种类、类别混杂在一起，极易出现重复或冲突。\n\n* 解决方案\n\n  *  redis为每个服务提供有16个数据库，编号从0到15。\n  * 每个数据库之间的数据相互独立。\n\n* 基本操作\n\n  * 切换数据库\n\n    ```shell\n    # index从0到15\n    select index\n    ```\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417105037.png)\n\n  * 其他操作\n\n    ```shell\n    # 退出客户端，关闭客户端和服务器的连接\n    quit\n    # 测试是否能连接上服务器\n    ping\n    # 打印消息\n    echo message\n    ```\n\n  * 数据移动\n\n    ```shell\n    # 移动当前库中的key到db库中。db表示为0到15，为库的编号\n    move key db\n    ```\n\n  * 数据清除\n\n    ```shell\n    # 查看当前库中的数据的个数，即key的个数\n    dbsize\n    # 删除当前库中的数据\n    flushdb\n    # 删除所有库中的数据。删库跑路。\n    flushall\n    ```\n\n\n\n# 第四章：jedis\n\n## 简介\n\n* jedis是编程语言连接redis数据库的中间桥梁。类比于JDBC是作用。\n* 和jedis相同的其他工具有：\n  * SpringData Redis\n  * Lettuce\n* jedis适用于多种语言\n  * C 、C++ 、C# 、Erlang、Lua 、Objective-C 、Perl 、PHP 、Python 、Ruby 、Scala\n\n## 连接redis\n\n* 准备工作\n\n  * jar包导入方式\n\n    * 下载地址：https://plumriver.lanzous.com/iTZHco7gc9i\n\n  * maven依赖方式\n\n    ```xml\n    <dependency>\n     <groupId>redis.clients</groupId>\n     <artifactId>jedis</artifactId>\n     <version>2.9.0</version>\n    </dependency>\n    ```\n\n  * API使用文档：https://www.javadoc.io/doc/redis.clients/jedis\n\n* 操作\n\n  ```java\n  import redis.clients.jedis.Jedis;\n  public class JedisTest {\n    @Test\n    public void testContention(){\n      //1.连接redis\n      Jedis redis = new Jedis(\"localhost\", 6379);\n      //2.操作redis\n      //Jedis类中提供的方法名和redis的操作大致都相同，这很方便我们使用它\n      redis.set(\"name\", \"ls\");\n      String name = redis.get(\"name\");\n      System.out.println(name);\n      //3.关闭连接\n      redis.close();\n    }\n  }\n  ```\n\n## 使用jedis读写redis数据\n\n* 简单的体验\n\n  ```java\n  @Test\n  public void testList(){\n    //1.连接redis\n    Jedis redis = new Jedis(\"localhost\", 6379);\n    //2.操作redis\n    redis.del(\"list1\");\n    redis.lpush(\"list1\",\"a\",\"b\",\"c\");\n    redis.rpush(\"list1\",\"d\",\"e\");\n    List<String> list1 = redis.lrange(\"list1\", 0, -1);\n    for (String s : list1) {\n      System.out.println(s);\n    }\n  \n    //3.关闭连接\n    redis.close();\n  }\n  @Test\n  public void testHash(){\n    //1.连接redis\n    Jedis redis = new Jedis(\"localhost\", 6379);\n    //2.操作redis\n  \n    redis.hset(\"user\",\"name\",\"ls\");\n    redis.hset(\"user\",\"age\",\"18\");\n  \n    Map<String, String> map = redis.hgetAll(\"user\");\n    for (String s : map.keySet()) {\n      System.out.println(map.get(s));\n    }\n  \n    //3.关闭连接\n    redis.close();\n  }\n  ```\n\n\n## jedis简易化工具开发\n\n**基于连接池技术获取**\n\n* JedisPool：Jedis提供的连接池技术\n\n  * poolConfig: 连接池配置对象\n  * host: redis服务地址\n  * port: redis服务端口号\n\n  ```java\n  private static JedisPool jedisPool = null;\n  static{\n    JedisPoolConfig jpc = new JedisPoolConfig();\n    //设置最大连接数量\n    jpc.setMaxTotal(30);\n    //设置最大空闲数量\n    jpc.setMaxIdle(10);\n    String host = \"localhost\";\n    int port = 6379;\n    jedisPool = new JedisPool(jpc,host,port);\n  }\n  \n  public static Jedis getJedis(){\n    return jedisPool.getResource();\n  }\n  ```\n\n**封装连接参数**\n\n* 使用类是jdbc配置文件的redis.properties\n\n  ```properties\n  jedis.host=localhost\n  jedis.port=6379\n  jedis.maxTotal=30\n  jedis.maxIdle=10\n  ```\n\n  ```java\n  private static JedisPool jedisPool = null;\n    static {\n      ResourceBundle rb = ResourceBundle.getBundle(\"redis\");\n      String host = rb.getString(\"redis.host\");\n      int port = Integer.parseInt(rb.getString(\"redis.port\"));\n      int maxTotal = Integer.parseInt(rb.getString(\"redis.maxTotal\"));\n      int maxIdle = Integer.parseInt(rb.getString(\"redis.maxIdle\"));\n      JedisPoolConfig jpc = new JedisPoolConfig();\n      jpc.setMaxTotal(maxTotal);\n      jpc.setMaxIdle(maxIdle);\n  \n      jedisPool = new JedisPool(jpc,host,port);\n    }\n  \n  public static Jedis getJedis(){\n    return jedisPool.getResource();\n  }\n  ```\n\n## 可视化客户端\n\nRedisDesktopManager的安装\n\n* 下载地址：https://plumriver.lanzous.com/iZuUyo7s8gd\n\n* 连接redis\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417163442.png)\n\n* 连接后的界面\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417163450.png)\n\n\n\n# 第五章：linux环境安装\n\n* linux-centos7下载地址：https://www.cnblogs.com/renlywen/p/13423722.html\n\n* VB安装centos方法：https://blog.csdn.net/u013826105/article/details/100175510\n\n* 准备工作：\n\n  * 安装wget工具：yum -y install wget\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418145928.png)\n\n  * 安装gcc工具：yum install gcc-c++ -y\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418150046.png)\n\n* Redis的安装：\n\n  * 下载安装包：wget http://download.redis.io/releases/redis-4.0.0.tar.gz\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418150410.png)\n\n  * 解压：tar -xvf redis-4.0.0.tar.gz\n\n  * 进入解压后的文件下：cd redis-4.0.0\n  * 编译并安装：make install\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418150628.png)\n\n  * 出现的错误：未装wget,未装gcc，make  distclean 清除编译残留文件\n\n* Redis服务和客户端的启动\n\n  * 默认配置启动\n\n  ```\n  # 默认端口启动\n  redis-server\n  redis-server --port 6379\n  # 指定端口启动\n  redis-server --port 6380 ……\n  ```\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418150745.png)\n\n  * Redis客户端连接\n\n  ```\n  # 默认连接\n  redis-cli\n  # 连接指定服务器\n  redis-cli -h 127.0.0.1\n  redis-cli –port 6379\n  redis-cli -h 127.0.0.1 –port 6379\n  ```\n\n* 使用配置文件文件启动服务\n\n  * 查看配置文件。默认的配置文件为redis.conf。在redis目录下。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210419095202.png)\n\n  * redsi.conf默认配置\n    * *cat redis.conf | grep -v \"#\" | grep -v \"^$\"*：查看此文件并去掉文件中的注释和空行\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210419095707.png)\n\n  * 修改配置文件\n\n    * 一般我们都不在源文件上修改，而是复制一个文件，在复制后的文件上修改。\n\n    ```\n    cat redis.conf | grep -v \"#\" | grep -v \"^$\" > redis-6379.conf\n    ```\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210419100017.png)\n\n    * 修改redis-6379.conf配置文件\n\n    ```\n    # 端口号\n    port 6379\n    # 表明当前服务是否是一个守护线程。为yes是不会打印日志信息，后台启动形式；为no时会打印日志信息\n    daemonize yes\n    # 生成的日志文件存放的位置。\n    logfile \"6379.log\"\n    # 设定当前服务文件保存位置，包含日志文件、持久化文件等。放在data目录下(先创建data目录)。\n    dir /redis-4.0.0/data\n    ```\n\n    * 启动。通过客户端连接测试也通过了\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210419104629.png)\n\n  * 创建配置文件管理目录\n\n    ```\n  mkdir conf\n    或\n    mkdir config\n    ```\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210419105312.png)\n\n  * 创建数据文件管理目录\n\n    ```\n  mkdir data\n    ```\n    \n  * 指定配置文件启动\n\n    ```\n  redis-server redis.conf\n    redis-server redis-6379.conf\n    redis-server redis-6380.conf ……\n    redis-server conf/redis-6379.conf\n  redis-server config/redis-6380.conf ……\n    ```\n\n* Redis基础环境设置\n\n  * 创建软连接\n\n    ```shell\n    ln -s 原始目录名 快速访问目录名\n    ```\n\n\n\n# 第六章：redis持久化\n\n## 简介\n\n* 利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。\n\n* 持久化的目的：防止数据的意外丢失，确保数据安全性。\n\n* 持久化保存的数据\n\n  * 将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据\n  * 将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210419110126.png)\n\n## RDB\n\n### 第一种启动命令\n\n* 简介：是redis操作者在任何时间都可以保存数据。\n\n  * 保存数据的文件名为dump.rdb。保存位置为配置文件的dir设置的目录下。\n\n* 基础命令\n\n  * 手动的保存一次数据\n\n  ```\n  save\n  ```\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420101011.png)\n\n* 相关配置。配置设置在.conf文件下\n\n  * *dbfilename dump.rdb*\n    * 说明：设置本地数据库文件名，默认值为 dump.rdb\n    * 经验：通常设置为**dump****-端口号.rdb**\n  * *dir*\n    * 说明：设置存储.rdb文件的路径\n    * 经验：通常设置成存储空间较大的目录中，上面配置时已经设置为data\n  * *rdbcompression yes*\n    * 说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩\n    * 经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）\n  * *rdbchecksum yes*\n    * 说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行\n    * 经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420102046.png)\n\n* save指令工作原理\n\n  * 由于redis在此版本中是单线程的，而且save指令会占用一定的CPU。\n  * save指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用。\n\n\n### 第二种启动命令\n\n* 目的：解决**数据量过大，单线程执行方式造成效率过低的问题**\n\n* 使用方式：redis操作者发起指令，redis在合理的时间执行，执行保存数据。简而言之就是后台执行。\n\n* 命令作用：手动启动，在后台保存。不是立即执行\n\n  ```\n  bgsave\n  ```\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420103829.png)\n\n  * 后台执行的结果可以在日志中查看\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420103857.png)\n\n* 工作原理\n\n  *  bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用。\n  * 实质上是在接收到命令后，开启了子线程来执行保存操作\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420104023.png)\n\n* 相关配置\n\n  * *stop-writes-on-bgsave-error yes*\n  * 说明：后台存储过程中如果出现错误现象，是否停止保存操作\n  * 经验：通常默认为开启状态\n\n### 第三种启动命令\n\n* 目的：**解决反复执行保存指令，忘记了怎么办？不知道数据产生了多少变化，何时保存？**\n\n* 使用方式：redis操作者发起指令，当满足一定条件，执行保存操作。\n\n* 启动方式：使用配置来达成操作\n\n  * 配置 :  \n\n    ```\n    # second：监控时间范围\n    # changes：监控key的变化量\n    save second changes\n    ```\n\n  * 作用：满足限定时间范围内key的变化数量达到指定数量即进行持久化\n\n  * 位置：在.conf配置文件种配置\n\n  * 示例：\n\n    ```\n    # 在900秒内数据发生了一次变化\n    save 900 1 \n    # 在300秒没数据发生了一次变化\n    save 300 10\n    # 在60秒内，数据发生了10000次变化\n    save 60 10000\n    ```\n\n* 工作原理\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420105657.png)\n\n* 注意点：\n\n  *  save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的。\n  * save配置中对于second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系\n  * save配置启动后执行的是bgsave操作。\n\n### 对比\n\n|  **方式** | **save指令** | **bgsave指令** |\n| ---- | ---- | ---- |\n|  读写 | 同步 | 异步    |\n|  阻塞客户端指令 | 是 | 否    |\n| 额外内存消耗 | 否 | 是   |\n|  启动新进程 | 否 | 是    |\n\n### 特殊的启动方式\n\n* 全量复制：在后面\n\n* 服务运行过程中重启，会自动执行保存命令\n\n  ```\n  debug reload\n  ```\n\n* 关闭客户端服务器时保存数据\n\n  ```\n  # 指定保存数据或不保存数据\n  shutdown save/nosave\n  ```\n\n  * 默认情况下执行shutdown命令时，自动执行bgsave(如果没有开启AOF持久化功能)\n\n### 总结\n\n* 优点：\n  * RDB是一个紧凑压缩的二进制文件，存储效率较高\n  * RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景\n  * RDB恢复数据的速度要比AOF快很多\n  * 应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。\n* 缺点：\n  * RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据\n  * bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能\n  * Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象.\n\n## AOF\n\n### 简介\n\n* RDB存储的弊端\n  *  存储数据量较大，时间效率较低。基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低\n  * 大数据量下的IO性能较低\n  * 基于fork创建子进程，内存产生额外消耗\n  * 宕机带来的数据丢失风险\n* 解决思路\n  * 不写全数据，仅记录部分数据\n  * 降低区分数据是否改变的难度，改记录数据为记录操作过程\n  * 对所有操作均进行记录，排除丢失数据的风险\n* **AOF(append only file)持久化**：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程。\n* AOF的主要作用是**解决了数据持久化的实时性**，目前已经是Redis持久化的主流方式\n\n### AOF写策略\n\n* AOF写的过程\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420111603.png)\n\n* 三种写策略\n\n  *  always(每次）\n    * 每次写入操作均同步到AOF文件中，<font color=\"red\">数据零误差，性能较低</font>，不建议使用。 \n  * everysec（每秒）\n    * 每秒将缓冲区中的指令同步到AOF文件中，<font color=\"red\">数据准确性较高，性能较高</font>，建议使用，也是默认配置。在系统突然宕机的情况下丢失1秒内的数据。（存在aof缓冲区）\n  * no（系统控制）\n    * 由操作系统控制每次同步到AOF文件的周期，整体过程<font color=\"red\">不可控</font>\n\n### AOF功能的开启\n\n* 第一步：该配置\n\n  * 配置\n\n    ```\n    appendonly yes|no\n    ```\n\n  * 作用：是否开启AOF持久化功能，默认为不开启状态\n\n* 第二步：配置写策略\n\n  * 配置\n\n  ```\n  appendfsync always|everysec|no\n  ```\n\n  * 作用：AOF写数据策略\n\n* aof文件所在的位置\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420160145.png)\n\n* 相关的配置\n\n  * 作用：AOF持久化文件名，默认文件名未appendonly.aof，建议配置为appendonly-端口号.aof\n\n    ```\n    appendfilename filename\n    ```\n\n  * 作用：AOF持久化文件保存路径，与RDB持久化文件保持一致即可\n  \n    ```\n    dir\n    ```\n\n### AOF重写\n\n* 随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将对同一个数据的若干个条命令执行结果转化成最终结果数据对应的指令进行记录。\n\n* 作用：\n\n  * 降低磁盘占用量，提高磁盘利用率\n  * 提高持久化效率，降低持久化写时间，提高IO性能\n  * 降低数据恢复用时，提高数据恢复效率\n\n* 重写效果示意图\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420160950.png)\n\n* 重写规则\n\n  * 进程内已超时的数据不再写入文件\n  * 忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令\n    * 如del key1、 hdel key2、srem key3、set key4 111、set key4 222等 \n  * 对同一数据的多条写命令合并为一条命令\n    * 如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c。\n    * 为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素\n\n* 重写方式：\n\n  * 手动重写指令\n\n    ```\n    # bg开头表示是系统后台运行的\n    bgrewriteaof\n    ```\n\n    * 重写工作原理的RDB的bgsave原理相似。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420161857.png)\n\n  * 自动重写配置\n\n    * 自动重写触发条件设置(可以任选一个配置，也可以两个都配置)\n\n    ```\n    # 自动重写的文件大小，当达到最小值就重写\n    auto-aof-rewrite-min-size size\n    # 自动重写的百分比，达到百分比后就重写\n    auto-aof-rewrite-percentage percent\n    ```\n\n    * 自动重写触发对比参数( 客户端运行指令info Persistence获取运行属性值)\n\n    ```\n    # 当前缓冲中aof文件的大小，在运行时获取\n    aof_current_size\n    # aof文件的基础大小\n    aof_base_size\n    ```\n\n    * 自动重写触发条件\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420163258.png)\n\n* 重写的工作原理\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420164118.png)\n\n* AOF缓冲区同步文件策略：由参数appendfsync控制\n\n  * write操作会触发延迟写（delayed write）机制，Linux在内核提供页缓冲区用来提高硬盘IO性能。write操作在写入系统缓冲区后直接返回。同步硬盘操作依赖于系统调度机制，列如：缓冲区页空间写满或达到特定时间周期。同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。\n  * fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞知道写入硬盘完成后返回，保证了数据持久化。\n  * 除了write、fsync、Linx还提供了sync、fdatasync操作，具体API说明参见：\n\n## RDB和AOF的区别\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420164403.png)\n\n* 对数据非常敏感，建议使用默认的AOF持久化方案\n  * AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。\n  * 注意：由于AOF文件存储体积较大，且恢复速度较慢\n* 数据呈现阶段有效性，建议使用RDB持久化方案\n  * 数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段点数据恢复通常采用RDB方案。\n  * 注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，\n* 综合比对\n  * RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊。\n  * 如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF。\n  * 如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB。\n  * 灾难恢复选用RDB。\n  * 双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量。\n\n## 应用场景\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420164436.png)\n\n\n\n# 第七章：redis事务\n\n## 事务\n\n* 简介：\n\n  * redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性按照添加顺序依次执行，中间不会被打断或者干扰。\n  * 一个队列中，一次性、顺序性、排他性的执行一系列命令。\n\n* Redis事务实现的方式：\n\n  * 存在两个标记位multi和exec，标记位范围内的命令被组合成一个事务。\n\n* 基本操作\n\n  * 开启事务\n\n    ```\n    multi\n    ```\n\n    * 作用：设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中\n\n  * 执行事务\n\n    ```\n    exec\n    ```\n\n    * 作用：设定事务的结束位置，同时执行事务。与multi成对出现，成对使用\n\n  * 取消事务\n\n    ```\n    discard\n    ```\n\n    * 作用：终止当前事务的定义，发生在multi之后，exec之前\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420171134.png)\n\n* 注意：<font color=\"red\">加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行</font>\n\n* 事务的工作流程\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420171445.png)\n\n* 注意事项\n\n  * **定义事务的过程中，命令格式输入错误怎么办？**\n    * 语法错误：指命令书写格式有误\n    * 处理结果：如果定义的事务中所包含的命令存在语法错误，整体事务中所有命令均不会执行。包括那些语法正确的命令。\n  * **定义事务的过程中，命令执行出现错误怎么办？**\n    * 运行错误：指命令格式正确，但是无法正确的执行。例如对list进行incr操作。\n    * 处理结果：能够正确运行的命令会执行，运行错误的命令不会被执行。\n  * 注意：已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚。\n\n* 事务回滚\n\n  * redis不提供自动回滚操作\n  * 使用手动回滚\n    * 记录操作过程中被影响的数据之前的状态。\n    * 设置指令恢复所有的被修改的项。\n\n## 锁\n\n### 场景一：监视锁\n\n* 业务场景\n\n  * 天猫双11热卖过程中，对已经售罄的货物追加补货，4个业务员都有权限进行补货。补货的操作可能是一系列的操作，牵扯到多个连续操作，如何保障不会重复操作？\n\n* 业务分析\n\n  * 多个客户端有可能同时操作同一组数据，并且该数据一旦被操作修改后，将不适用于继续操作\n  * 在操作之前锁定要操作的数据，一旦发生变化，终止当前操作\n\n* 解决方案\n\n  * 对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行\n\n    ```\n    watch key1 [key2……]\n    ```\n\n  * 取消对所有 key 的监视\n\n    ```\n    unwatch\n    # 当exec执行命令后，事务中的监视锁会被取消。\n    # 当执行discard命令时，也会取消对所有key的监视。\n    ```\n\n  * 应用场景：redis 应用基于状态控制的批量任务执行\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420173211.png)\n\n### 场景二：分布式锁/同步锁\n\n* 业务场景\n\n  * 天猫双11热卖过程中，对已经售罄的货物追加补货，且补货完成。客户购买热情高涨，3秒内将所有商品购买完毕。本次补货已经将库存全部清空，如何避免最后一件商品不被多人同时购买？【超卖问题】\n\n* 业务分析\n\n  * 使用watch监控一个key有没有改变已经不能解决问题，此处要监控的是具体数据\n  * 虽然redis是单线程的，但是多个客户端对同一数据同时进行操作时，如何避免不被同时修改？\n\n* 解决方案\n\n  * 使用 setnx 设置一个公共锁\n\n    ```\n    # lock-key为锁的名字\n    setnx lock-key value\n    # 实际为string类型的操作，只是它的返回值具有一个特点。所以可以当锁使用。\n    # 原型为 setnx key value\n    ```\n\n    * 利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功\n    * 对于返回设置成功的，拥有控制权，进行下一步的具体业务操作。\n    * 对于返回设置失败的，不具有控制权，排队或等待。\n\n  * 操作完毕通过del操作释放锁\n\n    ```\n    del lock-key\n    ```\n\n* 应用场景：redis 应用基于分布式锁对应的场景控制\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420173951.png)\n\n### 场景三：分布式锁的改良\n\n* 业务场景\n\n  * 依赖分布式锁的机制，某个用户操作时对应客户端宕机，且此时已经获取到锁。如何解决？\n\n* 业务分析\n\n  * 由于锁操作由用户控制加锁解锁，必定会存在加锁后未解锁的风险。\n  * 需要解锁操作不能仅依赖用户控制，系统级别要给出对应的保底处理方案。\n\n* 解决方案\n\n  * 使用expire 为锁key添加时间限定，到时不释放，放弃锁\n\n  ```\n  expire lock-key second\n  pexpire lock-key milliseconds\n  ```\n\n* 由于操作通常都是微秒或毫秒级，因此该锁定时间不宜设置过大。具体时间需要业务测试后确认。\n\n  * 例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。 \n  * 测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时。\n  * 锁时间设定推荐：最大耗时\\*120%+平均网络延迟*110%\n  * 如果业务最大耗时<<网络平均延迟，通常为2个数量级，取其中单个耗时较长即可。\n\n\n\n# 第八章：删除策略\n\n## 过期数据\n\n* Redis中的数据特征\n\n  * Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态\n  * XX ：具有时效性的数据\n  * -1 ：永久有效的数据\n  *  -2 ：**已经过期的数据** 或 被删除的数据 或 未定义的数据\n\n* 过期数据：指已经过期的数据，但是暂时并没有被删除的数据。\n\n* 数据删除策略\n\n  * 定时删除\n  * 惰性删除\n  * 定期删除\n\n* Redis数据的时效性存储原理\n\n  * 第一步：在内存中添加一个键值对，此时值的存储地址是已经知道的。\n  * 第二步：在内存中有一片区域是被称为过期区/时效区，此区域存放的键值对，键是上面的存储地址，值是时间。\n  * 示例如下\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422090428.png)\n\n## 数据删除策略\n\n* 目标：在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露。\n  * 即：当CPU忙时，此时的过期数据不用现在就删除，可以等不忙的时候再删。\n\n### 定时删除\n\n* 定义\n  * 创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作。\n* 优点：节约内存，到时就删除，快速释放掉不必要的内存占用。\n* 缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量。\n* 总结：到点就删，用处理器性能换取存储空间（拿时间换空间）\n\n### 惰性删除\n\n* 定义：\n  * 数据到达过期时间，不做处理。等下次访问该数据时。\n    * 如果未过期，返回数据。\n    * 发现已过期，删除，返回不存在。\n  * 在redis中，每次执行获取操作之前都会先执行*expireIfNeeded()*方法，此方法用于判断数据是否过期。\n* 优点：节约CPU性能，发现必须删除的时候才删除。\n* 缺点：内存压力很大，大量数据不删除会出现长期占用内存的数据。\n* 总结：用存储空间换取处理器性能 （拿时间换空间）\n\n### 定期删除\n\n* 首先要知道redis有16个库，每个库都会有对应的过期区，从expires[0]到expires[15]\n* 删除过程：\n  * 首先：Redis启动服务器初始化时，读取配置server.hz的值，此值默认为10。\n  * 然后：Redis每秒钟执行server.hz次**serverCron()**方法\n  * **serverCron()**方法会调用**databasesCron()**方法，\n  * **activeExpireCycle()**方法会循环查找每个库，循环过程中会调用**activeExpireCycle()**方法。\n  * **activeExpireCycle()**方法会对每个库中的expires区中的数据进行检测，每次执行时间为250ms/server.hz。\n  * 对某个expires检测时，随机挑选W个key检测\n    * 如果key超时，删除key。\n    * 如果一轮中删除的key的数量>W\\*25%，循环该过程。\n    * 如果一轮中删除的key的数量≤W\\*25%，检查下一个expires，0-15循环。\n  * 检测过程中，参数current_db用于记录**activeExpireCycle()** 进入哪个库的expires 执行。\n  * 如果**activeExpireCycle()**执行时间到期，下次从current_db继续向下执行。\n* 补充说明：\n  * W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值。\n  * 在配置文件中配置。\n* 定义：\n  * 周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度。\n* 特点：\n  * CPU性能占用设置有峰值，检测频度可自定义设置。\n  * 内存压力不是很大，长期占用内存的冷数据会被持续清理。\n* 总结：周期性抽查存储空间随机抽查，重点抽查）\n\n### 对比\n\n* Redis默认使用的删除策略是**惰性删除加定期删除**\n\n|          定时删除           |       惰性删除        |           定期删除            |\n| :-------------------------: | :-------------------: | :---------------------------: |\n|      节约内存，无占用       |     内存占用严重      |       内存定期随机清理        |\n| 不分时段占用CPU资源，频度高 | 延时执行，CPU利用率高 | 每秒花费固定的CPU资源维护内存 |\n|        拿时间换空间         |     拿空间换时间      |      随机抽查，重点抽查       |\n\n## 逐出算法\n\n* 出现的原因\n\n  * Redis使用内存存储数据，在执行每一个命令前，会调用**freeMemoryIfNeeded()**检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。\n  * 注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422094937.png)\n\n  * 即当redis中的数据太多了，已经占用满了内存，还想往redis中添加数据，此时就要删除一些数据了。\n\n* 相关配置\n\n  * 配置redis最大可使用内存\n\n    ```\n    maxmemory\n    ```\n\n    * 占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。\n\n  * 配置每次选取待删除数据的个数\n\n    ```\n    maxmemory-samples\n    ```\n\n    * 选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据。\n\n  * 配置删除策略\n\n    ```\n    maxmemory-policy \n    # 例如： maxmemory-policy  volatile-lru\n    ```\n\n    * 达到最大内存后的，对被挑选出来的数据进行删除的策略。\n\n* 8种逐出算法的删除策略\n\n  * 检测易失数据（可能会过期的数据集server.db[i].expires ） \n    * ① volatile-lru：挑选最近最少使用的数据淘汰\n    * ② volatile-lfu：挑选最近使用次数最少的数据淘汰\n    * ③ volatile-ttl：挑选将要过期的数据淘汰\n    * ④ volatile-random：任意选择数据淘汰\n  * 检测全库数据（所有数据集server.db[i].dict ）\n    * ⑤ allkeys-lru：挑选最近最少使用的数据淘汰\n    * ⑥ allkeys-lfu：挑选最近使用次数最少的数据淘汰\n    * ⑦ allkeys-random：任意选择数据淘汰\n  * 放弃数据驱逐\n    * ⑧ no-enviction（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory）\n\n* 策略配置依据\n\n  * 虽然我们并不能看到每个数据的使用情况。\n  * 但是我们可以使用INFO命令输出监控信息，查询缓存 hit 和 miss 的次数，根据业务需求调优Redis配置。\n  * hit表示命中率，miss表示缺失率。\n\n\n\n# 第九章：redis服务器配置\n\n* 基本的配置。配置文件：redis.conf\n\n## 服务器端设定\n\n* 设置服务器以守护进程的方式运行\n\n  ```\n  daemonize yes|no\n  ```\n\n* 绑定主机地址\n\n  ```\n  bind 127.0.0.1\n  ```\n\n* 设置服务器端口号\n\n  ```\n  port 6379\n  ```\n\n* 设置数据库数量\n\n  ```\n  databases 16\n  ```\n\n## 日志配置\n\n* 设置服务器以指定日志记录级别\n\n  ```\n  loglevel debug|verbose|notice|warning\n  ```\n\n* 日志记录文件名\n\n  ```\n  logfile 端口号.log\n  ```\n\n* 注意：日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频度。\n\n## 客户端配置\n\n* 设置同一时间最大客户端连接数，默认无限制。当客户端连接到达上限，Redis会关闭新的连接\n\n  ```\n  maxclients 0\n  ```\n\n* 客户端闲置等待最大时长，达到最大值后关闭连接。如需关闭该功能，设置为 0\n\n  ```\n  timeout 300\n  ```\n\n## 多服务器快捷配置\n\n* 导入并加载指定配置文件信息，用于快速创建redis公共配置较多的redis实例配置文件，便于维护\n\n  ```\n  include /path/server-端口号.conf\n  ```\n\n\n\n# 第十章：高级数据类型\n\n## Bitmaps\n\n* BItmaps数据类型是以字符串string类型为基础的，在value上存储字符串，但字符串的数据格式是一个二进制数。理论上这个二进制数长度小于2^32。\n\n  * 例如<key,value>  表示为<08,001010>。08表示key，001010表示value。\n  * 但是此数据类型并不是直接设置value值的，而是对二进制数的某一位进行操作。\n  * 此数据类型和二进制值相结合，通常只用来表示某种状态，而不是用来表示数的。\n  * 0和1可以表示两种相对立的状态。\n\n* 操作命令\n\n  * 获取指定key对应偏移量上的bit值。(偏移量表示二进制数从右开始数的第几位)\n\n    ```\n    # 如果 key不存在或者此偏移量上的值未被定义，都返回0\n    getbit key offset\n    ```\n\n  * 设置指定key对应偏移量上的bit值，value只能是1或0。\n\n    ```\n    setbit key offset value\n    ```\n\n  * 对指定key按位进行交、并、非、异或操作，并将结果保存到destKey中。\n\n    ```\n    # op表示要执行的操作类型，destKey是一个Bitmaps类型的数据\n    bitop op destKey key1 [key2...]\n    ```\n\n    * and：交\n    * or：并\n    * not：非\n    * xor：异或\n\n  * 统计指定key中1的数量。\n\n    ```\n    bitcount key [start end]\n    ```\n\n* 举例：统计电影院某天某部电影是否被点播，每天有多少电影没电播。\n\n  * 0，4，5，8分别表示一部电影，11表示11号，12表示12号\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422104028.png)\n\n* 应用：redis 应用于信息状态统计\n\n## HyperLongLong\n\n* 应用：统计用户的数量\n\n  * 原始方法：使用set存储每个用户的id\n  * 改进方法：使用Bitmaps存储每个用户状态\n  * 全新方法：使用HyperLogLog\n\n* HyperLogLog 是用来做基数统计的，运用了LogLog的算法\n\n  * 基数是数据集去重后元素个数。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422143019.png)\n\n* 命令操作\n\n  * 添加数据\n\n    ```\n    pfadd key element [element ...]\n    ```\n\n  * 统计数据\n\n    ```\n    pfcount key [key ...]\n    ```\n\n  * 合并数据\n\n    ```\n    pfmerge destkey sourcekey [sourcekey...]\n    ```\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422143406.png)\n\n* 应用：redis 应用于独立信息统计。\n\n* 相关说明\n\n  * 用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据\n  * 核心是基数估算算法，最终数值存在一定误差\n  * 误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值\n  * 耗空间极小，每个hyperloglog key占用了12K的内存用于标记基数\n  * pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大\n  * Pfmerge命令合并后占用的存储空间为12K，无论合并之前数据量多少\n\n## GEO\n\n* 简称地图。\n\n* 适用于生活服务类软件。\n\n  * 例如高德地图，美团，携程\n\n* 作用：在一个集合中，如果给定两个点的坐标，它会以地球为原型，从而计算出这两点之间的距离，以及执行相关的操作。\n\n* 命令操作\n\n  * 添加坐标点\n\n    ```\n    # member表示坐标点的名称\n    geoadd key longitude latitude member [longitude latitude member ...]\n    ```\n\n  * 获取指定点的坐标\n\n    ```\n    geopos key member [member ...]\n    ```\n\n  * 计算点与点之间的距离\n\n    ```\n    # unit表示单位，默认以m为单位。可以取值m|km|ft|mi\n    geodist key member1 member2 [unit]\n    ```\n\n  * 以给订的作表为中心，返回距离中心不超过给定距离的所有位置的元素\n\n    ```\n    # radius表示距离,withcoord表示经度和维度，withdist表示坐标\n    georadius key longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count] [ASC|DESC]\n    ```\n\n  * 以某个坐标点为中心，返回距离中心不超过给定距离的所有位置的元素\n\n    ```\n    georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count] [ASC|DESC]\n    ```\n\n  * 返回坐标点的hash表示\n\n    ```\n    geohash key member [member ...]\n    ```\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422145251.png)\n\n* 应用：redis 应用于地理位置计算\n\n\n\n# 第十一章：主从复制\n\n* 互联网的三高架构：\n  * 高并发\n  * 高性能\n  * 高可用\n\n## 简介\n\n* 单机redis的风险与问题\n\n  * 问题1：机器故障\n    * 现象：硬盘故障、系统崩溃\n    * 本质：数据丢失，很可能对业务造成灾难性打击\n    * 结论：基本上会放弃使用redis。\n  * 问题2.容量瓶颈\n    * 现象：内存不足，从16G升级到64G，从64G升级到128G，无限升级内存\n    * 本质：穷，硬件条件跟不上\n    * 结论：放弃使用redis\n  * 结论：为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服务器上，连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据冗余备份。\n\n* 多台服务器连接方案\n\n  * 提供数据方：master\n    * 主服务器，主节点，主库，主客户端\n  * 接收数据方：slave\n    * 从服务器，从节点，从库，从客户端\n  * 需要解决的问题：数据同步\n  * 核心工作：master的数据复制到slave中\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422154656.png)\n\n* 主从复制\n\n  * 主从复制即将master中的数据即时、有效的复制到slave中。\n  * 特征：一个master可以拥有多个slave，一个slave只对应一个master。\n  * master:\n    * 写数据\n    * 执行写操作时，将出现变化的数据自动同步到slave\n    * 读数据（可忽略）\n  * slave:\n    * 读数据\n    * 写数据（禁止）\n\n* 主从复制的作用\n\n  * 读写分离：master写、slave读，提高服务器的读写负载能力\n  * 负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量\n  * 故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复\n  * 数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式\n  * 高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案\n\n## 工作流程\n\n* 主从复制过程大体可以分为3个阶段\n\n  * 建立连接阶段（即准备阶段）\n  * 数据同步阶段\n  * 命令传播阶段 \n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422160159.png)\n\n### 建立连接阶段\n\n*  目的：建立slave到master的连接，使master能够识别slave，并保存slave端口号。\n\n* 步骤：\n\n  * 步骤1：设置master的地址和端口，保存master信息\n  * 步骤2：建立socket连接\n  * 步骤3：发送ping命令（定时器任务）\n  * 步骤4：身份验证\n  * 步骤5：发送slave端口信息\n  * 至此，主从连接成功！\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422160539.png)\n\n* 状态：\n\n  * slave：\n    * 保存master的地址与端口\n  * master：\n    * 保存slave的端口\n  * 总体：\n    * 创建了连接的socket\n\n* 连接命令\n\n  * 方式一：slave客户端发送命令\n\n    ```\n    slaveof <masterip> <masterport>\n    # 例如：slaveof 127.0.0.1 6379\n    ```\n\n  * 方式二：启动slave服务器时添加参数\n\n    ```\n    redis-server -slaveof <masterip> <masterport>\n    # 例如：redis-server redis-6378.conf -slaveof 127.0.0.1 6379\n    ```\n\n  * 方式三：slave服务器配置\n\n    ```\n    slaveof <masterip> <masterport>\n    ```\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422163037.png)\n\n  * 连接后的状态。输入info\n\n    * master服务器\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422163355.png)\n\n    * slave服务器\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422163247.png)\n\n* 断开连接命令\n\n  * slave客户端发送指令\n\n    ```\n    slaveof no one\n    ```\n\n  * slave断开连接后，不会删除已有数据，只是不再接受master发送的数据\n\n* 授权访问的命令\n\n  * master服务器设置密码\n\n    * master客户端发送命令设置密码\n\n    ```\n    requirepass <password>\n    ```\n\n    * master配置文件设置密码\n\n    ```\n    config set requirepass <password>\n    config get requirepass\n    ```\n\n  * slave连接带密码的master服务器\n\n    * slave客户端发送命令设置密码\n\n    ```\n    # 在发送连接命令后加上下面命令\n    auth <password>\n    ```\n\n    * slave配置文件设置密码\n\n    ```\n    masterauth <password>\n    ```\n\n    * slave启动服务器设置密码\n\n    ```\n    redis-server –a <password>\n    ```\n\n### 数据同步阶段\n\n* 目的：\n\n  * 在slave初次连接master后，复制master中的所有数据到slave。\n  * 将slave的数据库状态更新成master当前的数据库状态。\n\n* 步骤：\n\n  * 步骤1：请求同步数据\n  * 步骤2：创建RDB同步数据\n  * 步骤3：恢复RDB同步数据\n  * 步骤4：请求部分同步数据\n  * 步骤5：恢复部分同步数据\n  * 至此，数据同步工作完成！\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422164517.png)\n\n* 状态：\n\n  * slave：\n    * 具有master端全部数据，包含RDB过程接收的数据\n  * master：\n    * 保存slave当前数据同步的位置\n  * 总体：\n    * 完成了数据克隆\n\n* master部分说明\n\n  *  如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行\n\n  * 复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。\n\n    ```\n    # 配置master服务器缓冲区的大小\n    repl-backlog-size 1mb\n    ```\n\n  * master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执行bgsave命令和创建复制缓冲区\n\n* slave部分说明\n\n  * 为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务。\n\n    ```\n    # slave服务器设置为是否只读\n    slave-serve-stale-data yes|no\n    ```\n\n  * 数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令。\n\n  * 多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰。\n\n  * slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟较大，数据一致性变差，应谨慎选择。\n\n### 命令传播阶段\n\n* 目的：\n\n  * 当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，同步的动作称为命令传播。\n  * master将接收到的数据变更命令发送给slave，slave接收命令后执行命令。\n\n* 命令传播阶段出现了断网现象\n\n  * 网络闪断闪连   -->  忽略\n  * 短时间网络中断  -->  部分复制\n  * 长时间网络中断  -->  全量复制\n\n* 部分复制的三个核心要素\n\n  * 服务器的运行 id（run id） \n  * 主服务器的复制积压缓冲区\n  * 主从服务器的复制偏移量\n\n* **服务器运行ID（runid）**\n\n  * 概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id\n  * 组成：运行id由40位字符组成，是一个随机的十六进制字符\n    * 例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce\n  * 作用：运行id被用于在服务器间进行传输，识别身份如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别\n  * 实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过info Server命令，可以查看节点的runid\n\n* **复制积压缓冲区**\n\n  * 概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区。\n  * 复制缓冲区默认数据存储空间大小是1M，由于存储空间大小是固定的，当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列\n  * 组成：偏移量+字节值\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423102609.png)\n\n  * 工作原理\n    * 通过offset区分不同的slave当前数据传播的差异\n    * master记录已发送的信息对应的offset\n    * slave记录已接收的信息对应的offset\n  * 由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区。\n  * 作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select） \n  * 数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中\n\n* **主从服务器复制偏移量（offset）** \n\n  * 概念：一个数字，描述复制缓冲区中的指令字节位置\n  * 分类：\n    * master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）\n    * slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）\n  * 数据来源：\n    * master端：发送一次记录一次\n    * slave端：接收一次记录一次\n  * 作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用\n\n### 心跳机制\n\n* 进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线\n\n* master心跳：\n\n  * 指令：PING\n  * 周期：由repl-ping-slave-period决定，默认10秒 \n  * 作用：判断slave是否在线\n  * 查询：INFO replication      获取slave最后一次连接时间间隔，lag项维持在0或1视为正常\n\n* slave心跳任务\n\n  * 指令：REPLCONF ACK {offset}\n  * 周期：1秒 \n  * 作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令\n  * 作用2：判断master是否在线\n\n* 心跳阶段注意事项\n\n  * 当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作\n\n    ```\n    # slave在线的最小数量，小于此数就停止写服务\n    min-slaves-to-write 2\n    # slave的延迟最小值\n    min-slaves-max-lag 8\n    ```\n\n    * slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步。\n\n  * slave数量由slave发送**REPLCONF ACK**命令做确认。\n\n  * slave延迟由slave发送**REPLCONF ACK**命令做确认。\n\n### 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423103550.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423104528.png)\n\n## 常见问题\n\n### 频繁的全量复制（1）\n\n* 伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的全量复制操作\n\n* 内部优化调整方案(不用修改)：\n\n  1. master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave\n\n  2. 在master关闭时执行命令 **shutdown** save，进行RDB持久化,将runid与offset保存到RDB文件中\n     * repl-id repl-offset \n     * 通过 *redis-check-rdb文件*  命令可以查看该信息\n\n  3. master重启后加载RDB文件，恢复数据\n     * 重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中\n     * master_repl_id =repl   master_repl_offset =repl-offset\n     * 通过info命令可以查看该信息\n\n* 作用：\n\n  * 本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master\n\n### 频繁的全量复制（2）\n\n* 问题现象\n\n  * 网络环境不佳，出现网络中断，slave不提供服务\n\n* 问题原因\n\n  * 复制缓冲区过小，断网后slave的offset越界，触发全量复制\n\n* 最终结果\n\n  * slave反复进行全量复制\n\n* 解决方案\n\n  * 修改复制缓冲区大小\n\n  ```\n  repl-backlog-size\n  ```\n\n* 建议设置如下：\n\n  1. 测算从master到slave的重连平均时长second\n\n  2. 获取master平均每秒产生写命令数据总量write_size_per_second\n\n  3. 最优复制缓冲区空间 =2 \\* second * write_size_per_second\n\n### 频繁的网络中断（1）\n\n* 问题现象\n\n  * master的CPU占用过高 或 slave频繁断开连接\n\n* 问题原因\n\n  * slave每1秒发送REPLCONF ACK命令到master\n  * 当slave接到了慢查询时（keys *，hgetall等），会大量占用CPU性能\n  * master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应\n\n* 最终结果\n\n  * master各种资源（输出缓冲区、带宽、连接等）被严重占用\n\n* 解决方案\n\n  * 通过设置合理的超时时间，确认是否释放slave\n\n    ```\n    repl-timeout\n    ```\n\n    * 该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave\n\n### 频繁的网络中断（2）\n\n* 问题现象\n\n  * slave与master连接断开\n\n* 问题原因\n\n  * master发送ping指令频度较低\n  * master设定超时时间较短\n  * ping指令在网络中存在丢包\n\n* 解决方案\n\n  * 提高ping指令发送的频度\n\n    ```\n    repl-ping-slave-period\n    ```\n\n    * 超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时\n\n### 数据不一致\n\n* 问题现象\n\n  * 多个slave获取相同数据不同步\n\n* 问题原因\n\n  * 网络信息不同步，数据发送有延迟\n\n* 解决方案\n\n  * 优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象\n\n  * 监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问\n\n    ```\n    slave-serve-stale-data yes|no\n    ```\n\n    * 开启后仅响应info、slaveof等少数命令（慎用，除非对数据一致性要求很高）\n\n\n\n# 第十二章：哨兵模式\n\n## 简介\n\n* 问题：主机宕机\n\n  * 当master主机宕机怎么办？\n    * 关闭master和所有slave\n    * 找一个slave作为master\n    * 修改其他slave的配置，连接新的主\n    * 启动新的master与slave\n    * 全量复制\\*N+部分复制*N \n  * 那么\n    * 关闭期间的数据服务谁来承接？\n    * 找一个主？怎么找法？\n    * 修改配置后，原始的主恢复了怎么办？\n\n* **哨兵(sentinel)** 是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的master并将所有slave连接到新的master。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423152346.png)\n\n* 功能：\n\n  * 监控\n    * 不断的检查master和slave是否正常运行。\n    * master存活检测、master与slave运行情况检测。\n  * 通知（提醒）\n    * 当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。\n  * 自动故障转移\n    * 断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址。\n\n* 注意：哨兵也是一台redis服务器，只是不提供数据服务。通常哨兵配置数量为单数。\n\n## 启动哨兵模式\n\n* 配置哨兵\n\n  * 配置文件为sentinel.conf\n\n* 配置项解释\n\n  ```conf\n  # 哨兵的服务端口号，一般为监听的redis服务器的端口号前加2\n  port 26379\n  # 日志，数据目录\n  dir /tmp\n  # 配置监听的redis服务器。mymaster为服务器名称，可以自定义，后面跟服务器的IP和端口号。\n  # 最后边的数为参与选举成功的数量，一般为哨兵数量的一半加1\n  sentinel monitor mymaster 127.0.0.1 6379 2\n  # 当主机连接超过30秒时认为它宕机了。数字的单位是毫秒\n  sentinel down-after-milliseconds mymaster 30000\n  # 指定同时进行主从的slave数量，数值越大，要求网络资源越高，要求约小，同步时间约长\n  sentinel parallel-syncs mymaster 1\n  # 指定出现故障后，故障切换的最大超时时间，超过该值，认定切换失败，默认3分钟\n  sentinel failover-timeout mymaster 180000\n  \n  #其他的配置\n  # 连接服务器口令。例如：sentinel auth-pass mymaster 123456\n  sentinel auth-pass <服务器名称> <password>\n  # 服务器无法正常联通时，设定的执行脚本，通常调试使用。\n  sentinel notification-script <服务名称><脚本路径>\n  ```\n\n* 启动哨兵：\n\n  ```\n  redis-sentinel sentinel配置文件.conf\n  ```\n\n* 演示：\n\n  * 配置三个哨兵，除了端口号不同，其他的都可以一样。三个哨兵监视的都是一个主机。\n  * 启动顺序：先启动master，在启动slave，最后启动哨兵\n  * 哨兵的客户端连接也使用*redis-cli -p  端口号*。但是这个客户端不能进行数据的操作。\n  * 在客户端输入*info*命令能看到当前哨兵的一些信息。\n  * 当哨兵启动后，它的配置文件会发生一些改变，会保存对应主机的信息，以及从机的信息。\n  * 当新哨兵启动时，已经启动的哨兵会识别到新启动的哨兵。\n  * 哨兵的启动\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423161223.png)\n\n  * 当主master宕机时，哨兵打印的日志\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423162327.png)\n\n  * 此时6379又重新启动时，6378任作为主机，而6379变成了从机。\n\n## 哨兵工作原理\n\n* 哨兵在进行主从切换过程中经历三个阶段\n  * 监控\n  * 通知\n  * 故障转移\n\n### 阶段一：监控阶段\n\n* 用于同步各个节点的状态信息\n\n  * 获取各个sentinel的状态（是否在线）(通过ping命令)\n  * 获取master的状态（通过info命令）\n    * master属性\n      * runid\n      * role：master\n    * 各个slave的详细信息\n  * 获取所有slave的状态（根据master中的slave信息）（通过info命令）\n    * slave属性\n      * runid\n      * role：slave\n      * master_host、master_port\n      * offest\n      * .....\n\n* 详细过程\n\n  * 第一步：第一个哨兵启动时，先通过info命令获取master的信息。\n  * 第二步：第一个哨兵和master建立cmd连接。\n    * 此时，哨兵会保存**SentinelState**信息。master会保存**SentinelRedisInstance**信息。\n  * 第三步：第一个哨兵根据获取的信息，通过info命令连接其他的slave。\n  * 第四步：当第二个哨兵启动时，先通过info命令获取master的信息。\n  * 第五步：第二个哨兵和master建立cmd连接。并保存**SentinelState**信息，master保存的信息会被更新。\n  * 第六步：第二个哨兵会和第一个哨兵建立publish subscribe约定，以保证信息共享。\n    * 同时，这两个哨兵会发ping命令，以保证相互之间是存在的。\n  * 第七步：第二个哨兵连接slave。\n  * 再有新哨兵启动时，会按照第四步到第七步依次执行。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423164415.png)\n\n### 阶段二：通知阶段\n\n* 第一步：哨兵中的一个哨兵接收主机和从机的信息。\n* 第二步：这个哨兵将接受到的信息发送到publish subscribe区域。\n* 第三步：其他哨兵直接重这个区域获取主机和从机的信息。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423164913.png)\n\n### 阶段三：故障转移\n\n* **发现故障：**\n\n  * 第一步：哨兵1连续获取master信息，发现获取不了，标记master的状态为S_DOWN,并将这个消息发送到publish subscribe区域。\n  * 第二步：其他哨兵看到哨兵1的消息后，都尝试获取这个master的信息。超过半数无法获取时，就会将master的状态标志位0_DOWN。\n    * 标记为S_DOWN的被称为主观下线。\n    * 标记为0_DOWN的被称为客观下线。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423165833.png)\n\n* **发现故障后，所有的sentinel将选举出一个sentinel来处理这个master。**\n\n  * 第一步：所有哨兵发送命令到publish subscribe区域。\n  * 第二步：哨兵们进行投票。\n  * 第三步：投票没有结果时，再进行一次投票。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424145831.png)\n\n* **投票后的sentinel对master进行处置。**\n\n  * 服务器列表中挑选备选master\n    * 选取在线的。\n    * 再选取响应快的。\n    * 再选取与原master断开时间短的。\n    * 优先原则\n      * 再选取优先级高的\n      * 再选取offset小的\n      * 再选取runid小的\n  * 发送指令（ sentinel ）\n    * 向新的master发送slaveof no one。让它作为新的master\n    * 向其他slave发送slaveof 新masterIP端口。让它们连新的master\n\n### 总结\n\n*  监控\n  * 同步信息。\n* 通知\n  * 保持联通。\n* 故障转移\n  * 发现问题。\n  * 竞选负责人。\n  * 优选新master。\n  * 新master上任，其他slave切换master，原master作为slave故障回复后连接。\n\n\n\n# 第十三章：集群\n\n## 集群介绍\n\n* 出现的问题：业务发展过程中遇到的峰值瓶颈。\n  * redis提供的服务OPS可以达到10万/秒，当前业务OPS已经达到20万/秒 。\n    * OPS指一秒内可以执行的命令数量。\n  * 内存单机容量达到256G，当前业务需求内存容量1T。\n*  使用集群的方式可以快速解决上述问题。\n* **集群**就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果\n* 集群的作用：\n  *  分散单台服务器的访问压力，实现负载均衡。\n  * 分散单台服务器的存储压力，实现可扩展性。\n  * 降低单台服务器宕机带来的业务灾难。\n\n## Redis集群结构设计\n\n### 数据存储设计\n\n* 问题：当我们又很多个redis服务器做集群。有一个key过来了，我们要在哪个redis服务器中处理它呢？\n\n* 集群的数据存储设计：\n\n  * 首先通过算法设计，计算出key应该保存的位置。在让位置对16384区域。得到的就是该key存放的**槽**。\n  * 集群将所有redis服务器的存储空间计划切割成16384份，每台主机保存一部分。\n    * 每份代表的是一个存储空间，不是一个key的保存空间。\n  * 将key按照计算出的结果放到对应的存储空间\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423174533.png)\n\n* 当添加一个redis服务器，或删除一个服务器时。集群又是如何做的呢？\n\n* 以添加redis服务器为例：\n\n  * 集群会将已存在的redis服务器，每个服务器把一个槽给新添加的服务器。\n  * 体现了增强可扩展性。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423175153.png)\n\n### 集群内部通讯设计\n\n* 各个数据库相互通信，保存各个库中槽的编号数据。\n\n  * 一次命中，直接返回。\n  * 一次未命中，告知具体位置。\n    * 通过查询保存的数据，就能知道因该访问哪个服务器。 \n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423184709.png)\n\n## cluster集群结构搭建\n\n* cluster是集群框架的一种，经典常用的一种。\n\n### 搭建集群\n\n* 搭建6个redis服务器（三主三从）\n\n* 第一步：配置文件样式如下。（每个服务器的配置文件中，只有端口号不一样）\n\n  ```conf\n  port 6379\n  daemonize no\n  dir /redis-4.0.0/data\n  # rdb配置\n  dbfilename dump-6379.rdb\n  rdbcompression yes\n  rdbchecksum yes\n  save 10 2\n  # aof配置\n  appendonly yes\n  appendfsync always\n  appendfilename appendonly-6379.aof\n  bind 127.0.0.1\n  databases 16\n  # cluster配置\n  # 启动cluster功能\n  cluster-enabled yes\n  # cluster的配置文件的名称\n  cluster-config-file nodes-6379.conf\n  # 配置节点响应超时时间。10秒\n  cluster-node-timeout 10000\n  ```\n\n  * 将当前配置文件拷贝6份\n\n    ```\n    sed 's/6379/6380/g' redis-6379.conf > redis-6380.conf \n    ```\n\n* 第二步：启动6个redis服务器\n\n  * 启动成功后，在linux查看进程会发现如下信息\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424094235.png)\n\n* 第三步：启动cluster\n\n  * redis-trib.rb指令要想成功执行。需要基于两个工具ruby和RubyGems \n    * 安装ruby：*sudo yum install ruby*（安装高版本的ruby）\n    * 安装RubyGems ：*yum install rubygems*\n      * 执行*gem update --system*\n      * 执行*gem sources -a https://rubygems.org*\n    * 安装redis-xxx.gem组件：*gem sources -a https://rubygems.org*\n  * 然后执行下面命令\n\n  ```\n  /redis-4.0.0/src/redis-trib.rb create --replicas 1 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384\n  # /redis-4.0.0/src/是因为此命令只在src目录下有效\n  # 1 表示后面的IP中一个主节点对应一个从节点，因为有6个节点，又是一对一的关系，所以前三个为主节点\n  # 后面要将所有服务器的IP和端口号都加上\n  ```\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424124949.png)\n\n* 第四步\n\n  * 输入yes接口。出现*All 16384 slots covered.*表示成功。\n\n### 客户端的使用\n\n* 会发现原来使用*redis-cli*的客户端在添加数据时会出错，并且让你去其他服务器添加数据。\n\n* 对于集群的客户端要使用*reids-cli -c*命令。即在原来的命令的基础上加上-c。\n\n  * 此时添加数据时，集群会自动将数据放到对应的槽中。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424130033.png)\n\n### 集群的使用\n\n* 当从节点下线后。\n\n  * 比如slave1下线。对应的master1会显示slave1下线了，并将这个消息给其他四个服务器。\n  * 当这个从节点又上线时，对应的master1会同步信息，并将这个消息告诉其他四个服务器。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424131755.png)\n\n* 当主节点下线后。\n\n  * 从节点会一直请求连接，直到到达设定的时间，从节点会变成主节点。并告诉其他节点。\n    * 使用*cluster nodes*可以查看到主节点挂掉，从节点变成了master\n  * 当主节点重新启动时，由于对应的从节点已经变成了主节点。因此这个主节点启动后只能当从节点使用。\n    * 使用*cluster nodes*可以查看到主节点变成了slave\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424132951.png)\n\n### 说明\n\n* Cluster的配置\n\n  ```\n  # 添加节点\n  cluster-enabled yes|no\n  # cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容\n  cluster-config-file <filename>\n  # 节点服务响应超时时间，用于判定该节点是否下线或切换为从节点\n  cluster-node-timeout <milliseconds>\n  # master连接的slave最小数量\n  cluster-migration-barrier <count>\n  ```\n\n* Cluster节点操作命令\n\n  ```\n  # 查看集群节点信息\n  cluster nodes\n  # 进入一个从节点 redis，切换其主节点\n  cluster replicate <master-id>\n  # 发现一个新节点，新增主节点\n  cluster meet ip:port\n  # 忽略一个没有solt的节点\n  cluster forget <id>\n  # 手动故障转移\n  cluster failover\n  ```\n\n* redis-trib命令\n\n  ```\n  # 添加节点\n  redis-trib.rb add-node\n  # 删除节点\n  redis-trib.rb del-node\n  # 重新分片\n  redis-trib.rb reshard\n  ```\n\n\n\n# 第十四章：企业特技解决方案\n\n## 缓存预热\n\n* 问题：\n  * 服务器运行过程中关机了，想要重启，结果在重启后又迅速宕机了。\n* 原因：\n  * 请求数量较高。\n  * 主从之间数据吞吐量较大，数据同步操作频度较高。\n* 解决方案：\n  * 前置准备工作：\n    * 日常例行统计数据访问记录，统计访问频度较高的热点数据\n    * 利用LRU数据删除策略，构建数据留存队列\n      * 例如：storm与kafka配合\n  * 准备工作：\n    * 将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据\n    * 利用分布式多服务器同时进行数据读取，提速数据加载过程\n    * 热点数据主从同时预热\n  * 实施： \n    * 使用脚本程序固定触发数据预热过程\n    * 如果条件允许，使用了CDN（内容分发网络），效果会更好\n* 总结：缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！\n\n## 缓存雪崩\n\n* 问题：\n  * 首先系统平稳运行过程中，忽然数据库连接量激增。然后应用服务器无法及时处理请求。\n  * 然后大量408，500错误页面出现。导致客户反复刷新页面获取数据。\n  * 最后数据库崩溃，应用服务器崩溃。\n  * 发现重启应用服务器无效。\n  * 导致Redis服务器崩溃，Redis集群崩溃。\n  * 再次重启数据库后再次被瞬间流量放倒。\n* 原因：\n  * 在一个较短的时间内，缓存中较多的key集中过期。\n  * 此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据。\n  * 数据库同时接收到大量的请求无法及时处理。\n  * Redis大量请求被积压，开始出现超时现象。\n  * 数据库流量激增，数据库崩溃。\n  * 重启后仍然面对缓存中无数据可用。\n  * Redis服务器资源被严重占用，Redis服务器崩溃。\n  * Redis集群呈现崩塌，集群瓦解。\n  * 应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃。\n  * 应用服务器，redis，数据库全部重启，效果不理想。\n  * 总结：短时间范围内大量key集中过期导致的。\n* 解决方案1：\n  * 更多的页面静态化处理\n  * 构建多级缓存架构\n    * Nginx缓存+redis缓存+ehcache缓存\n  * 检测Mysql严重耗时业务进行优化\n    * 对数据库的瓶颈排查：例如超时查询、耗时较高事务等\n  * 灾难预警机制\n    * 监控redis服务器性能指标\n    * CPU占用、CPU使用率\n    * 内存容量\n    * 查询平均响应时间\n    * 线程数\n  * 限流、降级\n    * 短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问\n* 解决方案2：\n  * LRU与LFU切换。\n  * 数据有效期策略调整。\n    * 根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟。\n    * 过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量。\n  * 超热数据使用永久key。\n  * 定期维护（自动+人工）。\n    * 对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时。\n  * 加锁(不推荐使用)。\n* 总结：\n  * 缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现（约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。\n\n## 缓存击穿\n\n* 问题：\n  * 系统平稳运行过程中。\n  * 数据库连接量瞬间激增。\n  * Redis服务器无大量key过期。\n  * Redis内存平稳，无波动。\n  * Redis服务器CPU正常。\n  * 数据库崩溃。\n* 原因：\n  * 问题排查：\n    * Redis中某个key过期，该key访问量巨大。\n    * 多个数据请求从服务器直接压到Redis后，均未命中。\n    * Redis在短时间内发起了大量对数据库中同一数据的访问。\n  * 问题分析：\n    * 单个key高热数据\n    * key过期\n* 解决方案：\n  * 预先设定\n    * 以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长\n    * 注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势\n  * 现场调整\n    * 监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key\n  * 后台刷新数据\n    * 启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失\n  * 二级缓存\n    * 设置不同的失效时间，保障不会被同时淘汰就行\n  * 加锁\n    * 分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！\n* 总结：\n  * 缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可。\n\n## 缓存穿透\n\n* 问题：\n  * 系统平稳运行过程中。\n  * 应用服务器流量随时间增量较大。\n  * Redis服务器命中率随时间逐步降低。\n  * Redis内存平稳，内存无压力。\n  * Redis服务器CPU占用激增。\n  * 数据库服务器压力激增。\n  * 数据库崩溃。\n* 原因：\n  * 问题排查\n    * Redis中大面积出现未命中。\n    * 出现非正常URL访问。\n  * 问题分析\n    * 获取的数据在数据库中也不存在，数据库查询未得到对应数据。\n    * Redis获取到null数据未进行持久化，直接返回。\n    * 下次此类数据到达重复上述过程。\n    * 出现黑客攻击服务器。\n* 解决方案：\n  * 缓存null\n    * 对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟。\n  * 白名单策略\n    * 提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放行，加载异常数据时直接拦截（效率偏低）。\n    * 使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）。\n  * 实施监控\n    * 实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比。\n      * 非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象。\n      * 活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象。\n    * 根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）。\n  * key加密\n    * 问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验。\n    * 例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问。\n* 总结：\n  * 缓存击穿访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时<font color=\"red\">报警</font>。应对策略应该在临时预案防范方面多做文章。\n  * 无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。\n\n## 性能指标监控\n\n* 常监控的性能有\n\n  * 性能指标：Performance\n  * 内存指标：Memory\n  * 基本活动指标：Basic activity\n  * 持久性指标：Persistence\n  * 错误指标：Error\n\n* 性能指标：Performance\n\n  |           name            |       Description        |\n  | :-----------------------: | :----------------------: |\n  |          latency          | Redis响应一个 请求的时间 |\n  | instantaneous_ops_per_sec |   平均每秒处理请求总数   |\n  |   hit rate (calculated)   |  缓存命中率(计算出来的)  |\n\n* 内存指标：Memory\n\n  |           name            |                   Description                   |\n  | :-----------------------: | :---------------------------------------------: |\n  |       used_ memory        |                   已使用内存                    |\n  | mem_ fragmentation_ ratio |                   内存碎片率                    |\n  |       evicted_ keys       |        由于最大内存限制被移除的key的数量        |\n  |     blocked_ clients      | 由于BLPOP, BRPOP, or BRPOPLPUSH而备阻塞的客户端 |\n\n* 基本活动指标：Basic activity\n\n  |            name            |        Description         |\n  | :------------------------: | :------------------------: |\n  |     connected_ clients     |        客户端连接数        |\n  |      connected_slaves      |         Slave数量          |\n  | master_last_io_seconds_ago | 最近一次主从交互之后的秒数 |\n  |          keyspace          |    数据库中的key值总数     |\n\n* 持久性指标：Persistence\n\n  | name                        | Description                        |\n  | --------------------------- | ---------------------------------- |\n  | rdb_last_save_time          | 最后一次持久化保存到磁盘的时间戳   |\n  | rdb_changes_since_last_save | 自最后一次持久化以来数据库的更改数 |\n\n* 错误指标：Error\n\n  | name                           | Description                           |\n  | ------------------------------ | ------------------------------------- |\n  | rejected_connections           | 由于达到maxclient限制而被拒绝的连接数 |\n  | keyspace_misses                | Key值查找失败(没有命中)次数           |\n  | master_link_down_since_seconds | 主从断开的持续时间(以秒为单位)        |\n\n* 监控方式：\n\n  * 工具：\n    * Cloud Insight Redis\n    * Prometheus\n    * Redis-stat\n    * Redis-faina\n    * RedisLive\n    * zabbix\n  * 命令：\n    * *benchmark*\n    * redis cli\n      * *monitor*\n      * *showlog*\n\n* 命令说明：\n\n  * benchmark\n\n    ```\n    redis-benchmark [-h ] [-p ] [-c ] [-n <requests]> [-k ]\n    ```\n\n    * 作用：压力测试。此测试在命令行执行，不是在客户端执行。\n\n    * 示例一\n\n      ```\n      # 默认50个连接，10000次请求对应的性能\n      redis-benchmark\n      ```\n\n      ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424144749.png)\n\n    * 示例二\n\n      ```\n      # 100个连接，5000次请求对应的性能\n      redis-benchmark -c 100 -n 5000\n      ```\n\n    * 参数说明：\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424143810.png)\n\n  * monitor\n\n    ```\n    monitor\n    ```\n\n    * 作用：打印服务器调试信息。在客户端里执行命令。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424145545.png)\n\n  * showlog\n\n    ```\n    # operator可以是get/len/reset\n    showlong [operator]\n    ```\n\n    * get ：获取慢查询日志。\n    * len ：获取慢查询日志条目数。\n    * reset ：重置慢查询日志。\n    * 相关配置：\n\n    ```\n    slowlog-log-slower-than 1000    #设置慢查询的时间下线，单位：微妙\n    slowlog-max-len 100    #设置慢查询命令对应的日志显示长度，单位：命令数\n    ```","categories":["Java学习","数据库"]},{"title":"linux的搭建","url":"/2021/04/18/尚硅谷说Java/集成工具的使用/linux的搭建/","content":"\n在VirtualBox上搭建Centos7系统，并使用Xshell连接虚拟机\n\n<!--more-->\n\n# 安装VirtualBox\n\n* 下载地址：\n\n  ```\n  链接: https://pan.baidu.com/s/1l1X9I7OCXc-iKG_HZT_0VQ \n  提取码: 3ceq\n  ```\n\n* 安装步骤：一直点击安装即可。\n\n  * 可以自行选择安装的路径\n\n* 安装后打开的界面如下所示\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418102503.png)\n\n# Centos7的下载\n\n* 推荐从阿里云的镜像网站上下载。\n\n  * 地址：http://mirrors.aliyun.com/centos/7/isos/x86_64/\n\n* 点击iso下载即可\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418102831.png)\n\n# Centos7系统的搭建\n\n* 第一步：创建虚拟机\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418132653.png)\n\n  * 然后一直点创建\n\n* 第二步：设置虚拟机\n\n  * 右击，点击设置\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418132802.png)\n\n  * 将“软驱”移动到最下面，并取消软驱前的选择\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418132938.png)\n\n  * 选择虚拟盘时：选择自己下载的centos镜像文件\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418133157.png)\n\n  * 设置网卡\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418133405.png)\n\n  * 然后点击ok\n\n* 第三步：启动虚拟机\n\n  * 双击虚拟机即可启动。然后点击确定\n  * 选择安装centos\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418133627.png)\n\n  * 语言选择中文\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418133819.png)\n\n  * 设置分区：点击后再点击完成即可\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418134104.png)\n\n  * 然后点击“网络和主机名”。将两个网络连接打开，记住192的开头的IP。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418134344.png)\n\n  * 设置完网络后，点击完成，点击开始安装。\n  * 设置root密码。输入后如果密码过于简单，只需要连续点击两次完成即可设置成功。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418134643.png)\n\n  * 然后等待，最后出现重启按钮后，点击重启即可。\n\n* 第四步：进入虚拟机\n\n  * 重启后，会出现如下界面。输入账户*root*。密码为自己上述设置的即可\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418135304.png)\n\n  * 输入*ip addr*命令。查看虚拟机的IP\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418135553.png)\n\n  * 输入*dhclient*命令，让虚拟机获取得到自己的IP地址。\n    * 此时如果不打印任何东西，则获取成功\n  * 在输入*ip addr*命令，就可以看到虚拟机的ip地址\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418135837.png)\n\n* 第五步：设置IP为静态IP\n\n  * 进入网络配置文件夹下。输入命令：*cd /etc/sysconfig/network-scripts/*\n\n  * 查看文件夹下的文件。输入命令：*ls*\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418141837.png)\n\n  * 打开网卡的配置文件。输入命令：*vi ifcfg-enp0s3*\n    * 说明：这个ifcfg后面跟的是，在输入ip addr命令后出现192Ip的哪个网卡名。\n    * 例如的我网卡名就是enp0s3。\n  * 打开配置文件后，按*i*进入编辑模式，在配置文件中做如下修改\n    * 下面的GATEWAY这一行不要写，用自动生成的即可。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418142937.png)\n\n  * 然后按*ESC*,按冒号。在按*wq*表示退出并保存文件。\n  * 重启网络服务。输入命令：*systemctl restart network.service*\n\n  * 查看IP地址。输入命令：*ip addr*\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418142715.png)\n\n  * 测是网络是否连通。输入命令：*ping 8.8.8.8*\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418142752.png)\n\n  * 上述都成功时，整个设置就成功了。\n\n# Xshell的安装\n\n* 下载地址：\n\n  ```\n  链接: https://pan.baidu.com/s/1qf8tyLX4rY1L1UB8v_Zwyg \n  提取码: qnwm \n  ```\n\n* 下载后一直点击下一步即可\n\n  * 可以选择安装的位置\n\n# Xshell连接Centos7虚拟机\n\n* 第一步：打开Xshell。点击新建\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418143714.png)\n\n* 填写虚拟机的IP，点击确认。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418143857.png)\n\n* 选中刚才的会话，点击连接。点击选择并保存\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418144021.png)\n\n* 用户名输入root。密码输入自己设置的密码。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418144208.png)\n\n* 出现下面的界面，则表示连接成功。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418144318.png)\n\n","categories":["Java学习","集成工具的使用"]},{"title":"SpringBoot的使用","url":"/2021/04/11/尚硅谷说Java/分布式技术/SpringBoot2/","content":"\nSpringboot\n\n<!--more-->\n\n* 版本：springboot 2.3.9 + maven 3\n* 官方文档：https://docs.spring.io/spring-boot/docs/2.3.9.RELEASE/reference/html/index.html\n\n# 第一章 HelloWorld\n\n* 准备工作：修改maven配置。方便下载依赖从阿里云镜像下载。\n\n  * 配置文件：apache-maven-3.6.3\\conf\\setting.xml\n\n  ```xml\n  <mirror>\n    <id>alimaven</id>\n    <mirrorOf>central</mirrorOf>\n    <name>aliyun maven</name>\n    <url>https://maven.aliyun.com/nexus/content/repositories/central/</url>\n  </mirror>\n  ```\n\n* 创建一个maven工程\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210325114958.png)\n\n* 在pom.xml文件中引入依赖\n\n```xml\n<parent>\n  <groupId>org.springframework.boot</groupId>\n  <version>2.3.9.RELEASE</version>\n  <artifactId>spring-boot-starter-parent</artifactId>\n</parent>\n<dependencies>\n  <!--spring-boot-starter为SpringBoot依赖的启动依赖-->\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter</artifactId>\n  </dependency>\n  <!--spring-boot-starter-web为web相关依赖。\n引入后会引入springweb,webmvc,tomcat等依赖-->\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n  </dependency>\n</dependencies>\n```\n\n* 创建Spring Boot启动类\n\n```java\n/** \n* MainApplication作为启动整个项目的入口。\n* SpringBootApplication注解表明这是一个启动类\n*/\n@SpringBootApplication\npublic class MainApplication {\n  public static void main(String[] args) {\n    SpringApplication.run(MainApplication.class,args);\n  }\n}\n```\n\n* 创建控制层\n\n```java\n/**\n * RestController注解为spring的注解。\n *  其作用相当于Controller注解和ResponseBody注解的结合实现\n */\n@RestController\npublic class HelloController {\n  @RequestMapping(\"/hello\")\n  public String hello(){\n    return \"hello world Spring Boot\";\n  }\n}\n```\n\n* 结果\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210325115609.png)\n\n# 第二章：配置文件\n\n* Spring Boot的配置文件默认名为application.properties文件。也可以是application.yml文件。\n* 配置文件的路径应在resources文件下。\n* Spring Boot只有一个配置文件，且这个配置文件是全局的。\n* Spring Boot的配置很多都是默认的，但当我们想改时，只需要在配置文件中写出即可。就会覆盖默认值。\n* 配置文件支持的配置，官方文档：https://docs.spring.io/spring-boot/docs/2.3.9.RELEASE/reference/html/appendix-application-properties.html#common-application-properties\n* 例如：修改Tomcat启动的端口号为8088，而不是默认的8080。只需要在配置文件中添加以下带啊吗即可\n\n```properties\nserver.port=8088\n```\n\n* 当初同时存在properties文件且有yml文件时。两个都会生效。\n* 如果配置文件中配置了相同的设置。优先properties文件配置。\n\n**yml格式说明**\n\n* 基本语法\n\n  * key: value；kv之间有空格\n  * 大小写敏感\n  * 使用缩进表示层级关系\n  * 缩进不允许使用tab，只允许空格\n  * 缩进的空格数不重要，只要相同层级的元素左对齐即可\n  * '#'表示注释\n  * 字符串无需加引号，如果要加，''与\"\"表示字符串内容 会被 转义/不转义\n\n* 数据类型\n\n  * 字面量：单个的、不可再分的值。date、boolean、string、number、null\n\n  ```yml\n  k: v\n  ```\n\n  * 对象：键值对的集合。map、hash、set、object \n\n  ```yml\n  k: \n   k1: v1\n   k2: v2\n   k3: v3\n  #或者\n  k: {k1:v1,k2:v2,k3:v3}\n  ```\n\n  * 数组：一组按次序排列的值。array、list、queue\n\n  ```yml\n  k:\n   - v1\n   - v2\n   - v3\n  #或\n  k: [v1,v2,v3]\n  ```\n\n* 示例\n\n```java\n@Data\npublic class Person {\n    private String userName;\n    private Boolean boss;\n    private Date birth;\n    private Integer age;\n    private Pet pet;\n    private String[] interests;\n    private List<String> animal;\n    private Map<String, Object> score;\n    private Set<Double> salarys;\n    private Map<String, List<Pet>> allPets;\n}\n\n@Data\npublic class Pet {\n    private String name;\n    private Double weight;\n}\n```\n\n* 数据的写法\n\n```\n# yaml表示以上对象\nperson:\n  userName: zhangsan\n  boss: false\n  birth: 2019/12/12 20:12:33\n  age: 18\n  pet: \n    name: tomcat\n    weight: 23.4\n  interests: [篮球,游泳]\n  animal: \n    - jerry\n    - mario\n  score:\n    english: \n      first: 30\n      second: 40\n      third: 50\n    math: [131,140,148]\n    chinese: {first: 128,second: 136}\n  salarys: [3999,4999.98,5999.99]\n  allPets:\n    sick:\n      - {name: tom}\n      - {name: jerry,weight: 47}\n    health: [{name: mario,weight: 47}]\n```\n\n* 当编写自定义的配置时。在配置文件没有提示。此时需要引入下面的依赖。\n* 然后重新启动项目后就有提示了。\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-configuration-processor</artifactId>\n  <optional>true</optional>\n</dependency>\n\n\n<build>\n  <plugins>\n    <plugin>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-maven-plugin</artifactId>\n      <!--设置打包时不打包configuration-processor。因为它只是方便我们开发的。和项目没有用-->\n      <configuration>\n        <excludes>\n          <exclude>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-configuration-processor</artifactId>\n          </exclude>\n        </excludes>\n      </configuration>\n    </plugin>\n  </plugins>\n</build>\n```\n\n# 第三章：打包部署\n\n* 可以直接打包乘jar包。然后使用java -jar 包名的方式部署\n* 第一步：导入依赖\n\n```xml\n<!--注意点1-->\n<parent>\n  <groupId>org.springframework.boot</groupId>\n  <version>2.3.9.RELEASE</version>\n  <artifactId>spring-boot-starter-parent</artifactId>\n</parent>\n<!--注意点2-->\n<groupId>org.lc</groupId>\n<artifactId>helloworld</artifactId>\n<packaging>jar</packaging>\n<!--注意点3-->\n<!--此插件的作用是将项目直接打包成jar包，不需要打包成war包。\n打包成jar包后，使用java -jar 包名 的方式直接运行了整个项目-->\n<build>\n  <plugins>\n    <plugin>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-maven-plugin</artifactId>\n    </plugin>\n  </plugins>\n</build>\n```\n\n* 第二步：使用maven清除缓存，然后打包。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210325123354.png)\n\n* 注意：使用cmd时，需要设置cmd的窗口属性快速编辑模式前不打对号。\n\n# 第四章：依赖管理\n\n* SpringBoot中的依赖可以依赖父项目。\n\n  * 子项目在添加依赖时，只需要写出依赖的groupId即可，不需要编写版本号。因为父项目都给确定好了版本。\n\n  ```xml\n  <!--版本号的查看:\n  在父项目spring-boot-starter-parent的父项目spring-boot-dependencies中-->\n  <parent>\n    <groupId>org.springframework.boot</groupId>\n    <version>2.3.9.RELEASE</version>\n    <artifactId>spring-boot-starter-parent</artifactId>\n  </parent>\n  ```\n\n  * 当子项目的依赖的版本不想要父项目的版本，只需要设置properties中对应的版本覆盖父项目版本即可。\n    * maven的就近优先原则。\n\n  ```xml\n  <properties>\n    <mysql.version>5.0.23</mysql.version>\n  </properties>\n  ```\n\n* 在SpringBoot中starts意为一种场景。例如starts-web意为web项目的环境。环境中包含这个环境的所有依赖。\n\n  * 所有的场景支持：https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter\n\n* 在依赖中以*-spring-boot-starter开头的依赖都是第三方给我们提供的可以在springboot中使用的场景。\n\n* springboot支持自定义场景。且建议场景的名字为*-spring-boot-starter\n\n# 第五章：自动配置\n\n* SpringBoot的一个特点就是自动配置。\n  * 即它帮我们配置了几乎所有场景的依赖包。我们只需要引入依赖即可。\n  * 另外它也帮我们配置了很多场景的默认配置。比如tomcat的端口号等等配置。我们可以在application配置文件中修改这些配置。\n* 自动配好Tomcat\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-tomcat</artifactId>\n  <version>2.3.9.RELEASE</version>\n</dependency>\n```\n\n* 自动配好SpringMVC\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n* 自动配好Web常见功能，如：字符编码问题。\n  * SpringBoot会在启动时，就将依赖场景相关的配置都加入到IOC中了。\n* 默认的包结构\n  * 默认情况下，主程序所在包及其子包下的注解都会被SpringBoot扫描到。但是其他包就不能被扫描到。\n  * 但是我们可以自己设置扫描的位置。使用Componentscan注解。\n* 各种配置拥有默认值。\n  * 所有的默认配置都是先加载到MultipartProperties中。\n  * 然后配置文件的值会绑定到相关的类上。\n* 按需加载所有自动配置项。\n  * 按需指父项目中有的依赖，子项目不会全部加载。子项目只会加载子项目明确指定的依赖场景。\n\n# 第六章：容器功能\n\n## 6.1 组件添加\n\n### 6.1.1 @Configuration注解\n\n* @Configuration用于表明此类是一个配置类。相当于Spring中的xml文件的作用。\n* 使用方式如下\n\n```java\n//@Configuration\n@Configuration(value = \"\",proxyBeanMethods = false)\npublic class MyConfig {\n  /**\n   * 默认情况下。\n   *  组件类型为返回值类型\n   *  组件实例化就是返回值的数据\n   *  组件的id为方法名\n   *  组件实例默认为单实例\n   * @return\n   */\n  @Bean\n  public User user1(){\n    return new User(\"ads\",21);\n  }\n\n  /**\n   * value,name属性为组件的id。\n   * @return\n   */\n  @Bean(\"user\")\n  public User user2(){\n    return new User(\"fgfgs\",20);\n  }\n}\n```\n\n* 说明\n  * @Configuration：只用于指明当前类时配置文件。\n    * 配置类也是一个组件。默认是单实例的。组件id为类型第一个字母小写。\n    * value属性表示bean名称，id\n    * proxyBeanMethods属性：默认为true.\n    * 为true代表这个类是个代理对象。会被SpringBoot增强。且通过这个类调用的方法返回的都是一个实例。以保证单实例的bean\n    * 为false代表这个类就是一个配置类。且通过这个类调用的方法返回的不是同一个实例。此时的bean组件就是多实例了。\n    * 另一种说法：为true表示为全配置Full，生成单实例 。为false表示轻量配置Lite，生成多实例。\n  * @Bean：相当于xml文件的bean标签。\n    * 默认情况下：组件类型为返回值类型，组件实例化就是返回值的数据，组件的id为方法名，组件实例默认为单实例。\n    * name,value属性可以设置组件的id。\n\n### 6.1.2 @Bean、@Component、@Controller、@Service、@Repository\n\n* Spring boot也支持@Component、@Controller、@Service、@Repository注解的作用。\n* @Component：表明这个类是一个组件\n* @Controller：表明这个类是一个控制层的类。\n* @Service：表明这个类是一个访问层的类。\n* @Repository：表明这个类是一个数据访问层的类。\n\n### 6.1.3 @ComponentScan、@Import\n\n* @ComponentScan：指定扫描的包。一般是用在主配置文件上。\n* @Import：写在容器中的组件的类上。作用：给容器中导入组件\n  * 值为：类的Class类型。是个数组类型，因此可以导入多个。\n  * 导入的组件的id为类的全列名。\n\n```java\n@RestController\n@Import({User.class})\npublic class HelloController {}\n```\n\n### 6.1.4 @Conditional\n\n* 条件装配：当满足Conditional指定的条件时，此注解表示的类或方法中的注解才会生效。\n* @Conditional是个根注解，此注解下面还有很多的子注解。我们经常使用的就是子注解。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210325145602.png)\n\n* 实例\n\n```java\n//当容器中有user组件时，bean注解才生效\n@ConditionalOnBean(name = \"user\")\n@Bean\npublic User user1(){\n  return new User(\"ads\",21);\n}\n```\n\n## 6.2 原生配置文件引入@ImportResource\n\n* 此注解的作用就是导入资源路径下的配置文件资源。\n\n* 例如导入spring的配置文件，或springmvc的配置文件，或mybatis的配置文件(mybtis.xml)。\n\n  * springboot在导入配置文件后，会自动解析并绑定到相应的配置中。\n\n  ```java\n  @ImportResource(\"classpath:spring-config.xml\")\n  public class MyConfig {}\n  ```\n\n## 6.3 配置绑定\n\n* 当我们使用数据库连接时，一般我们希望把他们写在配置文件中，以方便我们后期修改数据。\n* 然后将配置的信息转载到JavaBean中。\n\n### 6.3.1 @ConfigurationProperties\n\n* 此注解用于将springboot主配置文件中的指定配置的信息绑定到当前的bean上。\n  * 位置：bean实体上。\n  * prefix属性：配置的前缀。\n  * 配置时除去前缀，剩下的应当与bean的属性名相一致。\n\n### 6.3.2 使用方式一：@ConfigurationProperties+@Component\n\n* 两个注解都位于bean实体类上。\n* @Component用于将此实体类注入到容器中。\n* @ConfigurationProperties用于绑定配置信息。\n\n```java\n@Component\n@ConfigurationProperties(prefix = \"mycar\")\npublic class Car {\n  private String name;\n  private Integer price;\n  ....\n}\n```\n\n* 配置信息\n\n```properties\nmycar.name=byd\nmycar.price=10000\n```\n\n### 6.3.3 使用方式二：@ConfigurationProperties+@EnableConfigurationProperties\n\n* @EnableConfigurationProperties注解用于配置类上。用于指定要开启配置信息绑定的类。\n* @ConfigurationProperties注解用于绑定配置信息。位于bean类上。\n  * 此时的bean可以不加@Component注解\n\n```Java\n//注解类\n//EnableConfigurationProperties意为：开启配置属性\n@Configuration()\n@EnableConfigurationProperties({Car.class})\npublic class MyConfig {\n}\n//bean类\n@ConfigurationProperties(prefix = \"mycar\")\npublic class Car {\n  private String name;\n  private Integer price;\n ...\n}\n```\n\n# 第七章：自动配置原理\n\n* 在启动程序类中\n\n```java\n@SpringBootApplication\n//相当于下面三个注解的作用。扫描路径默认为当前启动类的包路径\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(\"com.lc\")\n```\n\n## 7.1 引导自动配置类\n\n```java\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {}\n```\n\n### 7.1.1 @SpringBootConfiguration\n\n* 源码\n\n```java\n@Configuration\npublic @interface SpringBootConfiguration {}\n```\n\n* 作用：表明当前类是一个配置类。\n\n### 7.1.2 @EnableAutoConfiguration\n\n* 源码\n\n```java\n@AutoConfigurationPackage //自动配置包\n@Import(AutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {}\n```\n\n**@AutoConfigurationPackage注解**\n\n```java\n@Import(AutoConfigurationPackages.Registrar.class)\npublic @interface AutoConfigurationPackage {}\n```\n\n* @AutoConfigurationPackage注解导入了Registrar组件\n\n**Registrar类**\n\n* 此组件的方法：将注解的元信息的包路径的第一个路径进行了注册。\n  * 此路径就是启动类所在的包路径。例如com.lc\n  * 因为元注解的第一个是启动类，因此SpringBoot的默认扫描路径是启动类所在的包路径\n\n```java\n@Override\npublic void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {\n  register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));\n}\n```\n\n**import注解**\n\n* @EnableAutoConfiguration注解通过@Import(AutoConfigurationImportSelector.class)导入另一个组件。\n\n**AutoConfigurationImportSelector类**\n\n* 意为自动配置选择器。\n* 其中的一个方法：将元注解数据的所有配置信息都转换为字符数组返回。\n\n```java\n@Override\npublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n  if (!isEnabled(annotationMetadata)) {\n    return NO_IMPORTS;\n  }\n  AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);\n  return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());\n}\n```\n\n* 对*getAutoConfigurationEntry(annotationMetadata)*方法的解析\n  * 作用：给容器中批量导入组件\n* 源码\n\n```java\nprotected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {\n  if (!isEnabled(annotationMetadata)) {\n    return EMPTY_ENTRY;\n  }\n  AnnotationAttributes attributes = getAttributes(annotationMetadata);\n  //获取所有要导入容器信息中的配置类组件。\n  List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);\n  configurations = removeDuplicates(configurations);\n  Set<String> exclusions = getExclusions(annotationMetadata, attributes);\n  checkExcludedClasses(configurations, exclusions);\n  configurations.removeAll(exclusions);\n  configurations = getConfigurationClassFilter().filter(configurations);\n  fireAutoConfigurationImportEvents(configurations, exclusions);\n  return new AutoConfigurationEntry(configurations, exclusions);\n}\n```\n\n* 此方法调用了getCandidateConfigurations()方法。进而分析\n\n```java\nprotected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {\n  //工厂加载器\n  List<String> configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),\n                                                                       getBeanClassLoader());\n  Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \"\n                  + \"are using a custom packaging, make sure that file is correct.\");\n  return configurations;\n}\n```\n\n* getCandidateConfigurations()方法使用了工厂加载器获取所有的组件。\n* 而工厂加载器又从FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\"路径下扫描。\n  * 加载此文件后，加载此文件获取要加载的组件的类路径。\n  * 例如spring-boot-autocpnfigure.jar包中的spring.factories文件，列举了127个类路径。\n\n**总结**\n\n* @Import(AutoConfigurationImportSelector.class)通过一系列获取，最终在spring.factories文件中获取要加载的组件的类路经。\n* 这个文件中的类路径是写死的。\n\n### 7.1.3 @ComponentScan\n\n* 作用：指定包扫描的路径。\n\n## 7.2 按需开启自动配置项\n\n* 虽然Springboot在启动时加载了127个配置。\n* 但根据条件装配(@Conditional注解)，最终会按需装配这些组件，不会全部一次性加载完。\n\n## 7.3 修改默认配置\n\nSpringBoot配置的特点：\n\n* 对于所有的场景都会有配置属性的绑定。\n* 对于所有的配置类格式为xxxAutoConfig。\n* 对于所有的配置是默认都有。但当用户在application.xml文件中指出时。会覆盖默认的。\n\n查看spring-boot-autoconfigure.jar中的所有文件可知。\n\n```java\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) //此配置的优先级\n@Configuration(proxyBeanMethods = false) //此类是个配置类\n@ConditionalOnWebApplication(type = Type.SERVLET)//是否是web应用程序\n@ConditionalOnClass(DispatcherServlet.class) //存在DispatcherServlet组件\n@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)//在ServletWebServerFactoryAutoConfiguration配置类加载之后，在加载自己。\npublic class DispatcherServletAutoConfiguration {}\n```\n\n# 第八章：开发技巧\n\n## 8.1 SpringBoot使用步骤\n\n* 第一步：引入场景依赖。\n  * Spring官方的场景的介绍：https://docs.spring.io/spring-boot/docs/2.3.9.RELEASE/reference/html/using-spring-boot.html#using-boot-starter\n* 第二步：查看自动配置了那些/查看引入的接口/源码(选做)\n  * 可以查看自动配置相关的配置类。即spring-boot-autoconfigure.jar中的文件\n  * 在application.xml文件中加入debug=true开启debug模式。\n    * negative（不生效的）。positive（生效的）\n* 第三步：是否需要修改配置。\n* 第四步：加入组件或自定义组件\n\n## 8.2 Lombok\n\n* 简化JavaBean的开发，自动生成get,set.构造器等方法\n* 第一步：引入依赖\n\n```xml\n<dependency>\n  <groupId>org.projectlombok</groupId>\n  <artifactId>lombok</artifactId>\n</dependency>\n```\n\n* 第二步：开发工具装上lombok插件\n* 第三步：在JavaBean上使用Lombok的注解简化开发\n\n```java\n@Data //get,set,tostring方法\n@AllArgsConstructor //全参构造\n@NoArgsConstructor  //无参构造\npublic class User {\n  private String name;\n  private Integer age;\n}\n//简化日志的开发\n@Slf4j  //添加注解\n@RestController\npublic class HelloController {\n  @RequestMapping(\"/hello\")\n  public String hello(){\n    log.info(\"请求进来了\");  //日志输出\n    return \"hello world Spring Boot\";\n  }\n}\n```\n\n## 8.3 dev-tools\n\n* 作用：当引入此以来后。就实现了热部署。\n  * 即：在项目启动后。如果修改项目的代码时，不需要重新启动项目。\n  * IDEA需要按Ctrl+F9编译一遍项目。然后此依赖就会自动更新项目代码。\n* 但此依赖的实质还是重新启动项目。\n* 想要不重启也实现热部署。想要使用付费的东西：https://www.jrebel.com/products/jrebel\n\n```java\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-devtools</artifactId>\n  <optional>true</optional>\n  </dependency>\n```\n\n## 8.3 Spring Initailizr（项目初始化向导）\n\n* Spring Initailizr是IDEA支持的快速创建SpringBoot应用的快捷方式。\n* 第一步：选择Spring Initailizr，创建项目\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412135650.png)\n\n* 第二步：选择场景\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210325174214.png)\n\n* 第三步：设置项目名。\n* 第四步：等待。等待以依赖加载完成。\n* 项目结构\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210325174434.png)\n\n# 第九章： web开发\n\n* SpringBoot在官方文档中说已经给我们配置好了所有的配置。我们在大多数场景下都无需自定义配置。\n* 对于web开发，SpringBoot帮我们配置了\n  * 内容协商视图解析器和BeanName视图解析器\n  * 静态资源（包括webjars）\n  * 自动注册 `Converter，GenericConverter，Formatter `\n  * 支持 `HttpMessageConverters` \n  * 自动注册 `MessageCodesResolver` （国际化用）\n  * 静态index.html 页支持\n  * 自定义 `Favicon`  \n  * 自动使用 `ConfigurableWebBindingInitializer` ，（DataBinder负责将请求数据绑定到JavaBean上）\n* 同时我们还可以自定义自己的配置。例如：\n  * 不用@EnableWebMvc注解。使用 `@Configuration` + `WebMvcConfigurer` 自定义规则\n  * 声明 `WebMvcRegistrations` 改变默认底层组件\n  * 使用 `@EnableWebMvc+@Configuration+DelegatingWebMvcConfiguration 全面接管SpringMVC`\n\n## 9.1 静态资源访问\n\n* 在SpringBoot中默认的静态资源是放在类路径下的。\n\n  * 默认的资源路径文件目录可以是`/static` (or `/public` or `/resources` or ` /META-INF/resources` \n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210327131403.png)\n\n  * 访问路径为：当前项目根路径/+静态资源名。例如：http://localhost:8080/1.jpg\n\n* 当controller层有对/1.jpg请求的处理方法时，此请求不会访问资源，而是被controller的方法处理。\n\n* 原理：\n\n  * 首先SpringBoot设置的静态资源拦截是/**，表示拦截所有请求\n  * 当请求进来时，先找Controller能不能处理，不能处理则去静态资源的文件目录下寻找。即上述的目录。\n  * 当还找不到，就会报404错误。\n\n**更改资源的默认设置**\n\n* 更改静态资源的拦截的路径\n\n```properties\n# 设置静态资源的拦截路径是：当前项目根路径 + /res/ + 资源名称。\n# 例如：http://localhost:8080/res/1.jpg\nspring.mvc.static-path-pattern=/res/**\n```\n\n* 更改静态资源的文件目录\n\n```properties\n# 改变静态资源的默认路径。从原来的四个默认路径，变为了aaa路径下。此路径可以有多个\nspring.resources.static-locations[0]=classpath:/aaa/\nspring.resources.static-locations[1]=classpath:/bbb/\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210327135637.png)\n\n**webjar**\n\n* webjar是指：经常使用的js,jquery资源可以通过依赖的方式引入到项目中，而不通过将资源放到项目中。\n* webjar的官方地址：https://www.webjars.org/\n* SpringBoot对这类的资源的访问路径的前缀是：/webjar/**\n* 以访问jquery为例\n* 第一步：引入依赖\n\n```xml\n<dependency>\n  <groupId>org.webjars</groupId>\n  <artifactId>jquery</artifactId>\n  <version>3.6.0</version>\n</dependency>\n```\n\n* 第二步：查看依赖的源码（帮助理解的）\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210327140742.png)\n\n* 第三步：通过http://localhost:8080/webjars/jquery/3.6.0/jquery.js访问\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210327140949.png)\n\n### 9.1.1 欢迎页支持\n\n* SpringBoot默认访问的欢迎页是index.html。\n\n* 第一步：在静态资源路径下新建一个index.html文件\n\n* 注意点：\n\n  * 当设置的静态资源访问路径后，就无法访问欢迎页。\n  * 但是我们可以设置静态资源文件的目录。其不影响我们访问欢迎页。\n\n  ```properties\n  # 访问欢迎页时，这个设置不能有\n  # spring.mvc.static-path-pattern=/res/**\n  #下面的设置可以有\n  spring.resources.static-locations[0]=classpath: /aaa\n  ```\n\n* SpringBoot对于欢迎的访问默认为：http://localhost:8080/index.html。其中index.html可以隐藏。\n\n  * 因此当我们修改了静态资源访问路径后，无法访问到欢迎页面。\n  * 但是通过http://localhost:8080/res/index.html是可以访问到欢迎页的。\n\n### 9.1.2自定义Favicon(图标)\n\n* Favicon即图标，是浏览器标签页的小图标。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210327143721.png)\n\n* SpringBoot支持图标功能。但是图标的名称一定是favicon.ico\n* 图标文件可以放在静态资源路径下。\n* 注意点：和欢迎页一样。\n  * 当设置的静态资源访问路径后，就无法访问图标。\n* 原因和欢迎页一样。对图标的访问默认为：http://localhost:8080/favicon.ico\n\n### 9.1.3 静态资源配置原理\n\n* 首先SpringBoot在启动后会加载所有xxxAutoConfig（z自动配置）。\n* 因此我们查看WebMvcAutoConfiguration。他是一个静态资源的自动化配置类。代码如下：\n\n```java\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnWebApplication(type = Type.SERVLET) //确保当前是一个servlet的项目\n@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })//确保当前为mvc环境\n@ConditionalOnMissingBean(WebMvcConfigurationSupport.class) //确保当前没有mvc配置。即我们没有自定义mvc配置\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)\n@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,\n\t\tValidationAutoConfiguration.class })\npublic class WebMvcAutoConfiguration {}\n```\n\n* 总结：当前项目是mvc的servlet项目时，并且没有自定义配置。则``WebMvcAutoConfiguration`配置类生效。\n\n* 然后查看``WebMvcAutoConfiguration`，发现其内又包含一个配置类适配器。代码如下：\n\n  ```java\n  @Configuration(proxyBeanMethods = false)\n  @Import(EnableWebMvcConfiguration.class)\n  @EnableConfigurationProperties({ WebMvcProperties.class, ResourceProperties.class })//此处启用了配置属性类。\n  @Order(0)\n  public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer {\n  ```\n\n  * WebMvcProperties类：绑定了配置中以`spring.mvc`开头的配置\n  * ResourceProperties类：绑定了配置中以`spring.resources`开头的配置。并且注意一个代码\n\n  ```java\n  //此属性表明了资源的默认文件路径。对应配置中的spring.resources.static-locations配置\n  private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { \"classpath:/META-INF/resources/\",\n                                                                \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\" };\n  ```\n\n* 回到`WebMvcAutoConfigurationAdapter`配置类适配器中。发现只有一个有参的构造方法。代码如下：\n\n  ```java\n  public WebMvcAutoConfigurationAdapter(WebMvcProperties mvcProperties, ListableBeanFactory beanFactory,\n                                        ObjectProvider<HttpMessageConverters> messageConvertersProvider,\n                                        ObjectProvider<ResourceHandlerRegistrationCustomizer> resourceHandlerRegistrationCustomizerProvider,\n                                        ObjectProvider<DispatcherServletPath> dispatcherServletPath,\n                                        ObjectProvider<ServletRegistrationBean<?>> servletRegistrations) {\n    this.mvcProperties = mvcProperties;\n    this.beanFactory = beanFactory;\n    this.messageConvertersProvider = messageConvertersProvider;\n    this.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable();\n    this.dispatcherServletPath = dispatcherServletPath;\n    this.servletRegistrations = servletRegistrations;\n  }\n  ```\n\n  * **一个特点：有参构造器中所有参数的值都会从容器中确定**\n  * mvcProperties参数：获取所有spring.mvc绑定的值。\n  * beanFactory参数：Spring的bean工厂\n  * messageConvertersProvider参数：获取所有的HttpMessageConverters。消息转换器\n  * resourceHandlerRegistrationCustomizerProvider参数：找到资源处理器的自定义器\n  * dispatcherServletPath参数：servlet路径调度器\n  * servletRegistrations参数：给Servlet,Fliter...注册\n\n* 在``WebMvcAutoConfiguration`配置类中，有另一个配置类`EnableWebMvcConfiguration`\n\n**静态资源的配置代码** \n\n* 在其中有对资源`ResourceProperties`处理的默认配置。代码如下：\n\n  ```java\n  @Override\n  protected void addResourceHandlers(ResourceHandlerRegistry registry) {\n    super.addResourceHandlers(registry);\n    //当下面的属性为true时，启用资源配置。为false时不启用。\n    if (!this.resourceProperties.isAddMappings()) {\n      logger.debug(\"Default resource handling disabled\");\n      return;\n    }\n    //设置对webjar的静态资源配置\n    addResourceHandler(registry, \"/webjars/**\", \"classpath:/META-INF/resources/webjars/\");\n    //设置对静态资源的配置\n    addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(),\n                       this.resourceProperties.getStaticLocations());\n  \n  }\n  private void addResourceHandler(ResourceHandlerRegistry registry, String pattern, String... locations) {\n    if (registry.hasMappingForPattern(pattern)) {\n      return;\n    }\n    ResourceHandlerRegistration registration = registry.addResourceHandler(pattern);\n    registration.addResourceLocations(locations);\n    //设置静态资源的缓存策略。\n    registration.setCachePeriod(getSeconds(this.resourceProperties.getCache().getPeriod()));\n    registration.setCacheControl(this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl());\n    customizeResourceHandlerRegistration(registration);\n    this.autoConfiguredResourceHandlers.add(pattern);\n  }\n  ```\n\n  * 因此在`ResourceProperties`中查看addMappings属性。发现其默认为true。\n  * 且其可以在配置文件中配置。\n\n  ```properties\n  # 设置是否启用默认的静态资源配置\n  spring.resources.add-mappings=false\n  # 设置静态资源的缓存存在时间。单位秒\n  spring.resources.cache.period=11000\n  ```\n\n\n**欢迎页的配置代码**\n\n* 在上述的方法下面可以找到对欢迎页的配置。代码如下\n\n  ```java\n  @Bean\n  public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,\n                                                             FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) {\n    WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(\n      new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),\n      this.mvcProperties.getStaticPathPattern());\n    welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));\n    welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations());\n    return welcomePageHandlerMapping;\n  }\n  WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders,\n                            ApplicationContext applicationContext, Resource welcomePage, String staticPathPattern) {\n    //此处写死了欢迎页的访问。如果存在欢迎页，且静态资源访问路径为/**。则转发到欢迎页。\n    if (welcomePage != null && \"/**\".equals(staticPathPattern)) {\n      logger.info(\"Adding welcome page: \" + welcomePage);\n      setRootViewName(\"forward:index.html\");\n    }\n    else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) {\n      logger.info(\"Adding welcome page template: index\");\n      //如果修改了静态资源访问路径，则找有没有cpntroller能处理这个欢迎页。\n      setRootViewName(\"index\");\n    }\n  }\n  ```\n\n  * 首先明白一个单词： HandlerMapping：处理器映射。保存了每一个Handler能处理哪些请求。\n\n## 9.2 请求参数处理\n\n### 9.2.1 请求映射\n\n* SpringBoot支持REST风格的请求。因为它内置了HiddenHttpMethodFilter过滤器。\n\n* 但是在SpringBoot默认是关闭的。源码如下：\n\n  ```java\n  //WebMvcAutoConfiguration自动配置类中\n  @Bean\n  @ConditionalOnMissingBean(HiddenHttpMethodFilter.class)\n  @ConditionalOnProperty(prefix = \"spring.mvc.hiddenmethod.filter\", name = \"enabled\", matchIfMissing = false)\n  public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {\n    return new OrderedHiddenHttpMethodFilter();\n  }\n  ```\n\n**REST风格**\n\n* 指使用HTTP请求方式动词来表示对资源的操作\n\n* 以前：*/getUser*  *获取用户*   */deleteUser* *删除用户*   */editUser*  *修改用户*    */saveUser* *保存用户*\n\n* 现在： */user*   *GET-获取用户*   *DELETE-删除用户*   *PUT-修改用户*    *POST-保存用户*\n\n* HiddenHttpMethodFilter过滤器的使用方式：\n\n  * 表单提交。\n  * 隐藏提交的_method属性。其值设置为想要提交的方式(PUT,DELETE)。\n  * 表单的提交仍为post提交，但由于_method属性，在经过过滤器时，会将post提交设置为对应的put或delete提交。\n\n* HiddenHttpMethodFilter过滤器的代码：\n\n  ```java\n  @Override\n  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n    throws ServletException, IOException {\n  \n    HttpServletRequest requestToUse = request;\n  \t//提交方式为post提交，且有_method属性时才执行\n    if (\"POST\".equals(request.getMethod()) && request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) {\n      //获取请求中_method属性的值\n      String paramValue = request.getParameter(this.methodParam);\n      if (StringUtils.hasLength(paramValue)) {\n        //将其转换成大写\n        String method = paramValue.toUpperCase(Locale.ENGLISH);\n        //确定其是合法的。\n        //ALLOWED_METHODS包含PUT,DELETE,PATCH三种请求\n        if (ALLOWED_METHODS.contains(method)) {\n          //对请求进行装饰\n          requestToUse = new HttpMethodRequestWrapper(request, method);\n        }\n      }\n    }\n  \n    filterChain.doFilter(requestToUse, response);\n  }\n  ```\n\n  * 对于HttpMethodRequestWrapper装饰者类。利用了装饰式设计方式。代码如下：\n\n  ```java\n  private static class HttpMethodRequestWrapper extends HttpServletRequestWrapper {\n  \n    private final String method;\n  \n    public HttpMethodRequestWrapper(HttpServletRequest request, String method) {\n      super(request);\n      this.method = method;\n    }\n  \t//重写了这个方法，以区分请求的put和delete\n    @Override\n    public String getMethod() {\n      return this.method;\n    }\n  }\n  ```\n\n**REST风格请求的使用**\n\n* 首先在配置文件中开启HiddenHttpMethodFilter的功能\n\n  ```properties\n  # 开启Rest风格的请求\n  spring.mvc.hiddenmethod.filter.enabled=true\n  ```\n\n* 然后编写表单\n\n  ```html\n  <form action=\"/user\" method=\"get\">\n    <input type=\"submit\" value=\"get-提交\">\n  </form>\n  <br>\n  <form action=\"/user\" method=\"post\">\n    <input type=\"submit\" value=\"post-提交\">\n  </form>\n  <br>\n  <form action=\"/user\" method=\"post\">\n    <input name=\"_method\" hidden=\"hidden\" value=\"put\">\n    <input type=\"submit\" value=\"put-提交\">\n  </form>\n  <br>\n  <form action=\"/user\" method=\"post\">\n    <input name=\"_method\" hidden=\"hidden\" value=\"delete\">\n    <input type=\"submit\" value=\"delete-提交\">\n  </form>\n  ```\n\n* 编写controller代码。Spring支持简化的RequestMapping的写法，不同mappering对应不同的请求\n\n  ```java\n  //@RequestMapping(value = \"/user\",method = RequestMethod.GET)\n  //简化为\n  @GetMapping(\"/user\")\n  public String getUser(){\n    return \"get-user\";\n  }\n  //@RequestMapping(value = \"/user\",method = RequestMethod.POST)\n  @PostMapping(\"/user\")\n  public String postUser(){\n    return \"post-user\";\n  }\n  //@RequestMapping(value = \"/user\",method = RequestMethod.PUT)\n  @PutMapping(\"/user\")\n  public String putUser(){\n    return \"put-user\";\n  }\n  //@RequestMapping(value = \"/user\",method = RequestMethod.DELETE)\n  @DeleteMapping(\"/user\")\n  public String deleteUser(){\n    return \"delete-user\";\n  }\n  ```\n\n**REST使用客户端工具**\n\n* 加入使用的是PostMan或手机等工具。它们发送的请求本身就是REST风格的。因此不需要配置HiddenHttpMethodFilter\n* 这也是为什么spring.mvc.hiddenmethod.filter.enabled的值默认是false。\n\n**请求映射的原理**\n\n* 在SpringBoot中所有的请求都会访问DispatcherServlet的doDispatch()方法。代码如下：\n\n  ```java\n  protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    //复制当前的请求\n    HttpServletRequest processedRequest = request;\n    HandlerExecutionChain mappedHandler = null;\n    boolean multipartRequestParsed = false;\n  \n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n  \n    try {\n      ModelAndView mv = null;\n      Exception dispatchException = null;\n  \n      try {\n        processedRequest = checkMultipart(request);\n        multipartRequestParsed = (processedRequest != request);\n  \n        // 找到当前请求使用哪个handler处理。handler指controller中的方法。\n        mappedHandler = getHandler(processedRequest);\n        if (mappedHandler == null) {\n          noHandlerFound(processedRequest, response);\n          return;\n        }\n  \n        // Determine handler adapter for the current request.\n        HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n  ```\n\n* 然后调用getHandler方法。代码如下：\n\n  ```java\n  @Nullable\n  protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n    if (this.handlerMappings != null) {\n      //遍历当前所有的处理器映射。\n      for (HandlerMapping mapping : this.handlerMappings) {\n        HandlerExecutionChain handler = mapping.getHandler(request);\n        if (handler != null) {\n          return handler;\n        }\n      }\n    }\n    return null;\n  }\n  ```\n\n  * 初始情况下。处理器映射如下\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210327172601.png)\n\n  * 我们编写的被RequestMapping注解修饰的方法的映射就在RequestMappingHandlerMapping中。\n  * 位置如下：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210327172722.png)\n\n* 因此：当请求进来后。\n\n  * 首先在RequestMappingHandlerMapping中即controller中查找有没有处理请求的handler。\n  * 如果没有就去WelcomePageHandlerMapping 中查找。\n  * 当最中没有找到时，才会返回错误页面。\n\n* 我们有时会自定义一些映射处理，即xxxHandlerMapping。然后就可以对请求进行分类。达到不同系统 的问题。\n\n### 9.2.2 普通参数与基本注解\n\n* 对于在controller接受请求中传来的参数。对应的注解大致分为4种。\n\n**注解：**\n\n常见的有：@PathVariable、@RequestHeader、@RequestAttribute、@RequestParam、@MatrixVariable、@CookieValue、@RequestBody等\n\n* @PathVariable：获取请求中url路径的参数信息\n\n  * 请求的url格式为：/car/{1}/name/{李四}。其中{}中的数据为要获取的参数信息。\n\n  * 使用方式一：将参数封装到对应的参数中。想要指明哪个参数获取哪个信息。\n\n    * 请求的url：http://localhost:8080/car/1/owner/lisi\n    * controller层代码\n\n    ```java\n    /**\n     * 请求路径中的{}对应位置被绑定为参数，参数的名称为id或name.\n     * 在方法的参数上通过@PathVariable注解让id,name参数再绑定到对应的参数上。\n     */\n    @GetMapping(\"/car/{id}/owner/{name}\")\n    public Map<String,Object> test1(@PathVariable(\"id\") Integer id,@PathVariable(\"name\") String name){\n     //此时的id的值就是url中的1.name的值为lisi\n      \n      Map<String,Object> result = new HashMap<>();\n      result.put(\"id\", id);\n      result.put(\"name\", name);\n     \n      return result;\n    }\n    ```\n\n  * 使用方式二：将参数封装到map中。不需要指明。此时会将所有的都绑定到map中\n\n    * 请求url:http://localhost:8080/car/1/owner/lisi\n    * controller层代码\n\n    ```java\n    /**\n     * 此时不需要指定参数绑定的名称，默认将所有参数都绑定到map中\n     */\n    @GetMapping(\"/car/{id}/owner/{name}\")\n    public Map<String,String> test1(Map<String,String> pathParamMap){\n    \t//此时的pathParamMap中有两个key-value.\n      //一个是：id-1\n      //另一个是：name-lisi\n      return pathParamMap;\n    }\n    ```\n\n  * 源码：\n\n  ```java\n  /**\n   * Annotation which indicates that a method parameter should be bound to a URI template\n   * variable. Supported for {@link RequestMapping} annotated handler methods.\n   *\n   * <p>If the method parameter is {@link java.util.Map Map&lt;String, String&gt;}\n   * then the map is populated with all path variable names and values.\n   *意为如果方法的参数是Map<String,String>类型的，则将所有的路径参数绑定到map中\n   *注意Map的key和value都是String类型的\n   *\n   * @author Arjen Poutsma\n   * @author Juergen Hoeller\n   * @since 3.0\n   * @see RequestMapping\n   * @see org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\n   */\n  @Target(ElementType.PARAMETER)\n  @Retention(RetentionPolicy.RUNTIME)\n  @Documented\n  public @interface PathVariable {\n  ```\n\n* @RequestHeader：获取请求中请求头的信息。\n\n  * 类似于这样\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210330095925.png)\n\n  * 使用方式一：明确指出要获取的请求头中，对应key-value的属性值。\n\n    * controller代码：\n\n    ```java\n    @GetMapping(\"/car\")\n    public Map<String,String> test3(@RequestHeader(\"accept\") String accept){\n      //只获取请求头中accept对应的值，将其绑定到参数accept中。\n      Map<String,String> result = new HashMap<>();\n      result.put(\"accept\", accept);\n      return result;\n    }\n    ```\n\n  * 使用方式二：获取请求头中所有的信息。参数为Map或MultiValueMap或HttpHeaders\n\n    * 查看源码可知：HttpHeaders实现了MultiValueMap接口，而MultiValueMap接口继承了map接口\n    * controller代码：\n\n    ```java\n    @GetMapping(\"/car\")\n    public Map<String,Object> test4(@RequestHeader HttpHeaders headers){\n      //将请求头中的所有信息都绑定到headers参数中\n      Map<String, Object> result = new HashMap<>();\n      result.put(\"headers\", headers);\n      return result;\n    }\n    //HttpHeaders的部分源码\n    public class HttpHeaders implements MultiValueMap<String, String>, Serializable {\n      public static final String ACCEPT = \"Accept\";\n    \n      public static final String ACCEPT_CHARSET = \"Accept-Charset\";\n    \n      public static final String ACCEPT_ENCODING = \"Accept-Encoding\";\n    \n      public static final String ACCEPT_LANGUAGE = \"Accept-Language\";\n    \n      public static final String ACCEPT_RANGES = \"Accept-Ranges\";\n    \n      public static final String ACCESS_CONTROL_ALLOW_CREDENTIALS = \"Access-Control-Allow-Credentials\";\n    \n      public static final String ACCESS_CONTROL_ALLOW_HEADERS = \"Access-Control-Allow-Headers\";\n    \n      public static final String ACCESS_CONTROL_ALLOW_METHODS = \"Access-Control-Allow-Methods\";\n    \n      public static final String ACCESS_CONTROL_ALLOW_ORIGIN = \"Access-Control-Allow-Origin\";\n    }\n    //MultiValueMap的部分源码\n    public interface MultiValueMap<K, V> extends Map<K, List<V>> {}\n    ```\n\n  * 源码：\n\n  ```java\n  /**\n   * Annotation which indicates that a method parameter should be bound to a web request header.\n   *\n   * <p>Supported for annotated handler methods in Spring MVC and Spring WebFlux.\n   *\n   * <p>If the method parameter is {@link java.util.Map Map&lt;String, String&gt;},\n   * {@link org.springframework.util.MultiValueMap MultiValueMap&lt;String, String&gt;},\n   * or {@link org.springframework.http.HttpHeaders HttpHeaders} then the map is\n   * populated with all header names and values.\n   *\n   * @author Juergen Hoeller\n   * @author Sam Brannen\n   * @since 3.0\n   * @see RequestMapping\n   * @see RequestParam\n   * @see CookieValue\n   */\n  @Target(ElementType.PARAMETER)\n  @Retention(RetentionPolicy.RUNTIME)\n  @Documented\n  public @interface RequestHeader {}\n  ```\n\n* @RequestAttribute：绑定请求域中的信息\n\n  * 代码：转发前往request域中放入key-value信息，转发后获取请求与中的信息。\n\n  ```java\n  @GetMapping(\"/goToPage\")\n  public String goToPage(HttpServletRequest request){\n    request.setAttribute(\"msg\", \"成功了\");\n    request.setAttribute(\"code\", 200);\n    return \"success\";\n  }\n  \n  @ResponseBody\n  @GetMapping(\"/success\")\n  public Map<String,Object> test2(@RequestAttribute(\"msg\")String msg,@RequestAttribute(\"code\")Integer code){\n    //获取请求域中指定属性的值\n    Map<String,Object> result = new HashMap<>();\n    result.put(\"msg\", msg);\n    result.put(\"code\", code);\n    return result;\n  }\n  //直接获取请求域,作用和上面相同\n  @ResponseBody\n  @GetMapping(\"/success\")\n  public Map<String,Object> test3(HttpServletRequest request){\n    //获取请求域中指定属性的值\n    Map<String,Object> result = new HashMap<>();\n    result.put(\"msg\", request.getAttribute(\"msg\"));\n    result.put(\"code\",  request.getAttribute(\"code\"));\n    return result;\n  }\n  ```\n\n  * 源码：\n\n  ```java\n  /**\n   * Annotation to bind a method parameter to a request attribute.\n   *\n   * <p>The main motivation is to provide convenient access to request attributes\n   * from a controller method with an optional/required check and a cast to the\n   * target method parameter type.\n   *\n   * @author Rossen Stoyanchev\n   * @since 4.3\n   * @see RequestMapping\n   * @see SessionAttribute\n   */\n  @Target(ElementType.PARAMETER)\n  @Retention(RetentionPolicy.RUNTIME)\n  @Documented\n  public @interface RequestAttribute {}\n  ```\n\n* @RequestParam：绑定请求参数类型。和SpringMVC的用法一致\n\n* @CookieValue：获取请求头中cookie属性的值。cookie中又分很多key-value的信息。\n\n  * 例如上述的图片中就有lang和yuque_ctoken两个属性的值。\n  * 使用方式一：指定获取的key。将其value绑定到参数中\n\n  ```java\n  @GetMapping(\"/car\")\n  public Map<String,Object> test5(@CookieValue(\"lang\")String lang){\n    //只获取cookie中lang对应的value值，将其绑定到lang参数中\n    Map<String, Object> result = new HashMap<>();\n    result.put(\"lang\", lang);\n    return result;\n  }\n  ```\n\n  * 使用方式二：将所有的信息绑定到Cookie对象中。\n    * 注意Cookie是javax.servlet.http包下的Cookie类\n\n  ```java\n  @GetMapping(\"/car\")\n  public Map<String,Object> test6(@CookieValue Cookie cookie){\n    //将cookie中的所有属性绑定到cookie中\n    Map<String, Object> result = new HashMap<>();\n    result.put(\"cookie\", cookie);\n    return result;\n  }\n  ```\n\n  * 源码：\n\n  ```java\n  /**\n   * Annotation which indicates that a method parameter should be bound to an HTTP cookie.\n   *\n   * <p>The method parameter may be declared as type {@link javax.servlet.http.Cookie}\n   * or as cookie value type (String, int, etc.).\n   *\n   * @author Juergen Hoeller\n   * @author Sam Brannen\n   * @since 3.0\n   * @see RequestMapping\n   * @see RequestParam\n   * @see RequestHeader\n   * @see org.springframework.web.bind.annotation.RequestMapping\n   */\n  @Target(ElementType.PARAMETER)\n  @Retention(RetentionPolicy.RUNTIME)\n  @Documented\n  public @interface CookieValue {}\n  ```\n\n* @RequestBody：获取请求体中的数据。请求体一般只有post请求中才有。\n\n  * 代码\n\n  ```java\n  @PostMapping(\"/save\")\n  public Map<String,String> terst7(@RequestBody String context){\n    Map<String,String> map = new HashMap<>();\n    map.put(\"context\",context);\n    return map;\n  }\n  ```\n\n  * 源码\n\n  ```java\n  /**\n   * Annotation indicating a method parameter should be bound to the body of the web request.\n   * The body of the request is passed through an {@link HttpMessageConverter} to resolve the\n   * method argument depending on the content type of the request. Optionally, automatic\n   * validation can be applied by annotating the argument with {@code @Valid}.\n   *\n   * <p>Supported for annotated handler methods.\n   *\n   * @author Arjen Poutsma\n   * @since 3.0\n   * @see RequestHeader\n   * @see ResponseBody\n   * @see org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\n   */\n  @Target(ElementType.PARAMETER)\n  @Retention(RetentionPolicy.RUNTIME)\n  @Documented\n  public @interface RequestBody {}\n  ```\n\n* @MatrixVariable：<font color=\"red\">矩阵变量</font>\n\n  * 矩阵变量：在URL中，以url路径为基础的，用“;”分割的数据信息\n\n  ```java\n  //URL:/car/path;name=lisi;age=10\n  controller映射为：@GetMapping(\"/car/{path}\")\n  //其中path;name=lisi;age=10以;拆分，第一个path仍未路径参数。后面的name=lisi和age=10为矩阵变量。\n  ```\n\n  * 用处：当浏览器禁用Cookie时，对于Session的id服务器就无法获取了。因此可以在矩阵变量中传递这个SessionId。\n  * 通用的功能请求参数也能实现，但使用矩阵变量可以和请求参数区别开。\n  * 注意点：\n    * 语法：/car/path;name=lisi;brand=byd,audi,yd\n    * SpringBoot默认时禁用了矩阵变量的功能。想要手动开启。开启方式在下面\n    * 矩阵变量必须有url路径变量才能被解析。\n  * 使用方式：可以指明具体的key,也可以使用map承接全部的变量\n  * 示例一：值传递一个路径参数的矩阵变量\n\n  ```java\n  /**\n   * 请求url:/car/path;name=lisi;brand=byd,yd,audi\n   */\n  @GetMapping(\"/car/{path}\")\n  public Map test8(@MatrixVariable(\"name\") String name,\n                   @MatrixVariable(\"brand\") List<Integer> brand,\n                   @PathVariable(\"path\")String path){\n    //注意必须有@PathVariable。@MatrixVariable才起作用。\n    //参数的值分别为：path = path ,name = lisi ,brand = [byd,yd,audi]\n    Map<String,Object> result = new HashMap<>();\n    result.put(\"name\",name);\n    result.put(\"brand\",brand);\n    result.put(\"path\",path);\n    return result;\n  }\n  ```\n\n  * 示例二：值传递二个以上路径参数的矩阵变量。此处可以省略 @PathVariable路径变量注解。\n\n  ```java\n  /**\n   * 请求url:/car/first;age=20/second;age=10\n   * pathVar属性：指定当前的矩阵变量是属于哪个路径变量的\n   * @return\n   */\n  @GetMapping(\"/car/{first}/{second}\")\n  public Map test9(@MatrixVariable(value = \"age\",pathVar = \"first\") String firstAge,\n                   @MatrixVariable(value = \"age\",pathVar = \"second\") String secondAge,\n                   @PathVariable(\"first\")String first,\n                   @PathVariable(\"second\")String second){\n    //注意必须有@PathVariable。@MatrixVariable才起作用。\n    //参数的值分别为：firstAge = 20，secondAge=10，first=first，second=second\n    Map<String,Object> result = new HashMap<>();\n    result.put(\"firstAge\",firstAge);\n    result.put(\"secondAge\",secondAge);\n    result.put(\"first\",first);\n    result.put(\"second\",second);\n    return result;\n  }\n  ```\n\n* SpringBoot关于矩阵变量的源码\n\n  * 第一个：WebMvcAutoConfiguration自动配置类中有一个配置路径变量的方法。\n\n  ```java\n  //configurePathMatch意为：配置路径匹配\n  @Override\n  @SuppressWarnings(\"deprecation\")\n  public void configurePathMatch(PathMatchConfigurer configurer) {\n    configurer.setUseSuffixPatternMatch(this.mvcProperties.getPathmatch().isUseSuffixPattern());\n    configurer.setUseRegisteredSuffixPatternMatch(\n      this.mvcProperties.getPathmatch().isUseRegisteredSuffixPattern());\n    this.dispatcherServletPath.ifAvailable((dispatcherPath) -> {\n      String servletUrlMapping = dispatcherPath.getServletUrlMapping();\n      if (servletUrlMapping.equals(\"/\") && singleDispatcherServlet()) {\n        //UrlPathHelper被添加到了配置中。下面查看这个类\n        UrlPathHelper urlPathHelper = new UrlPathHelper();\n        urlPathHelper.setAlwaysUseFullPath(true);\n        configurer.setUrlPathHelper(urlPathHelper);\n      }\n    });\n  }\n  ```\n\n  * 第二个：UrlPathHelper类中有一个属性removeSemicolonContent\n\n  ```java\n  //UrlPathHelper意为url路径帮助。此类中配置了很多的关于URL的解码方式\n  public class UrlPathHelper {\n    //此属性意为：移除分号内容。此属性就是控制矩阵变量功能是否开启的配置。默认为true\n    //true：表示在url中会将\";\"分号后面的都给移除掉，因此矩阵变量就不起作用了。\n    //将其设置为false就可以开启矩阵变量功能。\n    private boolean removeSemicolonContent = true;\n  }\n  ```\n\n* 开启矩阵变量功能的方式：\n\n  * 方式一：创建一个配置类，让这个配置类实现WebMvcConfigurer接口，然后重写configurePathMatch方法。\n\n  ```java\n  @Configuration()\n  public class WebConfig implements WebMvcConfigurer {\n    @Override\n    public void configurePathMatch(PathMatchConfigurer configurer) {\n      UrlPathHelper helper = new UrlPathHelper();\n      //在此处将removeSemicolonContent属性设置为false即可\n      helper.setRemoveSemicolonContent(false);\n      configurer.setUrlPathHelper(helper);\n    }\n  }\n  ```\n\n  * 方式二：使用bean注解。往容器中加入一个修改后的WebMvcConfigurer实体。\n\n  ```java\n  @Configuration()\n  public class WebConfig{\n    @Bean\n    public WebMvcConfigurer webMvcConfigurer(){\n      //使用匿名内部类的方式实现实体的创建。\n      return new WebMvcConfigurer(){\n        @Override\n        public void configurePathMatch(PathMatchConfigurer configurer) {\n          UrlPathHelper helper = new UrlPathHelper();\n          //在此处将removeSemicolonContent属性设置为false即可\n          helper.setRemoveSemicolonContent(false);\n          configurer.setUrlPathHelper(helper);\n        }\n      };\n    }\n  }\n  ```\n\n**Servlet API**\n\nWebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId\n\n* 查看源码：ServletRequestMethodArgumentResolver类。请求方法参数解析。\n\n  * 用于解析上面的ServletAPI类型的参数。核心代码如下\n\n  ```java\n  @Override\n  public boolean supportsParameter(MethodParameter parameter) {\n    Class<?> paramType = parameter.getParameterType();\n    return (WebRequest.class.isAssignableFrom(paramType) ||\n            ServletRequest.class.isAssignableFrom(paramType) ||\n            MultipartRequest.class.isAssignableFrom(paramType) ||\n            HttpSession.class.isAssignableFrom(paramType) ||\n            (pushBuilder != null && pushBuilder.isAssignableFrom(paramType)) ||\n            Principal.class.isAssignableFrom(paramType) ||\n            InputStream.class.isAssignableFrom(paramType) ||\n            Reader.class.isAssignableFrom(paramType) ||\n            HttpMethod.class == paramType ||\n            Locale.class == paramType ||\n            TimeZone.class == paramType ||\n            ZoneId.class == paramType);\n  }\n  ```\n\n**复杂参数**\n\n**Map**、**Model（map、model里面的数据会被放在request的请求域  request.setAttribute）、**Errors/BindingResult、**RedirectAttributes（ 重定向携带数据）**、**ServletResponse（response）**、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder\n\n* map和model做参数时，会在解析时返回mavContainer.getModel()。\n* 而getModel()方法会BindingAwareModelMap对象。\n* 当map和model在同一个处理器中，参数解析器只会创建一个BindingAwareModelMap对象，而不是创建两个。\n\n### 9.2.3 **自定义对象参数** POJO封装过程\n\n* 解析器为ServletModelAttributeMethodProcessor类\n  * 先创建空对象。\n  * 然后将请求参数转换成对应的数据类型。(提供了大概124个类型转换器)\n  * 在为对象的属性设置值。通过反射。\n* GenericConversionService：在设置每一个值的时候，找它里面的所有converter那个可以将这个数据类型（request带来参数的字符串）转换到指定的类型（JavaBean -- Integer）。\n* 自定义的类型转换器。类型转换器会被添加到converter中。\n* 样例\n\n```java\n//1、WebMvcConfigurer定制化SpringMVC的功能\n@Bean\npublic WebMvcConfigurer webMvcConfigurer(){\n  return new WebMvcConfigurer() {\n    @Override\n    public void addFormatters(FormatterRegistry registry) {\n      registry.addConverter(new Converter<String, Pet>() {\n\n        @Override\n        public Pet convert(String source) {\n          // 啊猫,3\n          if(!StringUtils.isEmpty(source)){\n            Pet pet = new Pet();\n            String[] split = source.split(\",\");\n            pet.setName(split[0]);\n            pet.setAge(Integer.parseInt(split[1]));\n            return pet;\n          }\n          return null;\n        }\n      });\n    }\n  };\n}\n```\n\n### 9.2.4 参数处理原理\n\n* 首先：DispatcherServlet类中的doDispatch方法用于对请求进行处理。此方法中有三步处理\n* 方法的简化源码如下\n\n```java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n  ModelAndView mv;\n  HttpServletRequest processedRequest = request;\n  //第一步：getHandler()方法用于获取当前请求的处理器(即有RequestMapping注解的方法。)\n  mappedHandler = getHandler(processedRequest);\n  if (mappedHandler == null) {\n    noHandlerFound(processedRequest, response);\n    return;\n  }\n\n  //第二步：根据当前的处理器找到对应的处理器适配器\n  //这一步是因为方法的参数的匹配很麻烦，因此使用适配器解析参数，然后通过反射调用处理器。\n  HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n  //第三步：执行处理器适配的目标方法。此方法执行后请求就完成了处理。\n  mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\t//对响应结果进行处理\n  processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n}\n```\n\n* 上述的第一步：获取处理器的源码如下\n\n  ```java\n  @Nullable\n  protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n    if (this.handlerMappings != null) {\n      //遍历全部的处理器映射，返回合适的处理器\n      for (HandlerMapping mapping : this.handlerMappings) {\n        HandlerExecutionChain handler = mapping.getHandler(request);\n        if (handler != null) {\n          return handler;\n        }\n      }\n    }\n    return null;\n  }\n  ```\n\n  * 处理器映射的截图如下\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210327172601.png)\n\n* 上述的第二步：获取处理器适配器的源码如下\n\n  ```java\n  protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {\n    if (this.handlerAdapters != null) {\n      //遍历全部的处理器适配器，找到合适的适配器\n      for (HandlerAdapter adapter : this.handlerAdapters) {\n        if (adapter.supports(handler)) {\n          return adapter;\n        }\n      }\n    }\n    throw new ServletException(\"No adapter for handler [\" + handler +\n                               \"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler\");\n  }\n  ```\n\n  * 处理器适配器的截图如下：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210330153242.png)\n\n* 上述的第三步：\n\n  * handle方法又调用了handleInternal()方法。\n  * handleInternal方法判断请求是否是同步的。然后又调用了invokeHandlerMethod方法\n  * invokeHandlerMethod方法才是真正的执行处理器的方法。方法位于RequestMappingHandlerAdapter类中\n\n* invokeHandlerMethod的核心源码如下。\n\n  ```java\n  //设置参数解析器\n  if (this.argumentResolvers != null) {\n    invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n  }\n  //设置返回值解析器\n  if (this.returnValueHandlers != null) {\n    invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n  }\n  //执行并且处理。\n  invocableMethod.invokeAndHandle(webRequest, mavContainer);\n  ```\n\n  * 参数解析器如下：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210330154710.png)\n\n  * 返回值解析器如下：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210330155312.png)\n\n* 参数解析器的说明\n\n  ```java\n  public interface HandlerMethodArgumentResolver {\n  \tboolean supportsParameter(MethodParameter parameter);\n  \t@Nullable\n  \tObject resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n  \t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;\n  }\n  ```\n\n  * 使用步骤：supportsParameter用于判断当前参数支不支持这个参数解析器。\n  * 支持就调用resolveArgument方法\n\n* invokeAndHandle方法的说明\n\n  ```java\n  public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n                              Object... providedArgs) throws Exception {\n  \t//此方法真正的执行了controller层的方法。\n    //此方法先确定了方法的每个参数的值，然后通过反射执行目标方法。\n    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\n  }\n  ```\n\n* invokeForRequest()方法中调用了getMethodArgumentValues()方法获取了方法的参数值。\n\n* getMethodArgumentValues方法源码如下\n\n  ```java\n  protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n                                             Object... providedArgs) throws Exception {\n  \t//获取所有的参数列表\n    MethodParameter[] parameters = getMethodParameters();\n    //判断参数列表是否为空\n    if (ObjectUtils.isEmpty(parameters)) {\n      return EMPTY_ARGS;\n    }\n  \t//创建了Object数组，存放参数的值信息\n    Object[] args = new Object[parameters.length];\n    for (int i = 0; i < parameters.length; i++) {\n      MethodParameter parameter = parameters[i];\n      parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n      args[i] = findProvidedArgument(parameter, providedArgs);\n      if (args[i] != null) {\n        continue;\n      }\n      //判断当前解析器支不支持当前类型的请求\n      if (!this.resolvers.supportsParameter(parameter)) {\n        throw new IllegalStateException(formatArgumentError(parameter, \"No suitable resolver\"));\n      }\n      try {\n        //此处开始解析参数\n        args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);\n      }\n      catch (Exception ex) {\n        // Leave stack trace for later, exception may actually be resolved and handled...\n        if (logger.isDebugEnabled()) {\n          String exMsg = ex.getMessage();\n          if (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {\n            logger.debug(formatArgumentError(parameter, exMsg));\n          }\n        }\n        throw ex;\n      }\n    }\n    return args;\n  }\n  ```\n\n* resolveArgument方法调用了getArgumentResolver(parameter)方法。那到当前参数的参数解析器。\n\n* getArgumentResolver(parameter)方法源码如下\n\n  ```java\n  @Nullable\n  private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {\n    //首先从缓存中找。\n    HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);\n    if (result == null) {\n      //遍历所有的参数解析器\n      for (HandlerMethodArgumentResolver resolver : this.argumentResolvers) {\n        //supportsParameter通过检查参数是否标识了对应的注解。标识的化就返回true\n        if (resolver.supportsParameter(parameter)) {\n          result = resolver;\n          //将参数解析器和对应的参数存入缓存。这样后面的访问就会很快\n          this.argumentResolverCache.put(parameter, result);\n          break;\n        }\n      }\n    }\n    return result;\n  }\n  ```\n\n* resolveArgument方法调用resolver.resolveArgument()。解析器的解析方法。解析参数的值。并将值返回\n\n* resolveArgument方法源码如下。\n\n  ```java\n  @Override\n  @Nullable\n  public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n                                      NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n  \n    NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);\n    MethodParameter nestedParameter = parameter.nestedIfOptional();\n    //获取解析的key。比如路径解析中{}中的值\n    Object resolvedName = resolveEmbeddedValuesAndExpressions(namedValueInfo.name);\n  \n  \t//解析key对应的值\n    Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);\n  \n    return arg;\n  }\n  ```\n\n* 请求处理完后。会返回一个ModelAndView。这个对象存放着返回的视图和数据。\n\n* 对响应结果的处理\n\n## 9.3 数据响应与内容协商\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210403085808.jpg)\n\n### 9.3.1 响应JSON\n\n* 使用方式：\n\n  * 引入web开发场景。此时web开发场景已经整合了json依赖。\n\n  ```xml\n  <!--web开发场景-->\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n  </dependency>\n  <!--整合了以下关于json的依赖-->\n  <dependency>\n    <groupId>com.fasterxml.jackson.datatype</groupId>\n    <artifactId>jackson-datatype-jdk8</artifactId>\n    <version>2.11.4</version>\n    <scope>compile</scope>\n  </dependency>\n  <dependency>\n    <groupId>com.fasterxml.jackson.datatype</groupId>\n    <artifactId>jackson-datatype-jsr310</artifactId>\n    <version>2.11.4</version>\n    <scope>compile</scope>\n  </dependency>\n  ```\n\n  * 在处理器上添加注解。\n\n  ```java\n  @ResponseBody\n  @GetMapping(\"/test/json\")\n  public Person getPerson(){\n    Person person = new Person();\n    person.setName(\"lisi\");\n    person.setAge(18);\n    person.setBirth(new Date());\n    return person;\n  }\n  ```\n\n\n### 9.3.2 内容协商\n\n* 内容协商是指：浏览器再发送请求时，会在请求头中告诉服务器，浏览器能接收什么类型的返回数据。\n\n  ```xml\n  // q=0.9标识权重。权重越大标识客户端更想接收此类型的响应。\n  accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\n  ```\n\n* **内容协商原理**\n\n  * 第一步：客户端发送请求给服务器\n  * 第二步：服务器判断当前响应头中是否已经有确认的媒体类型。即被拦截器修改的\n  * 第三步：服务器获取客户端支持接收的内容类型。（获取客户端请求头中Accept的字段）\n    * **contentNegotiationManager** 内容协商管理器 默认使用基于请求头的策略。(此策略可以改)\n    * 进而使用**HeaderContentNegotiationStrategy**  确定客户端可以接收的内容类型 \n  * 第四步：遍历所有的消息转换器。看谁能支持当前的返回值类型数据\n  * 第五步：遍历客户端能接受的，服务端能产生的。匹配后放入list中\n  * 第六步：找到最佳匹配的媒体数据类型。\n  * 第六步：遍历所有的消息转换器。找到合适的消息转换器，将数据转换成对应的媒体类型\n\n  ```java\n  //创建媒体类型\n  MediaType selectedMediaType = null;\n  MediaType contentType = outputMessage.getHeaders().getContentType();\n  boolean isContentTypePreset = contentType != null && contentType.isConcrete();\n  if (isContentTypePreset) {\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Found 'Content-Type:\" + contentType + \"' in response\");\n    }\n    selectedMediaType = contentType;\n  }\n  else {\n    HttpServletRequest request = inputMessage.getServletRequest();\n    //获取客户端支持的响应媒体的类型\n    List<MediaType> acceptableTypes = getAcceptableMediaTypes(request);\n    //获取响应返回值支持的媒体的类型\n    List<MediaType> producibleTypes = getProducibleMediaTypes(request, valueType, targetType);\n  \n    List<MediaType> mediaTypesToUse = new ArrayList<>();\n    //双重遍历两个媒体类型。找到能被客户端接收的返回值支持的媒体类型\n    for (MediaType requestedType : acceptableTypes) {\n      for (MediaType producibleType : producibleTypes) {\n        if (requestedType.isCompatibleWith(producibleType)) {\n          mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n        }\n      }\n    }\n    if (mediaTypesToUse.isEmpty()) {\n      if (body != null) {\n        throw new HttpMediaTypeNotAcceptableException(producibleTypes);\n      }\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"No match for \" + acceptableTypes + \", supported: \" + producibleTypes);\n      }\n      return;\n    }\n  ```\n\n* **开启浏览器参数方式内容协商功能**\n\n  * 为了方便内容协商，开启基于请求参数的内容协商功能。\n\n  ```properties\n  # 开启请求参数内容协商模式\n  spring.mvc.contentnegotiation.favor-parameter=true\n  ```\n\n  * 请求样式为：http://localhost:8080/test/person?format=json或http://localhost:8080/test/person?format=xml。\n  * 默认使用format来确定格式。\n  * 原理：\n    * 在服务器获取客户端能接受的内容类型。\n    * **contentNegotiationManager** 内容协商管理器 。默认基于请求头策略。\n    * 此时会加上基于参数的协商功能。\n\n### 9.3.3 原理解析\n\n* 在SpringBoot中对于参数的解析有参数解析器。对于返回的解析当然也有返回值解析器。\n\n* 在HandlerMethodArgumentResolver的方法中有段代码是设置返回值解析器的。\n\n  ```java\n  @Nullable\n  protected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n                                             HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n  \n    ServletWebRequest webRequest = new ServletWebRequest(request, response);\n   \t\n      if (this.argumentResolvers != null) {\n        //设置所有的参数解析器\n        invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n      }\n      if (this.returnValueHandlers != null) {\n       //设置所有的返回值解析器\n        invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n      }\n  }\n  ```\n\n* 返回值解析器如下\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210403085804.png)\n\n* 使用返回值处理器的代码如下\n\n  ```java\n  if (returnValue == null) {\n    //返回值为空时\n    if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {\n      disableContentCachingIfNecessary(webRequest);\n      mavContainer.setRequestHandled(true);\n      return;\n    }\n  }\n  else if (StringUtils.hasText(getResponseStatusReason())) {\n    //返回值有错误信息时\n    mavContainer.setRequestHandled(true);\n    return;\n  }\n  try {\n    //使用返回值处理器\n    this.returnValueHandlers.handleReturnValue(\n      returnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n  }\n  ```\n\n* 内部使用原理如下\n\n  ```java\n  //获取具体的返回值处理器。即从15个处理器中选择一个真正处理这个返回值的处理器\n  HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);\n  if (handler == null) {\n    throw new IllegalArgumentException(\"Unknown return value type: \" + returnType.getParameterType().getName());\n  }\n  //调用处理器的处理方法，解析返回值\n  handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);\n  }\n  ```\n\n* 返回值解析器的原理：\n\n  * 返回值处理器判断是否支持这种类型返回值 supportsReturnType 方法\n  * 支持的话，返回值处理器调用 handleReturnValue方法 进行处理。\n\n* 以json返回为例：\n\n  * 返回值标注了ResponseBody注解，所以返回值处理器为RequestResponseBodyMethodProcessor处理器。\n  * handleReturnValue方法代码如下\n\n  ```java\n  @Override\n  public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n                                ModelAndViewContainer mavContainer, NativeWebRequest webRequest)\n    throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n  \n    mavContainer.setRequestHandled(true);\n    ServletServerHttpRequest inputMessage = createInputMessage(webRequest);\n    ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);\n  \n    // 使用消息转换器处理返回值数据\n    writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);\n  }\n  ```\n\n* 利用 MessageConverters 进行处理 将数据写为json\n\n  * 内容协商（浏览器默认会以请求头的方式告诉服务器他能接受什么样的内容类型）\n  * 服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据，\n  * SpringMVC会挨个遍历所有容器底层的 HttpMessageConverter ，看谁能处理？\n    * 得到MappingJackson2HttpMessageConverter可以将对象写为json\n    * 利用MappingJackson2HttpMessageConverter将对象转为json再写出去。\n\n\n### 9.3.4 SpringMVC支持的返回值类型\n\n```java\nModelAndView\nModel\nView\nResponseEntity \nResponseBodyEmitter\nStreamingResponseBody\nHttpEntity\nHttpHeaders\nCallable\nDeferredResult\nListenableFuture\nCompletionStage\nWebAsyncTask\n有 @ModelAttribute 且为对象类型的\n@ResponseBody 注解 ---> RequestResponseBodyMethodProcessor处理器；\n```\n\n### 9.3.5 HttpMessageConverter消息转换器\n\n* 作用：\n\n  * HttpMessageConverter: 看是否支持将 此 Class类型的对象，转为MediaType类型的数据。\n  * 例子：Person对象转为JSON。或者 JSON转为Person\n\n* 默认的MessageConverter\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210403094002.png)\n\n* 支持的类型\n\n  ```java\n  0 - 只支持Byte类型的\n  1 - String\n  2 - String\n  3 - Resource\n  4 - ResourceRegion\n  5 - DOMSource.class \\ SAXSource.class) \\ StAXSource.class \\StreamSource.class \\Source.class\n  6 - MultiValueMap\n  7 - true ,支持任何类型的\n  8 - true ，支持任何类型的\n  9 - 支持注解方式xml处理的。\n  ```\n\n### 9.3.6 自定义消息转换器\n\n* 功能：将person对象的数据转换成以；隔开的字符串。协议为application/x-guigu\n\n* 第一步：在webconfig中重写extendMessageConverters。并添加自定义消息转换器\n\n```java\n@Bean\npublic WebMvcConfigurer webMvcConfigurer(){\n  return new WebMvcConfigurer(){\n\n    @Override\n    public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {\n      //extendMessageConverters()方法表示在原有的基础上，另外扩展功能\n      converters.add(new GuiguMessageConverter());\n    }\n\n    @Override\n    public void configurePathMatch(PathMatchConfigurer configurer) {\n      UrlPathHelper helper = new UrlPathHelper();\n      helper.setRemoveSemicolonContent(false);\n      configurer.setUrlPathHelper(helper);\n    }\n  };\n}\n```\n\n* 第二步：自定义消息转换器。\n\n```java\npublic class GuiguMessageConverter implements HttpMessageConverter<Person> {\n  @Override\n  public boolean canRead(Class<?> clazz, MediaType mediaType) {\n    //不支持读。即不支持将此类型的传输，转换成person\n    return false;\n  }\n\n  @Override\n  public boolean canWrite(Class<?> clazz, MediaType mediaType) {\n    //\n    return clazz.isAssignableFrom(Person.class);\n  }\n\n  /**\n   * 服务器通过调用此方法来统计服务器能支持的所有的媒体类型。\n   * 我们自定义媒体类型为application/x-guigu\n   * @return\n   */\n  @Override\n  public List<MediaType> getSupportedMediaTypes() {\n    return MediaType.parseMediaTypes(\"application/x-guigu\");\n  }\n\n  @Override\n  public Person read(Class<? extends Person> clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {\n    return null;\n  }\n\n  @Override\n  public void write(Person person, MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {\n    //自定义协议的数据格式\n    String data = person.getName() + \";\" + person.getAge() + \";\" + person.getBirth();\n\n    //将其写入到输出流中\n    outputMessage.getBody().write(data.getBytes());\n  }\n}\n```\n\n* 当我们开启浏览器请求参数内容协商匹配时。上述的配置就会不起作用。\n\n  * 因为内容协商匹配策略默认是基于请求头的。\n\n* 解决方式：配置自定义内容协商匹配策略。\n\n  ```java\n  @Bean\n  public WebMvcConfigurer webMvcConfigurer(){\n    return new WebMvcConfigurer(){\n      @Override\n      public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {\n        //配置自定义内容协商策略。此配置会完全覆盖原来的配置。\n        Map<String, MediaType> mediaTypeMap = new HashMap<>();\n        mediaTypeMap.put(\"json\", MediaType.APPLICATION_STREAM_JSON);\n        mediaTypeMap.put(\"xml\", MediaType.APPLICATION_ATOM_XML);\n        mediaTypeMap.put(\"gg\",MediaType.parseMediaType(\"application/x-guigu\"));\n        //指定解析哪些参数对应的媒体类型。\n        ParameterContentNegotiationStrategy parameterStrategy = new ParameterContentNegotiationStrategy(mediaTypeMap);\n        //设置指定请求头的内容协商策略\n        HeaderContentNegotiationStrategy headStrategy = new HeaderContentNegotiationStrategy();\n  \n        configurer.strategies(Arrays.asList(parameterStrategy,headStrategy));\n      }\n  \n      @Override\n      public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {\n        //扩展消息转换器\n        converters.add(new GuiguMessageConverter());\n      }\n    };\n  }\n  ```\n\n## 9.4 视图解析与模板引擎\n\n### 9.4.1 视图解析\n\n视图解析：**SpringBoot默认不支持 JSP，需要引入第三方模板引擎技术实现页面渲染。**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210403123215.jpg)\n\n**视图解析流程**\n\n* 1.目标方法处理的过程中，所有数据都会被放在 **ModelAndViewContainer 里面。包括数据和视图地址**\n* 2.**方法的参数是一个自定义类型对象（从请求参数中确定的），把他重新放在** **ModelAndViewContainer** \n* 3.任何目标方法执行完成以后都会返回 ModelAndView（**数据和视图地址**）。\n* 4.**processDispatchResult  处理派发结果（页面改如何响应）**\n  * **render**(**mv**, request, response); 进行页面渲染逻辑\n  * 根据方法的String返回值得到 **View** 对象【定义了页面的渲染逻辑】\n    * 1.所有的视图解析器尝试是否能根据当前返回值得到**View**对象\n    * 2.得到了  **redirect:/main.html** --> Thymeleaf new **RedirectView**()\n    * 3.ContentNegotiationViewResolver 里面包含了下面所有的视图解析器，内部还是利用下面所有视图解析器得到视图对象。\n    * 4.view.render(mv.getModelInternal(), request, response);  视图对象调用自定义的render进行页面渲染工作\n      * **RedirectView 如何渲染【重定向到一个页面】**\n      * **1、获取目标url地址**\n      * **2、response.sendRedirect(encodedURL);**\n* 视图解析\n  * **返回值以 forward: 开始： new InternalResourceView(forwardUrl); -->  转发request.getRequestDispatcher(path).forward(request, response);**\n  * **返回值以** **redirect: 开始：** **new RedirectView() --》 render就是重定向** \n  * **返回值是普通字符串： new ThymeleafView（）--->** \n\n### 9.4.2 模板引擎\n\n#### 1、thymeleaf简介\n\nThymeleaf is a modern server-side Java template engine for both web and standalone environments, capable of processing HTML, XML, JavaScript, CSS and even plain text.\n\n**现代化、服务端Java模板引擎**\n\n#### 2、基本语法\n\n**1、表达式**\n\n| 表达式名字 | 语法   | 用途                               |\n| ---------- | ------ | ---------------------------------- |\n| 变量取值   | ${...} | 获取请求域、session域、对象等值    |\n| 选择变量   | *{...} | 获取上下文对象值                   |\n| 消息       | #{...} | 获取国际化等值                     |\n| 链接       | @{...} | 生成链接                           |\n| 片段表达式 | ~{...} | jsp:include 作用，引入公共页面片段 |\n\n**2、字面量**\n\n文本值: **'one text'** **,** **'Another one!'** **,…**数字: **0** **,** **34** **,** **3.0** **,** **12.3** **,…**布尔值: **true** **,** **false**\n\n空值: **null**\n\n变量： one，two，.... 变量不能有空格\n\n**3、文本操作**\n\n字符串拼接: **+**\n\n变量替换: **|The name is ${name}|** \n\n**4、数学运算**\n\n运算符: + , - , * , / , %\n\n**5、布尔运算**\n\n运算符:  **and** **,** **or**\n\n一元运算: **!** **,** **not** \n\n**6、比较运算**\n\n比较: **>** **,** **<** **,** **>=** **,** **<=** **(** **gt** **,** **lt** **,** **ge** **,** **le** **)**等式: **==** **,** **!=** **(** **eq** **,** **ne** **)** \n\n**7、条件运算**\n\nIf-then: **(if) ? (then)**\n\nIf-then-else: **(if) ? (then) : (else)**\n\nDefault: (value) **?: (defaultvalue)** \n\n**8、特殊操作**\n\n无操作： _\n\n#### 3、设置属性值-th:attr\n\n设置单个值\n\n```html\n<form action=\"subscribe.html\" th:attr=\"action=@{/subscribe}\">\n  <fieldset>\n    <input type=\"text\" name=\"email\" />\n    <input type=\"submit\" value=\"Subscribe!\" th:attr=\"value=#{subscribe.submit}\"/>\n  </fieldset>\n</form>\n```\n\n设置多个值\n\n```html\n<img src=\"../../images/gtvglogo.png\"  th:attr=\"src=@{/images/gtvglogo.png},title=#{logo},alt=#{logo}\" />\n```\n\n以上两个的代替写法 th:xxxx\n\n```html\n<input type=\"submit\" value=\"Subscribe!\" th:value=\"#{subscribe.submit}\"/>\n<form action=\"subscribe.html\" th:action=\"@{/subscribe}\">\n```\n\n所有h5兼容的标签写法：https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#setting-value-to-specific-attributes\n\n#### 4、迭代\n\n```html\n<tr th:each=\"prod : ${prods}\">\n  <td th:text=\"${prod.name}\">Onions</td>\n  <td th:text=\"${prod.price}\">2.41</td>\n  <td th:text=\"${prod.inStock}? #{true} : #{false}\">yes</td>\n</tr>\n<tr th:each=\"prod,iterStat : ${prods}\" th:class=\"${iterStat.odd}? 'odd'\">\n  <td th:text=\"${prod.name}\">Onions</td>\n  <td th:text=\"${prod.price}\">2.41</td>\n  <td th:text=\"${prod.inStock}? #{true} : #{false}\">yes</td>\n</tr>\n```\n\n#### 5、条件运算\n\n```html\n<a href=\"comments.html\"\n   th:href=\"@{/product/comments(prodId=${prod.id})}\"\n   th:if=\"${not #lists.isEmpty(prod.comments)}\">view</a>\n\n<div th:switch=\"${user.role}\">\n  <p th:case=\"'admin'\">User is an administrator</p>\n  <p th:case=\"#{roles.manager}\">User is a manager</p>\n  <p th:case=\"*\">User is some other thing</p>\n</div>\n```\n\n#### 6、属性优先级\n\n![](https://cdn.nlark.com/yuque/0/2020/png/1354552/1605498132699-4fae6085-a207-456c-89fa-e571ff1663da.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_YXRndWlndS5jb20g5bCa56GF6LC3%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n### 9.4.3 Thymeleaf的使用\n\n**1.引入依赖**\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n```\n\n**2.配置**\n\nSpringBoot会为我们自动配置好thymeleaf。\n\n```java\n@Configuration(proxyBeanMethods = false)\n@EnableConfigurationProperties(ThymeleafProperties.class)\n@ConditionalOnClass({ TemplateMode.class, SpringTemplateEngine.class })\n@AutoConfigureAfter({ WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class })\npublic class ThymeleafAutoConfiguration {}\n```\n\n* 所有的thymeleaf的配置值都在 ThymeleafProperties\n* 配置好了 **SpringTemplateEngine** 引擎\n* **配好了** **ThymeleafViewResolver** 视图解析器\n* 而我们只需要直接开发页面\n* 在 ThymeleafProperties中\n\n```java\n//默认视图跳转的前缀\npublic static final String DEFAULT_PREFIX = \"classpath:/templates/\";\n//默认跳转的后缀\npublic static final String DEFAULT_SUFFIX = \".html\";\n```\n\n**3.页面开发**\n\n* 首先在templates文件下创建一个index.html页面\n\n* 然后再页面上引入templates的名称空间。这样在编写页面时就会有提示。\n\n  ```html\n  <!DOCTYPE html>\n  <!--第一步加入thymeleaf的名称空间-->\n  <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n    <head>\n      <meta charset=\"UTF-8\">\n      <title>Title</title>\n    </head>\n    <body>\n      <h1 th:text=\"${msg}\">哈哈哈</h1>\n      <br>\n      <a href=\"*\" th:href=\"${link}\">去百度1</a>\n      <br>\n      <!--@取出的是{}中的路径。例如a标签的实际访问路径为相对路径。即：http://localhost:8080/link-->\n      <a href=\"*\" th:href=\"@{link}\">去百度2</a>\n      <br>\n      <!--当a标签的实际访问路径为绝对路径时，此路径的访问为：http://localhost:8080/项目访问路径/link-->\n      <a href=\"*\" th:href=\"@{/link}\">去百度2</a>\n    </body>\n  </html>\n  ```\n\n* 在controller层创建一个页面跳转的处理方法。\n\n  ```java\n  @GetMapping(\"/index\")\n  public String toIndex(Model model) {\n    model.addAttribute(\"msg\", \"你好\");\n    model.addAttribute(\"link\", \"http://www.baidu.com\");\n  \n    //此处的返回值再加上thymeleaf的前缀和后缀拼接后才是真正的页面位置。\n    return \"index\";\n  }\n  ```\n\n### 9.4.4 构建后台管理系统\n\n**1.项目创建**\n\n引入依赖：thymeleaf、web-starter、devtools、lombok\n\n**2.静态资源处理**\n\n自动配置好，我们只需要把所有静态资源放到 static 文件夹下\n\n**3.路径构建**\n\nth:action=\"@{/login}\"\n\n**4.模板抽取**\n\nth:insert：插入\n\nth:replace：替换\n\nth:include：包含\n\n* 公共页面\n\n```html\n<head th:fragment=\"commonHead\">\n\n  <link  th:href=\"@{/css/style.css}\" rel=\"stylesheet\">\n  <link  th:href=\"@{/css/style-responsive.css}\" rel=\"stylesheet\">\n\n  <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->\n  <!--[if lt IE 9]>\n<script  th:src=\"@{/js/html5shiv.js}\"></script>\n<script  th:src=\"@{/js/respond.min.js}\"></script>\n<![endif]-->\n</head>\n```\n\n* 使用模板\n\n```html\n<head>\n  \t<!--格式：\"模板的文件名 :: 模板的fragment名\"-->\n    <div th:include=\"common :: commonHead\"></div>\n</head>\n```\n\n**5.页面跳转**\n\n```java\n@PostMapping(\"/login\")\npublic String main(User user, HttpSession session, Model model){\n\n  if(StringUtils.hasLength(user.getUserName()) && \"123456\".equals(user.getPassword())){\n    //把登陆成功的用户保存起来\n    session.setAttribute(\"loginUser\",user);\n    //登录成功重定向到main.html;  重定向防止表单重复提交\n    return \"redirect:/main.html\";\n  }else {\n    model.addAttribute(\"msg\",\"账号密码错误\");\n    //回到登录页面\n    return \"login\";\n  }\n\n}\n```\n\n**6.数据渲染**\n\n```java\n@GetMapping(\"/dynamic_table\")\npublic String dynamic_table(Model model){\n  //表格内容的遍历\n  List<User> users = Arrays.asList(new User(\"zhangsan\", \"123456\"),\n                                   new User(\"lisi\", \"123444\"),\n                                   new User(\"haha\", \"aaaaa\"),\n                                   new User(\"hehe \", \"aaddd\"));\n  model.addAttribute(\"users\",users);\n\n  return \"table/dynamic_table\";\n}\n```\n\n```html\n<table class=\"display table table-bordered\" id=\"hidden-table-info\">\n  <thead>\n    <tr>\n      <th>#</th>\n      <th>用户名</th>\n      <th>密码</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class=\"gradeX\" th:each=\"user,stats:${users}\">\n      <td th:text=\"${stats.count}\">Trident</td>\n      <td th:text=\"${user.userName}\">Internet</td>\n      <td >[[${user.password}]]</td>\n    </tr>\n  </tbody>\n</table>\n```\n\n## 8.5 拦截器\n\n### 8.5.1 拦截器的使用\n\n* 我们可以使用Servlet的拦截器功能。也能使用SpringBoot提供的拦截器功能。\n\n* SpringBoot提供的拦截器功能需要实现接口。\n\n* 接口中有三个方法：\n\n  * preHandle()：处理器执行方法前\n  * postHandle()：处理器执行方法后，渲染视图前\n  * afterCompletion()：渲染视图后\n\n* 样例：实现是否登录的检测\n\n  ```java\n  /**\n   * 登陆检查\n   * 1.配置好拦截器要拦截那些请求。\n   * 2.把配置放到容器中\n   */\n  public class LoginInterceptor implements HandlerInterceptor {\n    /**\n     * 处理器方法执行前\n     */\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n  \n      HttpSession session = request.getSession();\n      Object loginUser = session.getAttribute(\"loginUser\");\n      if (null != loginUser){\n        //表示已经登陆，拦截器放行\n        return true;\n      }\n      \n      //未登录，不放行，跳转到登陆页面\n      request.setAttribute(\"msg\", \"请先登录\");\n      request.getRequestDispatcher(\"/\").forward(request,response);\n      \n      return false;\n    }\n  \n    /**\n     * 处理器方法执行后，视图渲染前\n     */\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n  \n    }\n  \n    /**\n     * 视图渲染后\n     */\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n  \n    }\n  }\n  \n  ```\n\n* 拦截器的使用步骤：\n\n  * 创建拦截器\n  * 注册拦截器：\n    * 设置拦截器需要拦截的请求路径。\n    * 设置拦截器不需要拦截的请求路径.\n\n* 示例\n\n  ```java\n  public class AdminWebConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n      /**\n       * 添加拦截器\n       * 设置拦截路径。 /**表示拦截所有请求。包括静态资源\n       * 设置不拦截的路径\n       */\n      registry.addInterceptor(new LoginInterceptor())\n        .addPathPatterns(\"/**\")\n        .excludePathPatterns(\"/\",\"/login\",\"/css/*\",\"/fonts/*\",\"/images/*\",\"/js/*\");\n    }\n  }\n  ```\n\n### 8.5.2 对静态资源的处理\n\n**方式一：**\n\n* 再配置不拦截的请求上，将所有的对静态资源的请求放行。\n\n```java\nexcludePathPatterns(\"/\",\"/login\",\"/css/*\",\"/fonts/*\",\"/images/*\",\"/js/*\");\n```\n\n**方式二：**\n\n* 修改对静态资源的访问路径。比如加个前缀。然后再将所有对此前缀的访问放行。\n\n```properties\nspring.mvc.static-path-pattern=/static/**\n```\n\n```java\nexcludePathPatterns(\"/\",\"/login\",\"/static/**\");\n```\n\n### 5.5.3 原理解析\n\n* 1、根据当前请求，找到**HandlerExecutionChain【**可以处理请求的handler以及handler的所有 拦截器】\n* 2、先来**顺序执行** 所有拦截器的 preHandle方法\n  - 1、如果当前拦截器prehandler返回为true。则执行下一个拦截器的preHandle\n  - 2、如果当前拦截器返回为false。直接   倒序执行所有已经执行了的拦截器的  afterCompletion；\n* **3、如果任何一个拦截器返回false。直接跳出不执行目标方法**\n* 4、所有拦截器都返回True。执行目标方法。\n* 5、倒序执行所有拦截器的postHandle方法。\n* **6、前面的步骤有任何异常都会直接倒序触发已执行的** afterCompletion\n* 7、页面成功渲染完成以后，也会倒序触发 afterCompletion\n\n![](https://cdn.nlark.com/yuque/0/2020/png/1354552/1605765121071-64cfc649-4892-49a3-ac08-88b52fb4286f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_10%2Ctext_YXRndWlndS5jb20g5bCa56GF6LC3%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fresize%2Cw_1212)\n\n## 9.6 文件上传\n\n### 9.6.1 页面表单\n\n```html\n<!--表单的格式必需是：method=\"post\" enctype=\"multipart/form-data\"-->\n<form role=\"form\" th:action=\"@{/upload}\" method=\"post\" enctype=\"multipart/form-data\">\n  <div class=\"form-group\">\n    <label for=\"exampleInputEmail1\">邮箱</label>\n    <input type=\"email\" name=\"email\" class=\"form-control\" id=\"exampleInputEmail1\" placeholder=\"Enter email\">\n  </div>\n  <div class=\"form-group\">\n    <label for=\"exampleInputFile\">单个文件</label>\n    <input type=\"file\" name=\"oneFile\" id=\"exampleInputFile\">\n    <p class=\"help-block\">Example block-level help text here.</p>\n  </div>\n  <div class=\"form-group\">\n    <label for=\"exampleInputFile\">多个文件</label>\n    <!--multiple：表示可以上传多个文件-->\n    <input type=\"file\" name=\"duoFile\" id=\"\" multiple>\n    <p class=\"help-block\">Example block-level help text here.</p>\n  </div>\n  <button type=\"submit\" class=\"btn btn-primary\">Submit</button>\n</form>\n```\n\n### 9.6.2 文件上传代码及配置\n\n```java\n/**\n  * MultipartFile：用于接收文件。只能接受一个文件。如果同时上传多个文件。则用数组模式\n  * 请求的注解为RequestPart。意为请求部分\n  */\n@PostMapping(\"/upload\")\npublic String upload(@RequestParam(\"email\") String email,\n                     @RequestPart(\"oneFile\") MultipartFile oneFile,\n                     @RequestPart(\"duoFile\") MultipartFile[] duoFile){\n  log.info(\"email={},oneFile={},duoFile={}\",email,oneFile.getSize(),duoFile.length);\n\n  return \"index\";\n}\n```\n\n```properties\n# 设置上传文件的单个文件最大大小.单位MB\nspring.servlet.multipart.max-file-size=10\n# 设置一个请求最大上传多大的文件。单位MB\nspring.servlet.multipart.max-request-size=100\n```\n\n### 9.6.3 原理\n\n* **文件上传自动配置类-MultipartAutoConfiguration-**MultipartProperties\n* 自动配置好了 **StandardServletMultipartResolver  【文件上传解析器】**\n* **原理步骤**\n\n- - **1、请求进来使用文件上传解析器判断（**isMultipart**）并封装（**resolveMultipart，**返回**MultipartHttpServletRequest**）文件上传请求**\n  - **2、参数解析器来解析请求中的文件内容封装成MultipartFile**\n  - **3、将request中文件信息封装为一个Map；**MultiValueMap<String, MultipartFile>\n\n**FileCopyUtils**。实现文件流的拷贝\n\n## 9.7 异常处理（缺失）\n\n### 9.7.1 默认规则\n\n* 默认情况下，Spring Boot提供`/error`处理所有错误的映射。即发生错误时，它会默认发出/error请求。\n* 对于机器客户端，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。\n* 对于浏览器客户端，响应一个“ whitelabel”错误视图，以HTML格式呈现相同的数据。\n* **要对其进行自定义，添加**`View`**解析为`error`**\n* 要完全替换默认行为，可以实现 `ErrorController `并注册该类型的Bean定义，或添加`ErrorAttributes类型的组件`以使用现有机制但替换其内容。\n* SpringBoot会自动解析静态资源下的error下的4xx，5xx页面作为错误页面；\n  * 或者templates下的error下的4xx，5xx页面。\n* 4xx用来表示发生以4开头的错误代码的信息。5xx用来表示错误代码以5开头的错误页面\n\n### 9.7.2 自定义错误页面实现逻辑\n\n* 自定义错误页\n  * error/404.html  error/5xx.html；\n  * 有精确的错误状态码页面就匹配精确，没有就找 4xx.html；\n  * 如果都没有就触发默认的错误白页。\n* \n\n\n\n \n\n### 9.7.3 异常处理原理\n\n* **ErrorMvcAutoConfiguration  自动配置异常处理规则**\n\n- - **容器中的组件：类型：DefaultErrorAttributes ->** **id：errorAttributes**\n  - \n\n\n\n### 9.7.4 异常处理流程\n\n\n\n\n\n## 9.8 Web原生组件注入\n\n### 9.8.1 使用原生的Servlet API\n\n* 对于三大组件，在创建类时，在类上分别标注对应的注解\n\n  * @WebServlet(urlPatterns = **\"/my\"**)：效果：直接响应，**没有经过Spring的拦截器？**\n  * @WebFilter(urlPatterns={**\"/css/\\*\"**,**\"/images/\\*\"**})\n  * @WebListener\n\n  ```java\n  @WebServlet(urlPatterns = \"/ms\")\n  public class MyServlet extends HttpServlet {}\n  @WebServlet(urlPatterns = \"/ms\")\n  public class MyFilter implements Filter {}\n  @WebListener\n  public class MyServletContextListener implements ServletContextListener {}\n  ```\n\n* 同时：需要在SpringBoot配置上加上扫描注解\n\n  * @ServletComponentScan(basePackages = **\"com.atguigu.admin\"**) :指定原生Servlet组件都放在那里\n\n  ```java\n  @ServletComponentScan(basePackages = \"com.lc.servlet\")\n  @SpringBootApplication\n  public class SpringbootAdminApplication {\n    public static void main(String[] args) {\n      SpringApplication.run(SpringbootAdminApplication.class, args);\n    }\n  }\n  ```\n  \n* 原生Servlet直接响应，不经过拦截器Interceptors的原因：\n\n  * 首先，拦截器的作用在Servlet后面。\n  * 然后，Spring的默认Servlet是DispatcherServlet 。它的默认匹配路径是“/”。\n  * 原生的Servlet。我们设置的匹配路径是“/my\"。\n  * 又根据Tomcat的精确匹配原则。当我们访问/my时。它会被匹配到原生的Servlet上，然后执行。\n  * 只有当我们的请求被匹配到DispatcherServlet 时，才会被拦截器拦截。因为拦截器是spring的。\n\n### 9.8.2 使用Spring的RegistrantionBean\n\n* 使用Spring的容器：ServletRegistrationBean, FilterRegistrationBean,ServletListenerRegistrationBean\n* 将要注册的三大组件通过bean注解的方式加入到容器中\n\n```java\n@Configuration\npublic class MyRegisterConfig {\n  @Bean\n  public ServletRegistrationBean myServlet(){\n    return new ServletRegistrationBean(new MyServlet(), \"/my\",\"/ms\");\n  }\n\n  @Bean\n  public FilterRegistrationBean myFilter(){\n    MyFilter myFilter = new MyFilter();\n    //方式一：以servlet为过滤路径\n    //return new FilterRegistrationBean(myFilter,myServlet());\n    //方式二：\n    FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(myFilter);\n    filterRegistrationBean.setUrlPatterns(Arrays.asList(\"/my\",\"/ms\"));\n    return filterRegistrationBean;\n  }\n\n  @Bean\n  public ServletListenerRegistrationBean myListener(){\n\n    return new ServletListenerRegistrationBean(new MyServletContextListener());\n  }\n\n}\n```\n\n* 注意：在上面注解配置中没有设置proxyBeanMethods属性。\n  * 不设置，即默认为true。保证组件在容器中的唯一性。\n\n## 9.9 嵌入式Servlet容器\n\n* 首先需要明白：SpringBoot内置了三个web服务器(Tomcat,Jetty,Undertow)。\n\n* SpringBoot启动时，对于web服务器的管理使用了一个容器`ServletWebServerApplicationContext`。\n\n  * 当启动web项目时。会从此容器中寻找web服务器工厂(`ServletWebServerFactory`)。\n  * SpringBoot内置了很多的服务器工厂：`TomcatServletWebServerFactory`, `JettyServletWebServerFactory`, or `UndertowServletWebServerFactory`\n\n* 关于web服务器的自动配置在`ServletWebServerFactoryAutoConfiguration`类中。\n\n* 此类在其作用前会先导入`ServletWebServerFactoryConfiguration`类。即服务器工厂配置类\n\n  * 服务器工厂配置类会根据项目导入的包动态的判断要导入哪个服务器。\n  * SpringBoot的web应用默认导入的是Tomcat包。因此服务器工厂配置类会导入Tomcat服务器。\n  * 因此导入：`TomcatServletWebServerFactory`Tomcat服务器工厂。\n  * Tomcat服务器工厂有个`getWebServer`方法，此方法用于创建服务器并启动服务器。\n\n* 总之：默认支持的web服务器有：\n\n* `ServletWebServerApplicationContext`会寻找已经加入到项目中的`ServletWebServerFactory` 并引导创建对应的服务器。\n\n  ```java\n  protected ServletWebServerFactory getWebServerFactory() {\n    // 获取项目中的所有web服务器\n    String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);\n    //如果没有服务器就报异常\n    if (beanNames.length == 0) {\n      throw new ApplicationContextException(\"Unable to start ServletWebServerApplicationContext due to missing \"\n                                            + \"ServletWebServerFactory bean.\");\n    }\n    //如果服务器过多，也报异常\n    if (beanNames.length > 1) {\n      throw new ApplicationContextException(\"Unable to start ServletWebServerApplicationContext due to multiple \"\n                                            + \"ServletWebServerFactory beans : \" + StringUtils.arrayToCommaDelimitedString(beanNames));\n    }\n    //ServletWebServerFactory类通过调用getWebServer()方法创建服务器并启动服务器\n    return getBeanFactory().getBean(beanNames[0], ServletWebServerFactory.class);\n  }\n  ```\n\n### 9.9.1 应用：如何切换服务器\n\n* 由于web服务器的导入是通过maven依赖引入的。\n* 因此：我们只需要在maven的SpringBoot场景中排除Tomcat，加入其他服务器即可。\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-web</artifactId>\n  <exclusions>\n    <!--排除Tomcat服务器-->\n    <exclusion>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-tomcat</artifactId>\n    </exclusion>\n  </exclusions>\n</dependency>\n<!--使用undertow服务器-->\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-undertow</artifactId>\n</dependency>\n```\n\n### 9.9.2 修改web服务器配置\n\n* 方式一：通过配置文件。\n\n  * 由于`ServletWebServerFactoryAutoConfiguration`自动配置类绑定的web服务器的属性配置为`ServerProperties`类。此类绑定了以server开头的属性配置。\n\n  ```properties\n  # 设置服务器的访问端口号\n  server.port=8088\n  ```\n\n* 方式二：实现`ConfigurableServletWebServerFactory`接口。此接口继承于`ServletWebServerFactory`接口。\n\n  * 因为`ServletWebServerApplicationContext`是通过`ServletWebServerFactory`来创建web服务器的。\n  * 并且`ConfigurableServletWebServerFactory`接口比`ServletWebServerFactory`接口多很多方法。\n\n  ```java\n  /**\n   * 修改web服务器的配置\n   */\n  @Bean\n  public ConfigurableServletWebServerFactory webServerFactory(){\n    TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();\n    factory.setPort(8088);\n    factory.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND,\"/notfound.html\"));\n    return factory;\n  }\n  ```\n\n* 方式三：实现  WebServerFactoryCustomizer\\<ConfigurableServletWebServerFactory> 定制化器\n\n  * 定制化器的作用：当容器中准备好web服务器后，定制化器将配置文件的信息和对应的工厂进行绑定。\n  * 例如：将配置文件的值和`ServletWebServerFactory` 进行绑定\n  * 在`ServletWebServerFactoryAutoConfiguration`中第一个方法就是`servletWebServerFactoryCustomizer`方法。用来设定定制化器。\n\n  ```java\n  @Component\n  public class CustomizationBean implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> {\n  \n    @Override\n    public void customize(ConfigurableServletWebServerFactory server) {\n      server.setPort(9000);\n    }\n  \n  }\n  ```\n\n## 9.10 定制化原理\n\n* 定制化：即我们要修改SpringBoot默认的配置。\n\n* 首先：通过前面的学习。我们了解到SpringBoot的配置都是一个逻辑。即：\n\n  * 1.通过依赖引入资源场景starter.\n  * 2.通过xxxAutoConfiguration自动配置类，进行配置。\n  * 3.在自动配置类中通过Bean注解的方式导入此配置的相关组件。\n  * 4.在自动配置类中绑定对应的xxxProperties类。\n  * 5.进而绑定配置文件中对应的属性。\n\n* 因此我们想要修改配置的方式如下：\n\n  * 1：修改配置文件\n  * 2：编写自定义的xxxCustomizer定制化器\n  * 3：编写自定义的配置类xxxConfiguration。将其放到容器中。或者使用@Bean注解替换默认组件。\n  * 4：编写一个实现WebMvcConfiguration的配置类，并加上@Configuration注解。此类就是web的配置类。再通过加@Bean注解添加组件。\n\n  ```java\n  @Configuration\n  public class AdminWebConfig implements WebMvcConfigurer\n  ```\n\n  * 5：在4的基础上给配置类添加@EnableWebMvc注解。表示全面接管web的配置。所有的默认配置都将不起作用。\n\n  ```java\n  @EnableWebMvc\n  @Configuration\n  public class AdminWebConfig implements WebMvcConfigurer\n  ```\n\n* @EnableWebMvc注解的原理\n\n  * 此注解在起作用时会导入`DelegatingWebMvcConfiguration`类。\n\n  * 此类会将项目中所有的WebMvcConfigurer接口的实现类都获取到，然后让其生效。\n\n  * 此类也会提供一些SpringBoot的一些非常底层的基本的配置组件。用于保证项目的正常启动。\n\n  * 从另一方面说：SpringBoot关于webmvc的配置都在`WebMvcAutoConfiguration`类中。而此类起作用的一个条件是容器中没有`WebMvcConfigurationSupport`类。\n\n    * 而`DelegatingWebMvcConfiguration`就是继承于`WebMvcConfigurationSupport`的。\n\n    ```java\n    //当不存在WebMvcConfigurationSupport时，此类生效\n    @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)\n    public class WebMvcAutoConfiguration {}\n    ```\n\n  * 因此当存在@EnableWebMvc时，容器中会存在`DelegatingWebMvcConfiguration`，进而`WebMvcAutoConfiguration`不能起作用。\n\n# 第十章：数据访问\n\n## 10.1 SQL\n\n### 10.1.1 数据的配置\n\n* 导入数据源和数据库驱动\n\n```xml\n<!--导入数据源-->\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n<!--导入数据库驱动。注意版本要和自己的mysql相一致-->\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <version>5.1.47</version>\n</dependency>\n```\n\n* 默认数据源的依赖图\n\n  ![](https://cdn.nlark.com/yuque/0/2020/png/1354552/1606366100317-5e0199fa-6709-4d32-bce3-bb262e2e5e6a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_10%2Ctext_YXRndWlndS5jb20g5bCa56GF6LC3%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n**数据源的自动配置**\n\n* DataSourceAutoConfiguration 数据源自动配置类\n\n* DataSourceTransactionManagerAutoConfiguration： 事务管理器的自动配置\n\n* JdbcTemplateAutoConfiguration： **JdbcTemplate的自动配置，可以来对数据库进行crud**\n\n* JndiDataSourceAutoConfiguration： jndi的自动配置\n\n* XADataSourceAutoConfiguration： 分布式事务相关的自动配置\n\n* DataSourceAutoConfiguration ：\n\n  * 使用绑定spring.datasource属性的配置。\n  * 当不指定具体的数据源时，默认配置**HikariDataSource**连接池\n\n  ```java\n  @Configuration(proxyBeanMethods = false)\n  @Conditional(PooledDataSourceCondition.class)\n  @ConditionalOnMissingBean({ DataSource.class, XADataSource.class })\n  @Import({ DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,\n           DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class,\n           DataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class })\n  protected static class PooledDataSourceConfiguration {\n  \n  }\n  ```\n\n* JdbcTemplateAutoConfiguration：\n\n  * 绑定配置属性spring.jdbc\n  * 此配置会往容器中添加JdbcTemplate组件，因此我们可以通过自动注入的方式使用它。\n\n**修改配置项**\n\n```properties\nspring.datasource.name=root\nspring.datasource.password=root\nspring.datasource.url=jdbc:mysql://localhost:3306/mysql\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\n```\n\n**使用第三方数据源的方式**\n\n* 方式一：导入第三方依赖，配置数据源，往容器中添加数据源Bean.\n* 方式二：找SpringBoot有没有第三方数据源的场景依赖。\n\n### 10.1.2 使用Druid数据源\n\n* 官方地址：https://github.com/alibaba/druid\n\n**方式一：自定义数据源**\n\n* 基本使用\n  * 引入依赖\n\n  ```xml\n  <dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid</artifactId>\n    <version>1.1.8</version>\n  </dependency>\n  ```\n\n  * 添加数据源Bean\n\n  ```java\n  @Configuration\n  public class MyDataSourceConfig {\n    /**\n     * 通过bean注解往容器中放入Druid数据源。\n     * 通过ConfigurationProperties注解绑定spring.datasource前缀的属性。并将数据绑定到datasource中\n     * @return\n     */\n    @ConfigurationProperties(\"spring.datasource\")\n    @Bean\n    public DataSource dataSource(){\n      DruidDataSource dataSource = new DruidDataSource();\n      //这里通过配置文件绑定属性，更能解开耦合性\n      //dataSource.setUrl();\n      return dataSource;\n    }\n  }\n  ```\n\n  * 绑定的基本配置\n\n  ```properties\n  spring.datasource.username=root\n  spring.datasource.password=root\n  spring.datasource.url=jdbc:mysql://localhost:3306/spring-jdbc\n  ```\n\n  * 测试使用\n\n  ```java\n  @Autowired\n  DataSource dataSource;\n  \n  @Test\n  void contextLoads() throws SQLException {\n  \n    log.info(dataSource.getClass().toString());\n  }\n  ```\n\n* StatViewServlet的使用(具体使用见官网)\n\n  * 作用：\n\n    * 提供监控信息展示的html页面\n    * 提供监控信息的JSON API\n\n  * 使用方式\n\n    * 官方如下所示\n\n    ```xml\n    <servlet>\n      <servlet-name>DruidStatView</servlet-name>\n      <servlet-class>com.alibaba.druid.support.http.StatViewServlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n      <servlet-name>DruidStatView</servlet-name>\n      <url-pattern>/druid/*</url-pattern>\n    </servlet-mapping>\n    ```\n\n    * 实质上是往容器中放入了一个servletBean，因此我们这样使用（注意此时项目要导入web场景的支持）\n\n    ```java\n    @Bean\n    public ServletRegistrationBean statViewServlet(){\n      StatViewServlet statViewServlet = new StatViewServlet();\n      ServletRegistrationBean<StatViewServlet> servletRegistrationBean = new ServletRegistrationBean<>(statViewServlet, \"/druid/*\");\n      return servletRegistrationBean;\n    }\n    ```\n\n    * 此时启动项目访问http://localhost:8080/druid/index.html。就可以看到如下界面\n    \n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210410145724.png)\n\n* StatFilter的使用\n  \n  * 作用：开启监控功能，将监控的数据显示在监控的页面上。\n  * 在上述的监控页面开启后，我们还需要配置这个StatFilter，用于将监控的信息显示在监控页面上。\n  * 使用方式：在数据源的配置上将某个属性的置设为StatFilterBean的名称。\n  * 官网方式：\n  \n  ````xml\n  需要给数据源中配置如下属性；可以允许多个filter，多个用，分割；如：\n  \n  <property name=\"filters\" value=\"stat,slf4j\" />\n  ````\n  \n  * springboot方式：\n  \n  ```java\n  @ConfigurationProperties(\"spring.datasource\")\n  @Bean\n  public DataSource dataSource() throws SQLException {\n    DruidDataSource dataSource = new DruidDataSource();\n    //开启监控功能。可以开启多个监控\n    dataSource.setFilters(\"stat\");\n    return dataSource;\n  }\n  ```\n  \n* WebStatFilter的使用\n\n  * 作用：开启web应用中对请求的监控功能\n  * 官方配置\n\n  ```xml\n  <filter>\n    <filter-name>DruidWebStatFilter</filter-name>\n    <filter-class>com.alibaba.druid.support.http.WebStatFilter</filter-class>\n    <init-param>\n      <param-name>exclusions</param-name>\n      <param-value>*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*</param-value>\n    </init-param>\n  </filter>\n  <filter-mapping>\n    <filter-name>DruidWebStatFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n  </filter-mapping>\n  ```\n\n  * springboot配置\n\n  ```java\n  @Bean\n  public FilterRegistrationBean druidWebStatFilter(){\n    WebStatFilter webStatFilter = new WebStatFilter();\n    FilterRegistrationBean<WebStatFilter> filterRegistrationBean = new FilterRegistrationBean<>();\n    //设置过滤的请求路径\n    filterRegistrationBean.setUrlPatterns(Arrays.asList(\"/*\"));\n    //设置要排除的请求\n    Map<String,String> initParam = new HashMap<>();\n    initParam.put(\"exclusions\",\"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*\");\n    filterRegistrationBean.setInitParameters(initParam);\n    return filterRegistrationBean;\n  }\n  \n  ```\n\n  * \n\n* 系统中所有的Filter\n\n| 别名          | Filter类名                                              |\n| ------------- | ------------------------------------------------------- |\n| default       | com.alibaba.druid.filter.stat.StatFilter                |\n| stat          | com.alibaba.druid.filter.stat.StatFilter                |\n| mergeStat     | com.alibaba.druid.filter.stat.MergeStatFilter           |\n| encoding      | com.alibaba.druid.filter.encoding.EncodingConvertFilter |\n| log4j         | com.alibaba.druid.filter.logging.Log4jFilter            |\n| log4j2        | com.alibaba.druid.filter.logging.Log4j2Filter           |\n| slf4j         | com.alibaba.druid.filter.logging.Slf4jLogFilter         |\n| commonlogging | com.alibaba.druid.filter.logging.CommonsLogFilter       |\n\n* 慢SQL记录设置\n\n```xml\n<bean id=\"stat-filter\" class=\"com.alibaba.druid.filter.stat.StatFilter\">\n  <property name=\"slowSqlMillis\" value=\"10000\" />\n  <property name=\"logSlowSql\" value=\"true\" />\n</bean>\n\n使用 slowSqlMillis 定义慢SQL的时长\n```\n\n**方式二：导入场景**\n\n* 引入场景依赖\n\n  ```xml\n  <dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid-spring-boot-starter</artifactId>\n    <version>1.1.17</version>\n  </dependency>\n  ```\n\n* 对应的自动配置类为\n\n  ```java\n  @EnableConfigurationProperties({DruidStatProperties.class, DataSourceProperties.class})\n  @Import({DruidSpringAopConfiguration.class,\n      DruidStatViewServletConfiguration.class,\n      DruidWebStatFilterConfiguration.class,\n      DruidFilterConfiguration.class})\n  public class DruidDataSourceAutoConfigure {\n  ```\n\n  * `DruidStatProperties` 对应的配置属性为spring.datasource.druid\n\n  * `DataSourceProperties`对应的配置属性为spring.datasource\n\n  * `DruidSpringAopConfiguration` 用于监控SpringBean的。对应的配置属性为spring.datasource.druid.aop-patterns\n\n  * `DruidStatViewServletConfiguration`用于监控页的配置。对应的配置属性为spring.datasource.druid.stat-view-servlet\n\n  * `DruidWebStatFilterConfiguration`用于web监控的配置。对应的配置属性为spring.datasource.druid.web-stat-filter\n\n  * `DruidFilterConfiguration`用于所有Druid子弟的Filter的配置。\n\n    * 其中的Filter配置对应的属性如下\n\n    ```java\n    private static final String FILTER_STAT_PREFIX = \"spring.datasource.druid.filter.stat\";\n    private static final String FILTER_CONFIG_PREFIX = \"spring.datasource.druid.filter.config\";\n    private static final String FILTER_ENCODING_PREFIX = \"spring.datasource.druid.filter.encoding\";\n    private static final String FILTER_SLF4J_PREFIX = \"spring.datasource.druid.filter.slf4j\";\n    private static final String FILTER_LOG4J_PREFIX = \"spring.datasource.druid.filter.log4j\";\n    private static final String FILTER_LOG4J2_PREFIX = \"spring.datasource.druid.filter.log4j2\";\n    private static final String FILTER_COMMONS_LOG_PREFIX = \"spring.datasource.druid.filter.commons-log\";\n    private static final String FILTER_WALL_PREFIX = \"spring.datasource.druid.filter.wall\";\n    private static final String FILTER_WALL_CONFIG_PREFIX = FILTER_WALL_PREFIX + \".config\";\n    ```\n\n* 配置示例演示：\n\n```properties\n# 开启对com.lc包下的所有Bean的监控\nspring.datasource.druid.aop-patterns=com.lc.*\n# 开启sql监控和防火墙监控\nspring.datasource.druid.filters=stat,wall\n# 配置监控功能(开启监控页功能，设置登陆账号和密码，禁用重置按钮)\nspring.datasource.druid.stat-view-servlet.enabled=true\nspring.datasource.druid.stat-view-servlet.login-username=admin\nspring.datasource.druid.stat-view-servlet.login-password=admin\nspring.datasource.druid.stat-view-servlet.reset-enable=false\n# 配置web监控(开启web监控功能，设置监控的路径匹配，排除不监控的路径匹配)\nspring.datasource.druid.web-stat-filter.enabled=true\nspring.datasource.druid.web-stat-filter.url-pattern=/*\nspring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*\n# 对sql监控的详细配置(开启sql监控功能，开启慢SQL的日志功能，设置慢SQL的限制时间)\nspring.datasource.druid.filter.stat.enabled=true\nspring.datasource.druid.filter.stat.log-slow-sql=true\nspring.datasource.druid.filter.stat.slow-sql-millis=1000\n# 对防火墙的详细配置(开启防火墙监控功能，允许删除表)\nspring.datasource.druid.filter.wall.enabled=true\nspring.datasource.druid.filter.wall.config.drop-table-allow=false\n```\n\n* 官方配置示例：https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter\n\n### 10.1.3 使用MyBatisca操作\n\n* 首先导入Mybatis的场景依赖\n\n  ```xml\n  <dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>2.1.4</version>\n  </dependency>\n  ```\n\n* 自动配置文件如下\n\n  ```java\n  @ConditionalOnSingleCandidate(DataSource.class) //当容器中只存在一个数据源时起作用\n  @EnableConfigurationProperties(MybatisProperties.class) //绑定属性配置文件\n  @AutoConfigureAfter({ DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class })\n  public class MybatisAutoConfiguration implements InitializingBean {}\n  //属性配置文件默认以mybatis开头\n  @ConfigurationProperties(prefix = MybatisProperties.MYBATIS_PREFIX)\n  public class MybatisProperties {\n    public static final String MYBATIS_PREFIX = \"mybatis\";\n  }\n  ```\n\n  * 在自动配置文件中。会为我们配置好SqlSessionFactory，SqlSession。\n  * 同时对于mapper的接口，自动配置文件会扫描所有带@Mapper注解的接口作为mapper的接口。\n\n* 使用规则：\n\n  * 在SpringBoot配置文件中可以配置Mybatis的所有配置，\n  * 也可以指定Mybatis全局配置文件的位置，然后再全局配置文件中配置mybatis.\n  * **注意：**当指定全局配置文件时，不能再Springboot配置文件中配置mybatis的全局配置。\n  * 我们推荐不适用使用全局配置文件，而是再springboot配置文件中配置。\n\n* 通用配置：\n\n  ```properties\n  # 对Mybatis的配置\n  # 指定mapper.xml文件的位置\n  mybatis.mapper-locations=classpath:mybatis/mapper/*.xml\n  # 指定mybatis全局配置文件的位置，不推荐使用\n  # mybatis.config-location=classpath:mybatis/mybatis-config.xml\n  # 配置开启驼峰命名\n  mybatis.configuration.map-underscore-to-camel-case=true\n  ```\n\n* 文件位置\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210410172926.png)\n\n**使用方式一：配置型使用**\n\n* 创建mapper接口\n\n  ```java\n  //注意注解一定要添加到\n  @Mapper\n  public interface BookMapper {\n    public Book selectBook(Integer id);\n  }\n  ```\n\n* 创建mapper.xml文件\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <!DOCTYPE mapper PUBLIC \"-//mybatis.org/DTD Mapper 3.0\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n  <mapper namespace=\"com.lc.mapper.BookMapper\">\n    <select id=\"selectBook\" parameterType=\"integer\" resultType=\"com.lc.bean.Book\">\n      select *\n      from `spring-jdbc`.book\n    </select>\n  </mapper>  \n  ```\n\n**使用方式二：注解型使用**\n\n```java\n@Mapper\npublic interface BookMapper {\n  @Select(\"select count(*) from book\")\n  public Integer selectCount(); \n}\n```\n\n**使用方式三：混合型使用**\n\n```java\n@Mapper\npublic interface BookMapper {\n  @Select(\"select count(*) from book\")\n  public Integer selectCount(); \n  \n  public Book selectBook(Integer id);\n}\n```\n\n**总结**\n\n* 第一步：引入mabatis场景\n* 配置application配置文件，指定mapper-location位置即可。(也可以配置一些其他的mybatis的配置)\n* 编写mapper接口并标注@Mapper注解。\n* 创建对应mapper.xml文件并编写SQL语句\n* 对于mapper接口的简化：\n  * 可以再启动类上使用`@MapperScan(\"com.atguigu.admin.mapper\")`直接指定扫描的位置，\n  * 而不用给每个接口添加mapper注解。\n\n### 10.1.4 使用Mybatis-Plus操作\n\n* mybatis-plus是在Mybatis的基础上又进行了封装和升级。\n\n* 官网：https://baomidou.com/\n\n* 添加mybatis-plus场景依赖\n\n  ```xml\n  <!--此场景另外引入了jdbc的场景-->\n  <dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.4.1</version>\n  </dependency>\n  ```\n\n* 自动配置\n\n  * `MybatisPlusAutoConfiguration`自动配置类。绑定`MybatisPlusProperties`属性配置。对应mybatis-plus前缀的属性配置。\n  * `SqlSessionFactory`是自动配置好的，默认使用jdbc默认的数据源\n  * 和mybatis不同的一点：`mapperLocations `也是默认配置好的。\n    * 默认属性为：classpath*:/mapper/**/*.xml。\n    * 表示匹配类资源路径下mapper文件，其文件下及其子文件下的所有xml文件。\n    * 因此建议将sql映射文件都放在mapper文件下。可以在mapper文件下左多层分级目录。\n  * `SqlSessionTemplate`是自动配置好的。\n  * 对于mapper接口的扫描。支持使用@Mapper注解表述每一个mapper接口。或使用@MapperScan注解指定批量扫描。\n\n* Mybatis-plus与Mybatis的最大的好处是：只要我们的mapper接口继承BaseMapper并标注泛型类型，就可以实现基本的CRUD功能。而且我们还可以添加自己的sql方法\n\n  ```java\n  @Mapper\n  public interface BookMapper extends BaseMapper<Book> {\n    Integer selectCount();\n  }\n  ```\n\n  * `BaseMapper`的基本功能如下：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210411155353.png)\n\n* Mybatis-plus的注意点：\n\n  * 对于bean实体，默认查询的表明和实体名相同，如果不同时，需要再实体类上指明要查询的表名。\n  * 对于实体类，默认操作时是操作所有的属性，因此当有此属性而数据库中没有对应字段时，也要标注出来。\n\n  ```java\n  @Data\n  @TableName(\"book\")\n  public class Book {\n    private Integer id;\n    private String name;\n    //当数据库中没有此字段时，可以使用此注解表明\n    @TableField(exist = false)\n    private Date date;\n  }\n  ```\n\n* MybatisPlus不仅对mapper有BaseMapper的升级，在service层也有升级。\n\n  * 在service接口需要继承`IService`\n  * 在service实现类需要继承`ServiceImpl`并指明泛型。\n\n  ```java\n  public interface BookService extends IService<Book>{\n  }\n  @Service\n  public class BookServiceImpl extends ServiceImpl<BookMapper,Book> implements BookService {\n  }\n  ```\n\n  * 此时的`BookServiceImpl`就具有`IService`和`ServiceImpl`的所有功能了。\n\n* 关于分页插件的功能\n\n  * 需要在项目的容器中添加一个配置。\n\n  ```java\n  @Bean\n  public MybatisPlusInterceptor mybatisPlusInterceptor(){\n    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n  \n    //添加分页拦截器\n    PaginationInnerInterceptor paginationInnerInterceptor = new PaginationInnerInterceptor();\n    //对分页进行设置\n    paginationInnerInterceptor.setOverflow(true);\n  \n    interceptor.addInnerInterceptor(paginationInnerInterceptor);\n    return interceptor;\n  }\n  ```\n\n## 10.2 NoSQL\n\n### 10.2.1 Redis配置\n\n\n\n\n\n### 10.2.2 RedisTemplate与Lettuce\n\n\n\n\n\n### 10.2.3 切换至jedis\n\n\n\n\n\n# 第十一章：单元测试\n\n# 第十二章：指标监控\n\n# 第十三章：原理解析","categories":["Java学习","分布式技术"]},{"title":"74-搜索二维矩阵","url":"/2021/03/30/力扣算法学习/初级算法/74-搜索二维矩阵/","content":"\n**题目：**\n\n编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：\n\n* 每行中的整数从左到右按升序排列。\n* 每行的第一个整数大于前一行的最后一个整数。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/search-a-2d-matrix\n\n<!--more-->\n\n**示例 1：**\n\n---\n\n![](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)\n\n输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n输出：true\n\n---\n\n**示例 2：**\n\n---\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg)\n\n输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n输出：false\n\n---\n\n**提示：**\n\n    m == matrix.length\n    n == matrix[i].length\n    1 <= m, n <= 100\n    -10^4 <= matrix[i][j], target <= 10^4\n\n**解题思路：**\n\n* 首先对每一行的最后一个数和targer进行比较，如果比它小，则表示target对应的位置可能在此行中。\n* 然后用二分查找当前行是否有target。有的话返回true.\n\n**代码：Java**\n\n```java\nclass Solution {\n  public boolean searchMatrix(int[][] matrix, int target) {\n    int across = matrix.length;\n    int down = matrix[0].length;\n    for (int i = 0; i < across; i++) {\n      if (target < matrix[i][down-1]){\n        //优化为二分查找\n        int left = -1;\n        int right = down-1;\n        while (left<right){\n          int center = (right-left+1)/2+left;\n          if (matrix[i][center]>target){\n            right = center-1;\n          }else if (matrix[i][center]<target){\n            left = center;\n          }else {\n            return true;\n          }\n        }\n        return false;\n      }\n      if (target == matrix[i][down-1]){\n        return true;\n      }\n    }\n    return false;\n  }\n}\n```","categories":["力扣算法学习","初级算法"]},{"title":"173-二叉搜索树迭代器","url":"/2021/03/28/力扣算法学习/初级算法/173-二叉搜索树迭代器/","content":"\n**题目：**\n\n实现一个二叉搜索树迭代器类`BSTIterator` ，表示一个按中序遍历二叉搜索树（BST）的迭代器：\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/binary-search-tree-iterator\n\n<!--more-->\n\n* BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。\n* boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。\n* int next()将指针向右移动，然后返回指针处的数字。\n\n注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。\n\n你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。\n\n**示例：**\n\n![](https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png)\n\n```\n输入\n[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n输出\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\n解释\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // 返回 3\nbSTIterator.next();    // 返回 7\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 9\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 15\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 20\nbSTIterator.hasNext(); // 返回 False\n```\n\n**提示：**\n\n树中节点的数目在范围 [1, 105] 内\n0 <= Node.val <= 106\n最多调用 105 次 hasNext 和 next 操作\n\n**进阶：**\n\n你可以设计一个满足下述条件的解决方案吗？next() 和 hasNext() 操作均摊时间复杂度为 O(1) ，并使用 O(h) 内存。其中 h 是树的高度。\n\n**解题思路：**\n\n直接在创建对象时，就中序遍历二叉树。然后将结果保存下来。\n\n使用一个数表示遍历到哪个位置了。\n\n**代码：Java**\n\n```java\nclass BSTIterator {\n  private int index;\n  private List<Integer> nodeList;\n\n  public BSTIterator(TreeNode root) {\n    index = -1;\n    nodeList = new ArrayList<Integer>();\n    middleOrderTraversal(root);\n  }\n  //中序遍历二叉树\n  public void middleOrderTraversal(TreeNode root){\n    if (root == null){\n      return ;\n    }\n    middleOrderTraversal(root.left);\n    nodeList.add(root.val);\n    middleOrderTraversal(root.right);\n  }\n\n  public int next() {\n    index++;\n    if (index<nodeList.size()){\n      return nodeList.get(index);\n    }\n    return 0;\n  }\n\n  public boolean hasNext() {\n    return index<nodeList.size()-1 ? true : false;\n  }\n}\n```","categories":["力扣算法学习","初级算法"]},{"title":"125-验证回文串","url":"/2021/03/27/力扣算法学习/初级算法/125-验证回文串/","content":"\n**题目：**\n\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/valid-palindrome\n\n<!--more-->\n\n说明：本题中，我们将空字符串定义为有效的回文串。\n\n**示例 1:**\n\n---\n\n输入: \"A man, a plan, a canal: Panama\"\n输出: true\n\n---\n\n**示例 2:**\n\n---\n\n输入: \"race a car\"\n输出: false\n\n---\n\n**解题思路：双指针**\n\n* 首先将字符串中除去字母和数字的字符都去掉，然后将字符转换成小写。\n* 然后双指针，一个指向前面，一个指向后面。当有不同时返回false.\n\n**代码：Java**\n\n```java\nclass Solution {\n  public boolean isPalindrome(String s) {\n    //判断特殊情况\n    if (s==null||s.length()<2){\n      return true;\n    }\n    StringBuilder stringBuilder = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      //isLetterOrDigit()表示判断当前字符是否是字母或数字\n      if (Character.isLetterOrDigit(s.charAt(i))){\n        //toLowerCase()表示将其转换为小写\n        stringBuilder.append(Character.toLowerCase(s.charAt(i)));\n      }\n    }\n    int i = 0;\n    int j = stringBuilder.length()-1;\n    while (i<j){\n      if (stringBuilder.charAt(i) != stringBuilder.charAt(j)){\n        return false;\n      }\n      i++;\n      j--;\n    }\n    return true;\n  }\n}\n```","categories":["力扣算法学习","初级算法"]},{"title":"8-字符串转换整数 (atoi)","url":"/2021/03/27/力扣算法学习/初级算法/8-字符串转换整数 (atoi)/","content":"\n**题目：**\n\n请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 `atoi` 函数）。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/string-to-integer-atoi\n\n<!--more-->\n\n函数 myAtoi(string s) 的算法如下：\n\n- 读入字符串并丢弃无用的前导空格\n- 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。\n- 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。\n  将前面步骤读入的这些数字转换为整数（即，\"123\" -> 123， \"0032\" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。\n- 如果整数数超过 32 位有符号整数范围 [−2^31,  2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。\n- 返回整数作为最终结果。\n\n**注意：**\n\n本题中的空白字符只包括空格字符 ' ' 。\n除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。\n\n**示例 1：**\n\n---\n\n输入：s = \"42\"\n输出：42\n解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。\n第 1 步：\"42\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"42\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"42\"（读入 \"42\"）\n           ^\n解析得到整数 42 。\n由于 \"42\" 在范围 [-231, 231 - 1] 内，最终结果为 42 。\n\n---\n\n**示例 2：**\n\n---\n\n输入：s = \"   -42\"\n输出：-42\n解释：\n第 1 步：\"   -42\"（读入前导空格，但忽视掉）\n            ^\n第 2 步：\"   -42\"（读入 '-' 字符，所以结果应该是负数）\n             ^\n第 3 步：\"   -42\"（读入 \"42\"）\n               ^\n解析得到整数 -42 。\n由于 \"-42\" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。\n\n---\n\n**示例 3：**\n\n---\n\n输入：s = \"4193 with words\"\n输出：4193\n解释：\n第 1 步：\"4193 with words\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"4193 with words\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"4193 with words\"（读入 \"4193\"；由于下一个字符不是一个数字，所以读入停止）\n             ^\n解析得到整数 4193 。\n由于 \"4193\" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。\n\n---\n\n**示例 4：**\n\n---\n\n输入：s = \"words and 987\"\n输出：0\n解释：\n第 1 步：\"words and 987\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"words and 987\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"words and 987\"（由于当前字符 'w' 不是一个数字，所以读入停止）\n         ^\n解析得到整数 0 ，因为没有读入任何数字。\n由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。\n\n---\n\n**示例 5：**\n\n---\n\n输入：s = \"-91283472332\"\n输出：-2147483648\n解释：\n第 1 步：\"-91283472332\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"-91283472332\"（读入 '-' 字符，所以结果应该是负数）\n          ^\n第 3 步：\"-91283472332\"（读入 \"91283472332\"）\n                     ^\n解析得到整数 -91283472332 。\n由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。\n\n ---\n\n**提示：**\n\n0 <= s.length <= 200\ns 由英文字母（大写和小写）、数字（0-9）、' '、'+'、'-' 和 '.' 组成\n\n**解题思路：**\n\n* 首先对字符串进行前缀空字符处理。然后对处理后的字符进行如下判断。\n* 查看第一个字符是数字，是+，是-，还是字符。\n* 从第二个字符开始，当为字符时退出。为数字时，转换成数字，并加和。\n* 当数字超出范围时可以提前退出。\n\n**代码：Java**\n\n```java\nclass Solution {\n  public int myAtoi(String s) {\n\n    int i = 0;\n    int flag = 1;\n    long result = 0;\n    //滤过前缀空字符\n    while (i < s.length() && s.charAt(i) == ' ') {\n      System.out.println(\"zx\");\n      i++;\n    }\n\n    //判断第一个字符是-还是+\n    if (i < s.length() && s.charAt(i) == '-') {\n      flag = -1;\n      i++;\n    } else if (i < s.length() && s.charAt(i) == '+') {\n      i++;\n    }\n    //对剩下的字符串进行判断转换\n    System.out.println(i);\n    while (i < s.length() && Character.isDigit(s.charAt(i))) {\n      result = result * 10 + s.charAt(i) - 48;\n      i++;\n      System.out.println(result);\n      if (result > Integer.MAX_VALUE) {\n        //超出范围后，结束循环\n        break;\n      }\n    }\n    //对结果的正负进行还原\n    result = flag > 0 ? result : -result;\n\n    if (result < Integer.MIN_VALUE) {\n      return Integer.MIN_VALUE;\n    } else if (result > Integer.MAX_VALUE) {\n      return Integer.MAX_VALUE;\n    }\n    return (int) result;\n  }\n}\n```","categories":["力扣算法学习","初级算法"]},{"title":"344-反转字符串","url":"/2021/03/26/力扣算法学习/初级算法/344-反转字符串/","content":"\n**题目：**\n\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。\n\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n\n你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/reverse-string\n\n<!--more-->\n\n**示例 1：**\n\n---\n\n输入：[\"h\",\"e\",\"l\",\"l\",\"o\"]\n输出：[\"o\",\"l\",\"l\",\"e\",\"h\"]\n\n---\n\n**示例 2：**\n\n---\n\n输入：[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n\n---\n\n**解题思路：**\n\n遍历字符串的一半长度。遍历时将其与其对称的位置的字符进行交换。\n\n**代码：java**\n\n```java\nclass Solution {\n  public void reverseString(char[] s) {\n    for (int i = 0; i < (s.length+1)/2; i++) {\n      char ch = s[i];\n      s[i] = s[s.length-i-1];\n      s[s.length-i-1] = ch;\n    }\n  }\n}\n```","categories":["力扣算法学习","初级算法"]},{"title":"387-字符串中的第一个唯一字符","url":"/2021/03/26/力扣算法学习/初级算法/387-字符串中的第一个唯一字符/","content":"\n**题目：**\n\n给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string\n\n<!--more-->\n\n**示例：**\n\n---\n\ns = \"leetcode\"\n返回 0\n\n---\n\ns = \"loveleetcode\"\n返回 2\n\n----\n\n提示：你可以假定该字符串只包含小写字母。\n\n**解题思路：**\n\n由于题目只有小写字母。因此开一个26大小的数组，保存每个字符在字符串出现的数字。\n\n**代码：Java**\n\n```java\nclass Solution {\n  public int firstUniqChar(String s) {\n    int[] nums = new int[26];\n    for (int i = 0; i < s.length(); i++) {\n      nums[s.charAt(i)-97] += 1;\n    }\n    for (int i = 0; i < s.length(); i++) {\n      if (nums[s.charAt(i)-97] == 1){\n        return i;\n      }\n    }\n    return -1;\n  }\n}\n```","categories":["力扣算法学习","初级算法"]},{"title":"7-整数反转","url":"/2021/03/26/力扣算法学习/初级算法/7-整数反转/","content":"\n**题目：**\n\n给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\n\n如果反转后整数超过 32 位的有符号整数的范围 [−2^31,  2^31 − 1] ，就返回 0。\n假设环境不允许存储 64 位整数（有符号或无符号）。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/reverse-integer\n\n<!--more-->\n\n**示例 1：**\n\n---\n\n输入：x = 123\n输出：321\n\n---\n\n**示例 2：**\n\n---\n\n输入：x = -123\n输出：-321\n\n---\n\n**示例 3：**\n\n---\n\n输入：x = 120\n输出：21\n\n---\n\n示例 4：\n\n---\n\n输入：x = 0\n输出：0\n\n---\n\n**提示：**\n\n-2^31 <= x <= 2^31 - 1\n\n**解题思路：**\n\n由于在计算后可能超出int的边界，所以可以在一开始使用long存储数据。\n\n然后对数进行反转即可。\n\n**代码：Java**\n\n```java\nclass Solution {\n  public int reverse(int x) {\n\n    if (x < 10 && x > -10) {\n      return x;\n    }\n\n    long s=0;\n    if (x<0){\n      s = -(long)x;\n    }else {\n      s=x;\n    }\n    long result = 0;\n    while (s!=0){\n      result = result*10 + s%10;\n      s= s/10;\n    }\n\n    //判断输出\n    if (result > Integer.MAX_VALUE || result < Integer.MIN_VALUE) {\n      return 0;\n    }\n    if (x<0){\n      return -(int)result;\n    }\n    return (int)result;\n  }\n}\n```","categories":["力扣算法学习","初级算法"]},{"title":"83-删除排序链表中的重复元素","url":"/2021/03/26/力扣算法学习/初级算法/83-删除排序链表中的重复元素/","content":"\n**题目：**\n\n存在一个按升序排列的链表，给你这个链表的头节点 `head` ，请你删除所有重复的元素，使每个元素 **只出现一次** 。\n\n返回同样按升序排列的结果链表。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list\n\n<!--more-->\n\n**示例 1：**\n\n---\n\n![](https://assets.leetcode.com/uploads/2021/01/04/list1.jpg)\n\n输入：head = [1,1,2]\n输出：[1,2]\n\n---\n\n**示例 2：**\n\n---\n\n![](https://assets.leetcode.com/uploads/2021/01/04/list2.jpg)\n\n输入：head = [1,1,2,3,3]\n输出：[1,2,3]\n\n---\n\n**提示：**\n\n链表中节点数目在范围 [0, 300] 内\n-100 <= Node.val <= 100\n题目数据保证链表已经按升序排列\n\n**解题思路：**\n\n创建一个头部节点。然后遍历节点。\n\n当当前节点的值和下一节点的值相同时，删除下一节点。\n\n值不同时，当前节点指向下一节点即可。\n\n**代码：**\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n  public ListNode deleteDuplicates(ListNode head) {\n    ListNode node = head;\n    //当数据为空时特殊处理\n    if (head==null){\n      return head;\n    }\n    //当遍历到最后一个节点时结束\n    while (node.next!=null){\n      if (node.val == node.next.val){\n        //当前节点指向下下节点\n        node.next = node.next.next;\n      }else{\n        //当前节点更新为下一节点\n        node = node.next;\n      }\n    }\n    return head;\n  }\n}\n```","categories":["力扣算法学习","初级算法"]},{"title":"1-两数之和","url":"/2021/03/25/力扣算法学习/初级算法/1-两数之和/","content":"\n**题目：**\n\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/two-sum\n\n<!--more-->\n\n**示例 1：**\n\n---\n\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n---\n\n**示例 2：**\n\n---\n\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n\n---\n\n**示例 3：**\n\n---\n\n输入：nums = [3,3], target = 6\n输出：[0,1]\n\n---\n\n**提示：**\n\n2 <= nums.length <= 103\n-109 <= nums[i] <= 109\n-109 <= target <= 109\n只会存在一个有效答案\n\n**思路：暴力或hash**\n\n暴力:直接循环两次，当找出后就返回。\n\nhash:循环数组，如果map中不存在target-当前数的值，则将当前数放到map中。找到了就返回。\n\n**代码：Java**\n\n```java\nclass Solution {\n  public int[] twoSum(int[] nums, int target) {\n    for (int i = 0; i < nums.length; i++) {\n      for (int j = i + 1; j < nums.length; j++) {\n        if (nums[i] + nums[j] == target){\n          int[] ints = new int[2];\n          ints[0] = i;\n          ints[1] = j;\n          return ints;\n        }\n      }\n    }\n    return null;\n  }\n}\n//----------\nclass Solution {\n  public int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();\n    for (int i = 0; i < nums.length; ++i) {\n      if (hashtable.containsKey(target - nums[i])) {\n        return new int[]{hashtable.get(target - nums[i]), i};\n      }\n      hashtable.put(nums[i], i);\n    }\n    return new int[0];\n  }\n}\n```","categories":["力扣算法学习","初级算法"]},{"title":"283-移动零","url":"/2021/03/25/力扣算法学习/初级算法/283-移动零/","content":"\n**题目：**\n\n给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/move-zeroes\n\n<!--more-->\n\n**示例:**\n\n---\n\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n\n---\n\n**说明:**\n\n必须在原数组上操作，不能拷贝额外的数组。\n尽量减少操作次数。\n\n**解题思路：双指针**\n\n一个指针j从0开始，另一个遍历数组。如果遍历时值不为0，则将值赋给nums[j]。然后j++向后移。\n\n最后遍历完后。数组中j往后的都应该是0.\n\n**代码：Java**\n\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int j =0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i]!=0){\n                nums[j]=nums[i];\n                j++;\n            }\n        }\n        for (;j<nums.length;j++){\n            nums[j]=0;\n        }\n    }\n}\n```","categories":["力扣算法学习","初级算法"]},{"title":"36-有效的数独","url":"/2021/03/25/力扣算法学习/初级算法/36-有效的数独/","content":"\n**题目：**\n\n判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。\n\n* 数字 1-9 在每一行只能出现一次。\n* 数字 1-9 在每一列只能出现一次。\n* 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/valid-sudoku\n\n<!--more-->\n\n数独部分空格内已填入了数字，空白格用 `'.'` 表示。\n\n**示例 1:**\n\n---\n\n输入:\n[\n  [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n]\n输出: true\n\n---\n\n**示例 2:**\n\n---\n\n输入:\n[\n  [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n]\n输出: false\n解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。\n     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。\n\n---\n\n**说明:**\n\n一个有效的数独（部分已被填充）不一定是可解的。\n只需要根据以上规则，验证已经填入的数字是否有效即可。\n给定数独序列只包含数字 1-9 和字符 '.' 。\n给定数独永远是 9x9 形式的。\n\n**解题思路：**\n\n两个数组，分别判断行和列是否有重复的。一个二维数组，判断每个区域是否有重复的。\n\n区域计算公式：n = i/3*3+j/3。\n\n采用位置下标判断。比如某行中有3，5，7三个数，则行数组中hang[3]=hang[5]=hang[7]=1;\n\n**代码：Java**\n\n```java\nclass Solution {\n  public boolean isValidSudoku(char[][] board) {\n    //行\n    int[] hang;\n    //列\n    int[] lie;\n    //区域\n    int[][] kuai = new int[9][9];\n    for (int i = 0; i < 9; i++) {\n      //每次换行既是换区域。因此数组想要重新替换\n      hang = new int[9];\n      lie = new int[9];\n      for (int j = 0; j < 9; j++) {\n        //首先判断不能是逗号\n        if (board[i][j]!=46){\n          //判断行\n          if (hang[board[i][j]-49]!=0){\n            return false;\n          }\n          //记录此次数据\n          hang[board[i][j]-49]=1;\n          //判断区域\n          int n = i/3*3+j/3;\n          if (kuai[n][board[i][j]-49]!=0){\n            return false;\n          }\n          //记录此次数据\n          kuai[n][board[i][j]-49]=1;\n        }\n        //首先判断不能是逗号\n        if (board[j][i]!= 46){\n          //判断列\n          if (lie[board[j][i]-49]!=0){\n            return false;\n          }\n          //记录此次数据\n          lie[board[j][i]-49]=1;\n        }\n\n      }\n    }\n    return true;\n  }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["力扣算法学习","初级算法"]},{"title":"48-旋转的图像","url":"/2021/03/25/力扣算法学习/初级算法/48-旋转图像/","content":"\n**题目：**\n\n给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。\n\n你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/rotate-image\n\n<!--more-->\n\n**示例一：**\n\n![](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)\n\n**示例二：**\n\n![](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)\n\n示例 3：\n\n---\n\n输入：matrix = [[1]]\n输出：[[1]]\n\n---\n\n示例 4：\n\n---\n\n输入：matrix = [[1,2],[3,4]]\n输出：[[3,1],[4,2]]\n\n---\n\n**解题思路：**\n\n* 方式一：先对半交换，在沿对角线交换即可。\n* 方式二：按层旋转90度。\n  * 对于每层的每个数进行移动。每层的横长为l个数\n  * 对于每个元素满足(a,b)-->(b,l-1-a)-->(l-1-a,l-1-b)-->(l-1-b,a)-->(a,b)。\n\n**代码：Java**\n\n```java\n//方式一：\nclass Solution {\n  public void rotate(int[][] matrix) {\n    int len = matrix.length;\n    //对半反转\n    for (int i = 0; i < len; i++) {\n      for (int j = 0; j < (len + 1) / 2; j++) {\n        int n = matrix[i][j];\n        matrix[i][j] = matrix[i][len-j-1];\n        matrix[i][len-j-1]=n;\n      }\n    }\n    //沿对角线反转\n    for (int i = 0; i < len; i++) {\n      for (int j = 0; j < len - i; j++) {\n        int n = matrix[i][j];\n        matrix[i][j]=matrix[len-1-j][len-1-i];\n        matrix[len-1-j][len-1-i] = n;\n      }\n    }\n  }\n}\n//方式二\nclass Solution {\n  public void rotate(int[][] matrix) {\n    int len = matrix.length;\n    //总共有len / 2层\n    for (int i = 0; i < len / 2; i++) {\n      //每一层都从上面开始，移动这一层的第一个直到最后一个之前\n      for (int j = i; j < len-i-1; j++) {\n        System.out.println(i + \" \" + j);\n        int n = matrix[i][j];\n        matrix[i][j] = matrix[len-1-j][i] ;\n        matrix[len-1-j][i] = matrix[len-1-i][len-1-j];\n        matrix[len-1-i][len-1-j] = matrix[j][len-1-i];\n        matrix[j][len-1-i] = n;\n      }\n    }\n  }\n}\n```\n\n","categories":["力扣算法学习","初级算法"]},{"title":"122-买卖股票的最佳时机 II","url":"/2021/03/24/力扣算法学习/初级算法/122-买卖股票的最佳时机 II/","content":"\n**题目：**\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii\n\n<!--more-->\n\n**示例 1:**\n\n---\n\n输入: [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n\n---\n\n**示例 2:**\n\n---\n\n输入: [1,2,3,4,5]\n输出: 4\n解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。\n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n\n---\n\n示例 3:\n\n---\n\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n---\n\n提示：\n\n    1 <= prices.length <= 3 * 10 ^ 4\n    0 <= prices[i] <= 10 ^ 4\n\n**解题思路：贪心**\n\n* 价低时买入，价高时卖出。定义一个标志位标志是否有股票。\n\n**代码：Java**\n\n```java\nclass Solution {\n  public int maxProfit(int[] prices) {\n    boolean flag = false;\n    int num=0;\n    int result = 0;\n    int i = 0;\n    for (; i < prices.length-1; i++) {\n      //当出现上升且没买时。买入\n      if (prices[i]<prices[i+1] && !flag){\n        num=prices[i];\n        flag = true;\n        //          System.out.println(\"买\" + prices[i]);\n      }\n      //当出现下降且买过了。卖出\n      if (prices[i]>prices[i+1]&& flag){\n        result += (prices[i]-num);\n        flag = false;\n        //          System.out.println(\"卖\" + prices[i]);\n      }\n    }\n    //当最后一个，且买的有股票，如果不亏本就买\n    if (flag && prices[i]-num>0){\n      result += (prices[i]-num);\n    }\n    return result;\n  }\n}\n```","categories":["力扣算法学习","初级算法"]},{"title":"136-只出现一次的数字","url":"/2021/03/24/力扣算法学习/初级算法/136-只出现一次的数字/","content":"\n**题目：**\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/single-number\n\n<!--more-->\n\n**说明：**\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n**示例 1:**\n\n---\n\n输入: [2,2,1]\n输出: 1\n\n---\n\n**示例 2:**\n\n---\n\n输入: [4,1,2,1,2]\n输出: 4\n\n---\n\n**解题思路：hash,位运算**\n\n* 方式一：使用HashSet。set中不存在就添加，存在就删除。最后只剩一个数。\n* 方式二：使用异或运算。由于满足a异或a为0。a异或0为a。所以数组中全部异或后，重复的都变为了0，而单个的就保留了下来。\n\n**代码：Java**\n\n```java\nimport java.util.HashSet;\nimport java.util.Set;\nclass Solution {\n  public int singleNumber(int[] nums) {\n   /* 方式一\n   Set<Integer> set = new HashSet<>();\n    for (int i = 0; i < nums.length; i++) {\n      if (!set.add(nums[i])) {\n        set.remove(nums[i]);\n      }\n    }\n    Integer s = 0;\n    for (Integer integer : set) {\n      s = integer;\n    }\n    return s;*/\n    //官方异或运算：0和a异或为a。a和a异或为0;\n    int n = 0;\n    for (int i = 0; i < nums.length; i++) {\n      n ^= nums[i];\n    }\n    return n;\n  }\n}\n```\n\n","categories":["力扣算法学习","初级算法"]},{"title":"189-旋转数组","url":"/2021/03/24/力扣算法学习/初级算法/189-旋转数组/","content":"\n**题目：**\n给定一个数组，将数组中的元素向右移动 `k` 个位置，其中 `k` 是非负数。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/rotate-array\n\n<!--more-->\n\n**进阶：**\n\n    尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。\n    你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？\n\n**示例 1:**\n\n---\n\n输入: nums = [1,2,3,4,5,6,7], k = 3\n输出: [5,6,7,1,2,3,4]\n解释:\n向右旋转 1 步: [7,1,2,3,4,5,6]\n向右旋转 2 步: [6,7,1,2,3,4,5]\n向右旋转 3 步: [5,6,7,1,2,3,4]\n\n---\n\n**示例 2:**\n\n---\n\n输入：nums = [-1,-100,3,99], k = 2\n输出：[3,99,-1,-100]\n解释: \n向右旋转 1 步: [99,-1,-100,3]\n向右旋转 2 步: [3,99,-1,-100]\n\n---\n\n**提示：**\n\n    1 <= nums.length <= 2 * 104\n    -231 <= nums[i] <= 231 - 1\n    0 <= k <= 105\n\n**解题思路：**\n\n* 先全部反转，再反转前k个，再反转后n-k个。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210324185435.jpg)\n\n**代码：Java**\n\n```java\nclass Solution {\n  public void rotate(int[] nums, int k) {\n    //全部反转\n    for (int i = 0; i < (nums.length+1)/2; i++) {\n      int num=nums[i];\n      nums[i] = nums[nums.length-i-1];\n      nums[nums.length-i-1]=num;\n    }\n    //k取余，可以缩小数据量，且保证k小于数组的长度。\n    k=k%nums.length;\n    //反转前k个\n    for (int i = 0; i < (k+1)/2; i++) {\n      int num=nums[i];\n      nums[i] = nums[k-i-1];\n      nums[k-i-1]=num;\n    }\n    //反转后n-k个\n    for (int i = k; i < (k+nums.length+1)/2; i++) {\n      int num=nums[i];\n      nums[i] = nums[nums.length-i-1+k];\n      nums[nums.length-i-1+k]=num;\n    }\n\n  }\n}\n```","categories":["力扣算法学习","初级算法"]},{"title":"217-存在重复元素","url":"/2021/03/24/力扣算法学习/初级算法/217-存在重复元素/","content":"\n**题目：**\n\n给定一个整数数组，判断是否存在重复元素。\n\n如果存在一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/contains-duplicate\n\n<!--more-->\n\n**示例 1:**\n\n---\n\n输入: [1,2,3,1]\n输出: true\n\n---\n\n**示例 2:**\n\n---\n\n输入: [1,2,3,4]\n输出: false\n\n---\n\n**示例 3:**\n\n---\n\n输入: [1,1,1,3,3,4,3,2,4,2]\n输出: true\n\n---\n\n**解题思路：**\n\n* 方式一：使用HashsSet。如果没有就添加，如果有就表示有重复数据。\n* \n\n**代码：Java**\n\n```java\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n      Set<Integer> set = new HashSet<Integer>();\n      for (int i = 0; i < nums.length; i++) {\n        //当添加失败表示已经存在这个数了了。\n        if (!set.add(nums[i])){\n          return true;\n        }\n      }\n      return false;\n    }\n}\n```","categories":["力扣算法学习","初级算法"]},{"title":"26-删除有序数组中的重复项","url":"/2021/03/24/力扣算法学习/初级算法/26-删除有序数组中的重复项/","content":"\n**题目：**\n给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array\n\n<!--more-->\n\n注意：本题需要在原来的数组的基础上修改，返回值为修改后的数组需要显示的数组。\n\n**测试方法：**\n\n```java\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n**示例 1：**\n\n---\n\n输入：nums = [1,1,2]\n输出：2, nums = [1,2]\n解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n\n---\n\n**示例 2：**\n\n---\n\n输入：nums = [0,0,1,1,1,2,2,3,3,4]\n输出：5, nums = [0,1,2,3,4]\n解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n\n---\n\n**数据规模：**\n\n- `0 <= nums.length <= 3 * 10^4`\n- `-10^4 <= nums[i] <= 10^4`\n- `nums` 已按升序排列\n\n**解题思路：双指针**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210324184251.jpg)\n\n**提交代码：java**\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n      int i=0;\n      for (int j = 1; j < nums.length; j++) {\n        //将后面与nums[i]不同的数放在i后面的位置上，然后i再移动。\n        if (nums[j]!=nums[i]){\n          nums[++i] = nums[j];\n        }\n      }\n      return i+1;\n    }\n}\n```","categories":["力扣算法学习","初级算法"]},{"title":"350-两个数组的交集 II","url":"/2021/03/24/力扣算法学习/初级算法/350-两个数组的交集 II/","content":"\n**题目：**\n给定两个数组，编写一个函数来计算它们的交集。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii\n\n<!--more-->\n\n**示例 1：**\n\n---\n\n输入：nums1 = [1,2,2,1], nums2 = [2,2]\n输出：[2,2]\n\n---\n\n**示例 2:**\n\n---\n\n输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出：[4,9]\n\n---\n\n**说明：**\n\n输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。\n我们可以不考虑输出结果的顺序。\n\n**进阶：**\n\n如果给定的数组已经排好序呢？你将如何优化你的算法？\n如果 nums1 的大小比 nums2 小很多，哪种方法更优？\n如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？\n\n**解题思路：HashMap**\n\n* 方法一：使用hahmap保存较小数组中每个元素出现的次数。\n\n  * key为元素，value为该元素在较小数组中出现的次数。\n  * 然后遍历较大的数组。\n  * 每当hashmap中存在较大数组中的元素时，将其记录下来。然后将hashmap中此元素的value值减一。\n  * 当value值为0时，剔除此键值对。\n\n  <img src=\"https://assets.leetcode-cn.com/solution-static/350/350_fig1.gif\"></img>\n\n* 方法二：使用双向指针+排序。\n\n  * 先排序。然后同时遍历数组，当下标超出时结束。\n    * 当有一方的值小时，下标加1。\n    * 相等时记录相等的数据并同时加一。\n\n**代码：**\n\n```java\n//方法一：hashmap\nimport java.lang.reflect.Array;\nimport java.util.*;\nclass Solution {\n  public int[] intersect(int[] nums1, int[] nums2) {\n    //保证数组1比数组2小\n    if (nums1.length>nums2.length){\n      return intersect(nums2,nums1);\n    }\n\n    Map<Integer,Integer> map = new HashMap<>();\n    for (int i = 0; i < nums1.length; i++) {\n      //插入，且得到原来的数据的value值\n      Integer old = map.put(nums1[i],1);\n      //如果原来没有数据，则为空。如果有数据，则将value+1再插入。\n      if (old!=null){\n        map.put(nums1[i],++old);\n      }\n    }\n    List<Integer> list = new ArrayList<>();\n    for (int i = 0; i < nums2.length; i++) {\n      //如果map存在此元素，则将map中的key对应的value减1。并保存一次\n      if (map.containsKey(nums2[i])){\n        Integer old = map.put(nums2[i],1);\n        if (old>0){\n          map.put(nums2[i],--old);\n          list.add(nums2[i]);\n        }else{\n          map.remove(nums2[i]);\n        }\n      }\n    }\n    int[] result = new int[list.size()];\n    for (int i = 0; i < list.size(); i++) {\n      result[i] = list.get(i);\n    }\n    return result;\n  }\n}\n//方法二：双向指针+排序\nclass Solution {\n  public int[] intersect(int[] nums1, int[] nums2){\n    Arrays.sort(nums1);\n    Arrays.sort(nums2);\n    int i = 0;\n    int j = 0;\n    List<Integer> list = new ArrayList<>();\n    //当遍历完一个数组时结束\n    while (i<nums1.length&&j<nums2.length){\n      if (nums1[i]==nums2[j]){\n        list.add(nums1[i]);\n        i++;\n        j++;\n      }else if (nums1[i]<nums2[j]){\n        i++;\n      }else{\n        j++;\n      }\n    }\n    int[] result = new int[list.size()];\n    for (int k = 0; k < list.size(); k++) {\n      result[k] = list.get(k);\n    }\n    return result;\n  }\n}\n```","categories":["力扣算法学习","初级算法"]},{"title":"66-加一","url":"/2021/03/24/力扣算法学习/初级算法/66-加一/","content":"\n**题目：**\n\n给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。\n\n最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。\n\n你可以假设除了整数 0 之外，这个整数不会以零开头。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/plus-one\n\n<!--more-->\n\n**示例 1：**\n\n---\n\n输入：digits = [1,2,3]\n输出：[1,2,4]\n解释：输入数组表示数字 123。\n\n---\n\n**示例 2：**\n\n---\n\n输入：digits = [4,3,2,1]\n输出：[4,3,2,2]\n解释：输入数组表示数字 4321。\n\n---\n\n**示例 3：**\n\n---\n\n输入：digits = [0]\n输出：[1]\n\n---\n\n**提示：**\n\n1 <= digits.length <= 100\n0 <= digits[i] <= 9\n\n **解题思路：**\n\n* 对于数组，个位加一。\n  * 当有进位时，往前进位。当没有进位时，结束循环即可。\n  * 当循环结束还有进位，则数组是999格式的。此时只需创建一个新数组第一位变为1即可。\n* 另一种思想：对于数组的每一个数，只有9和非9两种可能。当为9时置为0，否则加一并返回即可。\n  * 当循环结束还没有返回时，表明此时的情况是999格式的。\n\n**代码：Java**\n\n```java\nclass Solution {\n  public int[] plusOne(int[] digits) {\n    //m表示进位。初始值表示个位加1；\n    int m = 1;\n    int n = 0;\n    for (int i = digits.length-1;i>=0;i--) {\n      n = digits[i]+m;\n      m=n/10;\n      n=n%10;\n      digits[i]=n;\n      if (m==0){\n        //此时没有进位，跳出循环\n        break;\n      }\n    }\n    //如果还有进位.则结果类似于1000\n    if (m==1){\n      digits = new int[digits.length+1];\n      //除了第一个值为1，其他的都默认为0；\n      digits[0]=1;\n    }\n    return digits;\n  }\n}\n```","categories":["力扣算法学习","初级算法"]},{"title":"ssm整合之CRUD操作","url":"/2021/03/23/尚硅谷说Java/项目/ssm整合/","content":"功能：数据校验(前端Jquery校验，JSR303后端校验)。Ajax。Rest风格。\n\n技术：SpringMVC+Spring+Mybatis+MySQL+前端Bootstrap+Maven+PageHelper插件+Mybatis Generator。\n\n<!--more-->\n\n# 第一章 项目简介\n\n**项目技术：**\n\n* 基础框架：SpringMVC+Spring+MyBatis\n* 数据库：MySQL\n* 前端框架：BootStrap\n* 依赖管理：Maven\n* 分页：PageHelper\n* 逆向工程：MyBatis Generator\n\n# 第二章：项目的搭建\n\n## 2.1 创建maven项目\n\n## 2.2 引入jar包依赖\n\n```xml\n<!--spring mvc 的包-->\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-webmvc</artifactId>\n  <version>4.3.7.RELEASE</version>\n</dependency>\n<!--spring关于事务的包-->\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc -->\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-jdbc</artifactId>\n  <version>4.3.7.RELEASE</version>\n</dependency>\n<!--spring面向切面编程-->\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects -->\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-aspects</artifactId>\n  <version>4.3.7.RELEASE</version>\n</dependency>\n\n\n<!--mybatis-->\n<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis</artifactId>\n  <version>3.4.1</version>\n</dependency>\n<!--Spring和mybatis的适配包-->\n<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring -->\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis-spring</artifactId>\n  <version>1.3.1</version>\n</dependency>\n\n<!--数据库连接池c3p0-->\n<!-- https://mvnrepository.com/artifact/c3p0/c3p0 -->\n<dependency>\n  <groupId>c3p0</groupId>\n  <artifactId>c3p0</artifactId>\n  <version>0.9.1.2</version>\n</dependency>\n<!--数据库驱动-->\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <version>5.1.6</version>\n</dependency>\n<!--其他包-->\n<dependency>\n  <groupId>jstl</groupId>\n  <artifactId>jstl</artifactId>\n  <version>1.2</version>\n</dependency>\n<!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api -->\n<dependency>\n    <groupId>javax.servlet</groupId>\n    <artifactId>javax.servlet-api</artifactId>\n    <version>3.1.0</version>\n    <scope>provided</scope>\n</dependency>\n<dependency>\n  <groupId>junit</groupId>\n  <artifactId>junit</artifactId>\n  <version>4.12</version>\n</dependency>\n```\n\n## 2.3 引入BootStrap框架\n\n* 下载资源：[下载](https://github.com/twbs/bootstrap/releases/download/v3.3.7/bootstrap-3.3.7-dist.zip)\n* 将下载的文件解压后放到项目中。\n\n## 2.4 整合配置文件\n\n**配置web.xml文件**\n\n* 注意标签的顺序要按照格式\n\n```xml-dtd\n<!ELEMENT web-app (icon?, display-name?, description?, distributable?,\ncontext-param*, filter*, filter-mapping*, listener*, servlet*,\nservlet-mapping*, session-config?, mime-mapping*, welcome-file-list?,\nerror-page*, taglib*, resource-env-ref*, resource-ref*, security-constraint*,\nlogin-config?, security-role*, env-entry*, ejb-ref*,  ejb-local-ref*)>\n```\n\n* 配置文件如下\n\n```xml\n<web-app>\n  <display-name>Archetype Created Web Application</display-name>\n  <!--1.启动Spring的容器-->\n  <context-param>\n    <param-name>contextConfigLocation</param-name>\n    <!--指定Spring配置文件的位置-->\n    <param-value>classpath:applicationConfig.xml</param-value>\n  </context-param>\n\n  <!--3.配置请求的字符编码过滤器。注意：字符编码过滤器要放在所有过滤器之前-->\n  <filter>\n    <filter-name>encodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n    <init-param>\n      <param-name>encoding</param-name>\n      <param-value>UTF-8</param-value>\n    </init-param>\n    <!--设置请求的编码为UTF-8-->\n    <init-param>\n      <param-name>forceRequestEncoding</param-name>\n      <param-value>true</param-value>\n    </init-param>\n    <!--设置响应的编码为UTF-8-->\n    <init-param>\n      <param-name>forceResponseEncoding</param-name>\n      <param-value>true</param-value>\n    </init-param>\n  </filter>\n  <!--4.配置页面的请求转为指定的put,delete请求-->\n  <filter>\n    <filter-name>HiddenHttpMethodFilter</filter-name>\n    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n  </filter>\n\n  <filter-mapping>\n    <filter-name>encodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n  </filter-mapping>\n  <filter-mapping>\n    <filter-name>HiddenHttpMethodFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n  </filter-mapping>\n\n  <!--1.配置启动监听器-->\n  <listener>\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n  </listener>\n  \n  <!--2.配置SpringMVC的前端控制器，用于拦截所有请求-->\n  <servlet>\n    <servlet-name>dispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <!--配置SpringMVC的配置文件位置-->\n    <init-param>\n      <param-name>contextConfigLocation</param-name>\n      <param-value>classpath:SpringMVC-Config.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n  </servlet>\n  <servlet-mapping>\n    <servlet-name>dispatcherServlet</servlet-name>\n    <url-pattern>/</url-pattern>\n  </servlet-mapping>\n</web-app>\n```\n\n**配置SpringMVC.xml配置文件**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\n                           http://www.springframework.org/schema/context\n                           http://www.springframework.org/schema/context/spring-context.xsd\n                           http://www.springframework.org/schema/mvc\n                           http://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n  <!--SpringMVC的配置文件。主要包含网站跳转逻辑的控制，-->\n  <!--1.配置扫描控制层-->\n  <context:component-scan base-package=\"com.lc\" use-default-filters=\"false\">\n    <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n  </context:component-scan>\n\n  <!--2.配置视图解析器，方便页面返回-->\n  <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n    <property name=\"prefix\" value=\"/WEB-INF/views/\"/>\n    <property name=\"suffix\" value=\".jsp\"/>\n  </bean>\n  <!--3.标准配置-->\n  <!--此配置将SpringMVC不能处理的请求交给tomcat处理,比如静态资源交给tomcat处理-->\n  <mvc:default-servlet-handler/>\n  <!--此配置使SpringMVC开启高级功能，比如JSR303校验功能，映射动态请求功能-->\n  <mvc:annotation-driven/>\n\n</beans>\n```\n\n**配置Spring.xml配置文件**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\">\n  <!--Spring的配置文件：主要配置业务和逻辑相关-->\n  <!--主要内容：数据源，与mybatis的整合，事务控制-->\n\n  <!--1.配置扫描包，但不扫描控制层-->\n  <context:component-scan base-package=\"com.lc\">\n    <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n  </context:component-scan>\n\n  <!--2.配置数据库连接的数据源-->\n  <!--引入数据库配置文件-->\n  <context:property-placeholder location=\"classpath:db.properties\"/>\n  <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n    <property name=\"driverClass\" value=\"${jdbc.driverClass}\"/>\n    <property name=\"jdbcUrl\" value=\"${jdbc.url}\"/>\n    <property name=\"user\" value=\"${jdbc.username}\"/>\n    <property name=\"password\" value=\"${jdbc.password}\"/>\n  </bean>\n\n  <!--3.配置和MyBatis的整合-->\n  <!--此工厂能帮助我们创建数据库的连接会话-->\n  <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n    <!--指定MyBatis全局配置文件的位置-->\n    <property name=\"configLocation\" value=\"classpath:MyBatis-Config.xml\"></property>\n    <!--配置数据源，根据数据源创建会话-->\n    <property name=\"dataSource\" ref=\"dataSource\"/>\n    <!--指定mybatis的mapper文件的位置-->\n    <property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/>\n  </bean>\n  <!--.配置扫描器：将mybatis的接口加到IOC中-->\n  <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n    <!--扫描所有的dao接口加入到IOC容器中-->\n    <property name=\"basePackage\" value=\"com.lc.dao\"/>\n  </bean>\n  <!--==============mybatis的真和配置由此结束=============-->\n\n  <!--4.事务控制的配置-->\n  <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n    <!--控制数据源-->\n    <property name=\"dataSource\" ref=\"dataSource\"/>\n  </bean>\n\n  <!--开启基于注解的事务，比较重要的一般使用xml方式配置-->\n  <aop:config>\n    <!--切入点表达式-->\n    <aop:pointcut id=\"txPoint\" expression=\"execution(* com.lc.service..*(..))\"/>\n    <!--配置事务增强-->\n    <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPoint\"/>\n  </aop:config>\n  <!--配置事务增强，事务如何切入。-->\n  <!--transaction-manager的默认值为transactionManager，因此当事务管理的id为transactionManager时，此属性可以不写-->\n  <tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n    <tx:attributes>\n      <!--切入点的所有方法都是事务方法-->\n      <tx:method name=\"*\"/>\n      <!--切入点的所有get开头的方法都是只读属性的，相当于调优-->\n      <tx:method name=\"get*\" read-only=\"true\"/>\n    </tx:attributes>\n  </tx:advice>\n</beans>\n```\n\n**配置Mybatis.xml配置文件**\n\n* 由于数据库连接在spring中已经配置好了，因此在mybatis配置文件中一般只配置别名扫描和驼峰命名规则\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n    PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n    \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n  <!--MyBatis的配置文件-->\n  <settings>\n    <!--开启驼峰命名规则-->\n    <setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n  </settings>\n  <typeAliases>\n    <!--开启别名配置-->\n    <package name=\"com.lc.bean\"/>\n  </typeAliases>\n\n</configuration>\n```\n\n## 2.5 构建数据库\n\n* 本次项目使用两个表，一个员工表，一个部门表。一个部门可以有多个员工。\n\n```sql\nCREATE DATABASE `ssm_curd`;\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for department\n-- ----------------------------\nDROP TABLE IF EXISTS `department`;\nCREATE TABLE `department`  (\n  `dep_id` int(11) NOT NULL,\n  `dep_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`dep_id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Table structure for employee\n-- ----------------------------\nDROP TABLE IF EXISTS `employee`;\nCREATE TABLE `employee`  (\n  `emp_id` int(11) NOT NULL AUTO_INCREMENT,\n  `emp_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `gender` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `d_id` int(1) NULL DEFAULT NULL,\n  PRIMARY KEY (`emp_id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\nSET FOREIGN_KEY_CHECKS = 1;\n```\n\n## 2.6 Mybatis逆向工程\n\n* 使用Mybatis逆向工程可以很快的帮我们生成bean实体和dao接口，以及mapper.xml文件。\n* 官方文档：http://mybatis.org/generator/index.html\n* 第一步：在项目的pom.xml文件中引入依赖\n\n```xml\n<!--使用MBG即Mybatis逆向工程-->\n<dependency>\n  <groupId>org.mybatis.generator</groupId>\n  <artifactId>mybatis-generator-core</artifactId>\n  <version>1.4.0</version>\n</dependency>\n```\n\n* 第二步：在项目中新建mbg.xml文件，即逆向工程的配置文件。mbg.xml文件与pom.xml文件位于同一层。\n\n  * 注意：配置文件的标签顺序一定要是\n\n  ```xml-dtd\n  (property*,plugin*,commentGenerator?,(connectionFactory|jdbcConnection),javaTypeResolver?,javaModelGenerator,sqlMapGenerator?,javaClientGenerator?,table+)\n  ```\n\n  * mbg.xml配置文件。\n\n  ```xml\n  <!DOCTYPE generatorConfiguration PUBLIC\n      \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n      \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n  <generatorConfiguration>\n    <!--此处指定配置的几个版本：\n        简单版(MyBatis3Simple)：业务中只有基础的增删改查\n        豪华版(MyBatis3)：业务中有基础的增删改查，也有按条件的增删改查，和计数功能。本项目使用豪华版\n        注解版：即只生成带注释的dao层文件接口，接口通过注解实现操作数据库的功能，而不带任何xml文件\n          MyBatis3Kotlin：生成Kotlin代码。MyBatis3DynamicSql：生成Java代码。都是注解版\n        -->\n    <context id=\"simple\" targetRuntime=\"MyBatis3\">\n      <!--设置抑制注释的生成，即不生成注释-->\n      <commentGenerator>\n        <property name=\"suppressAllComments\" value=\"true\"/>\n      </commentGenerator>\n      <!--连接数据库-->\n      <jdbcConnection driverClass=\"com.mysql.jdbc.Driver\"\n                      connectionURL=\"jdbc:mysql://localhost:3306/ssm_crud\"\n                      userId=\"root\"\n                      password=\"root\"/>\n      <!--设置生成bean的文件地址-->\n  \n      <javaModelGenerator targetPackage=\"com.lc.bean\" targetProject=\"src/main/java\"/>\n      <!--设置mapper.xml文件的地址-->\n      <sqlMapGenerator targetPackage=\"mapper\" targetProject=\"src/main/resources\"/>\n      <!--设置生成数据访问dao层的接口的文件地址-->\n      <javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.lc.dao\" targetProject=\"src/main/java\"/>\n  \n      <!--设置要生成的表-->\n      <table tableName=\"department\"/>\n      <table tableName=\"employee\"/>\n  \n    </context>\n  <!--下面是配置文件基础的详细设置样例-->\n  <!--  <context id=\"DB2Tables\" targetRuntime=\"MyBatis3\">\n      <jdbcConnection driverClass=\"COM.ibm.db2.jdbc.app.DB2Driver\"\n                      connectionURL=\"jdbc:db2:TEST\"\n                      userId=\"db2admin\"\n                      password=\"db2admin\">\n      </jdbcConnection>\n  \n      &lt;!&ndash;为false表示将数据库的大数字段的属性转换为实体中的String表示&ndash;&gt;\n      <javaTypeResolver>\n        <property name=\"forceBigDecimals\" value=\"false\"/>\n      </javaTypeResolver>\n  \n      <javaModelGenerator targetPackage=\"test.model\" targetProject=\"\\MBGTestProject\\src\">\n        <property name=\"enableSubPackages\" value=\"true\"/>\n        <property name=\"trimStrings\" value=\"true\"/>\n      </javaModelGenerator>\n  \n      <sqlMapGenerator targetPackage=\"test.xml\" targetProject=\"\\MBGTestProject\\src\">\n        <property name=\"enableSubPackages\" value=\"true\"/>\n      </sqlMapGenerator>\n  \n      <javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"test.dao\" targetProject=\"\\MBGTestProject\\src\">\n        <property name=\"enableSubPackages\" value=\"true\"/>\n      </javaClientGenerator>\n  \n  \n      &lt;!&ndash;详细的设置表和实体类之间的对应关系&ndash;&gt;\n  \n      &lt;!&ndash;    <table schema=\"DB2ADMIN\" tableName=\"ALLTYPES\" domainObjectName=\"Customer\" >\n            <property name=\"useActualColumnNames\" value=\"true\"/>\n            <generatedKey column=\"ID\" sqlStatement=\"DB2\" identity=\"true\" />\n            <columnOverride column=\"DATE_FIELD\" property=\"startDate\" />\n            <ignoreColumn column=\"FRED\" />\n            <columnOverride column=\"LONG_VARCHAR_FIELD\" jdbcType=\"VARCHAR\" />\n          </table>&ndash;&gt;\n  \n    </context>-->\n  </generatorConfiguration>\n  ```\n\n* 第三步：在test包中新建一个类，添加如下代码，然后执行。\n\n```java\nimport org.mybatis.generator.api.MyBatisGenerator;\nimport org.mybatis.generator.config.Configuration;\nimport org.mybatis.generator.config.xml.ConfigurationParser;\nimport org.mybatis.generator.exception.InvalidConfigurationException;\nimport org.mybatis.generator.exception.XMLParserException;\nimport org.mybatis.generator.internal.DefaultShellCallback;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n//注意引入的类的引入\npublic class MBGTest {\n  public static void main(String[] args) throws IOException, XMLParserException, InvalidConfigurationException, SQLException, InterruptedException {\n    //配置文件：指向Mybatis逆向工程的配置文件，一般路径为项目名下，与pom.xml文件同一层\n    File configFile = new File(\"mbg.xml\");\n    //新建一个配置分析器\n    ConfigurationParser cp = new ConfigurationParser(warnings);\n    //分析mbg.xml文件，得到配置\n    Configuration config = cp.parseConfiguration(configFile);\n    //配置失败后，是否回调。相当于事务回滚\n    DefaultShellCallback callback = new DefaultShellCallback(overwrite);\n    //逆向工程启动类\n    MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);\n    //开始生成\n    myBatisGenerator.generate(null);\n  }\n}\n\n```\n\n* 最后生成的文件中有一定的功能实现，但通常情况下我们会修改这些文件使其更符合我们的业务需求。\n\n## 2.7 测试\n\n* 使用SprngTest的功能实现测试\n* 第一步：导入依赖\n\n```xml\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-test</artifactId>\n  <version>4.3.7.RELEASE</version>\n</dependency>\n```\n\n* 第二步：编写测试类，添加注解\n\n* 第三步：编写测试方法\n\n```java\nimport com.lc.bean.Department;\nimport com.lc.bean.Employee;\nimport com.lc.dao.DepartmentMapper;\nimport com.lc.dao.EmployeeMapper;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mybatis.spring.SqlSessionTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport java.util.UUID;\n\n/**\n * 测试Dao层\n * 使用Spring的单元测试功能实现\n * @author lc\n * @create 2021-03-21 9:47\n */\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = {\"classpath:applicationConfig.xml\"})\npublic class DaoTest {\n  @Autowired\n  DepartmentMapper departmentMapper;\n  @Autowired\n  EmployeeMapper employeeMapper;\n  //注入批量操作的会话连接\n  @Autowired\n  SqlSessionTemplate sessionTemplate;\n\n  @Test\n  public void testDepInsert(){\n    Department department1 = new Department(null,\"财务部\");\n    Department department2 = new Department(null,\"业务部\");\n    departmentMapper.insertSelective(department1);\n    departmentMapper.insertSelective(department2);\n  }\n  @Test\n  public void testDepSelect(){\n\n  }\n  @Test\n  public void testDepUpdate(){\n\n  }\n  @Test\n  public void testDepDelete(){\n\n  }\n\n  @Test\n  public void testEmpInsert(){\n    //    Employee employee = new Employee(null,\"Json\", \"1\", \"123456@163.com\", 1, null);\n    //    employeeMapper.insertSelective(employee);\n    //批量插入员工信息\n    //使用批量使用的SqlSession\n    EmployeeMapper mapper = sessionTemplate.getMapper(EmployeeMapper.class);\n    for (int i = 0; i < 100; i++) {\n      String substring = UUID.randomUUID().toString().substring(0, 5);\n      mapper.insertSelective(new Employee(null,substring, \"1\", substring+\"@163.com\", 1, null));\n    }\n  }\n  @Test\n  public void testEmpSelect(){\n    System.out.println(employeeMapper.countByExample(null));\n  }\n  @Test\n  public void testEmpUpdate(){\n\n  }\n  @Test\n  public void testEmpDelete(){\n\n  }\n}\n```\n\n# 第三章 项目功能实现\n\n## 3.1 员工查询功能\n\n### 3.1.1 分页查询\n\n* 我们使用mybatis的插件pagehelper来实现分页查询功能。\n* pagehelper官网地址：https://github.com/pagehelper/mybatis-pagehelper或https://pagehelper.github.io/\n* 实现原理：物理分页。对将要执行的sql进行拦截，然后动态的修改sql，再查询数据\n* 第一步：引入依赖\n\n```xml\n<!--版本号可以变-->\n<dependency>\n  <groupId>com.github.pagehelper</groupId>\n  <artifactId>pagehelper</artifactId>\n  <version>5.2.0</version>\n</dependency>\n```\n\n* 第二步：在mybatis配置文件中配置pagehelper插件。注意标签的顺序\n\n```xml\n<!--引入分页插件-->\n<plugins>\n  <plugin interceptor=\"com.github.pagehelper.PageInterceptor\"></plugin>\n</plugins>\n```\n\n* 第三步：使用pagehelper\n\n  * 控制层\n\n  ```java\n    @RequestMapping(\"/emps\")\n    public String getEmps(@RequestParam(value = \"currentPage\", defaultValue = \"1\") Integer currentPage, Model model) {\n      //pagehelper的使用\n      //注意点一： PageHelper.startPage()代码下面的第一条查询语句就是分页查询。\n      PageHelper.startPage(currentPage, CommonValue.PAGE_SIZE);\n      List<Employee> employees = employeeService.getAll();\n      //使用pageInfo对结果进行包装。只能传List类型。10表示显示页码显示到10\n      PageInfo<Employee> pageInfo = new PageInfo<>(employees,10);\n  \n      model.addAttribute(\"pageInfo\", pageInfo);\n      return \"EmpList\";\n    }\n  ```\n\n  * 服务层\n\n  ```java\n  @Override\n  public List<Employee> getAll() {\n    return employeeMapper.selectByExampleWithDepartment(null);\n  }\n  ```\n\n  * 数据访问层\n\n  ```xml\n  <resultMap id=\"EmpAndDepResultMap\" type=\"com.lc.bean.Employee\">\n    <id column=\"emp_id\" jdbcType=\"INTEGER\" property=\"empId\" />\n    <result column=\"emp_name\" jdbcType=\"VARCHAR\" property=\"empName\" />\n    <result column=\"gender\" jdbcType=\"CHAR\" property=\"gender\" />\n    <result column=\"email\" jdbcType=\"VARCHAR\" property=\"email\" />\n    <result column=\"d_id\" jdbcType=\"INTEGER\" property=\"dId\" />\n    <!--使用association联合部门查询-->\n    <association property=\"department\" javaType=\"com.lc.bean.Department\">\n      <id column=\"dep_id\" property=\"depId\"/>\n      <result column=\"dep_name\" property=\"depName\"/>\n    </association>\n  </resultMap>\n  \n  <select id=\"selectByExampleWithDepartment\" parameterType=\"com.lc.bean.EmployeeExample\" resultMap=\"EmpAndDepResultMap\">\n    select\n    <if test=\"distinct\">\n      distinct\n    </if>\n    <include refid=\"empAndDep_Column_List\" />\n    from employee e left join department d on e.d_id = d.dep_id\n    <if test=\"_parameter != null\">\n      <include refid=\"Example_Where_Clause\" />\n    </if>\n    <if test=\"orderByClause != null\">\n      order by ${orderByClause}\n    </if>\n  </select>\n  ```\n\n**测试**\n\n* 测试想要servlet为3版本以上。\n\n```java\n/**\n * 测试controller层\n * 使用SpringTest提供的方法，可以测试请求后controller层的数据结果\n *\n * @author lc\n * @WebAppConfiguration注解可以将自动注入的上下文变成mvc的上下文。 当不加此注解时。自动注入的只能是spring容器中的bean,而不能注入springmvc容器中的bean\n * @create 2021-03-21 11:00\n */\n@RunWith(SpringJUnit4ClassRunner.class)\n@WebAppConfiguration\n@ContextConfiguration(locations = {\"classpath:applicationConfig.xml\", \"classpath:SpringMVC-Config.xml\"})\npublic class MVCTest {\n  //传入Springmvc的上下文\n  @Autowired\n  WebApplicationContext context;\n  //虚拟的mvc请求，获取请求结果\n  MockMvc mockMvc;\n\n  //MockMvc想要创建出来才能使用，\n  @Before\n  public void intiMockMvc() {\n    mockMvc = MockMvcBuilders.webAppContextSetup(context).build();\n  }\n\n  @Test\n  public void testPage() throws Exception {\n    //模拟get请求，且参数currentPage值为1的请求。并拿到返回值\n    MvcResult result = mockMvc.perform(MockMvcRequestBuilders.get(\"/emps\")\n                                       .param(\"currentPage\", \"2\"))\n      .andReturn();\n\n    //请求成功后，请求域中有pageInfo属性\n    MockHttpServletRequest request = result.getRequest();\n    PageInfo pageInfo = (PageInfo) request.getAttribute(\"pageInfo\");\n\n    System.out.println(\"当前页码：\" + pageInfo.getPageNum());\n    System.out.println(\"总页码：\" + pageInfo.getPages());\n    System.out.println(\"总记录数：\" + pageInfo.getTotal());\n    System.out.print(\"连续显示的页码数：\" );\n    int[] nums = pageInfo.getNavigatepageNums();\n    for (int i = 0; i < nums.length; i++) {\n      System.out.print(nums[i] + \" \");\n    }\n    System.out.println();\n    //显示员工信息\n    List<Employee> list = pageInfo.getList();\n    for (Employee employee : list) {\n      System.out.println(employee);\n    }\n  }\n}\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210321120037.png)\n\n**页面实现**\n\n* 页面使用jsp页面。注意引入jsp的依赖\n\n```xml\n<dependency>\n  <groupId>javax.servlet.jsp</groupId>\n  <artifactId>jsp-api</artifactId>\n  <version>2.1</version>\n</dependency>\n```\n\n* 代码(注意JQuery版本)\n\n```jsp\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%@ page isELIgnored=\"false\" %>\n<html>\n  <head>\n    <title>Title</title>\n    <%\n    //此处想要引用jsp-api依赖\n    pageContext.setAttribute(\"APP_PATH\", request.getContextPath());\n    %>\n  </head>\n  <%--引入自己的JQuery。注意JQuery版本--%>\n  <script type=\"text/javascript\" src=\"${APP_PATH}/static/js/jquery2.1.4.min.js\"></script>\n  <%--引入bootstrap的样式--%>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"${APP_PATH}/static/bootstrap-3.3.7-dist/css/bootstrap.css\"/>\n  <script type=\"text/javascript\" src=\"${APP_PATH}/static/bootstrap-3.3.7-dist/js/bootstrap.min.js\"></script>\n  <body>\n    <%--使用bootstrap搭建页面--%>\n    <div class=\"container\">\n      <%--标题--%>\n      <div class=\"row\">\n        <div class=\"col-md-12\">\n          <h1>SSM-CRUD</h1>\n        </div>\n      </div>\n      <%--按钮--%>\n      <div class=\"row\">\n        <div class=\"col-md-4 col-md-offset-10\">\n          <button class=\"btn btn-primary\">新增</button>\n          <button class=\"btn btn-danger\">删除</button>\n        </div>\n      </div>\n      <br>\n      <%--显示表格--%>\n      <div class=\"row\">\n        <div class=\"col-md-12\">\n          <table class=\"table table-hover\">\n            <tr>\n              <td>编号</td>\n              <td>员工名</td>\n              <td>性别</td>\n              <td>邮箱</td>\n              <td>部门</td>\n              <td>编辑</td>\n              <td>删除</td>\n            </tr>\n            <c:forEach items=\"${pageInfo.list}\" var=\"emp\">\n              <tr>\n                <th>${emp.empId}</th>\n                <th>${emp.empName}</th>\n                <th>${emp.gender==\"1\" ? \"男\" : \"女\"}</th>\n                <th>${emp.email}</th>\n                <th>${emp.department.depName}</th>\n                <th>\n                  <button class=\"btn btn-primary btn-sm\">\n                    <span class=\"glyphicon glyphicon-pencil\" aria-hidden=\"true\"><a href=\"#\"></a></span>\n                  </button>\n                </th>\n                <th>\n                  <button class=\"btn btn-danger btn-sm\">\n                    <span class=\"glyphicon glyphicon-trash\" aria-hidden=\"true\"><a href=\"#\"></a></span>\n                  </button>\n                </th>\n              </tr>\n            </c:forEach>\n          </table>\n        </div>\n      </div>\n      <%--导航栏--%>\n      <div class=\"row\">\n        <%--分页信息--%>\n        <div class=\"col-md-5\">\n          <span>当前是第${pageInfo.pageNum}页，总共有${pageInfo.pages}页，总共有${pageInfo.total}条记录</span>\n        </div>\n        <%--分页条--%>\n        <div class=\"col-md-7\">\n          <nav aria-label=\"Page navigation\">\n            <ul class=\"pagination\">\n              <c:if test=\"${!pageInfo.isFirstPage}\">\n                <li><a href=\"${APP_PATH}/emps?pageNum=${pageInfo.navigateFirstPage}\">首页</a></li>\n              </c:if>\n              <c:if test=\"${pageInfo.hasPreviousPage}\">\n                <li>\n                  <a href=\"${APP_PATH}/emps?pageNum=${pageInfo.prePage}\" aria-label=\"Previous\">\n                    <span aria-hidden=\"true\">&laquo;</span>\n                  </a>\n                </li>\n              </c:if>\n              <c:forEach items=\"${pageInfo.navigatepageNums}\" var=\"index\">\n                <c:if test=\"${index == pageInfo.pageNum}\">\n                  <li class=\"active\"><a href=\"#\">${index}</a></li>\n                </c:if>\n                <c:if test=\"${index != pageInfo.pageNum}\">\n                  <li><a href=\"${APP_PATH}/emps?pageNum=${index}\">${index}</a></li>\n                </c:if>\n\n              </c:forEach>\n              <c:if test=\"${pageInfo.hasNextPage}\">\n                <li>\n                  <a href=\"${APP_PATH}/emps?pageNum=${pageInfo.nextPage}\" aria-label=\"Next\">\n                    <span aria-hidden=\"true\">&raquo;</span>\n                  </a>\n                </li>\n              </c:if>\n              <c:if test=\"${!pageInfo.isLastPage}\">\n                <li><a href=\"${APP_PATH}/emps?pageNum=${pageInfo.navigateLastPage}\">末页</a></li>\n              </c:if>\n            </ul>\n          </nav>\n        </div>\n      </div>\n    </div>\n  </body>\n</html>\n```\n\n* 效果图\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210321135652.png)\n\n### 3.1.2 分页查询-改进\n\n* 上述页面只适配于电脑端访问，而现代应用一般都是安卓端，IOS端，电脑端一起使用。因此我们这里做一个改动。\n* **使用Ajax实现。**\n  \n  * 页面通过Ajax发起请求，然后接受JSON数据，在解析数据显示到页面上。此时就体现了客户端无关性。\n  * 因为此时服务端只负责接受请求，然后返回JSON数据，剩下的都有客户端解决。\n  \n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210322100638.png)\n* 第一步：修改控制层方法\n\n```java\n//修改了返回值类型，添加了注解，并且删除了Model参数\n@RequestMapping(\"/emps\")\n@ResponseBody\npublic PageInfo getEmps(@RequestParam(value = \"pageNum\", defaultValue = \"1\") Integer pageNum) {\n\n  //pagehelper的使用\n  //注意点一： PageHelper.startPage()代码下面的第一条查询语句就是分页查询。\n  PageHelper.startPage(pageNum, CommonValue.PAGE_SIZE);\n  List<Employee> employees = employeeService.getAll();\n  //使用pageInfo对结果进行包装。只能传List类型。\n  PageInfo<Employee> pageInfo = new PageInfo<>(employees,CommonValue.PAGE_NUM_SIZE);\n\n  return pageInfo;\n}\n```\n\n* 第二步：导入JSON支持的依赖。以让返回数据转换为JSON格式字符串。\n\n```xml\n<dependency>\n  <groupId>com.fasterxml.jackson.core</groupId>\n  <artifactId>jackson-databind</artifactId>\n  <version>2.9.8</version>\n</dependency>\n```\n\n* 第三步：测试\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210321143437.png)\n\n**设计通用结果类**\n\n* 由于查询的返回值是pageInfo，而删除，增加，修改需要的返回值是一个状态码即可。因此需要设计一个返回值结果类型。\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\n/**\n * 封装返回值结果类型\n */\npublic class ResultMessage {\n  //状态码。\n  private int code;\n  //提示信息\n  private String message;\n  //返回给浏览器的数据\n  private Map<String,Object> data;\n\n  public ResultMessage() {\n    data = new HashMap<>();\n  }\n\n  /**\n   * 快捷添加信息。链式操作\n   * @param key\n   * @param value\n   * @return\n   */\n  public ResultMessage add(String key,Object value){\n    this.data.put(key,value);\n    return this;\n  }\n\n  //=====================常用的成功失败的封装对象========================\n  public static ResultMessage success(){\n    ResultMessage result = new ResultMessage();\n    result.setCode(100);\n    result.setMessage(\"成功\");\n    return result;\n  }\n  public static ResultMessage error(){\n    ResultMessage result = new ResultMessage();\n    result.setCode(100);\n    result.setMessage(\"成功\");\n    return result;\n  }\n\n  public int getCode() {\n    return code;\n  }\n\n  public void setCode(int code) {\n    this.code = code;\n  }\n\n  public String getMessage() {\n    return message;\n  }\n\n  public void setMessage(String message) {\n    this.message = message;\n  }\n\n  public Map<String, Object> getData() {\n    return data;\n  }\n\n  public void setData(Map<String, Object> data) {\n    this.data = data;\n  }\n}\n\n```\n\n* 修改控制层代码。修改返回值即可。\n\n```java\npublic ResultMessage getEmps(@RequestParam(value = \"pageNum\", defaultValue = \"1\") Integer pageNum) {\n  return ResultMessage.success().add(\"pageInfo\",pageInfo);\n}\n```\n\n**前端页面修改**\n\n```jsp\n\n<%--显示表格--%>\n<div class=\"row\">\n  <div class=\"col-md-12\">\n    <table class=\"table table-hover\" id=\"emps_table\">\n      <thead>\n        <tr>\n          <td>编号</td>\n          <td>员工名</td>\n          <td>性别</td>\n          <td>邮箱</td>\n          <td>部门</td>\n          <td>编辑</td>\n          <td>删除</td>\n        </tr>\n      </thead>\n      <tbody>\n      </tbody>\n    </table>\n  </div>\n</div>\n<%--导航栏--%>\n<div class=\"row\">\n  <%--分页信息--%>\n  <div class=\"col-md-5\" id=\"page_msg\">\n  </div>\n  <%--分页条--%>\n  <div class=\"col-md-7\" id=\"page_nav\">\n  </div>\n</div>\n<script type=\"text/javascript\">\n  $(function () {\n    // 访问此页面时，发送一个ajax请求，获取页面数据\n    toPageNum(1);\n  });\n\n  function list_emps_table(result) {\n    //初始化数据\n    $(\"#emps_table tbody\").empty();\n    //获取员工列表\n    var emps = result.data.pageInfo.list;\n    //遍历员工列表\n    $.each(emps, function (index, item) {\n      //创建表格的td标签，并加入员工信息。\n      var empId = $(\"<td></td>\").append(item.empId);\n      var empName = $(\"<td></td>\").append(item.empName);\n      var gender = $(\"<td></td>\").append(item.gender == '1' ? \"男\" : \"女\");\n      var email = $(\"<td></td>\").append(item.email);\n      var depName = $(\"<td></td>\").append(item.department.depName);\n      //编辑按钮和删除按钮\n      /*<button class=\"btn btn-primary btn-sm\">\n                      <span class=\"glyphicon glyphicon-pencil\" ></span>\n  </button>*/\n      var editBut = $(\"<button></button>\").addClass(\"btn btn-primary btn-sm update_btn\")\n      .append($(\"<span></span>\").addClass(\"glyphicon glyphicon-pencil\"));\n      var deleteBut = $(\"<button></button>\").addClass(\"btn btn-danger btn-sm delete_btn\")\n      .append($(\"<span></span>\").addClass(\"glyphicon glyphicon-trash\"));\n      var edit = $(\"<td></td>\").append(editBut);\n      var det = $(\"<td></td>\").append(deleteBut);\n\n      //创建tr标签，并将td添加到tr标签中。\n      //通过appendTo将tr标签 添加到页面的id为emps_table的表格中的tbody标签中\n      $(\"<tr></tr>\").append(empId)\n        .append(empName)\n        .append(gender)\n        .append(email)\n        .append(depName)\n        .append(edit)\n        .append(det)\n        .appendTo(\"#emps_table tbody\");\n    });\n  };\n\n  function list_page_msg(result) {\n    //初始化数据\n    $(\"#page_msg\").empty();\n    var pageNum = result.data.pageInfo.pageNum;\n    var pages = result.data.pageInfo.pages;\n    var total = result.data.pageInfo.total;\n\n    $(\"#page_msg\").append($(\"<span></span>\")\n                          .append(\"当前是第\" + pageNum + \"页，总共有\" + pages + \"页，总共有\" + total + \"条记录\"));\n  };\n\n  function list_emps_page_nav(result) {\n    //初始化数据\n    $(\"#page_nav\").empty();\n    var ul = $(\"<ul></ul>\").addClass(\"pagination\");\n\n    var firstPage = $(\"<li></li>\").append($(\"<span></span>\").append(\"首页\"));\n    var prePage = $(\"<li></li>\").append($(\"<span></span>\").append(\"&laquo;\").attr(\"aria-label\", \"Previous\"));\n\n    if (result.data.pageInfo.hasPreviousPage == false) {\n      firstPage.addClass(\"disabled\");\n      prePage.addClass(\"disabled\");\n    }else{\n      firstPage.click(function () {\n        toPageNum(1);\n      });\n      prePage.click(function () {\n        toPageNum(result.data.pageInfo.prePage);\n      });\n    }\n\n    //添加第一页和上一页\n    ul.append(firstPage).append(prePage);\n\n    $.each(result.data.pageInfo.navigatepageNums, function (index, item) {\n      var page = $(\"<li></li>\").append($(\"<span></span>\").append(item));\n\n      if (result.data.pageInfo.pageNum == item) {\n        page.addClass(\"active\");\n      }\n      page.click(function () {\n        toPageNum(item);\n      })\n\n      //添加中间的页码\n      ul.append(page);\n    });\n    var nextPage = $(\"<li></li>\").append($(\"<span></span>\").append(\"&raquo;\").attr(\"aria-label\", \"Previous\"));\n    var lastPage = $(\"<li></li>\").append($(\"<span></span>\").append(\"末页\").attr(\"aria-label\", \"Next\"));\n\n    if (result.data.pageInfo.hasNextPage == false) {\n      nextPage.addClass(\"disabled\");\n      lastPage.addClass(\"disabled\");\n    }else{\n      nextPage.click(function () {\n        toPageNum(result.data.pageInfo.nextPage);\n      });\n      lastPage.click(function () {\n        toPageNum(result.data.pageInfo.pages);\n      });\n    }\n\n    //添加下一页和最后一页\n    ul.append(nextPage).append(lastPage);\n\n    //将ul添加到nav标签中，在添加到div中\n    var nav = $(\"<nav></nav>\").append(ul).attr(\"aria-label\", \"Page navigation\");\n    nav.appendTo(\"#page_nav\");\n  };\n\n  //跳转页面请求\n  function toPageNum(pageNum) {\n    $.ajax({\n      url: \"${APP_PATH}/emps\",\n      data: \"pageNum=\" + pageNum,\n      type: \"GET\",\n      success: function (result) {\n        console.log(result);\n        //解析字符串数据；\n        //1.解析员工数据\n        list_emps_table(result);\n        //3.解析分页导航条\n        list_page_msg(result);\n        //2.解析分页信息\n        list_emps_page_nav(result);\n      }\n    });\n  }\n</script>\n</body>\n</html>\n```\n\n* 同时在pageHelper配置上添加属性\n\n```xml\n<plugins>\n  <plugin interceptor=\"com.github.pagehelper.PageInterceptor\">\n    <property name=\"reasonable\" value=\"true\"/>\n  </plugin>\n</plugins>\n```\n\n## 3.2 员工增加功能\n\n* 实现当点击新增按钮时，弹出一个下拉框，下拉框填写员工数据，当点击保存后，增加员工数据，并返回主界面。\n\n**下拉框的实现 **\n\n* 页面添加下拉框模板\n\n```jsp\n<%--新增员工信息的弹窗。--%>\n<div class=\"modal fade\" tabindex=\"-1\" role=\"dialog\" id=\"emp_add_modal\">\n  <div class=\"modal-dialog\" role=\"document\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span\n                                                                                          aria-hidden=\"true\">&times;</span></button>\n        <h4 class=\"modal-title\">员工添加</h4>\n      </div>\n      <div class=\"modal-body\">\n\n        <form class=\"form-horizontal\">\n          <div class=\"form-group\">\n            <label for=\"add_emp_name\" class=\"col-sm-2 control-label\">员工名</label>\n            <div class=\"col-sm-10\">\n              <input type=\"email\" class=\"form-control\" name=\"empName\" id=\"add_emp_name\" placeholder=\"张三\">\n            </div>\n          </div>\n          <div class=\"form-group\">\n            <label for=\"add_emp_email\" class=\"col-sm-2 control-label\">邮箱</label>\n            <div class=\"col-sm-10\">\n              <input type=\"password\" class=\"form-control\" name=\"email\" id=\"add_emp_email\" placeholder=\"111111@163.com\">\n            </div>\n          </div>\n          <div class=\"form-group\">\n            <label class=\"col-sm-2 control-label\">性别</label>\n            <div class=\"col-sm-10\">\n              <label class=\"radio-inline\">\n                <input type=\"radio\" name=\"gender\" id=\"add_emp_gender1\" value=\"1\" checked=\"checked\"> 男\n              </label>\n              <label class=\"radio-inline\">\n                <input type=\"radio\" name=\"gender\" id=\"add_emp_gender2\" value=\"2\"> 女\n              </label>\n            </div>\n          </div>\n          <div class=\"form-group\">\n            <label class=\"col-sm-2 control-label\">部门</label>\n            <div class=\"col-sm-5\">\n              <select class=\"form-control\" name=\"dId\" id=\"add_emp_dId\">\n                <%--<option>1</option>--%>\n              </select>\n            </div>\n          </div>\n        </form>\n\n      </div>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">取消</button>\n        <button type=\"button\" class=\"btn btn-primary\">保存</button>\n      </div>\n    </div><!-- /.modal-content -->\n  </div><!-- /.modal-dialog -->\n</div><!-- /.modal -->\n\n<%--按钮--%>\n<div class=\"row\">\n  <div class=\"col-md-4 col-md-offset-10\">\n    <button class=\"btn btn-primary\" id=\"emp_add_modal_btn\">新增</button>\n    <button class=\"btn btn-danger\">删除</button>\n  </div>\n</div>\n<br>\n```\n\n* JS代码实现弹出下拉框，其查询部门数据信息，显示在下拉框中。\n\n```js\n//点击新增按钮，弹出下拉框。\n$(\"#emp_add_modal_btn\").click(function () {\n  //发出请求，查询部门信息，并显示在部门列表中\n\n  getDepts();\n\n  $(\"#emp_add_modal\").modal({\n    backdrop: \"static\"\n  })\n});\n\nfunction getDepts() {\n  $.ajax({\n    url: \"${APP_PATH}/deps\",\n    type: \"GET\",\n    success: function (result) {\n      $(\"#add_emp_dId\").empty();\n      $.each(result.data.departmentList,function (index,item) {\n        $(\"<option></option>\").append(item.depName).attr(\"value\",item.depId).appendTo(\"#add_emp_dId\");\n\n      });\n    }\n  });\n}\n```\n\n* 后台查询：查询部门信息代码的实现。\n\n```java\n//controller层\n@RequestMapping(\"/deps\")\n@ResponseBody\npublic ResultMessage getDepts(){\n  List<Department> departmentList = departmentService.getDeprtments();\n  return ResultMessage.success().add(\"departmentList\", departmentList);\n}\n//service层\n@Override\npublic List<Department> getDeprtments() {\n  return departmentMapper.selectByExample(null);\n}\n```\n\n```xml\n<resultMap id=\"BaseResultMap\" type=\"com.lc.bean.Department\">\n  <id column=\"dep_id\" jdbcType=\"INTEGER\" property=\"depId\" />\n  <result column=\"dep_name\" jdbcType=\"VARCHAR\" property=\"depName\" />\n</resultMap>\n<select id=\"selectByExample\" parameterType=\"com.lc.bean.DepartmentExample\" resultMap=\"BaseResultMap\">\n  select\n  <if test=\"distinct\">\n    distinct\n  </if>\n  <include refid=\"Base_Column_List\" />\n  from department\n  <if test=\"_parameter != null\">\n    <include refid=\"Example_Where_Clause\" />\n  </if>\n  <if test=\"orderByClause != null\">\n    order by ${orderByClause}\n  </if>\n</select>\n```\n\n**实现添加数据的操作**\n\n* JS操作：发送Ajax请求和数据到后台\n\n```js\n$(\"#add_emp_save\").click(function () {\n\n  //Jquery提供的将表单中的输入序列化为字符串，用于Ajax请求使用\n  var form = $(\"#emp_add_modal form\").serialize();\n\n  $.ajax({\n    url: \"${APP_PATH}/emp\",\n    data: form,\n    type:\"POST\",\n    success:function(result) {\n      //员工保存成功后\n      //1.关闭模态框\n      $(\"#emp_add_modal\").modal(\"hide\");\n      //2.来到最后一页，显示员工数据。\n      //根据分页插件的功能，我们可以传一个很大的数，然后分页插件就会自动查询最后一页了。\n      toPageNum(999999);\n    }\n  });\n\n});\n```\n\n* 后台代码：接收数据，并插入到数据库中\n\n```java\n//控制层代码\n@RequestMapping(value = \"/emp\",method = RequestMethod.POST)\n@ResponseBody\npublic ResultMessage postEmp(Employee employee){\n  int rsult = employeeService.addEmp(employee);\n  return ResultMessage.success();\n}\n//业务层代码\n@Override\npublic int addEmp(Employee employee) {\n  return employeeMapper.insertSelective(employee);\n}\n```\n\n```xml\n<insert id=\"insertSelective\" parameterType=\"com.lc.bean.Employee\">\n  insert into employee\n  <trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\">\n    <if test=\"empId != null\">\n      emp_id,\n    </if>\n    <if test=\"empName != null\">\n      emp_name,\n    </if>\n    <if test=\"gender != null\">\n      gender,\n    </if>\n    <if test=\"email != null\">\n      email,\n    </if>\n    <if test=\"dId != null\">\n      d_id,\n    </if>\n  </trim>\n  <trim prefix=\"values (\" suffix=\")\" suffixOverrides=\",\">\n    <if test=\"empId != null\">\n      #{empId,jdbcType=INTEGER},\n    </if>\n    <if test=\"empName != null\">\n      #{empName,jdbcType=VARCHAR},\n    </if>\n    <if test=\"gender != null\">\n      #{gender,jdbcType=CHAR},\n    </if>\n    <if test=\"email != null\">\n      #{email,jdbcType=VARCHAR},\n    </if>\n    <if test=\"dId != null\">\n      #{dId,jdbcType=INTEGER},\n    </if>\n  </trim>\n</insert>\n```\n\n**表单数据的校验**\n\n* 新增弹窗添加一些信息\n\n```jsp\n<input type=\"text\" class=\"form-control\" name=\"empName\" id=\"add_emp_name\" placeholder=\"张三\">\n<span  class=\"help-block\"></span>\n<input type=\"email\" class=\"form-control\" name=\"email\" id=\"add_emp_email\" placeholder=\"111111@163.com\">\n<span class=\"help-block\"></span>\n```\n\n* 当点击保存时进行校验\n\n```js\n//校验表单数据\nfunction validata_add_form(){\n  //校验员工名字\n  var empName = $(\"#add_emp_name\").val();\n  //允许a到z,A到Z，0到9，下划线的3到16位。或者中文2到5位。\n  var regName=/(^[a-zA-Z0-9_-]{3,16}$)|(^[\\u2E80-\\u9FFF]{2,5}$)/;\n  if (!regName.test(empName)){\n    //校验失败。将当前编辑框变红，并提示信息。\n    show_validata_show(\"#add_emp_name\",\"error\",\"用户名可以是2到5位中文或3到16位英文和数字的组合\")\n    return false\n  }else{\n    show_validata_show(\"#add_emp_name\",\"success\",\"\")\n  }\n  //校验邮箱\n  var emailName = $(\"#add_emp_email\").val();\n  var regEmail = /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/;\n  if (!regEmail.test(emailName)){\n    show_validata_show(\"#add_emp_email\",\"error\",\"邮箱格式不正确\")\n    return false\n  }else{\n    show_validata_show(\"#add_emp_email\",\"success\",\"\")\n  }\n  return true;\n};\n\nfunction show_validata_show(elm,status,msg){\n  $(elm).parent().removeClass(\"has-success has-error\");\n  $(elm).next(\"span\").text(\"\");\n  if (\"success\" == status){\n    $(elm).parent().addClass(\"has-success\");\n    $(elm).next(\"span\").text(msg);\n  }else if (\"error\" == status){\n    $(elm).parent().addClass(\"has-error\");\n    $(elm).next(\"span\").text(msg);\n  }\n}\n\n$(\"#add_emp_save\").click(function () {\n  //首先校验输入的数据\n  if (!validata_add_form()){\n    return false;\n  }\n\n  //Jquery提供的将表单中的输入序列化为字符串，用于Ajax请求使用\n  var form = $(\"#emp_add_modal form\").serialize();\n\n  $.ajax({\n    url: \"${APP_PATH}/emp\",\n    data: form,\n    type:\"POST\",\n    success:function(result) {\n      //员工保存成功后\n      //1.关闭模态框\n      $(\"#emp_add_modal\").modal(\"hide\");\n      //2.来到最后一页，显示员工数据。\n      //根据分页插件的功能，我们可以传一个很大的数，然后分页插件就会自动查询最后一页了。\n      toPageNum(999999);\n    }\n  });\n\n});\n```\n\n**后端JSR303校验**\n\n* 第一步：导入JSR303支持依赖\n\n```xml\n<dependency>\n  <groupId>org.hibernate</groupId>\n  <artifactId>hibernate-validator</artifactId>\n  <version>5.4.1.Final</version>\n</dependency>\n```\n\n* 第二步：在实体类上添加注解\n\n```java\n@Pattern(regexp = \"(^[a-zA-Z0-9_-]{3,16}$)|(^[\\\\u2E80-\\\\u9FFF]{2,5}$)\",\n         message = \"用户名必须是2到5位中文或3到16位英文和数字的组合\")\nprivate String empName;\n\nprivate String gender;\n@Pattern(regexp = \"^([a-z0-9_\\\\.-]+)@([\\\\da-z\\\\.-]+)\\\\.([a-z\\\\.]{2,6})$\",\n         message = \"邮箱格式不正确\")\nprivate String email;\n```\n\n* 第三步：修改控制层代码\n\n```java\n@RequestMapping(value = \"/emp\",method = RequestMethod.POST)\n@ResponseBody\npublic ResultMessage postEmp(@Valid Employee employee, BindingResult result){\n  //如果校验失败\n  if (result.hasErrors()){\n    Map<String,Object> error = new HashMap<>();\n    List<FieldError> fieldErrors = result.getFieldErrors();\n    for (FieldError fieldError : fieldErrors) {\n      error.put(fieldError.getField(), fieldError.getDefaultMessage());\n    }\n    return ResultMessage.error().add(\"error\", error);\n  }else {\n    int rsult = employeeService.addEmp(employee);\n    return ResultMessage.success();\n  }\n}\n```\n\n* 第四步：修改前端保存请求的响应代码\n\n```js\nsuccess:function(result) {\n  if (result.code == 100){\n    //员工保存成功后\n    //1.关闭模态框\n    $(\"#emp_add_modal\").modal(\"hide\");\n    //2.来到最后一页，显示员工数据。\n    //根据分页插件的功能，我们可以传一个很大的数，然后分页插件就会自动查询最后一页了。\n    toPageNum(999999);\n  }else{\n    //保存失败\n    var errorEmpName = result.data.error.empName;\n    var errorEmail = result.data.error.email;\n    if (undefined != errorEmail){\n      show_validata_show(\"#add_emp_email\",\"error\",errorEmail);\n    }\n    if (undefined != errorEmail){\n      show_validata_show(\"#add_emp_name\",\"error\",errorEmpName);\n    }\n  }\n}\n```\n\n* 效果图\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210323210139.png)\n\n## 3.3 员工更新功能\n\n* 增加弹窗的代码\n\n```jsp\n<%--修改员工信息的弹窗--%>\n<div class=\"modal fade\" tabindex=\"-1\" role=\"dialog\" id=\"emp_update_modal\">\n  <div class=\"modal-dialog\" role=\"document\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span\n                                                                                          aria-hidden=\"true\">&times;</span></button>\n        <h4 class=\"modal-title\">员工修改</h4>\n      </div>\n      <div class=\"modal-body\">\n\n        <form class=\"form-horizontal\">\n          <div class=\"form-group\">\n            <label for=\"add_emp_name\" class=\"col-sm-2 control-label\">员工名</label>\n            <div class=\"col-sm-10\">\n              <p id=\"update_emp_id\" name=\"empId\" style=\"display: none\" class=\"form-control-static\"></p>\n              <p id=\"update_emp_name\"  name=\"empName\" class=\"form-control-static\"></p>\n            </div>\n          </div>\n          <div class=\"form-group\">\n            <label for=\"add_emp_email\" class=\"col-sm-2 control-label\">邮箱</label>\n            <div class=\"col-sm-10\">\n              <input type=\"email\" class=\"form-control\" name=\"email\" id=\"update_emp_email\" >\n              <span class=\"help-block\"></span>\n            </div>\n          </div>\n          <div class=\"form-group\">\n            <label class=\"col-sm-2 control-label\">性别</label>\n            <div class=\"col-sm-10\">\n              <label class=\"radio-inline\">\n                <input type=\"radio\" name=\"gender\" id=\"update_emp_gender1\" value=\"1\"> 男\n              </label>\n              <label class=\"radio-inline\">\n                <input type=\"radio\" name=\"gender\" id=\"update_emp_gender2\" value=\"2\"> 女\n              </label>\n            </div>\n          </div>\n          <div class=\"form-group\">\n            <label class=\"col-sm-2 control-label\">部门</label>\n            <div class=\"col-sm-5\">\n              <select class=\"form-control\" name=\"dId\" id=\"update_emp_dId\">\n                <%--<option>1</option>--%>\n              </select>\n            </div>\n          </div>\n        </form>\n      </div>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">取消</button>\n        <button type=\"button\" class=\"btn btn-primary\" id=\"update_emp_btn\">更新</button>\n      </div>\n    </div><!-- /.modal-content -->\n  </div><!-- /.modal-dialog -->\n</div><!-- /.modal -->\n\n```\n\n* js逻辑代码\n\n```js\n//编辑按钮的响应\n$(document).on(\"click\", \".update_btn\", function () {\n  $(\"#emp_update_modal form\")[0].reset();\n  var id = $(this).parent(\"td\").parent(\"tr\").find(\"td:eq(0)\").text();\n  getDepts(\"#update_emp_dId\");\n  getEmp(id);\n  $(\"#emp_update_modal\").modal({\n    backdrop: \"static\"\n  });\n});\nfunction getEmp(id) {\n  $.ajax({\n    url: \"${APP_PATH}/emp/\" + id,\n    type: \"GET\",\n    success: function (result) {\n      var empId =result.data.employee.empId;\n      var empName = result.data.employee.empName;\n      var gender =result.data.employee.gender;\n      var email =result.data.employee.email;\n      var dId =result.data.employee.dId;\n      $(\"#update_emp_id\").val(empId);\n      $(\"#update_emp_name\").text(empName).val(empName);\n      $(\"#emp_update_modal input[name=gender]\").val([gender]);\n      $(\"#update_emp_email\").val(email);\n      $(\"#emp_update_modal select\").val([dId]);\n    }\n  });\n}\n$(\"#update_emp_btn\").click(function () {\n  //首先校验输入的数据\n  //校验邮箱\n  var emailName = $(\"#update_emp_email\").val();\n  var regEmail = /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/;\n  if (!regEmail.test(emailName)) {\n    show_validata_show(\"#update_emp_email\", \"error\", \"邮箱格式不正确\")\n    return false\n  } else {\n    show_validata_show(\"#update_emp_email\", \"success\", \"\")\n  }\n  //Jquery提供的将表单中的输入序列化为字符串，用于Ajax请求使用\n  var form = $(\"#emp_update_modal form\").serialize();\n  var id = $(\"#update_emp_id\").val();\n  var empName = $(\"#update_emp_name\").val();\n  console.log(form);\n  $.ajax({\n    url: \"${APP_PATH}/emp/\"+id,\n    data: \"_method=PUT&empName=\"+empName +\"&\"+ form,\n    type: \"POST\",\n    success: function (result) {\n      if (result.code == 100) {\n        //员工保存成功后\n        //1.关闭模态框\n        $(\"#emp_update_modal\").modal(\"hide\");\n        //2.来到最后一页，显示员工数据。\n        //根据分页插件的功能，我们可以传一个很大的数，然后分页插件就会自动查询最后一页了。\n        toPageNum(1);\n      } else {\n        //保存失败\n        var errorEmail = result.data.error.email;\n        if (undefined != errorEmail) {\n          show_validata_show(\"#update_emp_email\", \"error\", errorEmail);\n        }\n      }\n    }\n  });\n});\n```\n\n* 后台代码\n\n```java\n@RequestMapping(value = \"/emp/{id}\",method = RequestMethod.PUT)\n@ResponseBody\npublic ResultMessage postEmp(@PathVariable(\"id\") Integer id,@Valid Employee employee, BindingResult result){\n  System.out.println(employee.getdId());\n  System.out.println(\"controller   \" + employee);\n  //如果校验失败\n  if (result.hasErrors()){\n    Map<String,Object> error = new HashMap<>();\n    List<FieldError> fieldErrors = result.getFieldErrors();\n    for (FieldError fieldError : fieldErrors) {\n      error.put(fieldError.getField(), fieldError.getDefaultMessage());\n    }\n    return ResultMessage.error().add(\"error\", error);\n  }else {\n    employee.setEmpId(id);\n    int rsult = employeeService.updateEmp(employee);\n    return ResultMessage.success();\n  }\n}\n\n@RequestMapping(value = \"/emp/{id}\",method = RequestMethod.GET)\n@ResponseBody\npublic ResultMessage getEmp(@PathVariable(\"id\") Integer id){\n  Employee employee = employeeService.getEmp(id);\n  return ResultMessage.success().add(\"employee\", employee);\n}\n```\n\n* 效果\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210323210044.png)\n\n## 3.4 删除员工功能\n\n* 编写删除员工的事件监听。注意此处用的是REST风格的请求，因此注意配置过滤器。\n* 前端代码\n\n```js\n$(document).on(\"click\",\".delete_btn\",function () {\n  var id = $(this).parent(\"td\").parent(\"tr\").find(\"td:eq(0)\").text();\n  var name = $(this).parent(\"td\").parent(\"tr\").find(\"td:eq(1)\").text();\n  if (confirm(\"确认删除\" +name +\"吗？\")){\n    $.ajax({\n      url: \"${APP_PATH}/emp/\"+id,\n      data: \"_method=DELETE\",\n      type:\"POST\",\n      success:function(result) {\n        toPageNum(1);\n      }\n    });\n  }\n});\n```\n\n* 后端代码\n\n```java\n//controller层代码\n@RequestMapping(value = \"/emp/{id}\",method = RequestMethod.DELETE)\n@ResponseBody\npublic ResultMessage postEmp(@PathVariable(\"id\") Integer id){\n  int rsult = employeeService.deleteEmp(id);\n  return ResultMessage.success();\n}\n//service层代码\n@Override\npublic int deleteEmp(Integer id) {\n  return employeeMapper.deleteByPrimaryKey(id);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["Java学习","项目"]},{"title":"SpringMVC的学习","url":"/2021/03/18/尚硅谷说Java/JavaEE框架/SpringMVC/","content":" \n\nREST风格请求，视图解析，表单处理，静态资源放行，数据的校验，JSON格式返回值\n国际化处理，文件的上传，拦截器，异常处理，与Spring的整合。\n\n<!--more-->\n\n* 基于Spring4版本\n\n# 第一章 入门\n\n* Spring 为展现层提供的基于 MVC 设计理念的优秀的Web 框架，是目前最主流的 MVC 框架之一。\n* Spring3.0 后全面超越 Struts2，成为最优秀的 MVC 框架。\n* Spring MVC 通过一套 MVC 注解，让 POJO 成为处理请求的控制器，而无须实现任何接口。\n* 支持 REST 风格的 URL 请求 。\n* 采用了松散耦合可插拔组件结构，比其他 MVC 框架更具扩展性和灵活性。\n\n**第一个hello world**\n\n* 创建java web工程。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210316083419.png)\n\n* 加入下列jar包。\n\n  * commons-logging-1.1.3.jar\n  * spring-aop-4.0.0.RELEASE.jar\n  * spring-beans-4.0.0.RELEASE.jar\n  * spring-context-4.0.0.RELEASE.jar\n  * spring-core-4.0.0.RELEASE.jar\n  * spring-expression-4.0.0.RELEASE.jar\n  * spring-web-4.0.0.RELEASE.jar\n  * spring-webmvc-4.0.0.RELEASE.jar\n\n* 编写web.xml配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n\n  <!--配置dispatcherServlet-->\n  <servlet>\n    <servlet-name>dispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <!--配置初始化参数。作用：指明SpringMVC配置文件的位置和名称-->\n    <init-param>\n      <param-name>contextConfigLocation</param-name>\n      <param-value>classpath:springmvc.xml</param-value>\n    </init-param>\n<!--当不通过配置初始化参数指定springmvc配置文件时，可以通过默认的路径即可。\n    默认的路径为/WEB-INF/<servlet-name>-servlet.xml。\n    例如：当前的默认配置文件的位置为/WEB-INF/dispatcherServlet-servlet.xml-->\n    <load-on-startup>1</load-on-startup>\n  </servlet>\n  <servlet-mapping>\n    <servlet-name>dispatcherServlet</servlet-name>\n    <url-pattern>/</url-pattern>\n  </servlet-mapping>\n\n  <welcome-file-list>\n    <welcome-file>index.jsp</welcome-file>\n  </welcome-file-list>\n</web-app>\n```\n\n* 编写springmvc的配置信息\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n       http://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context.xsd\">\n  <!--配置自动扫描的包-->\n  <context:component-scan base-package=\"com.lc\"></context:component-scan>\n  <!--配置视图处理器：如何把控制器controller的返回值解析为实际的物理视图-->\n  <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n    <property name=\"prefix\" value=\"/WEB-INF/views/\"></property>\n    <property name=\"suffix\" value=\".jsp\"></property>\n  </bean>\n</beans>\n```\n\n* 编写控制器\n\n```java\n@Controller\npublic class HelloController {\n  /**\n   * 使用RequestMapping注解来映射请求的URL\n   * 返回值会通过视图解析器拼接成实际的物理视图。对于InternalResourceViewResolver解析器会做如下的解析：\n   * 通过 prefix + 返回值 + suffix 的方式得到实际的物理视图，然后做转发操作\n   * @return\n   */\n  @RequestMapping(\"/helloworld\")\n  public String hello(){\n    System.out.println(\"hello world\");\n    return \"success\";\n  }\n}\n```\n\n* 配置dispatcherServlet\n  * DispatcherServlet 默认加载 /WEB-INF/\\<servletName>-servlet.xml 的 Spring 配置文件, 启动 WEB 层 的 Spring 容器。\n  * 可以通过 contextConfigLocation 初始化参数自定义配置文件的位置和名称。\n* 配置注解扫描：让controller注解起作用。\n* 配置视图解析器：将返回值解析为具体的jsp的路径。\n  * 对于InternalResourceViewResolver解析器会做如下的解析：\n     * 通过 prefix + 返回值 + suffix 的方式得到实际的物理视图，然后做转发操作。\n\n# 第二章 RequestMapping注解\n\n* Spring MVC 使用 **@RequestMapping** 注解为控制器指定可以处理哪些 URL 请求。\n\n* \n\n* 在控制器的类定义及方法定义处都可标注。\n\n  * 类定义处：提供初步的请求映射信息。相对于 WEB 应用的根目录\n  * 方法处：提供进一步的细分映射信息。相对于类定义处的 URL。若类定义处未标注 @RequestMapping，则方法处标记的 URL 相对于WEB 应用的根目录\n\n  例如:\n\n  ```java\n  //当访问路径为：http://localhost:8080/SpringMVC1_war_exploded/hello/world时才会调用hello()方法处理请求。\n  //当访问路径为：http://localhost:8080/SpringMVC1_war_exploded/hello时，表示使用HelloController中的某个方法进行处理请求。\n  @Controller\n  @RequestMapping(\"/hello\")\n  public class HelloController {\n    @RequestMapping(\"/world\")\n    public String hello(){\n      System.out.println(\"hello world\");\n      return \"success\";\n    }\n  }\n  ```\n\n* DispatcherServlet 截获请求后，就通过控制器上@RequestMapping 提供的映射信息确定请求所对应的处理\n  方法。\n\n## 2.1 @RequestMapping的属性\n\n* @RequestMapping 除了可以指定请求 URL 映射外，还可以指定请求方法、请求参数及请求头映射请求。\n* @RequestMapping 的 value、method、params 及 heads 分别表示请求 URL、请求方法、请求参数及请求头的映射条件，他们之间是**与**的关系，联合使用多个条件可让请求映射更加精确化。\n  * 当加上多个条件时，@RequestMapping的方法只会处理符合条件的请求url。\n  * params 及 heads可以支持多个条件。\n  * method的值为RequestMethod枚举类的所有属性。表示请求的类型。例如get，post，put请求等。\n* params 和 headers支持**简单的表达式**\n  * param1: 表示请求必须包含名为 param1 的请求参数\n  *  !param1: 表示请求不能包含名为 param1 的请求参数\n  * param1 != value1: 表示请求包含名为 param1 的请求参数，但其值不能为 value1\n  * {“param1=value1”, “param2”}: 请求必须包含名为 param1 和param2 的两个请求参数，且 param1 参数的值必须为 value1\n* 举例：\n\n```java\n@Controller\npublic class UserController {\n\n  @RequestMapping(value = \"/test\",method = RequestMethod.POST,\n        params = {\"username\",\"age!=10\"},headers = {\"contentType=html/*\"})\n  public String test1(){\n    return \"success\";\n  }\n}\n```\n\n* 说明：\n  * value：表示请求的url为http://localhost:8080/SpringMVC1_war_exploded/test。\n  * method：表示请求的类型要为POST请求。\n  * params：表示请求的参数要带username属性和age属性，且age属性的值不能为10。\n  * headers：表示请求头要有contentType属性，且属性值为html/*。\\*表示全匹配。\n  * 以上四个条件都满足的请求才能被这个方法处理。\n\n## 2.2 RequestMapping注解请求映射的风格\n\n* Ant 风格资源地址支持 3 种匹配符： \n  * ?    ：匹配文件名中的一个字符。\n  * \\*    ：匹配文件名中的任意字符。\n  * **   ： 匹配多层路径。\n*  @RequestMapping 还支持 Ant 风格的 URL：\n  *  /user/*/createUser: 匹配 /user/aaa/createUser、/user/bbb/createUser 等 URL\n  *  /user/**/createUser: 匹配/user/createUser、/user/aaa/bbb/createUser 等 URL。\n  *  /user/createUser??: 匹配/user/createUseraa、/user/createUserbb 等 URL。\n* 例如：\n\n```java\n//请求路径为：http://localhost:8080/SpringMVC1_war_exploded/test2/asd 。asd可以替换成任意英文，但只能匹配一层。\n@RequestMapping(\"/test2/*\")\npublic String test2(){\n  return \"success\";\n}\n```\n\n## 2.3 @PathVariable 映射 URL 绑定的占位符\n\n* 带占位符的 URL 是 Spring3.0 新增的功能，该功能在SpringMVC 向 REST 目标挺进发展过程中具有里程碑的意义 \n* 通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：\n  * URL 中的 {xxx} 占位符可以通过 @PathVariable(\"xxx\") 绑定到操作方法的参数中。\n  * @PathVariable注解中的字母和占位符的字母要保持一致。\n  * @PathVariable注解还会将请求中的值自动解析成形参的类型。\n* 例如：\n\n```java\n//访问路径为：http://localhost:8080/SpringMVC1_war_exploded/test3/100\n//此时形参中的id的值为100\n@RequestMapping(\"/test3/{qid}\")\npublic String test3(@PathVariable(\"qid\") int id){\n  return \"success\";\n}\n```\n\n# 第三章 REST风格\n\n* REST：即 Representational State Transfer。（资源）表现层状态转化。是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。\n\n* 资源（Resources）：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要 获取这个资源，访问它的URI就可以，因此 URI 即为每一个资源的独一无二的识 别符。 \n\n* 表现层（Representation）：把资源具体呈现出来的形式，叫做它的表现层（Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格 式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。\n\n* 状态转化（State Transfer）：每发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“ 状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “ 表现层状态转化”。\n\n* 具体说，就是 HTTP 协议里面，四个表示操作方式的动 词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获 取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。\n\n* 浏览器 form 表单只支持 GET 与 POST 请求，而DELETE、PUT 等 method 并不支 持，Spring3.0 添加了一个过滤器，可以将这些请求转换为标准的 http 方法，使得支持 GET、POST、PUT 与DELETE 请求。\n\n  * HiddenHttpMethodFilter过滤器：能够将POST请求转换成PUT和DELETE请求。\n\n* 格式：\n\n  * get请求：/order/1 。请求中需要指明要获取的资源名称，且指明当前请求是GET请求。\n  * post请求：/order 。请求中传递数据即可，且指明当前请求是POST请求。\n  * put请求：/order/1 。请求中需要指明要更新的资源名称，且指明当前请求是POST请求。\n    * 并且在请求中设置一个隐藏的属性。属性名为_method。属性值为PUT。\n  * delete请求：/order/1 。请求中需要指明要删除的资源名称，且指明当前请求是POST请求。\n    * 并且在请求中设置一个隐藏的属性。属性名为_method。属性值为DELETE。\n\n* 使用步骤：\n\n  * 第一步：在web.xml中配置HiddenHttpMethodFilter过滤器。\n\n  ```xml\n  <filter>\n    <filter-name>hiddenHttpMethodFilter</filter-name>\n    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n  </filter>\n  <filter-mapping>\n    <filter-name>hiddenHttpMethodFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n  </filter-mapping>\n  ```\n\n  * 第二步：前端页面代码\n\n  ```html\n  <form action=\"testPost/1\" method=\"post\">\n    <input type=\"hidden\" name=\"_method\" value=\"DELETE\">\n    <input type=\"submit\" value=\"sumbitDelete\">\n  </form>\n  <form action=\"testPost/1\" method=\"post\">\n    <input type=\"hidden\" name=\"_method\" value=\"PUT\">\n    <input type=\"submit\" value=\"sumbitPut\">\n  </form>\n  <form action=\"testPost\" method=\"post\">\n    <input type=\"submit\" value=\"sumbitPost\">\n  </form>\n  \n  <a href=\"testGet/1\">testGet</a>\n  ```\n\n  * 第三步：后台接收代码\n\n  ```java\n  @RequestMapping(value = \"/testGet/{qid}\",method = RequestMethod.GET)\n  public String testGet(@PathVariable(\"qid\") Integer id){\n    System.out.println(\"testGet \" + id);\n    return \"success\";\n  }\n  @RequestMapping(value = \"/testPost\",method = RequestMethod.POST)\n  public String testPost(){\n    System.out.println(\"testPost \");\n    return \"success\";\n  }\n  @RequestMapping(value = \"/testPost/{qid}\",method = RequestMethod.PUT)\n  public String testPut(@PathVariable(\"qid\") Integer id){\n    System.out.println(\"testPut \" + id);\n    return \"success\";\n  }\n  @RequestMapping(value = \"/testPost/{qid}\",method = RequestMethod.DELETE)\n  public String testDelete(@PathVariable(\"qid\") Integer id){\n    System.out.println(\"testDelete \" + id);\n    return \"success\";\n  }\n  ```\n\n* <font color=\"red\">注意事项：</font>\n\n  * 当请求被控制接收到，但在返回页面时出现405错误的提示。有如下方法解决：\n\n    * 1.将Tomcat版本降低为8以下的版本。\n    * 2.@RestController 或者 @Controller + @ResponseBody 标签，但是这样就无法跳转页面了。\n    * 3.避免使用 forward 方式跳转页面，改为 重定向redirect方式跳转到另一个控制器方法，再由这个控制器方法跳转页面。\n    * 例如：\n\n    ```java\n    @RequestMapping(value = \"/rest\", method = RequestMethod.PUT)\n    public String put() {\n    \t// 接收表单中的各种信息\n    \tSystem.out.println(\"PUT --- 更新数据\");\n    \treturn \"redirect:/success\";\n    }\n    \n    @RequestMapping(value = \"/success\")\n    public String success() {\n    \treturn \"success\";\n    }\n    ```\n\n    * 4.给Tomcat添加启动参数，使Tomcat允许读写操作\n    * 5.创建一个新的Filter来实现HiddenHttpMethodFilter的功能。\n\n# 第四章 映射请求参数和请求参数\n\n## 4.1 请求参数\n\n* Spring MVC 通过分析处理方法的签名，将 HTTP 请求信息绑定到处理方法的相应人参中。 \n\n* Spring MVC 对控制器处理方法签名的限制是很宽松的，几乎可以按喜欢的任何方式对方法进行签名。\n\n* 必要时可以对方法及方法入参标注相应的注解（ @PathVariable、@RequestParam、@RequestHeader 等）、Spring MVC 框架会将 HTTP 请求的信息绑定到相应的方法入参中，并根据方法的返回值类型做出相应的后续处理。\n\n* 在处理方法入参处使用 @RequestParam 可以把请求参数传递给请求方法\n\n  * value：参数名\n  * required：是否必须。默认为 true, 表示请求参数中必须包含对应的参数，若不存在，将抛出异常。\n  * defaultValue：默认值。当请求中不包含此参数时，默认值即为形参的值。当形参类型为基本类型时，需要带上默认值。否则会报错。\n\n* 示例\n\n  ```java\n  //访问路径为：http://localhost:8080/SpringMVC1_war_exploded/test4?name=root&age=11\n  //也可以为：http://localhost:8080/SpringMVC1_war_exploded/test4?name=root\n  @RequestMapping(\"/test4\")\n  public String test4(@RequestParam(\"name\") String name,\n                      @RequestParam(value = \"age\",required = false,defaultValue = \"0\") int age){\n    System.out.println(name + \" \" + age);\n    return \"success\";\n  }\n  ```\n\n* 上述代码的几种情况：\n\n  * 当请求中不传递age时，需要在@RequestParam 注解添加required=false。\n  * 当请求中不传递age时，且添加了required=false。\n    * 此时，如果age为int类型，会报错。需要再添加defaultValue属性。\n    * 此时，如果age为Integer类型，不会报错，age的值为null。\n\n## 4.2 请求头\n\n* 请求头包含了若干个属性，服务器可据此获知客户端的信息，通过 @RequestHeader 即可将请求头中的属性值绑定到处理方法的入参中。\n* @RequestHeader注解的值即为要获取的请求头的哪个属性。\n* 使用方法：\n\n```java\n@RequestMapping(\"/test5\")\npublic void test5(@RequestHeader(\"Accept-Encoding\") String encoding){\n  System.out.println(encoding);\n}\n```\n\n## 4.3 Cookie信息的获取\n\n* **@CookieValue** 可让处理方法入参绑定某个 Cookie 值。即获取指定Cookie属性的值为参数传递给控制方法。\n* 使用方法：\n\n```java\n@RequestMapping(\"/test6\")\npublic void test6(@CookieValue(value = \"JSESSIONID\",required = false) String sessionId){\n  System.out.println(sessionId);\n}\n```\n\n## 4.4 POJO对象绑定\n\n* Spring MVC 会按请求参数名和 POJO 属性名进行自动匹配，自动为该对象填充属性值。支持级联属性。\n* 示例：\n* 两个对象。要有get和set方法\n\n```java\npublic class User {\n  private String username;\n  private String password;\n  private Address address;\n}\npublic class Address {\n  private String province;\n  private String county;\n}\n```\n\n* 页面代码\n\n```html\n<form action=\"testPOJO\" >\n  用户名：<input type=\"text\" name=\"username\"><br>\n  密码：<input type=\"text\" name=\"password\"><br>\n  所在市：<input type=\"text\" name=\"address.province\"><br>\n  所在县：<input type=\"text\" name=\"address.county\"><br>\n  <input type=\"submit\" value=\"提交\">\n</form>\n```\n\n* 后端测试代码\n\n```java\n@RequestMapping(\"/testPOJO\")\npublic String testPOJO(User user){\n  System.out.println(user.toString());\n  System.out.println(user.getAddress().toString());\n  return \"success\";\n}\n```\n\n## 4.5 接受Servlet的原生API参数\n\n* 在接收参数时，可以接受servlet的一些原生参数。有以下几种：\n  * HttpServletRequest  ：请求\n  * HttpServletResponse  ：响应\n  * HttpSession  ：Session域\n  *  java.security.Principal ：安全认证标识符\n  * Locale：时区地址\n  * InputStream：读取请求主体\n  * OutputStream：写入请求主体\n  * Reader：读取请求正文\n  * Writer：写入请求正文\n* 示例：\n\n```java\n@RequestMapping(\"/test7\")\npublic void test7(HttpServletRequest request, HttpServletResponse response){\n  System.out.println(request + \" \" + response);\n}\n```\n\n# 第五章 模型数据\n\n* Spring MVC 提供了以下几种途径输出模型数据：\n  * ModelAndView: 处理方法返回值类型为 ModelAndView时, 方法体即可通过该对象添加模型数据。\n  * Map 及 Model: 入参为org.springframework.ui.Model、org.springframework.ui.ModelMap 或 java.uti.Map 时，处理方法返回时，Map 中的数据会自动添加到模型中。\n  * @SessionAttributes: 将模型中的某个属性暂存到HttpSession 中，以便多个请求之间可以共享这个属性。\n  * @ModelAttribute: 方法入参标注该注解后, 入参的对象就会放到数据模型中。\n* 总结：\n  * ModelAndView用于往request域中添加属性，且可以设置返回的页面，或新建一个页面作为返回的页面。\n  * Map 及 Model只用于传递数据，即将数据添加到request域属型中。\n  * @SessionAttributes也只用于传递数据，但是将数据添加到Session域中。\n  * 当使用SessionAttributes和ModelAttribute注解时，此注解\n\n## 5.1 ModelAndView\n\n* ModelAndView既包含视图信息，也包含模型数据信息。\n* 使用方式：将其作为控制方法的返回值类型。\n* 添加模型数据: \n  * MoelAndView addObject(String attributeName, Object attributeValue) \n  *  ModelAndView addAllObject(Map<String, ?> modelMap) \n* 设置视图: \n  * void setView(View view) \n  * void setViewName(String viewName)\n* 示例：\n\n```java\n@RequestMapping(\"/test8\")\npublic ModelAndView test8(){\n  ModelAndView modelAndView = new ModelAndView();\n  //添加属性键值对。实际上是往request域中添加键值对。\n  modelAndView.addObject(\"name\", \"root\");\n  //添加返回的页面视图名称\n  modelAndView.setViewName(\"success\");\n  return modelAndView;\n}\n```\n\n## 5.2 Map 及Model\n\n* Spring MVC 在调用方法前会创建一个隐含的模型对象作为模型数据的存储容器。 \n* 如果控制方法的参数为 Map 或 Model 类 型，Spring MVC 会将隐含模型的引用传递给这些入参。在方法体内，开发者可以通过这个入参对象访问到模型中的所有数据，也可以向模型中添加新的属性数据。\n* 示例：\n\n```java\n@RequestMapping(\"/test9\")\npublic String test9(Map<String,String> map){\n  map.put(\"name\", \"root\");\n  return \"success\";\n}\n```\n\n* 与ModelAndView的区别：\n  * 由于model和map只能传递数据，因此它不能作为返回值，因为它无法指明返回页面。\n  * model和map是在调用控制方法前就创建的隐含式模型数据的存储容器。\n  * 相同之处：都是往request域中添加域属型\n\n## 5.3 @SessionAttributes注解\n\n* 若希望在多个请求之间共用某个模型属性数据，则可以在控制器类上标注一个 @SessionAttributes, Spring MVC 将在模型中对应的属性暂存到 HttpSession 中。\n* @SessionAttributes 除了可以通过属性名指定需要放到会话中的属性外，还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中。\n* @SessionAttributes 有两个属性，都是指明在此控制类中所有的模型数据中的哪些数据要添加到session域中。\n  * value：以数据的key为此属性的值，可以有多个值。\n  * types：以数据的类的类型为此属性的值，也可以有多个值。\n* 示例\n\n```java\n@SessionAttributes(value = {\"name\"},types = {User.class})\n@Controller\npublic class UserController {\n  @RequestMapping(\"/test9\")\n  public String test9(Map<String,String> map){\n    map.put(\"name\", \"root\");\n    return \"success\";\n  }\n}\n```\n\n## 5.4 @ModelAttribute注解\n\n* 使用位置：在方法上，控制方法的形参上，控制方法的返回值上。\n\n* 在方法上：Spring MVC 在调用目标处理方法前，会先逐个调用在方法级上标注了@ModelAttribute 的所有方法。\n\n  * 每次调用控制层的方法，都会执行一次所有标注了@ModelAttribute 的方法。\n  * 作用：\n  * 这些方法都有map或model作为形参，这些map和model都是ModelAttribute的。\n  * 在这些方法中，可以将创建的数据对象添加到map或model中。\n  * 此时ModelAttribute中就会有数据对象，且数据对象的引用key也就被确定了。\n  * 然后，当SpringMVC调用控制方法时，如果有方法的形参类型的第一个首字母小写的字符串与key相同。\n  * 则将该数据对象作为形参的初始值，然后在接受到请求参数对初始值进行更新，最后的数据会被传入到控制方法中\n  * 简化版说明：\n    * ModelAttribute注解的方法中往ModelAttribute中存放了一个user对象。\n    * 请求到控制方法时，方法中的形参有一个user,\n    * 形参的user先以ModelAttribute的user为模板创建，然后在接受请求的参数，将请求参数值绑定到user中。\n    * 最后将user作为形参传递给控制方法。\n    * 同时，也会将user放入到request域中\n  * 注意：ModelAttribute的key要和形参的类名首字母小写相匹配时，才能起作用。\n\n  ```java\n  @ModelAttribute\n  public void getUser(Model model){\n    User user = new User();\n    user.setUsername(\"root\");\n    user.setPassword(\"root\");\n    model.addAttribute(\"user\", user);\n  }\n  //访问为：http://localhost:8080/SpringMVC1_war_exploded/test10?username=admin\n  //因为User类的首字母小写后与ModelAttribute中的key相同\n  //此时user的初始值为{username=root,password=root}\n  //在接受到请求参数后，user变成了：{username=admin,password=root}\n  //最后传入方法的user为：{username=admin,password=root}\n  @RequestMapping(\"/test10\")\n  public String test10(User user){\n    return \"success\";\n  }\n  ```\n\n* 在控制方法的形参上：用于指明将哪个key的数据对象赋给这个形参。然后请求参数绑定到形参中。最后的形参对象会被添加到ModelAttribute，覆盖先前的数据对象，key不变。\n\n  * 一般用于解决ModelAttribute的key和形参类名小写不一致的情况。\n  * 与不加ModelAttribute注解的形参的区别：不加时，只会赋给形参，不会覆盖老数据对象。\n  * 最后的形参对象不仅会添加到ModelAttribute中，也会放到request域中。\n\n```java\n@RequestMapping(\"/test10\")\npublic String test10(@ModelAttribute(\"user\") User user){\n  System.out.println(user);\n  return \"success\";\n}\n```\n\n* 注意：当ModelAttribute被应用在形参上，但是ModelAttribute中没有对应的数据对象此时就会验证SessionAttributes注解。\n  * 如果当前控制类没有此注解，则通过反射创建空的对象。\n  * 如果当前控制类有此注解，此时又分为两种情况：\n    * 如果SessionAttributes中有此对象数据，则赋给形参，最后再将形参添加到ModelAttribute中。\n    * 如果SessionAttributes中没有此对象数据，则抛异常：**HttpSessionRequiredException**\n* 控制方法的返回值上：将返回值的数据存储到ModelAttribute中，如果原先有，就覆盖。\n\n```java\n@RequestMapping(\"/test10\")\npublic @ModelAttribute(\"user\") User test10(){\n  User user = new User();\n  System.out.println(user);\n  return user;\n}\n```\n\n# 第六章 视图及视图解析器\n\n* 请求处理方法执行完成后，最终返回一个 ModelAndView对象。对于那些返回 String，View 或 ModeMap 等类型的处理方法，Spring MVC 也会在内部将它们装配成一个ModelAndView 对象，它包含了逻辑名和模型对象的视图。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210316173330.png)\n\n* Spring MVC 借助视图解析器（ViewResolver）得到最终 的视图对象（View），最终的视图可以是 JSP ，也可能是Excel、JFreeChart 等各种表现形式的视图。\n* 对于最终究竟采取何种视图对象对模型数据进行渲染，处理器(controller)并不关心，处理器工作重点聚焦在生产模型数据的工作上，从而实现 MVC 的充分解耦。\n\n## 6.1 视图\n\n* 视图的作用是渲染模型数据，将模型里的数据以某种形式呈现给客户。\n\n* 为了实现视图模型和具体实现技术的解耦，Spring 在org.springframework.web.servlet 包中定义了一个高度抽象的 View接口。\n\n* 视图对象由视图解析器负责实例化。由于视图是无状态的，所以他们不会有线程安全的问题。\n\n* 常见的视图实现类\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210316173700.png)\n\n## 6.2 视图解析器\n\n* SpringMVC 为逻辑视图名的解析提供了不同的策略，可以在 Spring WEB 上下文中配置一种或多种解析策略，并指定他们之间的先后顺序。每一种映射策略对应一个具体的视图解析器实现类。 \n* 视图解析器的作用比较单一：将逻辑视图解析为一个具体的视图对象。\n* 所有的视图解析器都必须实现 ViewResolver 接口。\n\n* 常用的视图解析器实现类：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210316173913.png)\n\n* 程序员可以选择一种视图解析器或混用多种视图解析器。\n\n* 每个视图解析器都实现了 Ordered 接口并开放出一个 order 属性，可以通过 order 属性指定解析器的优先顺序，order 越小优先级越高。 \n\n* SpringMVC 会按视图解析器顺序的优先顺序对逻辑视图名进行解析，直到解析成功并返回视图对象，否则将抛出 ServletException 异 常。\n\n**InternalResourceViewResolver**\n\n* JSP 是最常见的视图技术，可以使用InternalResourceViewResolver 作为视图解析器：\n\n  ```xml\n  <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n    <property name=\"prefix\" value=\"/WEB-INF/views/\"></property>\n    <property name=\"suffix\" value=\".jsp\"></property>\n  </bean>\n  ```\n\n* 若项目中使用了 JSTL，则 SpringMVC 会自动把视图由InternalResourceView 转为 JstlView。配置不需要变。\n\n* 若使用 JSTL 的 fmt 标签则需要在 SpringMVC 的配置文件中配置国际化资源文件\n\n  ```xml\n  <!--配置国际化资源-->\n  <bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\">\n    <property name=\"basename\" value=\"i18n\"></property>\n  </bean>\n  ```\n\n* 若希望直接响应通过 SpringMVC 渲染的页面，可以使用 mvc:view-controller 标签实现\n\n  ```xml\n  <!--配置直接转发的页面：即直接访问/success就可以访问success页面，不需要经过controller层\n      缺点：当配置了此配置后，success页面再通过controller层访问时会报错。\n      解决方法是：配置mvc:annotation-driven标签-->\n  <mvc:view-controller path=\"/success\" view-name=\"success\"/>\n  <mvc:annotation-driven></mvc:annotation-driven>\n  ```\n\n**自定义视图解析器**\n\n* 自定义视图\n\n```java\n//把此视图放到IOC容器中\n@Component\npublic class MyView implements View {\n  @Override\n  public String getContentType() {\n    //返回视图类型。\n    return \"text/html\";\n  }\n  @Override\n  public void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) throws Exception {\n    //渲染视图\n    response.getWriter().append(\"<h1> hello world myView </h1>\");\n  }\n}\n```\n\n* 配置视图解析器\n\n```xml\n<!--配置BeanNameViewResolver视图解析器。用于解析指定视图名称的视图。从IOC中获取视图实例-->\n<bean class=\"org.springframework.web.servlet.view.BeanNameViewResolver\">\n  <!--order为视图的优先级。值越小视图解析器的优先级就越高，越先解析-->\n  <property name=\"order\" value=\"100\"></property>\n</bean>\n```\n\n* 访问方式\n\n```java\n@RequestMapping(\"/testview\")\npublic String test1(){\n  System.out.println(\"asdas\");\n  //指明要返回到哪个视图。首字母小写\n  return \"myView\";\n}\n```\n\n**Excel视图**\n\n* 若希望使用 Excel 展示数据列表，仅需要扩展SpringMVC 提供的 AbstractExcelView 或AbstractJExcel View 即可。实现 buildExcelDocument() 方法，在方法中使用模型数据对象构建 Excel 文档就可以了。\n* AbstractExcelView 基于 POI API，而AbstractJExcelView 是基于 JExcelAPI 的。\n* 视图对象需要配置 IOC 容器中的一个 Bean，使用BeanNameViewResolver 作为视图解析器即可。\n* 若希望直接在浏览器中直接下载 Excel 文档，则可以设置响应头 Content-Disposition 的值为attachment;filename=xxx.xls。\n\n## 6.3 重定向和转发\n\n* 一般情况下，控制器方法返回字符串类型的值会被当成逻辑视图名处理 。\n* 如果返回的字符串中带 forward: 或 redirect: 前缀 时，SpringMVC 会对他们进行特殊处理：将 forward: 和\n  redirect: 当成指示符，其后的字符串作为 URL 来处理 。\n  * return = \"redirect:/success.jsp\"：会完成一个到 success.jsp 的重定向的操作。\n  * return = \"forward:success.jsp\"：会完成一个到 success.jsp 的转发操作。\n\n# 第七章 表单标签和静态资源的处理\n\n* 通过 SpringMVC 的表单标签可以实现将模型数据中的属性和 HTML 表单元素相绑定，以实现表单数据更便捷编辑和表单值的回显。\n\n## 7.1 \\<form:form> 标签\n\n* 一般情况下，通过 GET 请求获取表单页面，而通过POST 请求提交表单页面，因此获取表单页面和提交表单 页面的 URL 是相同的。只要满足该最佳条件的契约，\\<form:form> 标签就无需通过 action 属性指定表单提交的 URL\n\n* 可以通过 modelAttribute 属性指定绑定的模型属性，若没有指定该属性，则默认从 request 域对象中读取command 的表单 bean，如果该属性值也不存在，则会 发生错误。\n\n* SpringMVC 提供了多个表单组件标签，如<form:input/>、<form:select/> 等，用以绑定表单字段的属性值，它们的共有属性如下：\n\n  * – path：表单字段，对应 html 元素的 name 属性，支持级联属性\n  * – htmlEscape：是否对表单值的 HTML 特殊字符进行转换，默认值为 true\n  * – cssClass：表单组件对应的 CSS 样式类名 \n  * – cssErrorClass：表单组件的数据存在错误时，采取的 CSS 样式\n\n* form:input、form:password、form:hidden、form:textarea：对应 HTML 表单的 text、password、hidden、textarea标签\n\n* form:radiobutton：单选框组件标签，当表单 bean 对应的属性值和 value 值相等时，单选框被选中 \n\n* form:radiobuttons：单选框组标签，用于构造多个单选框\n\n  * – items：可以是一个 List、String[] 或 Map\n  * – itemValue：指定 radio 的 value 值。可以是集合中 bean 的一个属性值 \n  * – itemLabel：指定 radio 的 label 值 \n  * – delimiter：多个单选框可以通过 delimiter 指定分隔符\n\n* form:checkbox：复选框组件。用于构造单个复选框 • form:checkboxs：用于构造多个复选框。使用方式同form:radiobuttons 标签\n\n* form:select：用于构造下拉框组件。使用方式同form:radiobuttons 标签\n\n* form:option：下拉框选项组件标签。使用方式同form:radiobuttons 标签\n\n* form:errors：显示表单组件或数据校验所对应的错误\n\n  *  – <form:errors path= “ *” /> ：显示表单所有的错误\n  * – <form:errors path= “ user*” /> ：显示所有以 user 为前缀的属性对应\n    的错误\n  * – <form:errors path= “ username” /> ：显示特定表单对象属性的错误\n\n* 示例\n\n  ```jsp\n  <%@page import=\"java.util.HashMap\"%>\n  <%@page import=\"java.util.Map\"%>\n  <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n      pageEncoding=\"UTF-8\"%>\n  <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %>\n  <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n  <body>\n  \t<!--  \n  \t\t1. WHY 使用 form 标签呢 ?\n  \t\t可以更快速的开发出表单页面, 而且可以更方便的进行表单值的回显\n  \t\t2. 注意:\n  \t\t可以通过 modelAttribute 属性指定绑定的模型属性,\n  \t\t若没有指定该属性，则默认从 request 域对象中读取 command 的表单 bean\n  \t\t如果该属性值也不存在，则会发生错误。\n  \t-->\n  \t<br><br>\n  \t<form:form action=\"${pageContext.request.contextPath }/emp\" method=\"POST\" \n  \t\tmodelAttribute=\"employee\">\n  \t\t<form:errors path=\"*\"></form:errors>\n  \t\t<br>\n  \t\t<c:if test=\"${employee.id == null }\">\n  \t\t\t<!-- path 属性对应 html 表单标签的 name 属性值 -->\n  \t\t\tLastName: <form:input path=\"lastName\"/>\n  \t\t\t<form:errors path=\"lastName\"></form:errors>\n  \t\t</c:if>\n  \t\t<c:if test=\"${employee.id != null }\">\n  \t\t\t<form:hidden path=\"id\"/>\n  \t\t\t<input type=\"hidden\" name=\"_method\" value=\"PUT\"/>\n  \t\t\t<%-- 对于 _method 不能使用 form:hidden 标签, 因为 modelAttribute 对应的 bean 中没有 _method 这个属性 --%>\n  \t\t\t<%-- \n  \t\t\t<form:hidden path=\"_method\" value=\"PUT\"/>\n  \t\t\t--%>\n  \t\t</c:if>\n  \t\t\n  \t\t<br>\n  \t\tEmail: <form:input path=\"email\"/>\n  \t\t<form:errors path=\"email\"></form:errors>\n  \t\t<br>\n  \t\t<% \n  \t\t\tMap<String, String> genders = new HashMap();\n  \t\t\tgenders.put(\"1\", \"Male\");\n  \t\t\tgenders.put(\"0\", \"Female\");\n  \t\t\t\n  \t\t\trequest.setAttribute(\"genders\", genders);\n  \t\t%>\n  \t\tGender: \n  \t\t<br>\n  \t\t<form:radiobuttons path=\"gender\" items=\"${genders }\" delimiter=\"<br>\"/>\n  \t\t<br>\n  \t\tDepartment: <form:select path=\"department.id\" \n  \t\t\titems=\"${departments }\" itemLabel=\"departmentName\" itemValue=\"id\"></form:select>\n  \t\t<br>\n  \t\t<!--  \n  \t\t\t1. 数据类型转换\n  \t\t\t2. 数据类型格式化\n  \t\t\t3. 数据校验. \n  \t\t\t1). 如何校验 ? 注解 ?\n  \t\t\t①. 使用 JSR 303 验证标准\n  \t\t\t②. 加入 hibernate validator 验证框架的 jar 包\n  \t\t\t③. 在 SpringMVC 配置文件中添加 <mvc:annotation-driven />\n  \t\t\t④. 需要在 bean 的属性上添加对应的注解\n  \t\t\t⑤. 在目标方法 bean 类型的前面添加 @Valid 注解\n  \t\t\t2). 验证出错转向到哪一个页面 ?\n  \t\t\t注意: 需校验的 Bean 对象和其绑定结果对象或错误对象时成对出现的，它们之间不允许声明其他的入参\n  \t\t\t3). 错误消息 ? 如何显示, 如何把错误消息进行国际化\n  \t\t-->\n  \t\tBirth: <form:input path=\"birth\"/>\n  \t\t<form:errors path=\"birth\"></form:errors>\n  \t\t<br>\n  \t\tSalary: <form:input path=\"salary\"/>\n  \t\t<br>\n  \t\t<input type=\"submit\" value=\"Submit\"/>\n  \t</form:form>\n  </body>\n  </html>\n  ```\n\n## 7.2 处理静态资源\n\n* 优雅的 REST 风格的资源URL 不希望带 .html 或 .do 等后缀 \n\n* 若将 DispatcherServlet 请求映射配置为 /，则 Spring MVC 将捕获WEB 容器的所有请求，包括静态资源的请求， SpringMVC 会将他们当成一个普通请求处理，因找不到对应处理器将导致错误。 \n\n* 可以在 SpringMVC 的配置文件中配置 \\<mvc:default-servlet-handler/> 的方式解决静态资源的问题： \n\n  *  \\<mvc:default-servlet-handler/> 将在 SpringMVC 上下文中定义一个DefaultServletHttpRequestHandler，它会对进入 DispatcherServlet 的 请求进行筛查，如果发现是没有经过映射的请求，就将该请求交由 WEB 应用服务器默认的 Servlet 处理，如果不是静态资源的请求，才由DispatcherServlet 继续处理 \n  * 一般 WEB 应用服务器默认的 Servlet 的名称都是 default。若所使用的WEB 服务器的默认 Servlet 名称不是 default，则需要通过 default-servlet-name 属性显式指定\n\n* 操作\n\n  * 注意js文件要位于：项目/web/scripts下\n\n  ```xml\n  <!--springmvc对静态资源的处理-->\n  <mvc:default-servlet-handler></mvc:default-servlet-handler>\n  <mvc:annotation-driven/>\n  <!--<script type=\"text/javascript\" src=\"scripts/jquery-1.9.1.min.js\"></script>-->\n  ```\n\n# 第八章 数据的转换，格式化，校验\n\n## 8.1 数据绑定流程\n\n* 1.Spring MVC 主框架将 ServletRequest 对象及目标方法的入参实例传递给 WebDataBinderFactory 实例，以创 建 DataBinder 实例对象 。\n\n* 2.DataBinder 调用装配在 Spring MVC 上下文中的ConversionService 组件进行数据类型转换、数据格式化工作。将 Servlet 中的请求信息填充到入参对象中。\n\n* 3.调用 Validator 组件对已经绑定了请求消息的入参对象 进行数据合法性校验，并最终生成数据绑定结果BindingData 对象 。\n\n* 4.Spring MVC 抽取 BindingResult 中的入参对象和校验错误对象，将它们赋给处理方法的响应入参。\n\n* Spring MVC 通过反射机制对目标处理方法进行解析，将请求消息绑定到处理方法的入参中。数据绑定的核心部件是DataBinder，运行机制如下：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210318134325.png)\n\n## 8.2 数据转换\n\n* Spring MVC 上下文中内建了很多转换器，可完成大多数 Java 类型的转换工作。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210317205109.png)\n\n* 自动以类型转换器\n\n  * ConversionService 是 Spring 类型转换体系的核心接口。\n  * 可以利用 ConversionServiceFactoryBean 在 Spring 的 IOC 容器中定义一个 ConversionService。Spring 将自动识别出IOC 容器中的 ConversionService，并在 Bean 属性配置及Spring MVC 处理方法入参绑定等场合使用它进行数据的转换\n  * 可通过 ConversionServiceFactoryBean 的 converters 属性注册自定义的类型转换器\n  * Spring 定义了 3 种类型的转换器接口，实现任意一个转换器接口都可以作为自定义转换器注册到ConversionServiceFactroyBean 中：\n    * Converter<S,T>：将 S 类型对象转为 T 类型对象 。\n    * ConverterFactory：将相同系列多个 “同质” Converter 封装在一起。如果希望将一种类型的对象转换为另一种类型及其子类的对象（例如将 String 转换为 Number 及 Number 子类 （Integer、Long、Double 等）对象）可使用该转换器工厂类 。\n    * GenericConverter：会根据源类对象及目标类对象所在的宿主类 中的上下文信息进行类型转换。\n\n* 使用方式：\n\n  * 例如前端传递lastname-email-gender-department.id格式的字符串，例如GG\\-gg@atguigu.com-0-105\n  * 转化到后台时为Employee对象。\n  * 配置文件\n\n  ```xml\n  <mvc:annotation-driven conversion-service=\"conversionService2\"></mvc:annotation-driven>\n  <!--配置ConversionService-->\n  <bean class=\"org.springframework.context.support.ConversionServiceFactoryBean\" id=\"conversionService2\">\n    <property name=\"converters\">\n      <set>\n        <ref bean=\"employeeConverter\"></ref>\n      </set>\n    </property>\n  </bean>\n  ```\n\n  * 自定义的转换器\n\n  ```java\n  @Component\n  public class EmployeeConverter implements Converter<String,Employee> {\n    @Override\n    public Employee convert(String s) {\n      Employee employee = null;\n      if (s != null){\n        String[] values = s.split(\"-\");\n        if (values != null && values.length == 4){\n          String lastName = values[0];\n          String email = values[1];\n          Integer gender = Integer.parseInt(values[2]);\n          Department department = new Department();\n          department.setId(Integer.parseInt(values[3]));\n          employee = new Employee(null,lastName,email, gender,department);\n        }\n      }\n      return employee;\n    }\n  }\n  ```\n\n* 其他代码\n\n  ```java\n  /*\n  <form action=\"${pageContext.request.contextPath}/testconverter\" >\n    输入：<input type=\"text\" name=\"employee\">\n    <input type=\"submit\" value=\"提交\">\n  </form>\n  */\n  @RequestMapping(\"/testconverter\")\n  public String testConcerter(@RequestParam(\"employee\") Employee employee){\n    System.out.println(employee.toString());\n    return \"redirect:/emps\";\n  }\n  ```\n\n## 8.3 关于\\<mvc:annotation-driven/>配置\n\n* <mvc:annotation-driven /> 会自动注 册RequestMappingHandlerMapping、RequestMappingHandlerAdapter 与ExceptionHandlerExceptionResolver 三个bean。 \n* 还将提供以下支持：\n  * 支持使用 ConversionService 实例对表单参数进行类型转换\n  * 支持使用 @NumberFormat annotation、@DateTimeFormat注解完成数据类型的格式化\n  * 支持使用 @Valid 注解对 JavaBean 实例进行 JSR 303 验证\n  * 支持使用 @RequestBody 和 @ResponseBody 注解\n* **实际开发中都会配置这个标签。**\n* 目前使用此配置的时候\n  * 第一：配置\\<mvc:view-controller/>时需要添加此配置，保证页面能正常跳转。\n  * 第二：配置\\<mvc:default-servlet-handler/>时需要添加此配置，保证静态资源能正常使用。\n  * 第三：使用自定义类型转换器时，需要添加此配置，以将自定义类型转换器添加到系统中。\n\n## 8.4 @InitBinder注解\n\n*  @InitBinder 标识的方法，可以对 WebDataBinder 对 象进行初始化。WebDataBinder 是 DataBinder 的子类，用于完成由**表单字段到 JavaBean 属性**的绑定 。\n  * @InitBinder方法不能有返回值，它必须声明为void。 \n  * @InitBinder方法的参数通常是是 WebDataBinder。\n* 示例\n\n```java\n/**\n   * 作用：当请求的参数绑定为Employee类的对象时，对于lastName属性不绑定\n   * @param webDataBinder\n   */\n@InitBinder\npublic void initBinder(WebDataBinder webDataBinder){\n  webDataBinder.setDisallowedFields(\"lastName\");\n}\n```\n\n## 8.5 数据格式化\n\n* 对属性对象的输入/输出进行格式化，从其本质上讲依然属于 “类型转换” 的范畴。\n* Spring 在格式化模块中定义了一个实现ConversionService 接口的FormattingConversionService 实现类，该实现类扩展 了 GenericConversionService，因此它既具有类型转换的功能，又具有格式化的功能。\n* FormattingConversionService 拥有一个FormattingConversionServiceFactroyBean 工厂类，后者用于在 Spring 上下文中构造前者。\n* FormattingConversionServiceFactroyBean 内部已经注册了 : \n  * NumberFormatAnnotationFormatterFactroy：支持对数字类型的属性使用 @NumberFormat 注解\n  * JodaDateTimeFormatAnnotationFormatterFactroy：支持对日期类型的属性使用 @DateTimeFormat 注解\n* 装配了 FormattingConversionServiceFactroyBean 后，就可以在 Spring MVC 入参绑定及模型数据输出时使用注解驱动了。\\<mvc:annotation-driven/> 默认创建的ConversionService 实例即为FormattingConversionServiceFactroyBean。\n* 注意：\n  * 当使用以下注解时，<mvc:annotation-driven />注解中不能添加任何属性，比如自定义的类型转换器。\n  * 如果一定添加自定义类型转换器。那么ConversionService的class要由ConversionServiceFactoryBean变成FormattingConversionServiceFactroyBean 。\n\n**日期格式化**\n\n* @DateTimeFormat 注解可对java.util.Date、java.util.Calendar、java.long.Long 时间类型进行标注： \n  * pattern 属性：类型为字符串。指定解析/格式化字段数据的模式，如：”yyyy-MM-dd hh:mm:ss” 。\n  *  iso 属性：类型为 DateTimeFormat.ISO。指定解析/格式化字段数据的ISO模式，包括四种：ISO.NONE（不使用） ，默 认ISO.DATE(yyyy-MM-dd) 、ISO.TIME(hh:mm:ss.SSSZ)、ISO.DATE_TIME(yyyy-MM-dd hh:mm:ss.SSSZ) \n  * style 属性：字符串类型。通过样式指定日期时间的格式，由两位字符组成，第一位表示日期的格式，第二位表示时间的格式：S：短日期/时间格式、M：中日期/时间格式、L：长日期/时间格式、F：完整日期/时间格式、-：忽略日期或时间格式。\n* 示例\n\n```java\n/*\n页面代码为\nBirth：<form:input path=\"birth\" />\n输入：1992-1-1\n*/\n@DateTimeFormat(pattern=\"yyyy-MM-dd\")\nprivate Date birth;\n```\n\n**数值格式化**\n\n* @NumberFormat 可对类似数字类型的属性进行标 注，它拥有两个**互斥**的属性：\n  * style：类型为 NumberFormat.Style。用于指定样式类型，包括三种：Style.NUMBER（正常数字类型）、Style.CURRENCY（货币类型）、 Style.PERCENT（百分数类型）\n  * pattern：类型为 String，自定义样式，如patter=\"#,###\"；\n* 示例\n\n```java\n/*\n页面代码为\nSalary：<form:input path=\"salary\"/>\n输入：1,123.5\n*/\n@NumberFormat(pattern=\"#,###.#\")\nprivate Float salary;\n```\n\n## 8.6 数据校验\n\n**JSR 303**\n\n* JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 中 .\n\n* JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对 Bean 进行验证。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210317213832.png)\n\n**Hibernate Validator 扩展注解**\n\n* Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210317213909.png)\n\n**Spring MVC数据校验**\n\n* Spring 4.0 拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。\n\n* Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在 Spring MVC 中，可直接通过注解驱动的方式进行数据校验 。\n\n* Spring 的 LocalValidatorFactroyBean 既实现了 Spring 的Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在 Spring 容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean 中。\n\n* Spring 本身并没有提供 JSR303 的实现，所以必须将JSR303 的实现者的 jar 包放到类路径下。\n\n  * hibernate-validator-5.0.0.CR2.jar：[下载](https://plumriver.lanzous.com/iAB8On1jf1e)\n  * hibernate-validator-annotation-processor-5.0.0.CR2.jar：https://plumriver.lanzous.com/iyTKfn1jf2f\n\n* \\<mvc:annotation-driven/> 会默认装配好一个LocalValidatorFactoryBean，通过在处理方法的入参上标 注 @valid 注解即可让 Spring MVC 在完成数据定后执行数据校验的工作。\n\n* 在已经标注了 JSR303 注解的表单/命令对象前标注一个@Valid，Spring MVC 框架在将请求参数绑定到该入参对象后，就会调用校验框架根据注解声明的校验规则实施校验 。\n\n* 示例\n\n  ```java\n  //实体类\n  @NotEmpty\n  private String lastName;\n  @Email\n  private String email;\n  //控制层方法，添加@Valid注解\n  @RequestMapping(value = \"emp\",method = RequestMethod.POST)\n  public String save(@Valid Employee employee){\n    employeeDao.save(employee);\n    System.out.println(\"asdasd\");\n    return \"redirect:/emps\";\n  }\n  ```\n\n* Spring MVC 是通过对处理方法签名的规约来保存校验结果的：前一个表单/命令对象的校验结果保存到随后的入参中，这个保存校验结果的入参必须是 BindingResult 或Errors 类型，这两个类都位于org.springframework.validation 包中。\n\n* <font color=\"red\">需校验的 Bean 对象和其绑定结果对象或错误对象时成对出现的，它们之间不允许声明其他的入参。</font>\n\n* Errors 接口提供了获取错误信息的方法，如 getErrorCount() 或getFieldErrors(String field) \n\n* BindingResult 扩展了 Errors 接口\n\n```java\n@RequestMapping(value = \"emp\",method = RequestMethod.POST)\npublic String save(@Valid Employee employee, BindingResult result){\n  if (result.getErrorCount() > 0){\n    System.out.println(\"出错了\");\n    for (FieldError fieldError : result.getFieldErrors()) {\n      System.out.println(fieldError.getField() + \" : \" + fieldError.getDefaultMessage());\n    }\n  }\n}\n```\n\n* 在表单/命令对象类的属性中标注校验注解，在处理方法对 应的入参前添加 @Valid，Spring MVC 就会实施校验并将校验结果保存在被校验入参对象之后的 BindingResult 或Errors 入参中。\n* 常用方法：\n  * – FieldError getFieldError(String field)\n  * – List\\<FieldError> getFieldErrors()\n  * – Object getFieldValue(String field)\n  * – Int getErrorCount()\n\n**在页面上显示错误**\n\n* Spring MVC 除了会将表单/命令对象的校验结果保存到对 应的 BindingResult 或 Errors 对象中外，还会将所有校验 结果保存到 “隐含模型” \n* 即使处理方法的签名中没有对应于表单/命令对象的结果入参，校验结果也会保存在 “隐含对象” 中。\n* 隐含模型中的所有数据最终将通过 HttpServletRequest 的属性列表暴露给 JSP 视图对象，因此在 JSP 中可以获取错误信息\n* 在 JSP 页面上可通过 <form:errors path=“userName”> 显示错误消息。\n\n```jap\nEmail: <form:input path=\"email\"/>\n<form:errors path=\"email\"></form:errors>\n```\n\n**提示消息的国际化**\n\n* 每个属性在数据绑定和数据校验发生错误时，都会生成一个对应的 FieldError 对象。\n* 当一个属性校验失败后，校验框架会为该属性生成 4 个消息代码，这些代码以校验注解类名为前缀，结合modleAttribute、属性名及属性类型名生成多个对应的消息代码：例如 User 类中的 password 属性标准了一个 @Pattern 注解，当该属性值不满足 @Pattern 所定义的规则时, 就会产生以下 4 个错误代码： \n  * – Pattern.user.password\n  * – Pattern.password\n  * – Pattern.java.lang.String\n  * – Pattern\n* 当使用 Spring MVC 标签显示错误消息时， Spring MVC 会查看WEB 上下文是否装配了对应的国际化消息，如果没有，则显示默认 的错误消息，否则使用国际化消息。\n* 若数据类型转换或数据格式转换时发生错误，或该有的参数不存在，或调用处理方法时发生错误，都会在隐含模型中创建错误消息。其错误代码前缀说明如下：\n  * – required：必要的参数不存在。如 @RequiredParam(“param1”) 标注了一个入参，但是该参数不存在\n  * – typeMismatch：在数据绑定时，发生数据类型不匹配的问题\n  * – methodInvocation：Spring MVC 在调用处理方法时发生了错误\n* 注册国际化资源文件\n\n```xml\n<!--配置国际化资源-->\n<bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\">\n  <property name=\"basename\" value=\"i18n\"></property>\n</bean>\n```\n\n* 文件\n\n```properties\nNotEmpty.employee.lastName=填写的LastName为空\nEmail..employee.email=填写的Email不符合邮箱格式\n\ntypeMismatch.employee.birth=填写的Birth不是一个日期\n```\n\n# 第九章 JSON\n\n* 使用方式：\n\n  * 第一步：添加jsr包\n    * jackson-core-2.1.5.jar：[下载](https://plumriver.lanzous.com/ilAHjn1w51c)\n    * jackson-databind-2.1.5.jar：[下载](https://plumriver.lanzous.com/il7Mpn1w52d)\n    * jackson-annotations-2.1.5.jar：[下载](https://plumriver.lanzous.com/iOZLEn1w4za)\n  * 第二步：编写目标方法，使其返回JSON对应的对象和集合。\n  * 第三步：再目标方法上添加@ResponseBody注解\n\n  ```java\n  //@ResponseBody表示将返回值转换为Json格式传递到前页面。\n  //转换后如下：{\"id\":1001,\"lastName\":\"E-AA\",\"email\":\"aa@163.com\",\"gender\":1,\"department\":{\"id\":101,\"departmentName\":\"D-AA\"},\"birth\":null,\"salary\":null}\n  @ResponseBody\n  @RequestMapping(\"testJson\")\n  public Employee testJson(){\n    Employee employee = employeeDao.get(1);\n    return  employee;\n  }\n  ```\n\n* HttpMessageConverter\\<T> 是 Spring3.0 新添加的一个接口，负责将请求信息转换为一个对象（类型为 T），将对象（类型为 T）输出为响应信息\n\n* HttpMessageConverter\\<T>接口定义的方法： \n\n  * Boolean canRead(Class<?> clazz,MediaType mediaType): 指定转换器可以读取的对象类型，即转换器是否可将请求信息转换为 clazz 类型的对象，同时指定支持 MIME 类型(text/html,applaiction/json等) \n  * Boolean canWrite(Class<?> clazz,MediaType mediaType):指定转换器是否可将 clazz 类型的对象写到响应流中，响应流支持的媒体类型 在MediaType 中定义。 \n  * LIst\\<MediaType> getSupportMediaTypes()：该转换器支持的媒体类型。\n  * T read(Class<? extends T> clazz,HttpInputMessage inputMessage)： 将请求信息流转换为 T 类型的对象。\n  * void write(T t,MediaType contnetType,HttpOutputMessgaeoutputMessage):将T类型的对象写到响应流中，同时指定相应的媒体类 型为 contentType。\n\n* HttpMessageConverter\\<T> 的实现原理：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210318100613.png)\n\n* HttpMessageConverter\\<T> 的实现类：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210318100617.png)\n\n* DispatcherServlet 默认装配RequestMappingHandlerAdapter ，而RequestMappingHandlerAdapter在加入jackson jar包后，会装配jackson jar包中的转换器。\n\n* 使用 HttpMessageConverter\\<T> 将请求信息转化并绑定到处理方法的入参中或将响应结果转为对应类型的响应信息，Spring 提供了两种途径： \n\n  * 使用 @RequestBody / @ResponseBody 对处理方法进行标注 。\n  * 使用 HttpEntity\\<T> / ResponseEntity\\<T> 作为处理方法的入参或返回值。\n\n* 当控制器处理方法使用到 @RequestBody/@ResponseBody 或HttpEntity\\<T>/ResponseEntity\\<T> 时, Spring 首先根据请求头或响应头的Accept 属性选择匹配的 HttpMessageConverter, 进而根据参数类型或泛型类型的过滤得到匹配的 HttpMessageConverter, 若找不到可用的HttpMessageConverter 将报错。\n\n* @RequestBody 和 @ResponseBody 不需要成对出现。\n\n* 示例：\n\n```java\n@ResponseBody\n@RequestMapping(\"/testJson\")\npublic Employee testJson(){\n  Employee employee = employeeDao.get(1001);\n  System.out.println(employee);\n  return employee;\n}\n@RequestMapping(\"/testJson2\")\npublic String  testJson2(@RequestBody Employee employee){\n  return \"\";\n}\n@RequestMapping(\"/testJson3\")\npublic String  testJson3(HttpEntity<Employee> entity){\n  //获取请求头的内容长度\n  System.out.println(entity.getHeaders().getContentLength());\n  return \"\";\n}\n@RequestMapping(\"/testJson4\")\npublic ResponseEntity<byte[]> testJson4() throws IOException {\n  Resource resource = new ClassPathResource(\"/abc.jpg\");\n  byte[] fileDate = FileCopyUtils.copyToByteArray(resource.getInputStream());\n  ResponseEntity<byte[]> responseEntity = new ResponseEntity<byte[]>(fileDate, HttpStatus.OK);\n  return responseEntity;\n}\n```\n\n* 总结：一般情况下我们只会使用@ResponseBody和Ajax进行协调使用。\n\n# 第十章 国际化处理\n\n* 默认情况下，SpringMVC 根据 Accept-Language 参数判断客户端的本地化类型。\n\n* 当接受到请求时，SpringMVC 会在上下文中查找一个本地化解析器（LocalResolver），找到后使用它获取请求 所对应的本地化类型信息。\n\n* SpringMVC 还允许装配一个动态更改本地化类型的拦截 器，这样通过指定一个请求参数就可以控制单个请求的本地化类型。\n\n* AcceptHeaderLocaleResolver：根据 HTTP 请求头的Accept-Language 参数确定本地化类型，如果没有显式定义本地化解析器， SpringMVC 使用该解析器。\n\n  * CookieLocaleResolver：根据指定的 Cookie 值确定本地化类 型 \n  * SessionLocaleResolver：根据 Session 中特定的属性确定本地化类型 \n  * LocaleChangeInterceptor：从请求参数中获取本次请求对应的本地化类型\n\n* 注意：访问的第一个index.jsp中不能使用国际化，转发后的页面才可以使用国际化配置。\n\n* 使用步骤：\n\n  * 第一步：在springmvc配置文件中配置国际化资源包\n\n  ```xml\n  <!--配置国际化资源-->\n  <bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\">\n    <property name=\"basename\" value=\"i18n\"></property>\n  </bean>\n  ```\n\n  * 第二步：编写国际化资源\n\n  ```properties\n  # i18n.properties 默认加载的国际化资源文件\n  i18n.username=username\n  i18n.password=password\n  # i18n_en_US.properties 英文的国际化资源文件\n  i18n.username=username\n  i18n.password=password\n  # i18n_zh_CN.properties 中文的国际化资源文件\n  i18n.username=用户\n  i18n.password=密码\n  ```\n\n  * 第三步：前端页面引用\n\n  ```jsp\n  <%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %>\n  <%--fmt标签需要引入--%>\n  <fmt:message key=\"i18n.username\" ></fmt:message>\n  <br>\n  <fmt:message key=\"i18n.password\"></fmt:message>\n  ```\n\n* 实现页面跳转时在控制层获取国际化资源中i18n.username对应的信息\n\n```java\n@Autowired\nprivate ResourceBundleMessageSource messageSource;\n@RequestMapping(\"/i18n\")\npublic String testI18n(Locale locale){\n  String val = messageSource.getMessage(\"i18n.user\",null,locale);\n  System.out.println(val);\n  return \"i18n\";\n}\n```\n\n* 实现通过超链接更改页面语言，而不用通过浏览器设置。\n\n  * 第一步：在springmvc配置文件中配置国际化的解析器和拦截器\n\n  ```xml\n  <!--配置解析器-->\n  <bean class=\"org.springframework.web.servlet.i18n.SessionLocaleResolver\" id=\"localeResolver\"></bean>\n  <!--配置拦截器-->\n  <mvc:interceptors>\n    <bean class=\"org.springframework.web.servlet.i18n.LocaleChangeInterceptor\"></bean>\n  </mvc:interceptors>\n  ```\n\n  * 第二步：在超链接上添加local属性值。\n\n  ```jsp\n  <!--i18n表示要访问的页面请求-->\n  <a href=\"i18n?locale=zh_CN\">中文</a>\n  <br><br>\n  <a href=\"i18n?locale=en_US\">英文</a>\n  ```\n\n# 第十一章 文件的上传\n\n* Spring MVC 为文件上传提供了直接的支持，这种支持是通过即插即用的 MultipartResolver 实现的。Spring 用Jakarta Commons FileUpload 技术实现了一个MultipartResolver 实现类：CommonsMultipartResovler\n\n* Spring MVC 上下文中默认没有装配 MultipartResovler，因此默认情况下不能处理文件的上传工作，如果想使用 Spring 的文件上传功能，需现在配置文件中中配置 MultipartResolver。\n\n  ```xml\n  <!--配置文件上传-->\n  <bean class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\" id=\"multipartResolver\">\n    <property name=\"defaultEncoding\" value=\"UTF-8\">\n    </property>\n    <!--以字节kb为单位-->\n    <property name=\"maxUploadSize\" value=\"1024000\"></property>\n  </bean>\n  ```\n\n* defaultEncoding: 必须和用户 JSP 的 pageEncoding 属性一致，以便正确解析表单的内容\n\n* 为了让 CommonsMultipartResovler 正确工作，必须先 将 Jakarta Commons FileUpload 及 Jakarta Commons io的类包添加到类路径下。\n\n  * commons-fileupload-1.2.1.jar：[下载](https://plumriver.lanzous.com/iK0wcm3uhob)\n  * commons-io-2.0.jar：[下载](https://plumriver.lanzous.com/isPGVm3uqkb)\n\n* 示例：\n\n  * 前端代码\n\n  ```jsp\n  <form method=\"post\" action=\"testFileload\" enctype=\"multipart/form-data\">\n    file：<input type=\"file\" name=\"file\">\n    <input type=\"submit\" value=\"上传\">\n  </form>\n  ```\n\n  * 控制层处理方法\n\n  ```java\n  @RequestMapping(\"/testFileload\")\n  public void testFileload(@RequestParam(\"file\")MultipartFile file) throws IOException {\n    InputStream inputStream = file.getInputStream();\n    file.getName();\n  }\n  ```\n\n# 第十二章 拦截器\n\n* Spring MVC也可以使用拦截器对请求进行拦截处理，用户可以自定义拦截器来实现特定的功能，自定义的拦截器必须实现HandlerInterceptor接口\n\n  * preHandle()：这个方法在业务处理器处理请求之前被调用，在该方法中对用户请求 request 进行处理。\n    * 如果程序员决定该拦截器对 请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去进行处理，则返回true；\n    * 如果程序员决定不需要再调用其他的组件 去处理请求，则返回false。 \n  * postHandle()：这个方法在业务处理器处理完请求后，但是DispatcherServlet 向客户端返回响应前被调用，在该方法中对 用户请求request进行处理。 \n  * afterCompletion()：这个方法在 DispatcherServlet 完全处理完请求后被调用，可以在该方法中进行一些资源清理的操作。\n\n* 示例\n\n  * 自定义拦截器\n\n  ```java\n  public class FirstInterceptor implements HandlerInterceptor {\n    @Override\n    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {\n      System.out.println(\"接受请求前\");\n      //常用来权限管理，事务，日志，请求和响应的字符格式\n      return true;\n    }\n  \n    @Override\n    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {\n      System.out.println(\"响应请求后，渲染视图前\");\n      //可以用来修改请求域的属性或视图\n    }\n  \n    @Override\n    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {\n      System.out.println(\"渲染视图后\");\n      //常用来释放资源\n    }\n  }\n  ```\n\n  * 将自定义拦截器配置到springmvc中\n\n  ```xml\n  <!--配置解析器-->\n  <bean class=\"org.springframework.web.servlet.i18n.SessionLocaleResolver\" id=\"localeResolver\"></bean>\n  <!--配置拦截器-->\n  <mvc:interceptors>\n    <!--配置自定义拦截器，拦截所有请求-->\n    <bean class=\"com.lc.interceptor.FirstInterceptor\"></bean>\n    <!--配置自定义拦截器，拦截指定请求-->\n    <mvc:interceptor>\n      <mvc:mapping path=\"/emps\"/>\n      <bean class=\"com.lc.interceptor.FirstInterceptor\"></bean>\n    </mvc:interceptor>\n    <!--配置自定义拦截器，拦截所有请求，但不拦截指定请求-->\n    <mvc:interceptor>\n      <!--这个必须写在前面，需要先指定拦截哪些请求，然后再剔除-->\n      <mvc:mapping path=\"/*\"/>\n      <mvc:exclude-mapping path=\"/emp\"/>\n      <bean class=\"com.lc.interceptor.FirstInterceptor\"></bean>\n    </mvc:interceptor>\n  </mvc:interceptors>\n  ```\n\n* 多个拦截器的使用顺序(默认按照在springmvc配置文件中的顺序执行)\n\n  * 第一：多个拦截器的preHandle()都返回true。\n    * 先顺序执行拦截器的preHandle()方法，在逆序执行postHandle()方法，再逆序执行afterCompletion()方法。\n  * 第二：第一个拦截器的preHandle()返回false。\n    * 只执行第一个拦截器的preHandle()方法，其他的都不执行。\n  * 第三：有一个拦截器的preHandle()返回false。\n    * 先执行在这个拦截器之前注册的拦截器的preHandle()方法，在执行这个拦截器的preHandle()方法。最后逆序执行在这个拦截器之前注册的拦截器的afterCompletion()方法。\n\n# 第十三章 异常处理\n\n* Spring MVC 通过 HandlerExceptionResolver 处理程序的异常，包括 Handler 映射、数据绑定以及目标方法执行时发生的异常。 \n* SpringMVC 提供的 HandlerExceptionResolver 的实现类。\n* 使用异常处理时，需要添加\\<mvc:annotation\\-driven/> 配置。\n\n**ExceptionHandlerExceptionResolver异常处理解析器**\n\n* 作用：主要处理 Handler 中用 @ExceptionHandler 注解定义的方法。 \n* @ExceptionHandler 注解定义的方法优先级问题：例如发生的是NullPointerException，但是声明的异常有\n  RuntimeException 和 Exception，此候会根据异常的最近继承关系找到继承深度最浅的那个 @ExceptionHandler注解方法，即标记了 RuntimeException 的方法。\n* 注意：异常处理方法只能处理方法所在类中发生的异常，无法处理全局的异常。\n* 示例\n\n```java\n/**\n   * 1,方法的参数为Exception时，传入的e是异常对象\n   * 2.@ExceptionHandler注解的值是一个数组，值是要处理的异常的类\n   * 3.如果要将异常信息放到页面上,需要使用ModelAndView作为返回值才可以\n   * @param e\n   * @return\n   */\n@ExceptionHandler({RuntimeException.class})\npublic ModelAndView handException(Exception e){\n  System.out.println(e);\n  ModelAndView modelAndView = new ModelAndView(\"error\");\n  modelAndView.addObject(\"exception\", e);\n  return modelAndView;\n}\n```\n\n* ExceptionHandlerMethodResolver 内部若找不到@ExceptionHandler 注解的话，会找 @ControllerAdvice 中的@ExceptionHandler 注解方法。\n* 即：若是出现异常时，在本类中找不到异常处理方法，则在springmvc中找注解为@ControllerAdvice 的类，然后找这个类中带@ExceptionHandler 注解的方法。\n\n```java\n@ControllerAdvice\npublic class FirstExceptionHandle {\n  @ExceptionHandler({RuntimeException.class})\n  public ModelAndView handException(Exception e){\n    System.out.println(e);\n    ModelAndView modelAndView = new ModelAndView(\"error\");\n    modelAndView.addObject(\"exception\", e);\n    return modelAndView;\n  }\n}\n```\n\n**ResponseStatusExceptionResolver异常状态解析器**\n\n* 作用：解析异常发生后要发送的状态码。\n* @ResponseStatus 注解用于修饰自定义异常类。\n\n```java\n//value为发生异常时返回的状态码，reason为需要在页面显示的信息\n@ResponseStatus(value = HttpStatus.UNAUTHORIZED,reason = \"输入数据为0，发生除法异常\")\npublic class FirstException extends RuntimeException {\n}\n```\n\n* 若抛出了自定义的异常： ExceptionHandlerExceptionResolver 异常处理解析器不会解析此异常。\n* 又因为触发的自定义异常 带有@ResponseStatus注解。因此会被ResponseStatusExceptionResolver 解析到。最后响应HttpStatus.UNAUTHORIZED 代码给客户端。HttpStatus.UNAUTHORIZED 代表响应码401，无权限。\n* 关于其他的响应码请参考 HttpStatus 枚举类型源码。\n\n**DefaultHandlerExceptionResolver默认异常解析器**\n\n* 对一些特殊的异常进行处理，比如NoSuchRequestHandlingMethodException、HttpRequestMethodNotSupportedException、HttpMediaTypeNotSupportedException、HttpMediaTypeNotAcceptableException等。\n\n**SimpleMappingExceptionResolver映射异常解析器**\n\n* 如果希望对所有异常进行统一处理，可以使用SimpleMappingExceptionResolver，它将异常类名映射为视图名，即发生异常时使用对应的视图报告异常。\n\n```xml\n<!--对所有异常进行统一处理-->\n<bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"\n      id=\"simpleMappingExceptionResolver\">\n  <!--出现异常时要映射到哪个页面-->\n  <property name=\"exceptionMappings\">\n    <props>\n      <!--将算数异常映射到error.jsp页面-->\n      <prop key=\"java.lang.ArithmeticException\">error</prop>\n    </props>\n  </property>\n</bean>\n```\n\n# 第十四章 总结\n\n* 在控制层，所有的控制方法，如果有自定义的pojo类型的形参，则会在此请求结束后，将形参的数据添加到request域属型中。\n* SpringMVC的运行流程\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210318125159.png)\n\n# 第十五章 Spring与SpringMVC的整合\n\n* Spring与SpringMVC的整合\n\n  * 需要整合：通常情况下，类似于数据源，事务，整合其他框架都是放在Spring的配置文件中的，而且service和dao层也是都放在Spring中的。\n  * 不需要整合：也可以都放在SpringMVC中，也可以分多个配置文件，然后在主配置文件中通过import标签导入其他配置文件。\n  * 推荐整合，使用Spring和SpringMVC两个配置文件。\n\n* 问题1：当Spring的IOC容器和SpringMVC的IOC扫描的包有重复时，会导致由的bean被创建两次。\n\n  * 解决1：让它们扫描不同的包，\n  * 解决2：扫描包可以重复，使用exclude-filter和include-filter规定扫描的注解要不同。\n\n* 整合示例：\n\n  * Spring的配置文件：Spring-Config.xml\n\n  ```xml\n  <!--只不扫描Controller和ControllerAdvice注解的bean-->\n  <context:component-scan base-package=\"com.lc\">\n    <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n    <context:exclude-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.ControllerAdvice\"/>\n  </context:component-scan>\n  ```\n\n  * SpringMVC配置文件：SpringMVC-Config.xml\n\n  ```xml\n  <!--只扫描Controller和ControllerAdvice注解的bean-->\n  <context:component-scan base-package=\"com.lc\" use-default-filters=\"false\">\n    <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n    <context:include-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.ControllerAdvice\"/>\n  </context:component-scan>\n  ```\n\n  * web.xml配置文件\n\n  ```xml\n  <servlet>\n    <servlet-name>DispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n      <param-name>contextConfigLocation</param-name>\n      <param-value>classpath:*-Config.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n  </servlet>\n  <servlet-mapping>\n    <servlet-name>DispatcherServlet</servlet-name>\n    <url-pattern>/</url-pattern>\n  </servlet-mapping>\n  ```\n\n* 注意：SpringMVC中的bean可以引用Spring中的bean。反之则不行。\n\n* 在 Spring MVC 配置文件中引用业务层的 Bean。\n\n  * 多个 Spring IOC 容器之间可以设置为父子关系，以实现良好的解耦。 \n  * Spring MVC WEB 层容器可作为 “业务层” Spring 容器的子容器：即 WEB 层容器可以引用业务层容器的 Bean，而业务层容器却访问不到 WEB 层容器的 Bean。\n\n# 第十六章 SpringMVC与Struts2的对比\n\n* ①. Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter\n* ②. Spring MVC 会稍微比 Struts2 快些. Spring MVC 是基于方法设计, 而 Sturts2 是基于类, 每次发一次请求都会实例一个 Action.\n* ③. Spring MVC 使用更加简洁, 开发效率Spring MVC确实比 struts2 高: 支持 JSR303, 处理 ajax 的请求更方便\n* ④. Struts2 的 OGNL 表达式使页面的开发效率相比Spring MVC 更高些.","categories":["Java学习","JavaEE框架"]},{"title":"Servlet学习","url":"/2021/03/16/尚硅谷说Java/前端/Servlet/","content":"Servlet学习\n<!--more-->\n\n# 第一章 Servlet基础\n\n* 宏观地讲，Servlet 是连接Web服务器与服务端Java程序的协议，是一种通信规范。这个规范是以一套接口的形式体现的。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210205121836.png)\n\n* 通常来说，Servlet 是宏观上Servlet规范中的一个具体的接口，Servlet 规范中包含一套接口。而Servlet接口仅仅是其中之一。 \n\n* 微观地讲, Servlet是Servlet接口实现类的一个实例对象，是运行在服务器上的一段Java小程序，即Server Applet, 也就是Servlet这个单词的来历。Servlet 的主要功能是根据客户端提交的请求，调用服务器端相关代码，完成对请求的处理与运算。\n\n## 1.1 Servlet生命周期\n\n* 所谓Servlet 生命周期是指，Servlet 对象的创建、Servlet 对象的初始化、Servlet 对象服务的执行，及最终Servlet对象被销毁的整个过程。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210208112902.png)\n\n* Servlet的整个生命周期过程的执行,均由Web服务器负责管理。即Servlet从创建到服务到销毀的整个过程中方法的调用，都是由Web服务器负责调用执行，程序员无法控制其执行流程。\n\n* 但程序员可以获取到Servlet 的这些生命周期时间点，并可以指定让Servlet做一些具体业务相关的事情。\n\n### 1.1.1 生命周期方法执行流程\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210208113132.png)\n\n* 对于以上代码的运行，注意以下几个时间点: \n  * (1)项目部署后启动服务器，发现并没有执行Servlet 的无参构造器方法，说明在Web容器启动时并没有创建Servlet对象。\n  * (2)用户提交请求后，马上可以看到无参构造器、init()方法、service()方法均执行。 \n  * (3)刷新页面,发现只会执行service()方法，每刷新一次，即每提交一次请求，就会执行一次service()方法。\n  * (4)让另外一个浏览器也发出同样的请求,会发现只执行service()方法,而无参构造器、init()方法均未执行。\n  * (5)正常关闭Tomcat (使用stop server关闭,不能使用Terminate 关闭)，发现destroy()方法也会执行\n\n### 1.1.2 Servlet特征\n\n* (1) Servlet 是单例多线程的。\n* (2)一个Servlet实例只会执行一次无参构造器与init()方法，并且是在第一次访问时执行。\n* (3)用户每提交一次对当前Servlet的请求，就会执行一次 service()方法。\n* (4)一个Servlet实例只会执行一次 destroy()方法，在应用停止时执行。\n* (5)由于Servlet是单例多线程的，所以为了保证其线程安全性，一般情况下是不为Servlet类定义可修改的成员变量的。因为每个线程均可修改这个成员变量,会出现线程安全问题。\n* (6)默认情况下，Servlet 在Web容器启动时是不会被实例化的。\n\n### 1.1.3 Web容器启动时创建Servlet实例\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210208143730.png)\n\n### 1.1.4 Web容器中的两个Map\n\n* 一个Map\n\n  |    key     |       value       |\n  | :--------: | :---------------: |\n  | url-patten | Servlet实例的引用 |\n\n* 另一个Map\n\n  |    key     |      value      |\n  | :--------: | :-------------: |\n  | url-patten | Servlet的类路径 |\n\n* 当Servlet实例被创建好后被放在了哪里? web.xml中URI与Servlet的映射关系反映到内存中是以什么形式存在呢?\n\n  * 当Servlet实例被创建好后,会将该Serlet实例的引用存放到一个Map集合中。该Map ,集合的key为URI,而value购Servlet实例的引用，即Map<String, Servlet>.当Web容器从用户请求中分离出URI后,会首先到这个Map中查找是否存在其所对应的value。若存在，则直接调用其servicel(方法。若不存在，则需要创建该Servlet 实例。\n\n* 若请求的Servlet 实例不存在, Web容器又是根据什么创建这个Servlet 实例的呢?\n\n  * 在Web容器的内存中,还存在一个Map集合。该Map集合的key为URI,而value购web.xml中配置的与之对应的Servlet的全限定性类名，即Map<String, String>.。\n\n* 总结：当Web容器从用户请求中分离出URI后,到第一个Map中又没有找到其所对应的Servlet实例，则会马上查找这第二个Map, 从中找到其所对应的类名,再根据反射机制，创建这个Servlet实例。然后再将这个创建好的Servlet的引用放入到第一个Map中。然后执行Servlet实例的service()方法。\n\n### 1.1.5 关于getServletInfo()方法\n\n* Servlet接口中的getServletInfo()方法，是由程序员自己定义的有相关当前Servlet的一些基本信息，不属于Servlet生命周期中的方法。对程序的运行没有任何影响与作用。仅仅是返回一些让他人阅读的信息。\n* 比如Servlet的作者，版本等。\n\n## 1.2 ServletConfig\n\n### 1.2.1 什么是ServletConfig\n\n* ServletConfig是一个配置接口，其实现类保存着web.xml文件中的配置信息。\n\n### 1.2.2 获取ServletConfig对象\n\n* 由于ServletConfig中可以获取到Servlet 的初始化参数,获取到ServletContext对象, 而这些参数与对象在进行业务逻辑处理时，即执行service()方法时需要经常访问，很重要,所以ServletConfig对象也就显得很重要了。\n* 由于ServetConfig对象是Web容器通过init()方法传递给当前Servlet类的,而init()方法只会在Servlet对象初始化时调用一次。所以,需要在init()方法中将ServletConfig对象传递给Servlet的servletConfig成员变量,这样service()方法即可使用ServletConfig对象了。也就是说，我们需要在Servlet中声明一个ServletConfig 成员变量。\n* 若在Servlet中声明一个ServetConfig 成员变量,是否会存在线程安全问题呢?因为Servlet是单例多线程的。只要在Servlet中不为ServletConfig 对象提供其它修改方法，其值只能由Web容器通过init()方法进行赋值,那么ServletConfig 对象就不存在线程安全问题。因为对于所有线程来说，ServletConfig 对象是只读的，不能修改。\n\n### 1.2.3 ServletConfig中的方法\n\n* 一个Servlet实例只有一个ServletConfig。\n\n* 查看帮助文档可以知道ServletConfig接口中有四个方法：\n\n  *  getServletName() ：获取Servlet名字，即在web.xml中配置的\n  *  getServletContext()  ：获取servlet上下文\n  *  getInitParameter(String name) ：获取Servlet的初始化参数的value,通过name获取，\n  *  getInitParameterNames() ：获取Servlet的初始化参数的所有name，\n\n  ```java\n  //获取servlet的名称，即web.xml文件中servlet-name标签中的内容\n  String servletName = servletConfig.getServletName();\n  System.out.println(\"servletName = \" + servletName);\n  //获取Servlet上下文\n  ServletContext servletContext = servletConfig.getServletContext();\n  System.out.println(\"servletContext = \" + servletContext);\n  \n  //获取Servlet的初始化参数的所有name，即init-param节点里的param-name节点的内容\n  //顺序为从下往上输出\n  Enumeration<String> names = servletConfig.getInitParameterNames();\n  while (names.hasMoreElements()){\n    String name = names.nextElement();\n    //获取Servlet的初始化参数的value,通过name获取，\n    String value = servletConfig.getInitParameter(name);\n    System.out.println(name + \" \" + value);\n  }\n  ```\n\n## 1.3 ServletContext\n\n* ServletContext官方叫servlet上下文。服务器会为每一个工程创建一个对象，这个对象就是ServletContext对象。\n* 这个对象全局唯一，而且工程内部的所有servlet都共享这个对象。所以叫全局应用程序共享对象\n* 作用：\n  * 是一个域对象\n  * 可以读取全局配置参数。\n  *  可以搜索当前工程目录下面的资源文件。\n  * 可以获取当前工程名字。\n* 方法：\n  * getInitParameterNames() ：获取应用所有初始化参数名。\n  * getInitParameter() ：获取应用的初始化参数的value,通过name获取。\n  * setAttribute(key,value) ：设置域属型，当已存在此key域属性时，会覆盖原来的域属性。\n  * getAttribute(key) ：获取域属性。\n  * removeAttribute(key) ：删除域属性。\n  * getContextPath() ：获取项目应用名称。\n  * getRealPath(string) ：获取以string为基础的绝对路径\n* 在web.xml中配置全局域属型\n\n```xml\n<!-- context-param：表示定义整个应用都能使用的初始化参数  -->\n  <context-param>\n  <param-name>name</param-name>\n  <param-value>cj</param-value>\n  </context-param>\n  <context-param>\n  <param-name>address</param-name>\n  <param-value>河南</param-value>\n  </context-param>\n```\n\n* servletContext的使用\n\n```java\n//获取Servlet上下文\nServletContext servletContext = servletConfig.getServletContext();\nSystem.out.println(\"servletContext = \" + servletContext);\n\n//获取应用所有初始化参数名\nEnumeration<String> initParameterNames = servletContext.getInitParameterNames();\nwhile (initParameterNames.hasMoreElements()){\n  String name = initParameterNames.nextElement();\n  String value = servletContext.getInitParameter(name);\n  System.out.println(name + \" \" + value);\n}\n//设置域属性。域属性是全局性的，在每个Servlet中都能访问\n//当再次设置相同key的域属性时是重置，而不是添加\nservletContext.setAttribute(\"email\", \"xxx@qq.com\");\nservletContext.setAttribute(\"mobile\", \"110\");\n//获取域属性\nObject email = servletContext.getAttribute(\"email\");\nSystem.out.println(email);\n//删除域属性\nservletContext.removeAttribute(\"email\");\n\n//获取应用名称\nString contextPath = servletContext.getContextPath();\nSystem.out.println(\"contextPath = \" + contextPath);\n//获取基于/的绝对路径\nString realPath = servletContext.getRealPath(\"/\");\nSystem.out.println(\"realPath = \" + realPath);\n```\n\n## 1.4 欢迎页面设置\n\n* 自定义欢迎页面\n\n  ```xml\n  <!--此处可以放多个欢迎页面，查找顺序为从上到下。默认欢迎页面都是名为index的的页面文件  -->\n  <welcome-file-list>\n    <welcome-file>index.jsp</welcome-file>\n  </welcome-file-list>\n  ```\n\n* 默认的欢迎页面\n\n  ```xml\n  <welcome-file-list>\n    <welcome-file>index.html</welcome-file>\n    <welcome-file>index.htm</welcome-file>\n    <welcome-file>index.jsp</welcome-file>\n  </welcome-file-list>\n  ```\n\n## 1.5 url-pattern的使用\n\n* url路径可以写多级路径，这种方式被称为**精确路径匹配**。\n  * 类似于/xxx/000/jjj/main。访问时url也必须是/xxx/000/jjj/main。\n* 一个servlet-mapping中可以有多个url-pattern。\n* **通配符路径模式**：例如/aaa/*。表示匹配以/aaa/开头的所有url。\n* **全路径模式**：\n  * 例如/*。表示匹配所有的url。包括对静态资源和动态资源的请求也会拦截。\n  * 例如/ 。表示匹配所有的url。拦截对静态资源的请求，但不拦截动态资源的请求。\n* **后缀模式**：例如*.do。表示拦截所有以.do结尾的url请求。\n  * 后缀模式不能和路径模式一块使用。\n* 路径匹配的优先原则：精确路径 > 通配符路径 > 全路径 > 后缀模式。\n  * 相同模式中长路径优先于短路径。\n\n# 第二章 Servlet核心\n\n## 2.1 GenericServlet的定义和使用\n\n* 定义一个抽象类GenericServlet。这个类的作用：实现Servlet接口的四个抽象方法，这四个方法是空实现，留一个service方法不实现。\n\n  * 因为service方法经常被使用。\n  * 这种设计模式被称为缺省适配器设计模式。\n\n* 在抽象类GenericServlet，重写了父类的init()方法，但也定义了一个无参的init()方法给子类重写。\n\n  * 模板方法设计模式：父类重写了init有参方法，定义一个无参的init方法留给子类去重写。在编译时this.init()调用的是父类的init方法，运行时调用的是子类重写的init()方法。\n\n* 抽象类GenericServlet相当于servlet接口和ServletConfig接口的子接口，供程序员只使用这两个接口的核心功能。\n\n* 核心代码如下\n\n  ```java\n  public abstract class GenericServlet implements Servlet,ServletConfig{\n    private ServletConfig servletConfig;\n  \n    @Override\n    public void init(ServletConfig servletConfig) throws ServletException {\n      this.servletConfig = servletConfig;\n      this.init();\n    }\n  \n    /**\n     * 该无参方法，是为了让子类重写此方法\n     */\n    public void init(){}\n  \n    @Override\n    public ServletConfig getServletConfig() {\n      return servletConfig;\n    }\n  \n    /**\n     * 抽象方法必须使用抽象类\n     * @param servletRequest\n     * @param servletResponse\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    public abstract void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException ;\n  \n    @Override\n    public String getServletInfo() {\n      return null;\n    }\n  \n    @Override\n    public void destroy() {\n  \n    }\n  \n    @Override\n    public String getServletName() {\n      return servletConfig.getServletName();\n    }\n  \n    @Override\n    public ServletContext getServletContext() {\n      return servletConfig.getServletContext();\n    }\n  \n    @Override\n    public String getInitParameter(String s) {\n      return servletConfig.getInitParameter(s);\n    }\n  \n    @Override\n    public Enumeration<String> getInitParameterNames() {\n      return servletConfig.getInitParameterNames();\n    }\n  }\n  ```\n\n* 子类调用代码\n\n  ```java\n  public class SomeServlet extends GenericServlet {\n    @Override\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {\n      System.out.println(\"执行Servlet的service()方法\");\n      Enumeration<String> names = this.getInitParameterNames();\n      while (names.hasMoreElements()) {\n        String name = names.nextElement();\n        String value = this.getInitParameter(name);\n        System.out.println(value);\n      }\n    }\n  \n    /**\n     * 重写父类的无参init方法\n     */\n    @Override\n    public void init() {\n      super.init();\n      System.out.println(\"另外的代码\");\n    }\n  }\n  ```\n\n* 其实javax包中已经定义好了GenericServlet类，因此我们在使用servlet时，直接继承GenericServlet即可，不必继承Servlet。\n\n## 2.2 HttpServlet的定义和使用\n\n* HttpServlet类主要用去处理请求的方式，比如get请求就调用doGet方法，post请求就调用doPost方法，同时隐藏了service方法。\n\n* HttpServlet类继承于GenericServlet类。\n\n* 自定义的HttpServlet类核心代码如下\n\n  ```java\n  public class HTTPServlet extends GenericServlet {\n    @Override\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {\n  \n      // 多态的体现：分为向下转型和向上转型\n      // 下转型：将父类引用赋值给子类引用。但Java中是不支持真正的下转型的。但若父类对象本身\n      //        是由子类对象上转型而来的，那么可以通过强转的方式，将其赋值给子类对象。\n      //  上转型：将子类引用赋值给父类引用。\n      HttpServletRequest request = (HttpServletRequest)servletRequest;\n      HttpServletResponse response = (HttpServletResponse) servletResponse;\n      String method = request.getMethod();\n      System.out.println(method);\n      if (\"POST\".equals(method)){\n        doPost(request,response);\n      }else if (\"GET\".equals(method)){\n        doGet(request,response);\n      }\n  \n    }\n  \n    private void doGet(HttpServletRequest request, HttpServletResponse response) {\n    }\n  \n    private void doPost(HttpServletRequest request, HttpServletResponse response) {\n    }\n  }\n  ```\n\n* 使用方法如下\n\n  ```java\n  public class SomeServlet extends HttpServlet {\n  \n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) {\n      System.out.println(\"执行doGET\");\n    }\n  \n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) {\n      System.out.println(\"执行doPOST\");\n    }\n  }\n  ```\n\n* 其实javax包中已经定义好了HttpServlet类，因此我们在使用servlet时，直接继承HttpServlet即可，不必继承Servlet和GenericServlet。\n\n## 2.3 HttpServletRequest\n\n### 2.3.1 请求的生命周期\n\n* javax.servet.http.HttpServletRequest是SUN制定的Servlet规范,是一个接口,表示请求，其父接口是javax.servlet.ServletRequest。“HTTP请求协议”的完整内容都被封装到request对象中。\n\n* HttpServletRequest实例对象是什么时候创建和销毁的呢?\n* 当客户端浏览器将请求(字符序列)发送到服务器后，服务器会根据HTTp请求协议的格式对请求进行解析。同时，服务器会创建HttpServletRequest的实现类RequestFacade的对象，即请求对象。然后再调用相应的set 方法，将解析出的数据封装到请求对象中。此时HttpServletRequest实例就创建并初始化完毕了。也就是说，请求对象是由服务器创建。\n* 当服务器向客户端发送响应结束后，HttpServletRequest 实例对象被服务器销毁。\n* 一次睛求对应一个请求对象,另外一次请求对应另外一个请求对象，与之前的请求对象没有任何关系。HttpServletRequest 实例的生命周期很短暂。\n\n### 2.3.2 请求参数\n\n* HttpServletRequest对于请求中所携带的参数是以Map的形式接收的,并且该Map的key为String, value 为**String数组**。注意，是String数组。\n* 为什么是String数组而不是string呢?因为Http请求协议允许一个请求参 数具有多个值的情况出现。例如下面表单中的复选框hobby的值就可能是多个。\n\n```java\n/**\n * 1.请求参数是存放在map中的\n * 2.map中的key为请求参数的名称，为String类型\n *   map中的value为请求参数的所有值，为String[]类型。\n * 3.使用最多的是getParameter()方法\n */\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n  //获取请求的表单中的参数值\n  //getParameter：本质上等同于获取getParameterValues(key)[0]。\n  String name = request.getParameter(\"name\");\n  String ageStr = request.getParameter(\"age\");\n  Integer age = Integer.valueOf(ageStr);\n  System.out.println(name + \" \" + age);\n\n  //获取请求的表单中的所有参数名称\n  Enumeration<String> names = request.getParameterNames();\n  while (names.hasMoreElements()){\n    String element = names.nextElement();\n    String value = request.getParameter(element);\n    System.out.println(element + \" : \" + value);\n  }\n  \n  //获取请求参数的map\n  Map<String, String[]> parameterMap = request.getParameterMap();\n  for (String key : parameterMap.keySet()) {\n    System.out.println(key + \" : \" + request.getParameter(key));\n  }\n  System.out.println();\n}\n```\n\n### 2.3.3 域属型\n\n* 在Request中也存在域属性空间，用于存放有名称的数据。该数据只在当Request请求中可以进行访问。\n  * 能够实现跨Servlet的数据传输。\n* 对域属型的访问：\n\n```java\n//设置域属型\nrequest.setAttribute(\"name\", \"cl\");\nrequest.setAttribute(\"age\", 12);\n//获取所有的域属性名称\nEnumeration<String> names = request.getAttributeNames();\nwhile (names.hasMoreElements()){\n  String element = names.nextElement();\n  Object value =  request.getAttribute(element);\n  System.out.println(element + \" : \" + value);\n}\n//删除域属型\nrequest.removeAttribute(\"name\");\n//将请求转发给OtherServlet\nrequest.getRequestDispatcher(\"/other\").forward(request,response);\n\n//获取域属性。由于是同一个request，因此能够获取到值\nObject name = req.getAttribute(\"name\");\nObject age = req.getAttribute(\"age\");\n```\n\n### 2.3.4 服务端相关信息\n\n* request的其他方法的使用：\n\n```java\n//获取请求的URL\nStringBuffer requestURL = request.getRequestURL();\nSystem.out.println(\"requestURL: \" + requestURL);\n//获取请求的URI：即url路径去掉协议和主机地址的剩下的\nString requestURI = request.getRequestURI();\nSystem.out.println(\"requestURI: \" + requestURI);\n//获取当前web应用的根名称\nString contextPath = request.getContextPath();\nSystem.out.println(\"contextPath: \" + contextPath);\n//获取客户端IP\nString clientIP = request.getRemoteAddr();\nSystem.out.println(\"clientIP: \" + clientIP);\n//获取servle与url映射中路径的精确部分\nString servletPath = request.getServletPath();\nSystem.out.println(\"servletPath: \" + servletPath);\n//获取servle与url映射中路径的非精确部分\nString pathInfo = request.getPathInfo();\nSystem.out.println(\"pathInfo: \" + pathInfo);\n```\n\n## 2.4 关于乱码问题\n\n* 当在浏览器输入汉字时，服务器端接受的数据可能是乱码的现象。\n* 原因：浏览器的数据是经过HTTP协议传输到服务端的，\n  * Http协议中规定,数据的传输采用字节编码方式,即无论浏览器提交的数据所包含的中文是什么字符编码格式，一旦由浏览器经过Http协议传输，则这些数据均将以字节的形式上传给服务器。因为HTTP协议的底层使用的是TCP传输协议。TCP, Transmission ControlProtocol,传输控制协议，是一种面向连接的、可靠的、基于字节流的、端对端的通信协议。\n  * 在请求中，这些字节均以%开头，并以十六进制形式出现。如%5A%3D等。\n* 那么，乱码是如何产生的呢?\n  * 当用户通过浏览器提交一个包含UTF-8编码格式的两个字的中文请求时,浏览器会将这两个中文字符变为六个字节(-般一个UTF-8汉字占用三个字节),即形成六个类似%8E的字节表示形式，并将这六个字节。上传至Tomcat服务器。\n  * 例如：name=%E8%AF%95%E7%82%B9%E8%8C%83%E5%9B%B4  ==>  name=试点范围\n  * Tomcat服务器在接收到这六个字节后，并不知道它们原始采用的是什么字符编码。而Tomcat默认的编码格式为1SO-8859-1。所以会将这六个字节按照1SO-8859-1的格式进行编码,编码后在控制台显示，所以在控制台会显示乱码。\n* 注意：Tomcat9版本中，使用GET提交的不会出现中文乱码问题，使用POST提交的会出现中文乱码问题。\n  * 只有9版本解决了GET提交方式的中文乱码，其他版本的都没有解决。\n\n### 2.4.1 解决POST请求的中文乱码\n\n* 在接受请求后，通过request.setCharacterEncoding(\"UTF-8\");设置编码格式，然后在使用request。\n\n```java\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n  //解决POST提交时的中文乱码问题\n  //setCharacterEncoding()：设置了请求正文中的字符编码格式\n  request.setCharacterEncoding(\"UTF-8\");\n\n  String name = request.getParameter(\"name\");\n  String ageStr = request.getParameter(\"age\");\n  Integer age = Integer.valueOf(ageStr);\n  System.out.println(name + \" \" + age);\n}\n```\n\n### 2.4.2 解决GET请求的中文乱码\n\n* 打开tomcat的安装路径，找到tomcat下的conf文件夹里面的server.xml文件。在server.xml文件中，将 URIEncoding=\"UTF-8\"添加到如下位置：\n\n```xml\n<Connector port=\"8080\" protocol=\"HTTP/1.1\"\n               connectionTimeout=\"20000\"\n               redirectPort=\"8443\" URIEncoding=\"UTF-8\"/>\n```\n\n* 另一种解决方式：在接受到数据后，对数据进行编码转换。\n  * <font color=\"red\">这种方案是万能方式，能够解决get和post请求的中文乱码问题。</font>\n\n```java\nString name = request.getParameter(\"name\");\n//针对tomcat9除外的其他版本的get请求。通过转换成浏览器的字节编码格式\nbyte[] bytes = name.getBytes(\"ISO8859-1\");\nString newName = new String(bytes, \"UTF-8\");\n```\n\n## 2.5 HttpServletResponse\n\n* Web服务器收到一个Http请求后，会针对每个请求创建一个HttpServletRequest 对象和HttpSservletResponse对象。若需要获取客户端提交请求的相关信息，则需要从HttpServletRequest对象中获取;若需要向客户端发送数据，则需要通过HttpServletResponse对象来完成。\n\n### 2.5.1 向客户端发送数据\n\n* SenvletResponse'接口有-一个方法getWriter()，用于获取到一个输出流对象PrintWriter,该输出流对象是专门用于向客户端浏览器中输出字符数据的，称为标准输出流。\n\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n  //获取标准输出流：用于输出到浏览器中\n  PrintWriter writer = response.getWriter();\n  //将数据传输到浏览器，浏览器会直接显示这些数据\n  /*writer.print(\"asd\");\n    writer.println(\"acd\");\n    writer.print(\"zxczx\");*/\n  /*writer.write(\"zxc\");\n    writer.write(\"dfger\");*/\n  //像标准输出流中写入数据，那么客户端浏览器会直接看到这些数据\n  writer.append(\"ad\");\n  writer.append(\"zc\");\n  //对标准输出流的关闭。注意关闭的时间。可以不用手动关闭\n  //writer.close();\n}\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210211104213.png)\n\n### 2.5.2 响应时出现乱码\n\n* 若在PrintWriter流中写入中交字符，那么，在客户端浏览器中将显示乱码。\n* 只所以响应时会产生乱码，是因为HTTP 协议中规定，默认响应体的字符编码为ISO-8859-1。所以，若要解决乱码问题，就需要修改响应体的默认编码。一般情况下，有两种方式可以修改: \n  * HttpServletResponse 的setContentType(\"text/html;charset=utf-8\"]方法， 用于设置响应内容的MIME类型，其中可以指定MIME的字符编码。而MIME的字符编码，即响应体的字符编码。\n  * HttpServletResponse 的setCharacterEncoding(\"ut-8\")方法,用于修改MIME的字符编码，即修改响应体的字符编码。但使用setCharacterEncoding()方法的前提是，之前必须要通过使用方法setContentType()方法设置响应内容的MIME类型。否则setChar acterEncoding()方法不起作用。\n* 浏览器会根据响应体字符编码,自动调整其对响应体内容的解码方式;即会使用响应俸的字符编码显示响应体内容。\n* 不过，需要注意一点，这些设置，必愤在PrintWriter对象产生之前先设置，否则将不起作用。\n\n```java\n//方法一\n//设置响应的MIME类型。例如：video/mp4,image/jpg\n//其中可以指定MIME的字符编码，即响应体的字符编码\n//response.setContentType(\"text/html;charset=UTF-8\");\n\n//setCharacterEncoding()此方法的使用必须在getWriter()方法使用前使用\n//这个方法的使用前提是必须先使用setContentType()方法\n//这个方法用于修改ContentType的MIME类型字符编码\nresponse.setCharacterEncoding(\"UTF-8\");\n```\n\n## 2.6 转发与重定向\n\n* 通过HttpServletRequest获取到的RequestDispatcher对象的forward()方法，可以完成请求转发功能。而通过HttpServletResponse的sendRedirect()方法，可以完成重定向功能。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210211143310.png)\n\n* 图解\n\n<img src=\"https://gitee.com/plumChuan/picture-bed/raw/master/img/20210211144852.png\"  />\n\n* 请求转发：也称为服务器内跳转。重定向：也称为服务器外跳转。\n\n### 2.6.1 请求转发\n\n* 请求转发：是由请求发起的跳转操作。\n  * 跳转时会携带浏览器的传参。\n  * 浏览器的url不会变。\n  * 转发前后的request和response根据转发的方式不同，也有所不同。见下面6.7\n\n```java\nString name = request.getParameter(\"name\");\n//请求转发操作\nrequest.getRequestDispatcher(\"/other\").forward(request,response);\n```\n\n### 2.6.2 重定向\n\n* 重定向：是由响应发起的跳转操作。\n  * 跳转时是浏览器默认发起的请求，不带任何参数。\n  * 浏览器的url会发生变化。\n  * 重定向之后此servlet中的request和response已经失效。\n  * 重定向与请求转发还有一点很重要的不同点是，重定向可以跳转到其它应用中,而请求转发只能在当前应用中跳转。也正因为如此,所以以sendRedirect()的参数中必须要添加request.getContextPath(),即当前应用的根目录，指定要跳转到哪个应用的哪个资源。\n\n```java\n//重定向：\nresponse.sendRedirect(request.getContextPath() + \"/other\");\n//此处以下的代码仍会执行，但请求和响应已经结束。\nSystem.out.println(name);\nPrintWriter writer = response.getWriter();\nSystem.out.println(writer);\n//此处无法向浏览器发送数据\nwriter.append(\"asdasd\");\n```\n\n* 重定向时传输数据。\n\n```java\nresponse.sendRedirect(request.getContextPath() + \"/other?pname=\" + name + \"&age=\" + age);\n```\n\n* 此时会发现重定向后pname没有值。因为此时发生了重定向的数据乱码方式。\n\n### 2.6.3 重定向时的乱码解决方式\n\n* 首先重定向一般是在GET请求时，\n* 在重定向前，需要将中文数据通过URL工具的编码方式，在接收后通过URL的解码方式。\n  * 同时针对Tomcat9之外的其他版本，在解码后需要get请求的中文处理方式解决中文乱码现象。\n\n```java\n//编码：打散,使得url能够显示数据\nname = URLEncoder.encode(name,\"UTF-8\");\n//重定向：\nresponse.sendRedirect(request.getContextPath() + \"/other?pname=\" + name + \"&age=\" + age);\n\ntring name = request.getParameter(\"pname\");\nSystem.out.println(name);\n//解码：组装，将url的数据解码\nname = URLDecoder.decode(name,\"UTF-8\");\n\n//对get请求的乱码问题的解决。当tomcat为9之外的版本\nString sname = new String(name.getBytes(\"ISO8859-1\"), \"UTF-8\");\n\n```\n\n* Tomcat9版本的get重定向中，只需要编码和解码即可，不需要解决中文乱码的方式。\n\n### .6.4 请求转发与重定向的对比\n\n* 请求转发\n  * 浏览器只发出一次请求，收到一次响应。\n  * 请求所转发到的资源中可以直接获取到请求中所携带的数据。\n  * 浏览器地址栏显示的为用户所提交的请求路径。\n  * 只能跳转到当前应用的资源中。\n* 重定向\n  * 浏览器发出两次请求，接收到两次响应。\n  * 重定向到的资源不能直接获取到用户提交请求中所携带的数据。\n  * 浏览器地址栏显示的为重定向的请求路径，而非用户提交请求的路径。也正因为如此，重定向的一个很重要作用是：防止表单重复提交。\n  * 重定向不仅可以跳转到当前应用的其它资源，也可以跳转到到其它应用中资源。\n\n### 2.6.5 请求转发与重定向的选择\n\n* 若需要跳转到其它应用，则使用重定向。\n* 若是处理表单数据的ervlet要跳转到其它Servlet,则需要选择重定向。为了防止表单重复提交。\n* 若对某一请求进行处理的Servlet的执行需要消耗大量的服务器资源(CPU、内存),此时这个Servlet执行完毕后，也需要重定向。\n* 其它情况，一般使用请求转发。\n\n## 2.7 RequestDispatcher\n\n* RequestDispatcher是lavax.servlet 包下的一个接口,通过HttpServletRequest可以获取到RequestDispatcher的接口对象。顾名思义，该对象就是用于完成请求转发功能的。\n* RequestDispatcher接口中只有两个方法：forward(),include()。\n\n### 2.7.1 forward()与include()\n\n* RequestDispatcher接口中具有两个方法: forward()与include()，均可完成请求的转发。即可以将请求中所携带的参数由当前Servlet传递给下一下资源，如另一个Servlet。也就是说，这两个方法对于请求来说是相同的，都是请求转发。但它们的不同之处是响应，是标准响应输出流的开启时间不同。\n* 对于forward()与include()。在请求转发后，它们的request实体都是由RequestFacade变成了ApplicationHttpRequest。而对于response实体，在使用forword()之后，没有发生变化；而使用了include()之后，实体由ResponseFacade变成了ApplicationHttpResponse。\n  * ApplicationHttpRequest和ApplicationHttpResponse分别是对HttpServletRequest和HttpServletResponse的增强类。\n\n```java\nrequest = org.apache.catalina.connector.RequestFacade@22cd7cf1\nresponse = org.apache.catalina.connector.ResponseFacade@67cff6cc\n//使用forword后的变化  \nrequest === org.apache.catalina.core.ApplicationHttpRequest@fded0ec\nresponse === org.apache.catalina.connector.ResponseFacade@67cff6cc\n  \nrequest = org.apache.catalina.connector.RequestFacade@780737f2\nresponse = org.apache.catalina.connector.ResponseFacade@3d05b696\n//使用include后的变化  \nrequest === org.apache.catalina.core.ApplicationHttpRequest@1e0b2a35\nresponse === org.apache.catalina.core.ApplicationHttpResponse@483434df\n```\n\n* void forward(ServletRequest request, ServletResponse response)\n\n  * 使用该方法，则当前的servlet 中只能进行业务处理,而不能向浏览器发送要显示的数据。因为请求还未完成，需要继续向前(forward)，当请求完成后，服务器才会开启标准响应输出流，向输出流中写入数据。\n  * 该方法的响应对象，使用的是第二个资源的响应对象。即第二个资源向浏览器回送的响应数据。\n  * 不过，需要注意的是,在后面的测试代码的someServlet与otherservlet中均添加对于Response对象的输出语句，会发现这两个Servlet中所使用的Response对象为同一个ResponseFacade对象。那为什么在someServlet中向out中print()数据后，并不会显示到客户端浏览器?原因就是Response对象在SomeServlet中创建了,但标准输出流并未开启。输出流的开启是在OtherServlet中进行的。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210212193316.png)\n\n* void Include(ServletRequest request, servletResponse response)\n\n  * 使用该方法，在将请求向后转发时，服务器会将标准响应输出流开启。当前ervlet可以向输出流中写入数据,并且服务器还会将要转向的资源的输出流中数据合并到当前的输出流中。\n  * 该方法的响应对象，使用的是第一个资源的响应对象，即当前servlet向浏览器回送的响应数据。\n  * 需要注意的是，在后面的测试代码的SomeServlet 与Otherervlet 中均添加对于Response对象的输出语句，会发现SomeSenvlet输出的是ResponseFacade 对象，而OtherServlet输出的则是_ ApplicationHttpResponse 对象。ApplicationHttpResponse 是HttpServletResponse接口的实现类ResponseFacade 的装饰者类，其增强了ResponseFacade类的功能。\n  * ApplicationHttpResponse底层完成的一个工作是，将当前的OtherServlet 中的输出流中的数据合并到了SomeServlet的标准输出流中。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210212193322.png)\n\n* 样例\n\n```java\n//设置响应的文本内容以text/html方式解析\nresponse.setContentType(\"text/html\");\n\nPrintWriter writer = response.getWriter();\nwriter.append(\"SomeServlet:forward() before <br>\");\n\n/*\n * forward()与include()的区别：主要表现在标准输出流的开启时间不同。\n * forward(): forward单词本意为”向前“，说明当前的请求还未结束，需要继续向前，所以服务器不会\n *    在这里打开输出流。所以此时写入到out中的数据不会写到客户端浏览器中。\n * include(): include单词本意为”包含“，说明当前的请求已经结束，可以对客户端进行响应的。\n *    其不仅将自己的数据写入到标准输出流，还将包含的其他servlet中写入的数据包含到自己的输出流中。\n *\n * 总结：在使用forward()进行请求转发时，使用forward()的Servlet不应向Response中写入数据，\n *    若要写入数据，则应使用include()进行转发。\n */\n\n//request.getRequestDispatcher(\"/other\").forward(request,response);\nrequest.getRequestDispatcher(\"/other\").include(request,response);\n\nwriter.append(\"SomeServlet:forward() after <br>\");\n```\n\n* 当上述代码使用forward转发方式时\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222194719.png)\n\n* 当上述代码使用include转发方式时。注意输出的顺序\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222194719-1.png)\n\n## 2.8 访问路径问题\n\n### 2.8.1 访问路径的组成\n\n* URL,统一资源定位符，用于定位资源的一种方式。通常的<font color=\"red\">URL资源访问路径由两部分构成:资源路径</font>与<font color=\"red\">资源名称</font>。资源名称指的是要访问资源的直接名称，如show.html,或与要访问资源存在映射关系的间接名称，如show.do。而资源路径,则是通过该路径则可以定位到指定的资源，即资源路径是指在URL资源访问路径中除了资源名称以外的其它部分。\n\n* 根据以上规则，URI,统一资源标识符，也可以分为资源路径与资源名称两部分。\n* 一般情况下，在URL或URI中，最后一个斜杠后的部分为资源名称,而其它部分则为资源路径。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210212204440.png)\n\n* 根据”资源路径是否可以独立完成资源准确定位“的判别标准,可以将访问路径分为绝对路径与相对路径。\n\n### 2.8.2 绝对路径\n\n* 绝对路径,是指根据给出的访问路径可以准确定位到资源的路径。例如，你要告诉对方你现在的位置,你说:我现在在北京故宫游客A入口处。这就是个绝对地址,听者根据你所述地址,可以准确的找到你。\n* 而对于计算机中<font color=\"red\">Web应用的绝对路径，则是指带访问协议的路径,即URL。</font>例如下面的路径就是一个带有http 访问协议的绝对路径。\n  * http://127.0.0.1:.8080/primary/index.jsp\n\n### 2.8.3 相对路径\n\n* 相对路径,是指仅根据访问路径无法准确定位资源的路径。<font color=\"red\">相对路径必须要结合其参照路径才可组成可以准确定位资源的绝对路径。</font>參照路径的不同,所形成的可以准确定位资源的绝对路径也是不同的。在进行资源访问时，必须要将相对路径转换为绝对路径才可完成资源的准确定位。它们的关系如下:\n  * <font color=\"red\">绝对路径=参照路径+相对路径</font>\n* 例如，你要告诉对方你现在的位置，你说:我在人民公园的正门门口。这就是个相对地址。因为很多城市都有人民公园,每个人民公园也都有正门]。当对方不知道你在哪个城市时，他是无法准确定位你的。当然，你只所以不说是哪个城市，是因为这里存在一个默认的参照路径:与听者在同一个城市。听者会将你所说的相对地址,自动转换为一个绝对地址:与听者在同一城市的人民公园正门门口。\n* 在Web应用中，浏览器或服务器会自动为不同的相对路径添加不同的参照路径，将相对路径转换为绝对路径,以定位这个资源。作为程序员,必须要理解并掌握浏览器或服务器为相对路径添加参照路径的规则，这样才能在编程时更为准确地书写相对路径。\n* 相对路径的写法有两种: -种是以斜杠开头的相对路径,-种是以路径名称开头的相对路径。<font color=\"red\">根据相对路径是否以斜杠开头,且路径出现的文件的不同，其默认的参照路径是不同的。</font>\n* 这是我们学习的重点，是路径问题中最容易出错的地方:确定相对路径的参照路径。\n\n#### (1) 以斜杠开头的相对路径\n\n* 以斜杠开头的相对路径,根据路径所在文件所处位置的不同,分为两种:前台路径与后台路径。\n\n**前台路径**\n\n* 所谓前台路径是指，由浏览器解析执行的代码中所包含的路径。例如，html. css、 js中的路径，及jsp文件中静态部分的路径(HTML标签中的路径)。例如，html 及jsp文件中的\\<img src-=\\*/>、\\<a href=\"\">\\</a> ,\\<form actio=\"\">\\</form>等标签中的路径;再如，css 文件中的background:img(\"\")等属性中的路径，js文件中的window.location.href=\"\"等属性中的路径，都属于前台路径。\n* <font color=\"red\">前台路径的参照路径是Web服务器的根路径</font>,即http://127.0.0.1:8080。\n* 将前台路径转换为绝对路径的工作,是<font color=\"red\">由浏览器自动完成的</font>。该路径的作用是要为用户提交对某种资源的请求,是要查找并定位服务器中的某资源。简单来说，前台路径的作用是“查找”。\n\n**后台路径**\n\n* 所谓后台路径是指，由服务器解析执行的代码及文件中所包含的路径。例如，java 代码中的路径、jsp文件动态部分(java 代码块)中的路径、xml等配置文件中的路径(配置文件是要被java代码解析后加载到内存的，其中的路径会出现在Java代码中)等。\n* <font color=\"red\">后台路径的参照路径是Web应用的根路径</font>。如http://127.0.0.1:8080/primary。\n* 将后台路径转换为绝对路径的工作,是<font color=\"red\">由服务器自动完成的</font>。该路径的作用是标识出该资源在服务器中的路径，以便客户端能够按照这个设定路径来查找相应资源。简单来说，后台路径的作用是“标识”。\n\n**后台路径特例**\n\n* 对于后台路径的參照路径有一个特例：<font color=\"red\">当代码中使用response 的sendRedirect()方法进行重定向时，若其参照路径是以斜杠开头,则其參照路径不是web应用的根路径,而是web服务器的根路径。</font>\n  * 例如，执行response.sendRedirect(\"*/show.sp\");将 会报404错误。因为其参照路径是Tomcat的根，而非当前项目的根。所以若要使用重定向，就需要在路径上添加上项目名称: response.sendRedirect(request.getContextPath+“/show.jsp\");\n* 为什么这里是特例?\n  * 因为sendRedirect()方法可以重定向到其它应用， 若不指定要跳转的应用，其将无法确定跳转方向。\n\n#### (2) 以路径名称开头的相对路径\n\n* <font color=\"red\">以路径名称开头的相对路径</font>，无论是出现在前台页面,还是出现在后台Java 代码或配置文件中，<font color=\"red\">其参照路径都是当前访问路径的资源路径</font>。即使是response的sendRedirect()方法的参数路径,若不以斜杠开头，其也属于“以路径名称开头的相对路径”类,参照路径为当前访问路径的资源路径。\n\n#### (3) 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210213112649.png)\n\n### 2.8.4 实例\n\n* 前台路径的实例\n\n```html\n<!--\n  以斜杠开头的前台页面的静态路径是前台路径。前台路径的参照路径是当前Web服务器的根路径，\n  即：http://localhost:8080\n  绝对路径 = 参照路径+相对路径。\n  因此这个img的图片的访问路径(绝对路径)为：http://localhost:8080/images/csd.png。\n  因为images文件不在当前服务器下，因此是访问不到的。\n-->\n<img src=\"/images/csd.png\">\n<br>\n<!--\n  因此这个img的图片的访问路径(绝对路径)为：http://localhost:8080/JavaWeb1_war_exploded/images/csd.png。\n  因为JavaWeb1_war_exploded文件在Web服务器下，而images文件又在此文件下，因此这个可以访问到\n-->\n<img src=\"/JavaWeb1_war_exploded/images/csd.png\" height=\"100px\" width=\"100px\">\n<br>\n<!--\n  这个action的访问路径(绝对路径)为：http://localhost:8080/some\n  因为Web服务器的跟路径中不存在some，因此这个访问是不能被访问到的。\n-->\n<form action=\"/some\" method=\"get\">\n  名字：<input type=\"text\" name=\"name\"><br>\n  <input type=\"submit\" value=\"登录\">\n</form>\n<br>\n<!--\n  这个action的访问路径(绝对路径)为：http://localhost:8080/JavaWeb1_war_exploded/some\n  因为Web服务器的跟路径存在JavaWeb1_war_exploded项目文件，项目文件中又存在some文件，\n  因此这个访问是能被访问到的。\n-->\n<form action=\"/JavaWeb1_war_exploded/some\" method=\"get\">\n  名字：<input type=\"text\" name=\"name\"><br>\n  <input type=\"submit\" value=\"登录\">\n</form>\n```\n\n* 后台路径的实例\n\n```xml\n<!--\n  以斜杠开头的存在与xml文件或Java代码中的路径被称为后台路径。后台路径的参照路径是当前Web应用的根路径\n  即：http://localhost:8080/JavaWeb1_war_exploded\n  绝对路径 = 参照路径+相对路径。\n  因此这里的url的绝对路径是：http://localhost:8080/JavaWeb1_war_exploded/other\n  后台路径的作用是”标识“。即客户端想要访问我定义的other，那么必须提交上述的绝对路径。\n-->\n<servlet-mapping>\n  <servlet-name>other-servlet</servlet-name>\n  <url-pattern>/other</url-pattern>\n</servlet-mapping>\n```\n\n```java\n/*\n * 因此这里的访问路径(绝对路径)是：http://localhost:8080/JavaWeb1_war_exploded/other\n * 当提出此请求路径后，即可访问到other的资源。\n */\n//request.getRequestDispatcher(\"/other\").forward(request,response);\n/*\n * 特殊的是sendRedirect()方法。此方法的参照路径是Web服务器的根路径\n * 即：http://localhost:8080 与后台路径的参照路径不同。\n * 因为此方法不仅可以跳转到当前项目的资源中，还可以跳转到其他项目的资源中\n * 因此在使用此方法时，需要在访问路径前加上访问资源的项目名称。\n * 注意：只有此方法的重定向需要加上项目名称，其他的重定向方法不需要\n */\n//输出的是 /JavaWeb1_war_exploded\nSystem.out.println(request.getContextPath());\nresponse.sendRedirect(request.getContextPath() + \"/other\");\n```\n\n* 以路径名称开头的相对路径\n\n```html\n<!--\n\t这是一个”以路径名称开头的相对路径“，其参照路径是”当前访问路径的资源路径“\n\t对于初始页面index.html而言。参照路径是：http://localhost:8080/JavaWeb1_war_exploded\n\t绝对路径 = 参照路径+相对路径。\n\t此路径的访问路径(绝对路径)为:http://localhost:8080/JavaWeb1_war_exploded/images/csd.png\n\t此路径在不启动服务器时，也能访问到图片\n-->\n<img src=\"images/csd.png\" height=\"100px\" width=\"100px\">\n```\n\n```xml\n<!--\n\t此处的路径的作用是标识资源的位置，因此此处的路径只能以斜杠开头，不能省略。 \n  且当服务启动时，此处并没有参照路径的存在。\n-->\n<servlet-mapping>\n  <servlet-name>other-servlet</servlet-name>\n  <url-pattern>/other</url-pattern>\n</servlet-mapping>\n```\n\n```java\n/*\n * 这是一个以路径开头的访问路径，其参照路径是”当前当问路径的资源路径“。\n * 就本路径而言，其参照路径是：http://localhost:8080/JavaWeb1_war_exploded\n * 绝对路径 = 参照路径+相对路径。\n * 此路径的访问路径(绝对路径)为：http://localhost:8080/JavaWeb1_war_exploded/other\n */\nrequest.getRequestDispatcher(\"other\").forward(request,response);\n/*\n * 对于sendRedirect()方法完成的重定向，若参数路径不以斜杠开头，则项目名称不用写。\n * 也能完成跳转。\n */\nresponse.sendRedirect(\"other\");\n// 对于可以写斜杠，和不写斜杠的效果相同时，优先推荐写斜杠。\n//因为带斜杠的参考路径是定死的，而不写斜杠时，参考路径是变化的，可能会出错。\n```\n\n## 2.9 Servlet的线程安全问题\n\n* Servlet是在单例多线程环境下运行的。其运行可能会出现线程安全问题。\n\n### 2.9.1 线程安全问题\n\n**(1) 什么是线程安全问题**\n\n* 同时满足以下两个条件,则会出现线程安全问题。\n  * 存在多线程并发访问。\n  * 存在可修改的共享数据。\n* 当多个线程同时修改同一个共享数据时,后修改的数据会将先修改的数据覆盖,对数据先进行修改的用户读取到的不是自己修改后的数据，这就是线程安全问题。\n\n**(2) JVM中可能存在线程安全问题的数据分析**\n\n* 栈内存数据分析。\n  * 栈内存是多例的，即JVM会为每个线程创建一个栈， 所以其中的数据不是共享的。另外，方法中的局部变量存放在Stack 的栈帧中,方法执行完毕，栈帧弹栈，局部变量消失。局部变量是局部的，不是共享的。所以栈内存中的数据不存在线程安全问题。。\n* 堆内存数据分析。\n  * 一个JVM中只存在一个堆内存,堆内存是共享的。被创建出的对象是存放在堆内存的，而存放在堆内存中的对象,实际就是对象成员变量的值的集合。即成员变量是存放在堆内存的。堆内存中的数据是多线程共享的，也就是说，堆内存中的数据是存在线程安全问题的。\n* 方法区数据分析。\n  * 一个JVM中只存在一个方法区。静态变量与常量存放在方法区，方法区是多线程共享的。常量是不能被修改的量,所以常量不存在线程安全问题。静态变量是多线程共享的,所以静态变量存在线程安全问题。\n\n**(3) 线程安全问题的解决方案**\n\n* 若要解决数据的线程安全问题，则可按照下面思路考虑:\n  * 对于一般性的类,不要定义为单例的。除非项目有特殊需求,或该类对象属于重量级对象。所谓重量级对象是指，创建该类对象时需要占用较大的系统资源。\n  * 无论类是否为单例类，尽量不使用静态变量。\n  * 若需要定义为单例类,则单例类虫尽量不使用成员变量。\n  * 若单例类中必须要 使用成员变量,则对成员变量的操作，可以添加串行化锁synchronized,实现线程同步。不过，最好不要使用线程同步机制。因为一旦操作进入串行化的排队状态，将大大降低程序的执行效率。\n\n### 2.9.2  Servlet的线程安全问题\n\n* Servlet是单例多线程并发访问的，所以其就有可能会出现线程安全问题。为了避免线程安全问题的产生，对于Servlet的使用，一般是不声明成员变量的。若项目中要求必须要声明成员变量,则只能通过线程同步机制synchronized 避免。\n\n```java\n/**\n * 由于当前Servlet是单例多线程的，而且其中又存在可修改的成员变量userName\n * 所以，当前这个Servlet存在线程安全问题，即这个Servlet是线程不安全的。\n */\npublic class LoginServlet extends HttpServlet {\n  /**\n   * 成员变量\n   */\n  private String userName;\n\n  @Override\n  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    //解决方法一：不定义成员变量，定义局部变量\n    //String userName = req.getParameter(\"userName\");\n\n    //解决方法二：定义成员变量，但使用串行锁\n    synchronized (this){\n      userName = req.getParameter(\"userName\");\n      PrintWriter writer = resp.getWriter();\n      writer.append(userName);\n    }\n  }\n}\n```\n\n# 第三章 Cookie\n\n## 3.1 Cookie简介\n\n* Cookie是1993年由网景公司(Netscape) 前雇员发明的一种进行网络会话状态跟踪的技术。\n* 会话是由一组请求与响应组成,是围绕着一件相关事 情所进行的请求与响应。所以这些请求与响应之间一定是需要有数据传递的，即是需要进行会话状态跟踪的。然而HTP协议是一种无状态协议，在不同的请求间是无法进行数据传递的。此时就需要一种可以进行请求间数据传递的会话跟踪技术，而Cookie就是一种这样的技术。 \n* Cookie是由服务器生成,保存在客户端的-种信息载体。这个载体中存放着用户访问该站点的会话状态信息。只要Cookie没有被清空，或都Cookie没有失效，那么,保存在其中的会话状态就有效。\n* 用户在提交第一-次请求后，由服务器生成Cookie,并将其封装到响应头中,以响应的形式发送给客户端。客户端接收到这个响应后，将Cookie 保存到客户端。当客户端再次发送同类请求后，在请求中会携带保存在客户端的Cookie 数据,发送到服务端，由服务器对会话进行跟踪。\n* Cookie技术并不是JavaWeb开发专属技术,而是属于Web开发的技术，是所有Web开发语言均支持的技术。\n* Cookie是由若干键值对构成,这里的键一般称为name,值称为value。 Cookie 中的键值对均为字符串。\n\n## 3.2 火狐下的Cookie\n\n* 不同的浏览器，其Cookie的保存位置及查看方式是不同的。删除了某-浏览器下的Cookie,不会影响到其它浏览器中的Cookie。\n* 在火狐浏览器下可以直接查看到Cookie 的信息。查看位置在:\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222165817.png)\n\n* 打开选项后，找到隐私然后打开，就可以找到火狐浏览器对Cookie的管理了。\n\n## 3.3 JavaEE中的Cookie\n\n* 在JavaEE中的javax.servlet.http包中存在一个类Cookie ,就是用于完成会话跟踪的Cookie。其只有一个带参构造器:\n  * public Cookie(String name, String value)\n* 而HttpServletResponse中有一个方法，可以将Cookie 添加到响应头中。\n  * public void addCookie(Cookie cookie)\n* 注意，一个response中可以添加多个Cookie的键值对。\n\n**(1)默认绑定路径**\n\n* 访问路径由资源路径与资源名称构成。默认情况下，Cookie与访问路径中的资源路径(URi)绑定。只要用户发出带有绑定资源路径的请求,则在请求头部,将自动会携带与之绑定的Cookie数据。\n\n**(2)服务器生成Cookie**\n\n```java\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    //创建两个Cookie\n    Cookie cookie1 = new Cookie(\"company\", \"北京新能源\");\n    Cookie cookie2 = new Cookie(\"name\", \"asd\");\n    //设置Cookie绑定的访问路径。注意需要添加上项目名称\n    cookie1.setPath(req.getContextPath()+\"/xxx/ooo\");\n    cookie2.setPath(req.getContextPath()+\"/bbb\");\n    //设置Cookie的有效期。值为整型值，单位为秒。\n    //该值大于0，表示将Cookie存放到客户端的硬盘。\n    //该值小于0或不设置，表示将Cookie存放到浏览器的缓存中。\n    //该值等于0，表示Cookie一生成就马上失效。\n    cookie1.setMaxAge(60*60);\n    cookie2.setMaxAge(60*60*24*10);\n    //向响应中添加Cookie\n    resp.addCookie(cookie1);\n    resp.addCookie(cookie2);\n  }\n```\n\n**(3)服务端获取并解析Cookie**\n\n```java\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    //获取请求中的Cookie\n    Cookie[] cookies = req.getCookies();\n    for (Cookie cookie : cookies) {\n      System.out.println(cookie.getName() + \"  \" + cookie.getValue());\n    }\n  }\n```\n\n## 3.4 Cookie的禁用\n\n* Cookie的禁用会导致很多网站都无法正常访问。\n\n# 第四章 Session\n\n* Session,即会话,是Webj开发中的一种会话状态跟踪技术。当然,前面所讲述的Cookie也是一种会话跟踪技术。不同的是Cookie是将会话状态保存在了客户端，而Session则是将会话状态保存在了服务器端。\n* 那么，到底什么是“会话”?当用户打开浏览器，从发出第一次请求开始，一 直到最终关闭浏览器，就表示一次会话的完成。\n* Session并不是JavaWeb开发所特有的,而是整个Web开发中所使用的技术。在JavaWeb开发中，Session 是以javax.servlet.http.HttpSession的接口对象的形式出现的。\n\n## 4.1 Session的访问\n\n**(1) Session对象的创建**\n\n* 若要对Session进行操作，则可以通过HttpServletRequest的getession(方法获取。该方法具有两个重载的方法。\n* public HttpSession getSession(boolean create)\n  * 该方法用于创建Session。若参数create为true,则表示若当前没有Session,则新建一个Session,若当前存在Session 则使用当前的Session。若参数create为false 表示若当前没有Session,则直接返回null。\n* public Httpsession getSession()\n  * 该方法用于创建Session。相当于getSession(true), 即没有Session则创建新的Session。\n* 何时使用getsession(true),即getSession(),何时使用getSession(false)呢? \n* 一般情况下， 若要向Session中存放数据，则使用getSession(true),即getSessin()。意义为:若当前存在Session,则使用当前的Session;若当前不存在Session,则创建一个新的Session。因为存放数据是必须要有Session 的。\n* 若要从Session中获取数据,则一般使用getsession(fase)。意义为:若当前存在Session,则从中获取数据;若当前根本就没有Session, 那就更不可能存在Session中的数据了。无需创建一个新的Session,再从新的Session中获取数据,因为新创建的Session 中是不可能有数据的。\n\n**(2) Session的域属型空间**\n\n* Session是-一个专门用于存放数据的集合,我们一般称这个用于存放数据的内存空间为域属性空间,简称域。HttpSession 中具有三个方法，是专门用于对该域属性空间中数据进行写、读操作的。\n* public void setAttribute(String name, Object value)\n  * 该方法用于向Session的域属性空间中放入指定名称、指定值的域属性。\n* public Object getAttribute(String name)\n  * 该方法用于从Session的域属性空间中读取指定名称为域属性值。\n* public void removeAttribute(String name)\n  * 该方法用于从Session的域属性空间中删除指定名称的域属性。\n\n```java\n//获取Session\nHttpSession session = req.getSession();\n//往Session中添加域属性\nsession.setAttribute(\"name\", \"root\");\n//获取Session\nHttpSession session = req.getSession(false);\n//获取Session中的域属型\nif (session != null){\n  Object name = session.getAttribute(\"name\");\n}\n```\n\n* 注意：在使用Session时，浏览器不要禁调Cookie。\n* 多个用户均在自己的电脑上访问当前应用，发现不同用户从Session 中读取到的都是自己所提交的参数值,并没有读取到别人的参数，并没有发生“错乱”现象。这是为什么呢?\n* Web开发中的Session机制，为每个用户都分配了一个Session。即一个 用户-个Session,确切地说,是一次会话- -个Sesson对象。同一用户可以发出多个会话,即会产生多个Session\n\n## 4.2 Session的工作原理\n\n* 在服务器中系统会为每个会话维护一个Session。 不同的会话，对应不同的Session。 那么，系统是如何识别各个Session对象的?即是如何做到在同一会话过程中，一直使用的是同一个Session对象呢?。\n\n**(1) 写入Session列表**\n\n* 服务器对当前应用中的Session是以Map的形式进行管理的,这个Map称为session 列表。该Map的key为一个32位长度的随机串,这个随机串称为JSessionlD , value为Session对象的引用。\n* 当用户第一次提交请求时，服务端Servlet中执行到reguest.gesession()方法后，会自动生成一个Map.Entry对象，key 为一个根据某种算法新生成的JsessionID, value 则为新创建的HttpSession对象。\n* 注意：是在执行到reguest.gesession()方法后才生成Session对象。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222194646.png)\n\n**(2) 服务器生成并发送Cookie**\n\n* 在将Session信息写入Session列表后，系统还会自动将“JSESSIONID”作为name,这个32位长度的随机串作为value,以Cookie 的形式存放到响应报头中，并随着响应，将该Cookie发送到客户端。小\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222194943.png)\n\n**(3) 客户端接受并发送Cookie**\n\n* 客户端接收到这个Cookie 后会将其存放到浏览器的缓存中。即，只要客户端浏览器不关闭，浏览器缓存中的Cookie就不会消失。\n* 当用户提交第二次请求时，会将缓存中的这个Cookie,伴随着请求的头部信息，一块发送到服务端。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222195205.png)\n\n**(4) 从Session列表中查找**\n\n* 服务端从请求中读取到客户端发送来的Cookie, 并根据Cookie 的SSIONID的值，从Map中查找相应key对应的value,即Session对象。然后,对该Session对象的域属性进行读写操作。\n\n## 4.3 Session的失效\n\n* Web开发中引入的Session超时的概念，Session 的失效就是指Session的超时。若某个Session在指定的时间范围内一直未被访问，那么Session 将超时，即将失效。\n* 在web.xml中可以通过\\<session-config/>标签设置Session的超时时间，单位为分钟。默认Session的超时时间为30分钟。需要再次强调的是，这个时间并不是从Session被创建开始计时的生命周期时长，而是从最后一次被访问开始计时,在指定的时长内一直未被访问的时长。\n\n```xml\n<!--设置Session失效时间。单位：分钟-->\n<session-config>\n  <session-timeout>120</session-timeout>\n</session-config>\n```\n\n* 若未到超时时限，也可通过代码提前使Session 失效。Httsession 中的方法Inalide(),使得Session失效。\n  * public void invalidate()\n\n```java\n//使Session失效同时解绑所有的域属型。但失效的Session不为空\nsession.invalidate();\n```\n\n## 4.4 Cookie禁用后使用Session进行会话跟踪\n\n* 从前面Session的工作原理可知,服务器只所以可以针对不同的会话找到不同的Session,是因为Cookie完成了会话的跟踪。但是,若客户端浏览器将Cookie 禁用，那么服务器还怎样保证同一会话使用的是同一个Session 呢?\n* 若客户端浏览器禁用了Cookie, 会发现向服务器所提交的每一次请求,服务器在给出的响应中都会包含名称为JSESSIONID 的Cookie, 只不过这个Cookie 的值每一次都不同。 也就是说，只要客户端刘览器所提交的请求中没有包含JSESSIONID, 服务器就会认为这是一次新的会话的开始,就会为其生成一个Map.Entry对象，key 为新的32位长度的随机串，value为新创建的Session 会话引用。这样的话,也就无法实现会话跟踪了。\n\n**手写重写URL**\n\n* 此时仍可以通过地址栏+:jsessionid=Cookie发过来的JSESSIONID 。来跟踪对应Session的状态。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210223084707.png)\n\n* 此时将会出现一个问题：\n\n  * 假设A用浏览器登录了淘宝网站。再访问一段时间后。走开了，B又过来使用此电脑记录下了A访问电脑时的Session的JSESSIONID 。\n  * 此时B在另一台电脑上访问淘宝，然后在地址栏中加上JSESSIONID 。即可使用A的账户了。\n\n**重定向的URL重写**\n\n* 当浏览器禁掉Cookie时，重定向后的请求和重定向前的请求会是两个会话过程。\n\n```java\nString uri = req.getContextPath() + \"/otherServlet\";\n//重新编码后的uri可以解决Cookie禁用后，Session禁用的问题。但会将JSESSIONID暴露在地址栏中\nuri = resp.encodeRedirectURL(uri);\nresp.sendRedirect(uri);\n```\n\n**超链接的URL重写**\n\n```java\nresp.setContentType(\"text/html;charset=utf-8\");\nString uri = \"otherServlet\";\n//解决Cookie禁用后非重定向时的url\nuri = resp.encodeURL(uri);\nresp.getWriter().println(\"<a href='\"+uri+\"'>跳转</a>到OtherServlet\");\n```\n\n# 域属型空间范围对比\n\n* 在JavaWeb编程的API中,存在三个可以存放域属性的空间范围对象,这三个对象中所存储的域属性作用范围，由大到小分别为:\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210223122735.png)\n\n* ServletContext,即aplication,置入其中的域属性是整个应用范围的，可以完成跨会话共享数据。\n\n* HttpSession,置入其中的域属性是会话范围的，可以完成跨请求共享数据。\n\n* HttpServletRequest,置入其中的域属性是请求范围的，可以完成跨Servlet 共享数据。但这些Serlet必须在同一请求中。\n\n* 对于这三个域属性空间对象的使用原则是,在可以保证功能需求的前提下,优先使用小范围的。这样不仅可以节省服务器内存，还可以保证数据的安全性。\n\n# 第五章 监听器\n\n* 在Servlet规范中存在三大组件: Servlet 接口、Listener 接口、Filter 接口。这里要学习监听器接口Listener。 监听器是一种设计模式，是观察者设计模式的一种实现。\n\n## 5.1 设计模式\n\n**(1) 创建型**\n\n* 通过特定方式创建特定对象的设计模式。例如，工厂方法模式、单例模式等。\n\n**(2) 结构型**\n\n* 为了解决某-特定问题所搭建的特定代码结构的设计模式。例如,适配器模式、代理模式等。\n\n**(3) 行为型**\n\n* 通过构建不同的角色来完成某一特定 功能的设计模式。例如，模板方法模式、观察者摸式等。\n\n### 5.1.1 观察者设计模式\n\n* 从现实角度来说，我们每一个人都是一个观察者,同时也是一个被观察者。作为被观察者，我们会发出一些信息,观察者在接收到这些信息后,会做出相应的反映;而作为观察者，我们是可以被“被观察者”所发出的信息影响的一个被观察者，可能存在多个观察者。也就是说，一个被观察者所发出的信息，可能会影响到多个观察者。\n* 观察者设计模式，定义了一种一对多的关联关系。一个对象A与多个对象B、C. D之间建立“被观察与观察关系”。当对象A的状态发生改变时，通知所有观察者对象B、C. D，当观察者对象B、C、D在接收到A的通知后，根据自身实际情况，做出相应改变。\n* 当然，观察者与被观察者指的都是具有某一类功能的对象,所以这里的观察者与被观察者都是指的接口，而真正的观察者对象与被观察者对象，是指实现了这些接口的类的对象。\n\n**定义观察者接口**\n\n```java\npublic interface ObServer {\n  /**\n   * 处理被观察者发送来的信息\n   * @param message\n   */\n  void handleNotify(String message);\n}\n```\n\n**定义被观察者接口**\n\n```java\npublic interface ObServerable {\n  /**\n   * 添加观察者\n   * @param obServer\n   */\n  void addObServer(ObServer obServer);\n  /**\n   * 删除观察者\n   * @param obServer\n   */\n  void removeObServer(ObServer obServer);\n  /**\n   * 向观察者发送信息\n   * @param message\n   */\n  void notifyObServers(String message);\n}\n```\n\n**定义观察者**\n\n```java\n/**\n * 一号观察者\n */\npublic class FirstObServer implements ObServer{\n  @Override\n  public void handleNotify(String message) {\n    System.out.println(\"一号观察者接受到 \" + message + \"信息\");\n  }\n}\n\n/**\n * 二号观察者\n */\npublic class SecondObServer implements ObServer{\n  @Override\n  public void handleNotify(String message) {\n    System.out.println(\"二号观察者接受到 \" + message + \"信息\");\n  }\n}\n```\n\n**定义被观察者**\n\n```java\npublic class Some implements ObServerable{\n  private List<ObServer> observers;\n\n  public Some() {\n    observers = new ArrayList<>();\n  }\n\n  @Override\n  public void addObServer(ObServer obServer) {\n    observers.add(obServer);\n  }\n\n  @Override\n  public void removeObServer(ObServer obServer) {\n    observers.remove(obServer);\n  }\n\n  @Override\n  public void notifyObServers(String message) {\n    //通知每一个观察者\n    for (ObServer observer : observers) {\n      observer.handleNotify(message);\n    }\n  }\n}\n```\n\n**测试**\n\n```java\npublic static void main(String[] args) {\n  //创建多个观察者\n  ObServer first = new FirstObServer();\n  ObServer second = new SecondObServer();\n  //创建被观察者\n  ObServerable some = new Some();\n  //被观察者添加观察者\n  some.addObServer(first);\n  some.addObServer(second);\n  //被观察者向所有观察者发送消息\n  some.notifyObServers(\"全体起立\");\n  System.out.println(\"====================\");\n  //被观察者删除观察者\n  some.removeObServer(first);\n  //被观察者向所有观察者发送消息\n  some.notifyObServers(\"全体起立\");\n}\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210227185948.png)\n\n### 5.1.2 监听器设计模式\n\n* 监听器设计模式，是观察者设计模式的一种实现，它并不是23种设计模式之一。\n* 这里的监听器实际对应的就是观察者,而被监听对象，则是指被观察者。当被监听对象的状态发生改变时，也需要通知监听器，监听器在收到通知后会做出相应改变。\n* 与观察者设计模式不同的是，被监听者的状态改变,被定义为了一个对象，称为事件;被监听对象有了个新的名子,称为事件源;对监听器的通知，称为触发监听器。其实质与观察者设计模式是相同的。\n* 下面以对被监听者所执行的增删改查CURD操作进行监听为例,来演示监听器设计模式的用法。\n\n**定义事件接口**\n\n```java\n/**\n * 定义增删改查事件接口\n * C:Create 增加\n * U:Update 修改\n * R:Retrieve 检索\n * D:Delete 删除\n * 通过，对于事件对象，一般是可以事件对象中获取到事件源对象\n */\npublic interface ICurdEvent {\n  //声明事件类型\n  String CRE_EVENT = \"creat event\";\n  String UPD_EVENT = \"update event\";\n  String RET_EVENT = \"retrieve event\";\n  String DEL_EVENT = \"delete event\";\n  /**\n   *获取事件源对象\n   */\n  IListenerable getEventSource();\n  /**\n   * 获取事件类型\n   */\n  String getEventType();\n}\n```\n\n**定义监听器接口**\n\n```java\npublic interface IListener {\n  /**\n   * 处理事件\n   */\n  void handle(ICurdEvent event);\n}\n```\n\n**定义事件源接口**\n\n```java\npublic interface IListenerable {\n  /**\n   * 为事件源注册监听器\n   */\n  void setListener(IListener listener);\n  /**\n   * 触发监听器\n   */\n  void triggerListener(ICurdEvent event);\n}\n```\n\n**定义事件类**\n\n```java\npublic class CurdEvent implements ICurdEvent {\n  //事件源\n  private IListenerable eventSource;\n  //事件源执行的方法名称\n  private String methodName;\n\n  public CurdEvent() {\n  }\n\n  public CurdEvent(IListenerable eventSource, String methodName) {\n    this.eventSource = eventSource;\n    this.methodName = methodName;\n  }\n\n  @Override\n  public IListenerable getEventSource() {\n    return eventSource;\n  }\n\n  @Override\n  public String getEventType() {\n    //根据事件源所执行的不同的方法，返回不同的事件\n    String eventType = null;\n    if (methodName.startsWith(\"save\")){\n      eventType = CRE_EVENT;\n    } else if (methodName.startsWith(\"remove\")){\n      eventType = DEL_EVENT;\n    } else if (methodName.startsWith(\"modify\")){\n      eventType = UPD_EVENT;\n    } else if (methodName.startsWith(\"find\")){\n      eventType = RET_EVENT;\n    }else {\n      eventType = \"have not this event type\";\n    }\n    return eventType;\n  }\n}\n```\n\n**定义监听器**\n\n```java\npublic class CurdListener implements IListener {\n  @Override\n  public void handle(ICurdEvent event) {\n    String eventType = event.getEventType();\n    IListenerable eventSource = event.getEventSource();\n\n    System.out.print(eventSource + \"事件源执行了\");\n    if (ICurdEvent.CRE_EVENT.equals(eventType)){\n      System.out.println(\"添加操作\");\n    } else if (ICurdEvent.DEL_EVENT.equals(eventType)){\n      System.out.println(\"删除操作\");\n    } else if (ICurdEvent.RET_EVENT.equals(eventType)){\n      System.out.println(\"查询操作\");\n    } else if (ICurdEvent.UPD_EVENT.equals(eventType)){\n      System.out.println(\"修改操作\");\n    }\n  }\n}\n```\n\n**定义事件源**\n\n```java\npublic class Some implements IListenerable {\n  //声明一个监听器\n  private IListener listener;\n  @Override\n  public void setListener(IListener listener) {\n    this.listener = listener;\n  }\n\n  @Override\n  public void triggerListener(ICurdEvent event) {\n    listener.handle(event);\n  }\n  //下面的方法就是事件源的业务方法\n  public void saveStudent(){\n    System.out.println(\"向DB中插入一条数据\");\n    ICurdEvent event = new CurdEvent(this,\"saveStudent\");\n    this.triggerListener(event);\n  }\n  public void findStudent(){\n    System.out.println(\"查找DB中的数据\");\n    ICurdEvent event = new CurdEvent(this,\"findStudent\");\n    this.triggerListener(event);\n  }\n  public void removeStudent(){\n    System.out.println(\"移除了DB中的一条数据\");\n    ICurdEvent event = new CurdEvent(this,\"removeStudent\");\n    this.triggerListener(event);\n  }\n  public void modifyStudent(){\n    System.out.println(\"修改了DB的一条数据\");\n    ICurdEvent event = new CurdEvent(this,\"modifyStudent\");\n    this.triggerListener(event);\n  }\n}\n```\n\n**测试**\n\n```java\npublic static void main(String[] args) {\n  //定义监听器\n  IListener listener = new CurdListener();\n  //定义事件源\n  Some some = new Some();\n  //事件源注册监听器\n  some.setListener(listener);\n  //事件源执行业务方法\n  some.saveStudent();\n  some.findStudent();\n  some.removeStudent();\n  some.modifyStudent();\n}\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210223142833.png)\n\n## 5.2 监听器Listener\n\n### 5.2.1 Servlet中的监听器\n\n* Servlet规范中已经定义好了八个监听器接口,它们要监听的对象分别是request、session、servletContext对象，触发监听器的事件是这三个对象的创建与销毁，它们的域属性空间中属性的添加、删除、修改，及session的钝化与活化操作。\n\n* 在JavaWeb项目中使用监听器，需要在web.xml文件中对监听器进行注册。\n\n  ```xml\n  <!--注册监听器-->\n  <listener>\n    <listener-class>com.lc.Listener.MyListener</listener-class>\n  </listener>\n  ```\n\n\n**(1) ServletRequestListener**\n\n* 此监听器用于监听request请求的创建和销毁。内部有两个方法。\n\n```java\npublic class MyRequestListener implements ServletRequestListener {\n  @Override\n  public void requestDestroyed(ServletRequestEvent sre) {\n    System.out.println(\"请求对象被销毁\");\n  }\n  @Override\n  public void requestInitialized(ServletRequestEvent sre) {\n    System.out.println(\"请求对象被创建\");\n  }\n}\n```\n\n**(2) ServletRequestAttributeListener**\n\n* 此监听器用于监听request域中的域属型的添加，修改和删除。内部包含三个方法。\n\n```java\npublic class MyRequestAttributeListener implements ServletRequestAttributeListener {\n  @Override\n  public void attributeAdded(ServletRequestAttributeEvent srae) {\n    System.out.println(\"向request域中添加属性：\"+srae.getName() + \"=\" + srae.getValue());\n  }\n\n  @Override\n  public void attributeRemoved(ServletRequestAttributeEvent srae) {\n    System.out.println(\"向request域中删除属性\");\n  }\n\n  @Override\n  public void attributeReplaced(ServletRequestAttributeEvent srae) {\n    System.out.println(\"替换request域中的属性\");\n  }\n}\n```\n\n**(3) HttpSessionListener**\n\n* 此监听器用于监听创建的创建和销毁。内部有两个方法。\n\n```java\npublic class MySessionListener implements HttpSessionListener {\n  @Override\n  public void sessionCreated(HttpSessionEvent se) {\n    System.out.println(\"Session正被创建\");\n  }\n\n  @Override\n  public void sessionDestroyed(HttpSessionEvent se) {\n    System.out.println(\"Session正被销毁\");\n  }\n}\n```\n\n**(4) HttpSessionAttributeListener**\n\n* 此监听器用于监听Session域中的域属型的添加，修改和删除。内部包含三个方法。\n\n```java\npublic class MySessionAttributeListener implements HttpSessionAttributeListener {\n  @Override\n  public void attributeAdded(HttpSessionBindingEvent se) {\n    System.out.println(\"正在往Session中添加域属型\");\n  }\n\n  @Override\n  public void attributeRemoved(HttpSessionBindingEvent se) {\n    System.out.println(\"正在删除Session中的域属型\");\n  }\n\n  @Override\n  public void attributeReplaced(HttpSessionBindingEvent se) {\n    System.out.println(\"正在修改Session中的域属型\");\n  }\n}\n```\n\n**(5) ServletContextListener**\n\n* 该监听器用于完成对ServletContext 对象的创建及销毁的监听。不过需要注意，由于ServletContext在一个应用中只有一个，且是在服务器启动时创建。另外，ServletConetxt 的生命周期与整个应用的相同，所以当项目重新部署，或Tomcat正常关闭(通过stop service关闭，不能是terminate关闭)时，可以销ServletContext。\n\n```java\npublic class MyServletContextListener implements ServletContextListener {\n  @Override\n  public void contextInitialized(ServletContextEvent sce) {\n    System.out.println(\"ServletContext被创建\");\n\n  }\n  @Override\n  public void contextDestroyed(ServletContextEvent sce) {\n    System.out.println(\"ServletContext被销毁。服务器正在关闭\");\n  }\n}\n```\n\n**(6) ServletContextAttributeListener**\n\n* 该监听器用于完成对ServletContext 域中属性的添加，重置，删除的监听。\n\n```java\npublic class MyServletContextAttributeListener  implements ServletContextAttributeListener {\n  @Override\n  public void attributeAdded(ServletContextAttributeEvent scae) {\n    System.out.println(\"往ServletContext中添加域属型\");\n  }\n\n  @Override\n  public void attributeRemoved(ServletContextAttributeEvent scae) {\n    System.out.println(\"删除ServletContext中的域属型\");\n  }\n\n  @Override\n  public void attributeReplaced(ServletContextAttributeEvent scae) {\n    System.out.println(\"重置ServletContext中的域属型\");\n  }\n}\n```\n\n**(7) HttpSessionBindingListener**\n\n* 该监听器用于完成对实现类绑定到Session域中和解绑的监听。\n* 注意：\n  * 该监听器接口需要被实体类实现。即Student ,User等实体类。\n  * 该监听器不需要注册。即不需要在web.xml中配置。\n\n```java\npublic class Student implements HttpSessionBindingListener {\n  private String name;\n  private Integer age;\n  ...\n  //当当前类的对象绑定到Session时会触发该方法的执行\n  @Override\n  public void valueBound(HttpSessionBindingEvent event) {\n    System.out.println(\"Student对象放入到了Session域中\");\n  }\n  //当当前类的对象与Session解绑时会触发该方法的执行\n  @Override\n  public void valueUnbound(HttpSessionBindingEvent event) {\n    System.out.println(\"Student对象从Session域中删除\");\n  }\n}\n/*\nStudent student = new Student();\nstudent.setName(\"asd\");\nstudent.setAge(18);\n//Session绑定\nsession.setAttribute(\"student\", student);\n//Session解绑\nsession.removeAttribute(\"student\");\n*/\n```\n\n**(8) HttpSessionActivationListener**\n\n* 该监听器用于监听在Session中存放的指定类型对象的钝化与活化。\n* 钝化是指将内存中的数据写入到硬盘中，而话化是指将硬盘中的数据恢复到内存。当用户正在访问的应用或该应用所在的服务器由于种种原因被停掉,然后在短时间内又重启，此时用户在访问时session中的数据是不能丢掉的,在应用关闭之前,需要将数据写入到硬盘,在重启后应可以立即重新恢复Session中的数据。这就称为Session的钝化与活化。\n* 那么Session中的哪些数据能够钝化呢?只有存放在JVM堆内存中的实现了Serializable类的对象能够被钝化。也就是说，对于字符串常量、基本数据类型常量等存放在JVM方法区中常量池中的常量，是无法被钝化的。\n* 对干监听Session中对象数据的钝化与活化，需要注意以下几点:\n  * 该接口需要由实体类实现。即Student,User等类似的类。\n  * 实体类实现该接口时还要实现Serializable序列化接口。\n  * 该监听器不需要注册。\n\n```java\npublic class User implements HttpSessionActivationListener,Serializable {\n  private String name;\n  private String password;\n  \n  //当当前类的对象被钝化(内存中的数据写入到硬盘)时会触发该方法的执行\n  @Override\n  public void sessionWillPassivate(HttpSessionEvent se) {\n    System.out.println(\"Student对象将要被钝化\");\n  }\n  //当当前类的对象被活化(硬盘中的数据回复到内存中)时会触发该方法的执行\n  @Override\n  public void sessionDidActivate(HttpSessionEvent se) {\n    System.out.println(\"Student对象以经被活化\");\n  }\n}\n```\n\n### 5.2.2 监听器应用举例\n\n**客户端数量统计**\n\n* 要求：统计在线客户端的数量。\n* 解决方案：\n* 第一步：在服务器的全局域中创建一个Map的域属型。map中key为ip,用于区分客户端。map中value为List\\<HttpSession>,用于保存一个客户端发送的所有会话。这一步是在ServletContextListener监听器中完成的。\n\n```java\npublic class MyServletContextListener implements ServletContextListener {\n  @Override\n  public void contextInitialized(ServletContextEvent sce) {\n    //创建一个map。map的key为ip,value为该ip上发送出的所有会话对象\n    Map<String,List<HttpSession>> map = new HashMap<>();\n    ServletContext context = sce.getServletContext();\n    context.setAttribute(\"map\", map);\n  }\n}\n```\n\n* 第二步：针对请求的处理。找出当前请求的Session和IP，判断其是否要放入到全局域中的map中。这一步是在ServletRequestListener监听器中完成的。\n\n```java\npublic class MyRequestListener implements ServletRequestListener {\n\n  @Override\n  public void requestInitialized(ServletRequestEvent sre) {\n    //获取当前request\n    HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();\n    //获取当前ip\n    String IP = request.getRemoteAddr();\n    System.out.println(\"ip = \" + IP);\n\n    //获取当前session\n    HttpSession session = request.getSession();\n    //获取全局域\n    ServletContext context = sre.getServletContext();\n    //从全局域中获取map\n    Map<String, List<HttpSession>> map = (Map<String, List<HttpSession>>) context.getAttribute(\"map\");\n    //从map中获取由当前ip发出的所有Session组成的list。\n    List<HttpSession> sessions = map.get(IP);\n    //判断list是否为空。\n    if (sessions == null){\n      sessions = new ArrayList<>();\n    }\n    //遍历list是否已存在这个会话\n    for (HttpSession httpSession : sessions) {\n      if (httpSession == session){\n        return;\n      }\n    }\n\n    sessions.add(session);\n    //将变化后的list放回map中\n    map.put(IP,sessions);\n    //将变化后的map放回域中\n    context.setAttribute(\"map\",map);\n\n    //将当前IP放入到当前Session中。方便session结束时判断是否在线客户端是否改变\n    session.setAttribute(\"ip\", IP);\n  }\n}\n```\n\n* 第三步：对于每一次的会话结束(即关闭浏览器)，需要判断此次会话的客户端ip是否已经全部关闭。这一步是在HttpSessionListener监听器中完成的。\n\n```java\npublic class MySessionListener implements HttpSessionListener {\n  @Override\n  public void sessionDestroyed(HttpSessionEvent se) {\n    //获取当前sessiona\n    HttpSession session = se.getSession();\n    //获取当前ip\n    String ip = (String) session.getAttribute(\"ip\");\n    //获取全局域\n    ServletContext context = session.getServletContext();\n    //获取map\n    Map<String, List<HttpSession>> map = (Map<String, List<HttpSession>>) context.getAttribute(\"map\");\n    //获取list\n    List<HttpSession> sessions = map.get(ip);\n    //从list中删除当前session\n    sessions.remove(session);\n    //对当前ip包含的session列表进行判空处理\n    if (sessions.size() == 0){\n      map.remove(ip);\n    } else {\n      map.put(ip,sessions);\n    }\n    //将变化后的map放到全局域中\n    context.setAttribute(\"map\",map);\n  }\n}\n\n```\n\n* 第四步：页面的显示，及会话结束的方式。\n\n```java\npublic class LogoutServlet extends HttpServlet {\n  @Override\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    request.getSession().invalidate();\n  }\n}\n<body>\n  在线用户已有${applicationScope.map.size()}人数<br>\n  安全<a href=\"${pageContext.request.contextPath}/logout\">退出</a><br>\n  <c:forEach items=\"${applicationScope.map}\" var=\"entry\">\n    ${entry.key} = ${entry.value.size()}<br>\n  </c:forEach>\n</body>\n```\n\n**管理员踢出用户**\n\n* \n* \n\n\n\n# 第六章 过滤器\n\n* Filter是Servlet规范的三大组件之一。顾名思义，就是过滤。可以在请求到达目标资源之前先对请求进行拦截过滤，即对请求进行一些处理 ;也可以在响应到达客户端之前先对响应进行拦截过滤，即对响应进行一些处理。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210224093841.png)\n\n## 6.1 Filter的生命周期\n\n* Filter的生命周期与Servlet的生命周期类似，其主要生命周期阶段有四个:Filter对象的创建、Filter 对象的初始化、Filter 执行doFilter()方法，及最终Filter 对象被销毁。\n* Filter的整个生命周期过程的执行，均由Web服务器负责管理。即Filter从创建到销毁的整个过程中方法的调用，都是由Web服务器负责调用执行，程序员无法控制其执行流程。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210224094554.png)\n\n**1.Filter的简单使用**\n\n* 定义Filter\n\n```java\npublic class SomeFilter implements Filter {\n  public SomeFilter() {\n    System.out.println(\"创建SomeFilter\");\n  }\n  @Override\n  public void init(FilterConfig filterConfig) throws ServletException {\n    System.out.println(\"初始化SomeFilter\");\n  }\n  @Override\n  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n    System.out.println(\"执行了SomeFilter --before--\");\n    //下面代码的作用：将请求放行到下一个资源\n    filterChain.doFilter(servletRequest,servletResponse);\n    System.out.println(\"执行了SomeFilter --after--\");\n  }\n  @Override\n  public void destroy() {\n    System.out.println(\"销毁SomeFilter\");\n  }\n}\n```\n\n* 注册Filter\n\n```xml\n<filter>\n  <filter-name>some-fliter</filter-name>\n  <filter-class>fliters.SomeFilter</filter-class>\n</filter>\n<filter-mapping>\n  <filter-name>some-fliter</filter-name>\n  <!--配置Filter的要过滤的请求路径-->\n  <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n**2.Filter的特征**\n\n* (1) Filter 是单例多线程的。\n* (2 )Filter是在应用被加载时创建并初始化,这是与Servlet不同的地方。Servlet是在该Servlet被第一次访问时创建。Filter与Servlet的共同点是,其无参构造器与init()方法只会执行- -次。\n* (3)用户每提交- -次该Filter 可以过滤的请求，服务器就会执行一次doFilter()方法， 即doFilter()方法是可以被多次执行的。\n* (4)当应用被停止时执行destroy()方法，Filter 被销毁，即destroy()方法只会执行一次。\n* (5) 由于Filter是单例多线程的，所以为了保证其线程安全性，一般情况下是不为Filter类定义可修改的成员变量的。因为每个线程均可修改这个成员变量，会出现线程安全问题。\n\n## 6.2 FilterConfig\n\n* FilterConfig是Filter在web.xml中的配置信息。\n* FilterConfig中有四个方法。使用方式如下：\n\n```java\npublic class SecondFilter implements Filter {\n  private FilterConfig config;\n  @Override\n  public void init(FilterConfig filterConfig) throws ServletException {\n    config = filterConfig;\n  }\n  @Override\n  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n    //获取Filter名字\n    String filterName = config.getFilterName();\n    System.out.println(\"filterName = \" + filterName);\n    //获取Filter所有的初始化参数名\n    Enumeration<String> names = config.getInitParameterNames();\n    while (names.hasMoreElements()) {\n      String name = names.nextElement();\n      //获取name对应的初始化参数值\n      String value = config.getInitParameter(name);\n      System.out.println(\"initName = \" + name);\n      System.out.println(\"initValue = \" + value);\n    }\n    //获取应用全局域\n    ServletContext context = config.getServletContext();\n    System.out.println(context);\n  }\n}\n```\n\n* web.xml中的配置信息如下\n\n```xml\n<filter>\n  <filter-name>second-fliter</filter-name>\n  <filter-class>fliters.SecondFilter</filter-class>\n  <!--放置Filte的初始化参数-->\n  <init-param>\n    <param-name>name</param-name>\n    <param-value>lisi</param-value>\n  </init-param>\n  <init-param>\n    <param-name>age</param-name>\n    <param-value>18</param-value>\n  </init-param>\n</filter>\n<filter-mapping>\n  <filter-name>second-fliter</filter-name>\n  <!--配置Filter的要过滤的请求路径-->\n  <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n## 6.3 Filter的\\<url-pattern/>\n\n* 注意事项：\n  * 若Filter的url-pattern为全路径匹配方式，那么url-pattern只能写为/*，而不能写为/\n  * 当filter-mapping中不写url-pattern时，必须写Servlet-Name。此时表示的是。当访问该Servlet-Name时。过滤这个访问的请求。\n\n```xml\n<filter-mapping>\n  <filter-name>second-fliter</filter-name>\n  <!--若Filter为全路径匹配方式，那么url-pattern只能写为/*，而不能写为/-->\n  <!--<url-pattern>/</url-pattern>-->\n  <!--\n   当filter-mapping中不写url-pattern时，必须写servlet-name。\n   此时表示的是。当访问该servlet-name时。过滤这个访问的请求。\n  -->\n  <servlet-name>some-servlet</servlet-name>\n</filter-mapping>\n<servlet-mapping>\n  <servlet-name>some-servlet</servlet-name>\n  <!--\n   对于Servlet来说：\n   /*表示拦截所有资源请求。包括动态资源和静态资源。\n   /表示拦截所有资源请求。但不包括动态资源。\n  -->\n  <url-pattern>/someServlet</url-pattern>\n</servlet-mapping>\n```\n\n## 6.4 \\<dispatcher/>标签\n\n* 该标签位于filter-mapping标签下。用于对拦截的请求进行进一步的约束。\n\n  ```xml\n  <filter-mapping>\n    <filter-name>second-fliter</filter-name>\n    <url-pattern>/*</url-pattern>\n    <dispatcher>REQUEST</dispatcher>\n  </filter-mapping>\n  ```\n\n* 这个标签的取值由五个。分别是： FORWARD, REQUEST(默认值),INCLUDE, ASYNC, and ERROR。\n\n* FORWARD：当前Filter只会拦截由RequestDispatcher 的forward()方法所转发的请求。其它请求均不拦截。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210224124311.png)\n\n* INCLUDE：当前Filter只会拦截由RequestDispatcher 的include()方法所转发的请求。其它请求均不拦截。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210224124224.png)\n\n* REQUEST：当前Filter会拦截所有的请求。但不拦截forward()方法和include()方法转发的请求。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210224124507.png)\n\n* ERROR：在web.xml中可以配置错误页面\\<error-page>。当发生指定错误会跳转到错误页面。而这个跳转同样是发出的请求。若dispatcher标签设置为ERROR，则只会拦截这样的请求。\n\n## 6.5 Filter的使用\n\n* Filter可以在doFilter()方法中修改，拦截的请求和响应的数据。\n* 多个Filter同时存在时。其执行顺序与其注册的先后顺序有关。执行过程如下：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210224131110.png)\n\n## 6.6 Filter的执行原理\n\n* 一个数组与一个Map:\n  * 一个Map: Map的key为\\<url-pattern/>的值, value为Filter实例对象的引用\n  * 一个数组:存放着与请求相匹配的所有Filter\n* 执行原理:\n* 当对某资源的请求到达Web容器时，会先对请求进行解析,使用解析出的URI作为比较对象,Map中查找是否存在相匹配的key。\n  * 若存在，那么读取其value,即Filter对象的引用，将该引用存入到数组中。然后继续向后查找，直到将该Map查找完毕。这样在数组中就会存在按照查找顺序排好序的Filter引用。\n  * 数组初始化完毕后,开始按照数组元素顺序进行执行。所有数组中的Filter全部执行完毕后，再跳转到请求的目标资源。\n\n## 6.7 Filter的应用举例\n\n### 6.7.1 装饰者设计模式\n\n* Decorator Pattefn, 能够在不修改目标类也不使用继承的情况下，动态地扩展一个类的功能。它是通过创建于个包装对象，也就是装饰者来达到增强目标类的目的的。\n* 装饰者设计模式的实现有两个要求:\n  * 装饰者类与目标类要实现相同的接口，或继承自相同的抽象类。\n  * 装饰者类中要有目标类的引用作为成员变量，而具体的赋值一般通过带参构造器完成。\n* 这两个要求的目的是，在装饰者类中的方法可以调用目标类的方法，以增强这个方法。而增强的这个方法是通过重写的方式进行的增强,所以要求实现相同的接口或继承相同的抽象类。\n* 在装饰者设计模式中,装饰者类一般是不对目标类进行增强的。装饰者类作为一个基类，具体的装饰者继承自这个基类，对目标类进行具体的、单功能的增强。这样做的好处是，在很方便的情况下实现多重地，组合式地增强。\n\n### 6.7.2 应用举例\n\n* 对于请求和响应中的中文乱码问题的解决方案：\n  * 自定义一个请求的装饰者，装饰者继承装饰者基类。在装饰者中解决中文乱码的问题，并替换request请求的具体实现类为自定的装饰者类。\n* 装饰者类\n\n```java\npublic class CustomRequest extends HttpServletRequestWrapper {\n  private final String oldCharsetName = \"ISO8859-1\";\n  private final String newCharsetName = \"utf-8\";\n\n  public CustomRequest(HttpServletRequest request) {\n    super(request);\n  }\n\n  /**\n   * 将原始的map替换为新的map。\n   * 原因：原始map中的中文数据是乱码的。在解决中文乱码后放到新map中。\n   * @return\n   */\n  @Override\n  public Map<String, String[]> getParameterMap() {\n    //新建一个新map\n    Map<String, String[]> newMap = new HashMap<>();\n    //获取原始的map\n    Map<String, String[]> oldMap = super.getParameterMap();\n\n    /*   解决原始Map中的中文乱码问题    */\n    //遍历原始的map\n    try {\n      for (String key : oldMap.keySet()) {\n        //获取当前遍历key的所有值\n        String[] values = oldMap.get(key);\n        //遍历values，对每一个值的中文乱码问题解决\n        for (int i = 0; i < values.length; i++) {\n          //按当前编码将数据打散成二进制流。\n          byte[] bytes = values[i].getBytes(oldCharsetName);\n          //将二进制流按照目标编码方式进行组装\n          values[i] = new String(bytes,newCharsetName);\n        }\n        //将解决了乱码问题的数据放入到新map中\n        newMap.put(key,values);\n      }\n    } catch (UnsupportedEncodingException e) {\n      e.printStackTrace();\n    }\n    return newMap;\n  }\n\n  @Override\n  public Enumeration<String> getParameterNames() {\n    return super.getParameterNames();\n  }\n\n  @Override\n  public String[] getParameterValues(String name) {\n    Map<String, String[]> parameterMap = this.getParameterMap();\n    return parameterMap.get(name);\n  }\n\n  @Override\n  public String getParameter(String name) {\n    return this.getParameterValues(name)[0];\n  }\n}\n```\n\n* 过滤器\n\n```java\npublic void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {\n  //当只想解决post请求的中文乱码问题时\n  //req.setCharacterEncoding(\"UTF-8\");\n\n  //解决get和post请求的中文乱码问题\n  req = new CustomRequest((HttpServletRequest) req);\n  //解决get和post响应时的中文乱码问题\n  resp.setContentType(\"text/html;charset=UTF-8\");\n  chain.doFilter(req, resp);\n}\n```\n\n# 第七章 文件上传下载\n\n## 7.1什么是上传与下载\n\n* 数据上传是指客户端向服务器上传数据,客户端向服务器发送的所有请求都属于数据上传。文件上传是数据上传的一种特例，指客户端向服务器上传文件。即将保存在客户端的文件上传至服务器中一个副本，保存到服务器中。\n* 数据下载是指客户端从服务器上获取数据的过程。文件下载是数据下载的一种特例，指客户端从服务器下载文件,即将原本保存在服务器中的文件下载到到客户端中一个副本保存\n* 通常我们对服务器所发出的请求,大多是文件下载请求,从服务器中下载文本、图片、声音、视频等文件，然后由客户端浏览器对这些文件进行解析后，才可能看到这些多媒体信息。\n* 但我们这里所说的文件下载，指的是文件从服务器下载到浏览器后,浏览器并不直接解析，而是以附件的形式保存到客户端。\n* 上传与下载的文件可以是文本文件、图片、声音、视频等各种类型。\n\n## 7.2 文件的上传\n\n### 7.2.1 上传表单的要求\n\n* 文件上传要求客户端表单提交特殊的请求--- multipart请求,即包含多部分数据的请求。所以文件上传表单对于表单数据的编码类型要求,必须为mutipart/form-data 。即要为\\<fom/>标签指定enctype属性值为“mutipart/form-data”。enctype,即encoding type : 编码类型。\n\n* 由于客户端上传文件的大小是不确定的，所以HTTP协议规定，文件上传的数据要存放于请求正文中，而不能出现在URL的地址栏中，因为地址栏中可以存放的数据量太小。也就是说，文件上传的表单，必须提交POST请求，而不能提交GET请求。\t\t\n\n* multipart请求和普通请求的请求正文有些不一样\n\n  * multipart请求.其中-----------------------------22445177718463892833146896101为分隔符。\n\n  ```\n  -----------------------------22445177718463892833146896101\n  Content-Disposition: form-data; name=\"name\"\n  \n  as\n  -----------------------------22445177718463892833146896101\n  Content-Disposition: form-data; name=\"age\"\n  \n  12\n  -----------------------------22445177718463892833146896101\n  Content-Disposition: form-data; name=\"photo\"; filename=\"新建文本文档.txt\"\n  Content-Type: text/plain\n  \n  添加新的别名\n  -----------------------------22445177718463892833146896101--\n  ```\n\n  * 普通请求\n\n  ```\n  name=as&age=12\n  ```\n\n* multipart请求样式\n\n```jsp\n<%--    文件上传表单--%>\n<form action=\"${pageContext.request.contextPath}/submit\" method=\"post\" enctype=\"multipart/form-data\">\n  姓名：<input type=\"text\" name=\"name\"><br>\n  年龄：<input type=\"text\" name=\"age\"><br>\n  照片：<input type=\"file\" name=\"photo\"><br>\n  <input type=\"submit\" value=\"提交\"><br>\n</form>\n```\n\n### 7.2.3 使用第三方工具解析上传的文件\n\n* 需要两个jar包。两个jar包要一起使用。将压缩包导入到web项目下的lib文件中。\n  * [fileupload](https://plumriver.lanzous.com/iK0wcm3uhob)\n  * [io](https://plumriver.lanzous.com/isPGVm3uqkb)\n\n**基础的代码**\n\n```java\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n  boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n  //判断请求是否是Multipart请求\n  if (!isMultipart){\n    throw new RuntimeException(\"当前请求不支持文件上传\");\n  }\n  try {\n    //创建一个FileItem工厂\n    DiskFileItemFactory factory = new DiskFileItemFactory();\n    //创建一个文件上传的核心组件\n    ServletFileUpload upload = new ServletFileUpload(factory);\n    //获取请求的正文信息的文件项\n    List<FileItem> items = upload.parseRequest(request);\n    //遍历文件项\n    for (FileItem item : items) {\n      if (item.isFormField()) {\n        //若文件为普通表单项。例如name=xx\n\n        //获取表单项名称。即name\n        String fieldName = item.getFieldName();\n        //获取表单项的值。即xx\n        String value = item.getString();\n        System.out.println(fieldName + \" = \" + value);\n      }else{\n        //若item为文件表单项\n\n        //获取上传的文件名\n        String fileName = item.getName();\n        //获取上传文件的输入流\n        InputStream is = item.getInputStream();\n        //定义服务器接收文件的路径\n        String path = this.getServletContext().getRealPath(\"/file\");\n        //创建文件路径\n        File fileDirectory = new File(path);\n        if (!fileDirectory.exists()){\n          fileDirectory.mkdirs();\n        }\n        //创建接收文件的对象\n        File descFile = new File(path,fileName);\n        //创建接收文件的输出流\n        FileOutputStream os = new FileOutputStream(descFile);\n        //将上传的文件写道服务器中\n        byte[] bytes = new byte[1024];\n        int len = -1;\n        while ((len = is.read(bytes)) != -1){\n          os.write(bytes,0,len);\n        }\n        //关闭输入输出流\n        os.close();\n        is.close();\n      }\n    }\n  } catch (FileUploadException e) {\n    e.printStackTrace();\n  }\n}\n```\n\n**解决上传缓冲文件**\n\n* 在创建一个FileItem工厂后添加下面代码\n\n```java\n//2.设置临时文件的边界值.\n//大于该值，上传文件会先保存在临时文件中，否则直接保存在服务器中。单位：字节。\nfactory.setSizeThreshold(1024*1024*1);\n//3.设置临时文件路径\nString tempPath = this.getServletContext().getRealPath(\"/temp\");\nFile tempFile = new File(tempPath);\nif (!tempFile.exists()){\n  tempFile.mkdirs();\n}\nfactory.setRepository(tempFile);\n\n//在关闭流操作添加下面代码\n//8.删除临时文件\nitem.delete()\n```\n\n**解决上传时的中文乱码**\n\n* 在基础代码上修改为下面代码\n\n```java\n//设置每一个item的头部字符编码，其可以解决文件名的中文乱码问题。\nupload.setHeaderEncoding(\"UTF-8\");\n//获取表单项的值,以指定的字符串编码。即xx\nString value = item.getString(\"UTF-8\");\n```\n\n**解决上传多个文件，对单个文件和总量的限制**\n\n* 在创建文件上传的核心组件后添加如下代码\n\n```java\n//设置上传单个文件的最大边界值为2M\nupload.setFileSizeMax(1024*1024*2);\n//设置多个文件上传时的总和最大值为5M(只对上传多个文件时起效)\n//注意此时\nupload.setSizeMax(1024*1024*5);\n```\n\n**解决上传文件存放的目录管理问题**\n\n* 以年月日分级存放文件。在定义服务器接收文件的路径后添加如下代码\n\n```java\n//获取当前系统时间\nCalendar now = Calendar.getInstance();\n//获取年月日\nint year = now.get(Calendar.YEAR);\nint month = now.get(Calendar.MONTH)+1;\nint day = now.get(Calendar.DAY_OF_MONTH);\n\npath = path + \"/\" + year + \"/\" + month + \"/\" + day;\n```\n\n## 7.3 文件的下载\n\n**超链接方式的文件下载**\n\n```jsp\n<%--超链接方式的文件下载--%>\n<a href=\"${pageContext.request.contextPath}/resources/aaa.jpg\"/><br>\n<a href=\"${pageContext.request.contextPath}/resources/bbb.jar\"/><br>\n<a href=\"${pageContext.request.contextPath}/resources/ccc.zip\"/><br>\n<a href=\"${pageContext.request.contextPath}/resources/ddd.exe\"/><br>\n<a href=\"${pageContext.request.contextPath}/resources/eee.txt\"/><br>\n```\n\n* 缺点：\n  * 下载文件的打开方式由浏览器决定。和服务器无关。(一般来说浏览器能解析的会在浏览器直接打开，浏览器无法解析的会另存为本地磁盘中)\n\n**正常的文件下载**\n\n* 实现下载的文件都以附件的方式保存在磁盘中\n  * 以get提交。\n\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n  //防止文件名出现中文乱码问题\n  String filename = \"车.jpg\";\n  //打散\n  byte[] filenameBytes = filename.getBytes(\"UTF-8\");\n  //组装\n  filename = new String(filenameBytes,\"ISO8859-1\");\n\n  //修改响应的头部属性content-disposition值为attachment\n  //同时设置文件名。\n  response.setHeader(\"content-disposition\",\"attachment;filename=\" + filename);\n\n  //获取服务端资源文件的输入流\n  InputStream is = this.getServletContext().getResourceAsStream(\"/resources/aaa.jpg\");\n  //获取输出流\n  ServletOutputStream os = response.getOutputStream();\n\n  int len = -1;\n  byte[] bytes = new byte[1024];\n  while ((len = is.read(bytes)) != -1){\n    os.write(bytes,0,len);\n  }java\n\n    os.close();\n  is.close();\n}\n```\n\n# 第八章 Servlet3.0\n\n* 往前的Servlet版本为Servlet2.5\n* Servlet3.0规范是JavaEE6.0规范中的子规范。其要求运行环境最低是JDK6.0, Tomcat7.0\n* 而之前学习的是Servlet2.5版本的规范，其是JavaEE5.0规范的子规范。其要求运行环境最低是JDK5.0, Tomcat5.0\n\n## 8.1 Servlet3.0的注解\n\n*\tServlet3.0规范中允许在定义Serf/let、 Filter 与Listener 三大组件时使用注解，而不用在Web.xml进行注册了。Servlet3.0规范允许项目没有web.xml配置文件。\n\n### 8.1.1 Servlet注解\n\n*\tServlet3.0规范中使用@WebServlet()注解来注册当前的Servlet类。该注解具有多个属性,常用属性的类型与意义如下表所示:\n\n|       属性        |      类型      |                             作用                             |\n| :---------------: | :------------: | :----------------------------------------------------------: |\n|       name        |     String     |       表示Servlet的名字name。相当于\\<servlet-name>标签       |\n| value/urlPatterns |    String[]    |   表示此Servlet要匹配的请求路径。相当于\\<url-pattern>标签    |\n|   loadOnStartup   |      int       |    表示此Servlet创建的级别。相当于\\<load-on-startup>标签     |\n|    initParams     | WebInitParam[] | 表示此Servlet的初始化参数。注意值为注解数组。相当于\\<init-param>标签 |\n\n* 对应的使用方法\n\n```java\n@WebServlet(value = {\"/someServlet\",\"/xxx\"},\n            name = \"some-servlet\",\n            initParams = {@WebInitParam(name = \"name\",value = \"cl\"),\n                          @WebInitParam(name = \"age\",value = \"18\")},\n            loadOnStartup = 1\n           )\npublic class SomeServlet extends HttpServlet {\n  public SomeServlet() {\n    System.out.println(\"创建SomeServlet\");\n  }\n  @Override\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    PrintWriter writer = response.getWriter();\n    //获取servletName\n    String servletName = this.getServletName();\n    writer.println(servletName);\n    //获取初始化参数\n    Enumeration<String> names = this.getInitParameterNames();\n    while (names.hasMoreElements()) {\n      String name = names.nextElement();\n      String value = this.getInitParameter(name);\n      writer.println(name + \" = \" + value);\n    }\n  }\n}\n```\n\n### 8.1.2 Filter注解\n\n* Servlet3.0规范中使用@WebFilter()注解来注册当前的Filter类。该注解具有多个属性,常用属性的类型与意义如下表所示:\n\n|       属性        |       类型       |                         作用                         |\n| :---------------: | :--------------: | :--------------------------------------------------: |\n|    filterName     |      String      |    表示Filter的名字name。相当于\\<filter-name>标签    |\n|    initParams     |  WebInitParam[]  |   表示Filter的初始化参数。相当于\\<init-param>标签    |\n|   servletNames    |     String[]     | 表示Filter的过滤的Servlet。相当于\\<servlet-name>标签 |\n| value/urlPatterns |     String[]     |  表示Filter的过滤请求路径。相当于\\<url-pattern>标签  |\n|  dispatcherTypes  | DispatcherType[] | 表示Filter的过滤的请求类型。相当于\\<dispatcher>标签  |\n\n* 使用方式：\n\n```java\n//@WebFilter(servletNames = \"some-servlet\")\n@WebFilter(value = \"/*\",dispatcherTypes = DispatcherType.FORWARD)\npublic class SomeFilter implements Filter {\n  @Override\n  public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {\n    System.out.println(\"==========拦截前\");\n    chain.doFilter(req, resp);\n    System.out.println(\"==========拦截后\");\n  }\n}\n```\n\n### 8.1.3 Listener注解\n\n* Servlet3.0规范中使用@WebListener()注解来注册当前的Listener类.使用如下\n\n```java\n@WebListener()\npublic class SomeListener implements ServletContextListener{}\n```\n\n### 8.1.4 Servlet3.0中的web.xml\n\n* 当web应用程序中即存在注解的注册，又存在web.xml中的注册。对于不同的组件会出现不同的效果。\n* 若对于Servlet采用了两种方式同时进行注册，则需要注意:\n  * 1.若两种方式的url-pattern值相同，则应用无法启动。\n  * 2.若两种方式的url-pattern值不同，那么相当于该Servlet具有两个url-pattern。\n* 若对于Filter采用了两种方式同时进行注册，则需要注意:\n  * 无论url-pattern的值是否相同，其都是作为两个独立的Filter出现的。\n* 若对于Listener采用了两种方式同时进行注册，则需要注意:\n  * 若对于Listener采用了两种方式同时进行注册，其仅仅是相当于一个Listener。\n* 除了上述的情况注意web.xml的头文件的属性信息。\n\n```xml\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\" metadata-complete=\"true\">\n<!--\n<web-app/>中的属性metadata- complete的值\n若为true,则表示对三大组件的注册方式，只有web.xml中的注册起作用，将忽略注解的注册。\n若为false,则表示两种注册方式同时起作用。默认为false\n-->\n</web-app>\n```\n\n## 8.2 Servlet3.0的文件上传\n\n* Servlet3.0提供了专门的文件上传API。HttpServletRequest中的getPart()方法可以完成单个文件上传，而getParts()方法可以完成多个文件上传。注意，这两个方法是从Servlet3.0开始定义的。\n* 使用步骤：\n  * 1.在页面中添加multipart上传。\n  * 2.在Servlet上添加MultipartConfig注解。用于表示当前Servlet可以处理Multipart请求。\n  * 3.创建服务器保存上传文件的目录路径\n  * 4.获取上传文件的数据\n  * 5.解析上传文件的原始名字\n  * 6.写入服务器\n* 上传页面代码\n\n```jsp\n<%--    文件上传表单--%>\n<form action=\"${pageContext.request.contextPath}/submitServlet\" method=\"post\" enctype=\"multipart/form-data\">\n  姓名：<input type=\"text\" name=\"name\"><br>\n  年龄：<input type=\"text\" name=\"age\"><br>\n  照片：<input type=\"file\" name=\"file\"><br>\n  <input type=\"submit\" value=\"提交\"><br>\n</form>\n```\n\n* 处理上传请求的代码\n\n```java\n@WebServlet(value = \"/submitServlet\",name = \"submit-servlet\")\n@MultipartConfig\npublic class SubmitServlet extends HttpServlet {\n  @Override\n  protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    //创建服务器保存上传文件的目录路径\n    String path = this.getServletContext().getRealPath(\"/file\");\n    File dirFile = new File(path);\n    if (!dirFile.exists()){\n      dirFile.mkdirs();\n    }\n    //获取multipart请求中指定属性名字的上传文件的\"部分数据\"对象。\n    Part part = request.getPart(\"file\");\n\n    //解析除原始文件名。\n    //获取请求中的指定的头部信息\n    String header = part.getHeader(\"Content-Disposition\");\n    int start = header.indexOf(\"filename=\");\n    String fileName = header.substring(start + 10, header.length() - 1);\n\n    //完成文件上传。将上传文件以xxx.txt的方式存放在path路径下\n    part.write(path+\"/\"+fileName);\n  }\n}\n```\n\n## 8.3 Servlet3.0的异步处理\n\n* 这里的异步处理，是指服务端的异步处理，与AJAX是没有关系的。AIAX 是客户端的异步处理。\n\n### 8.3.1 为什么使用Servlet异步\n\n* Servlet是单例多线程的。当一个请求到达服务器后,服务器会马上为该请求创建一个相应的Servlet 线程,为该请求服务。那么,一个请求就一定会有一个Servlet线程为之服务吗?\n* 答案是否定的。服务器会为每一个Servlet实例创建一个Servlet线程池,而线程池中该Servlet实例的线程对象并不是“取之不尽”的，而是有上限的。当达到该上限后，再有请求要访问该Servlet，那么该请求就只能等待了。只有当又有了空闲的Servlet线程对象后才能为该请求分配Servlet线程对象。\n* 对于Servlet来说，其最典型的工作一般分为三步:\n  * 接收并解析用户请求。\n  * 根据用户请求调用Service层代码进行计算。\n  * 将计算结果响应给客户端。\n\n### 8.3.2 Servlet异步的实现\n\n* Servlet主线程代码\n\n```java\n//asyncSupported = true表示当前Servlet支持异步操作\n@WebServlet(value = \"/first\",asyncSupported = true)\npublic class FirstServlet extends HttpServlet {\n  @Override\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    response.setContentType(\"text/html;charset=UTF-8\");\n    //获取异步上下文对象\n    AsyncContext asyncContext = request.startAsync();\n    //创建耗时的子线程\n    FirstThread firstThread = new FirstThread(asyncContext);\n    //2.设置异步上下文对象的超时时限。默认的超时时限是30秒\n    //当超时时，子线程的响应和请求将被结束。\n    //asyncContext.setTimeout(5000);\n\n    //为异步操作添加异步监听器\n    asyncContext.addListener(new AsyncListener() {\n      @Override\n      public void onComplete(AsyncEvent event) throws IOException {\n        System.out.println(\"异步操作完成时触发\");\n\n      }\n\n      @Override\n      public void onTimeout(AsyncEvent event) throws IOException {\n        System.out.println(\"异步操作超时时触发\");\n      }\n\n      @Override\n      public void onError(AsyncEvent event) throws IOException {\n        System.out.println(\"异步操作错误时触发\");\n      }\n\n      @Override\n      public void onStartAsync(AsyncEvent event) throws IOException {\n        System.out.println(\"异步操作启动时触发\");\n      }\n    });\n    //开启异步上下文对象\n    asyncContext.start(firstThread);\n  }\n}\n```\n\n* 子线程代码\n\n```java\npublic class FirstThread implements Runnable{\n  private AsyncContext asyncContext;\n\n  public FirstThread(AsyncContext asyncContext) {\n    this.asyncContext = asyncContext;\n  }\n\n  @Override\n  public void run() {\n    try {\n      HttpServletRequest request = (HttpServletRequest) asyncContext.getRequest();\n      HttpSession session = request.getSession();\n\n      int sum = 0;\n      sum = 0;\n      for (int i = 0; i < 10; i++) {\n        System.out.println(\"i ======\" + i);\n        sum = sum + i;\n        Thread.sleep(1000);\n      }\n      //将子线程的结果放到session中\n      session.setAttribute(\"message\", sum);\n      //1.通知主线程：子线程执行完毕\n      //asyncContext.complete();\n\n      //3.dispatch()方法相当于请求转发的include()操作。可以结束子线程的请求与响应对象\n      asyncContext.dispatch(\"/show.jsp\");\n\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n```\n\n### 8.3.3 异步的注意事项\n\n* 当Servlet接收到用户的请求后，开启了一个很耗时的子线程。\n  * 再不做异步处理时，浏览器会接收到servlet线程的结果，但由于子线程很耗时。并不能接受到子线程的结果。\n* 使用异步处理的步骤\n  * 1.配置Servlet的asyncSupported = true。以支持异步操作\n  * 2.在servlet中获取异步上下文对象。\n  * 2.在servlet中创建以“异步上下文对象”为参数的子线程对象。\n  * 3.在servlet中调用start()方法开启异步上下文。\n  * 4.结束子线程。\n* 在异步处理中。对异步对象ac的结束方式如下：\n  * 1.在异步子线程中使用ac. complete()方法:该方法用于结束异步操作，并将与当前异步对象相关的request与response对象销毁。\n  * 在异步子线程中使用ac .dispatch(path)方法:该方法在结束异步操作的同时,会将参数所指定的页面内容包含到当前异步对象相关的标准输出流中。其执行效果相当于RequestDispatcher对象的include(path )方法的执行效果。\n  * 在异步Servlet主线程中通过ac.setTimeout()设置ac的超时时限，当超时时限到达时，异步对象及其相关的request与response对象销毁。\n* 在异步处理时，不推荐使用request和response对象。但可以使用类似session之类的对象。可以把子线程的结果放进入。能够方便用户体验。\n* 对于异步操作可以添加<font color=\"red\">监听器</font>。\n\n## 8.4 Servlet3.0的组件可插性\n\n* 所谓组件可插性是指，JavaEE6.0 项目支持将打为Jar 包的Servlet、Filter、 Listener 直接插入到正在运行的Web项目中。当然，这些Jar包中同时包含有相应的配置文件。\n* [视频地址](https://www.bilibili.com/video/BV18z411i7gh?p=211)\n\n## 8.5 Servlet3.0的三大组件动态注册\n\n* Servlet的三大组件的三大注册方式\n  * 通过web.xml注册。\n  * 通过注解注册。\n  * 动态注册。\n* Servlet3.0对于ServletContext进行了功能增强，可以对Servlet、Filter及Listener进行动态注册。所谓动态注册是指，Web应用在运行过程中通过代码对Servlet、 Filter 或Listener进行注册。\n* 为了系统安全考虑，这个动态注册是有限制的:只能在应用启动时进行，而不能在应用运行过程中的进行注册。这个应用启动时间点，可以通过ServletContextListener监听器来把握。\n\n**Servlet动态注册**\n\n* 未注册的Servlet类\n\n```java\npublic class DynamicServlet extends HttpServlet {\n  @Override\n  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    resp.setContentType(\"text/html;charset=UTF-8\");\n    PrintWriter out = resp.getWriter();\n    out.println(\"DynamicServlet已被动态注册\");\n  }\n}\n```\n\n* 在ServletContextListener监听器的实现类中动态注册\n\n```java\n//一个servlet的名字，一个servlet的类路径。一般从配置文件中获取\n//注意：当servletName设置为some-servlet时会注册不成功。dynamic对象为null\nString servletName = \"dynamicServlet\";\nString className = \"com.lc.mode3.DynamicServlet\";\n//动态注册Servlet\nServletRegistration.Dynamic dynamic = context.addServlet(servletName, className);\n\n//给servlet添加初始化信息\ndynamic.setInitParameter(\"name\", \"cl\");\n\n//给servlet添加url-pattern信息\ndynamic.addMapping(\"/dynamic\");\n```\n\n**Filter动态注册**\n\n* 未注册的Filter类\n\n```java\npublic class DynamicFilter implements Filter {\n  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    System.out.println(\"过滤器前\");\n    chain.doFilter(request,response);\n    System.out.println(\"过滤器后\");\n  }\n}\n```\n\n* 在ServletContextListener监听器的实现类中动态注册\n\n```java\nString filterName = \"dynamicFilter\";\nString filterClassName = \"com.lc.mode3.DynamicFilter\";\nFilterRegistration.Dynamic filterDynamic = context.addFilter(filterName, filterClassName);\n//配置当前filter的配置信息\n//true表示对于相同url先执行其他filter在执行此filter.false则相反\nfilterDynamic.addMappingForServletNames(EnumSet.of(DispatcherType.REQUEST),true,\"dynamicServlet\");\n```\n\n**Listener动态注册**\n\n* 未注册的Listener类\n\n```java\npublic class DynamicListener implements ServletRequestListener {\n  @Override\n  public void requestInitialized(ServletRequestEvent sre) {\n    System.out.println(\"**********\");\n  }\n}\n```\n\n* 在ServletContextListener监听器的实现类中动态注册\n\n```java\nString listenerClassName = \"com.lc.mode3.DynamicListener\";\ncontext.addListener(listenerClassName);\n```\n\n\n\n\n\n\n\n\n\n","categories":["Java学习","前端"]},{"title":"tomcat配置","url":"/2021/03/14/工具的使用/IDEA/tomcat/","content":"\n启动虚拟机在控制台乱码，输入下面在配置tomcat时jvm的参数\n\n<!--more-->\n* JVM:   -Dfile.encoding=UTF-8","categories":["工具的使用","IDEA"]},{"title":"Mybatis知识总结","url":"/2021/03/09/尚硅谷说Java/JavaEE框架/Mybatis/","content":" \n\nMybatis的使用，配置文件解析，mapper文件解析，动态SQL，日志，分页功能，\nLombok插件的使用\n\n<!--more-->\n\n\n* mybatis版本：3.5.2\n* mybatis中文官网：https://mybatis.org/mybatis-3/zh/index.html\n\n# 第一章 Mybatis简介\n\n* MyBatis 是一款优秀的**持久层框架**\n* 它支持定制化 SQL、存储过程以及高级映射。\n* MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。\n* MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n* MyBatis 本是[apache](https://baike.baidu.com/item/apache/6265)的一个开源项目[iBatis](https://baike.baidu.com/item/iBatis), 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。\n* 2013年11月迁移到Github。\n* mybatis的maven仓库\n\n```xml\n<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis</artifactId>\n    <version>3.5.2</version>\n</dependency>\n```\n\n* 持久化：指将程序的数据在持久状态和瞬时状态转化的过程。即数据在外存和内存之间的转换。\n* 持久层：指完成持久化工作的代码块，一般指三层架构中的dao层。\n\n**Mybatis的优点**\n\n* 简单易学，灵活。\n* sql和代码的分离，提高了可维护性。\n* 提供映射标签，支持对象与数据库的orm字段关系映射\n* 提供对象关系映射标签，支持对象关系组建维护\n* 提供xml标签，支持编写动态sql。\n\n# 第二章 Mybatis的简单使用\n\n* 步骤：搭建环境--->导入Mybatis--->编写代码--->测试\n\n## 2.1 搭建环境\n\n* 搭建数据库\n\n```sql\nCREATE DATABASE `mybatis`;\n\nuse `mybatis`;\n\nCREATE TABLE `user` (\n`id` int(20) not null primary key,\n`name` varchar(30) default null,\n`pwd` varchar(30) default NULL\n)ENGINE=INNODB default CHARSET=utf8;\n\ninsert into `user`(`id`,`name`,`pwd`) values\n(1,'qw','qw'),\n(2,'as','as'),\n(3,'zx','zx');\n```\n\n* 新建maven项目。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210306195950.png)\n\n* 导入Mybatis依赖\n\n```xml\n<!--导入依赖-->\n<dependencies>\n  <!--mysql驱动：用于连接数据库-->\n  <dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>5.1.47</version>\n  </dependency>\n  <!--mybatis-->\n  <dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis</artifactId>\n    <version>3.5.2</version>\n  </dependency>\n  <!--junit：测试使用-->\n  <dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.12</version>\n  </dependency>\n</dependencies>\n```\n\n## 2.2 编写代码\n\n* 项目架构\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210307155052.png)\n\n* 配置mybatis配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n    PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n    \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<!--Mybatis核心配置文件-->\n<configuration>\n  <!--配置环境。及默认使用的环境-->\n  <environments default=\"development\">\n    <!--开发使用的环境-->\n    <environment id=\"development\">\n      <!--事务管理器-->\n      <transactionManager type=\"JDBC\"/>\n      <!--配置数据源-->\n      <dataSource type=\"POOLED\">\n        <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n        <!--useSSL=true表示安全连接，&amp表示转义字符&，useUnicode=true表示中文使用字符编码，characterEncoding=UTF-8表示编码格式是UTF-8-->\n        <!--mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8-->\n        <property name=\"url\"\n                  value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=false\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"root\"/>\n      </dataSource>\n    </environment>\n    <!--测试使用的环境-->\n    <environment id=\"test\">\n      <transactionManager type=\"JDBC\"/>\n      <dataSource type=\"POOLED\">\n        <property name=\"driver\" value=\"${driver}\"/>\n        <property name=\"url\" value=\"${url}\"/>\n        <property name=\"username\" value=\"${username}\"/>\n        <property name=\"password\" value=\"${password}\"/>\n      </dataSource>\n    </environment>\n  </environments>\n\n</configuration>\n```\n\n* 工具类\n\n```java\n/**\n * 用于获取mybatis的sqlSession实例的工具类\n */\npublic class MybatisUtil {\n  private static SqlSessionFactory factory;\n  static {\n    try {\n      //根路径在项目的resources目录下。\n      String resource = \"mybatis-config.xml\";\n      //加载mybatis的配置文件\n      InputStream inputStream = Resources.getResourceAsStream(resource);\n      //获取sqlSession工厂对象。\n      factory = new SqlSessionFactoryBuilder().build(inputStream);\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n\n  /**\n   * 从工厂对象中创建sqlSession实例，并返回。\n   * @return\n   */\n  public static SqlSession getSqlSession(){\n    return factory.openSession();\n  }\n\n}\n```\n\n* 实体类\n\n```java\npublic class User {\n  private int id;\n  private String name;\n  private String pwd;\n\n  public User() {\n  }\n\n  public User(int id, String name, String pwd) {\n    this.id = id;\n    this.name = name;\n    this.pwd = pwd;\n  }\n\n  public int getId() {\n    return id;\n  }\n\n  public void setId(int id) {\n    this.id = id;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPwd() {\n    return pwd;\n  }\n\n  public void setPwd(String pwd) {\n    this.pwd = pwd;\n  }\n\n  @Override\n  public String toString() {\n    return \"User{\" +\n        \"id=\" + id +\n        \", name='\" + name + '\\'' +\n        \", pwd='\" + pwd + '\\'' +\n        '}';\n  }\n}\n```\n\n* dao层接口\n\n```java\npublic interface UserDao {\n  /**\n   * 查询所有数据\n   * @return\n   */\n  List<User> selectAll();\n}\n```\n\n* dao接口实现类-->mybatis中以mapper.xml配置文件的方式代替了接口实现类\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!--namespace：命名空间。一个mapper.xml文件对应一个dao层接口-->\n<mapper namespace=\"com.lc.dao.UserDao\">\n<!--select查询语句：id表示对应接口的方法名，resultType表示返回值类型-->\n  <select id=\"selectAll\" resultType=\"com.lc.pojo.User\">\n    select * from mybatis.user\n  </select>\n</mapper>\n```\n\n## 2.3 测试\n\n* 测试代码\n\n```java\n@Test\npublic void test1(){\n  //第一步：获取sqlSession对象。\n  SqlSession sqlSession = MybatisUtil.getSqlSession();\n\n  //第二步：执行数据访问操作。\n  //方式一：\n  UserDao userDao = sqlSession.getMapper(UserDao.class);\n  List<User> users = userDao.selectAll();\n  for (User user : users) {\n    System.out.println(user);\n  }\n  //方式二：不推荐使用\n  //List<Object> list = sqlSession.selectList(\"com.lc.dao.UserDao.selectAll\");\n\n  //第三步：关闭sqlSession对象。\n  sqlSession.close();\n}\n```\n\n* 测试结果\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210306213002.png)\n\n## 2.4 总结\n\n* **SqlSession** 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。\n* 命名空间的作用有两个，一个是利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。\n* **命名解析：**为了减少输入量，MyBatis 对所有具有名称的配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。\n  - 全限定名（比如 “com.mypackage.MyMapper.selectAllThings）将被直接用于查找及使用。\n  - 短名称（比如 “selectAllThings”）如果全局唯一也可以作为一个单独的引用。 如果不唯一，有两个或两个以上的相同名称（比如 “com.foo.selectAllThings” 和 “com.bar.selectAllThings”），那么使用时就会产生“短名称不唯一”的错误，这种情况下就必须使用全限定名。(不推荐使用)\n* 每个线程都有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的。\n  * 每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 \n  * 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 \n\n* 可能会遇到的问题\n  * 配置文件没有注册\n  * 绑定接口错误。\n  * 方法名不对\n  * 返回类型不对\n  * Maven导出资源问题\n\n## 2.5 Mybatis的生命周期和作用域\n\n* Mybatis中有三个核心类\n\n  * SqlSessionFactoryBuilder\n  * SqlSessionFactory\n  *  SqlSession\n\n* Mybatis的使用步骤\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210307160029.png)\n\n**SqlSessionFactoryBuilder**\n\n* 作用：通过mybatis配置文件来创建SqlSessionFactory。\n* 这个类可以被实例化、使用和丢弃，但一旦创建了 SqlSessionFactory，就不再需要它了。\n* SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。\n\n**SqlSessionFactory**\n\n* 作用：创建，管理SqlSession。相当于一个工厂或连接池。\n* SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在。\n* 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次。\n*  SqlSessionFactory 的最佳作用域是应用作用域。\n* 使用单例模式或者静态单例模式就可以实现它的作用域和生命周期。\n\n **SqlSession**\n\n* 作用：java和数据库之间的连接。\n* 每个线程都有它自己的 SqlSession 实例。因此每一次执行sql语句后都要关闭它。\n* 最佳的作用域是请求或方法作用域。\n\n# 第三章 实现CRUD操作\n\n## 3.1 基础的CRUD操作\n\n* mapper文件中对应的sql操作要在对应的标签中进行。\n* 对于每一个sql的执行，都需要提交事务。\n  * 因为查询语句没有对数据库进行改变，因此查询语句可以不提交事务。\n* 增删改的默认返回类型是int，表示受影响的数据行数。可以不写resultTypr。\n\n### 3.1.1 select\n\n```xml\n<select id=\"selectUser\" parameterType=\"integer\" resultType=\"com.lc.pojo.User\">\n  select * from mybatis.user where id=#{id}\n</select>\n```\n\n### 3.1.2 insert\n\n```xml\n<insert id=\"insertUser\" parameterType=\"com.lc.pojo.User\">\n  insert into mybatis.user(id, name, pwd) VALUES (#{id},#{name},#{pwd});\n</insert>\n```\n\n### 3.1.3 update\n\n```xml\n<update id=\"updateUser\" parameterType=\"com.lc.pojo.User\">\n  update mybatis.user set name=#{name},pwd=#{pwd} where id=#{id};\n</update>\n```\n\n### 3.1.4 delete\n\n```xml\n<delete id=\"deleteUser\" parameterType=\"integer\">\n  delete from mybatis.user where id=#{id}\n</delete>\n```\n\n**测试**\n\n```java\n@Test\npublic void test2(){\n  SqlSession sqlSession = MybatisUtil.getSqlSession();\n  UserDao userDao = sqlSession.getMapper(UserDao.class);\n\n  // 增\n  //    int insertUser = userDao.insertUser(new User(4, \"op\", \"op\"));\n  //    System.out.println(insertUser);\n\n  // 删\n  //    int deleteUser = userDao.deleteUser(4);\n  //    System.out.println(deleteUser);\n\n  // 改\n  //    int updateUser = userDao.updateUser(new User(3, \"asdf\", \"asdf\"));\n  //    System.out.println(updateUser);\n\n  // 查\n  User user = userDao.selectUser(3);\n  System.out.println(user);\n\n  //提交事务\n  sqlSession.commit();\n  sqlSession.close();\n}\n```\n\n## 3.2 标签解释\n\n* mapper文件，标签解析\n  * select：用于执行查询SQL语句\n  * insert：用于执行插入SQL语句\n  * update：用于执行更新SQL语句\n  * delete：用于执行删除SQL语句\n* mapper文件，属性解析\n  * id：表示为此标签起名字，但select等标签的id一定要对应接口的方法名。\n  * resultType：sql语句执行的返回值。\n    * 对于返回值是数组和list类型，resultType的值是数组或list的基本数据类型的全称类路径。\n    * 对于返回值是引用数据类型，resultType的值是引用数据类型的全称类路径。\n    * 对于返回值是基本数据类型，resultType的值基本类型，也可以是基本类型的包装类。\n    * resultType的是实质是调用set方法，因此引用数据类型必须有set方法。\n  * parameterType：参数类型。\n    * 当参数为基本类型时，parameterType的值可以是基本类型，也可以是基本类型的包装类。\n    * 当参数是引用类型时，parameterType的值只能是引用类型。\n  * 对于resultType和parameterType，如果返回值或参数只是一个基本参数类型的值，则该属性可以不写。默认自动匹配基本参数类型的值。\n  * SQL语句中的#{}表示占位符，占位符的值是方法中的参数。\n    * 当参数为基本类型时，占位符中的字母和参数名相同。\n    * 当参数是引用类型时，占位符的字母是引用类型的属性名。占位符顺序没有要求。\n    * 但占位符的实质是调用引用类型的get属性名()方法。因此引用类型必须有get方法。\n\n## 3.3 Map和模糊查询\n\n### 3.3.1 通用map\n\n```java\n//万能的Map\nint addUser2(Map<String,Object> map);\n```\n\n```xml\n<!--对象中的属性，可以直接取出来    传递map的key-->\n<insert id=\"addUser\" parameterType=\"map\">\n  insert into mybatis.user (id, pwd) values (#{userid},#{passWord});\n</insert>\n```\n\n```java\n@Test\npublic void addUser2(){\n  SqlSession sqlSession = MybatisUtils.getSqlSession();\n  UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n\n  //注意map的key要和sql中的占位符相同\n  Map<String, Object> map = new HashMap<String, Object>();\n  map.put(\"userid\",5);\n  map.put(\"passWord\",\"2222333\");\n\n  mapper.addUser2(map);\n  sqlSession.close();\n}\n```\n\n### 3.3.2 模糊查询\n\n* 方式一：在Java中拼接\n\n```java\nList<User> userList = mapper.getUserLike(\"%李%\");\n```\n\n* 方式二：在mysql中拼接\n\n```xml\nselect * from mybatis.user where name like \"%\"#{value}\"%\"\n```\n\n## 3.4  使用注解开发\n\n* 另一种方法来完成语句映射。 它们映射的语句可以不用 XML 来配置，而可以使用 Java 注解来配置。\n* 使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。 \n* 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。\n* 例如\n\n```java\n@Select(\"select * from user\")\nList<User> getUsers();\n```\n\n**设置事务自动提交**\n\n* 在工具类创建的时候实现自动提交事务\n\n```java\npublic static SqlSession  getSqlSession(){\n  \t//true就表示开启自动提交。\n    return sqlSessionFactory.openSession(true);\n}\n```\n\n**使用注解的案例**\n\n```java\npublic interface UserMapper {\n\n    @Select(\"select * from user\")\n    List<User> getUsers();\n\n    // 方法存在多个参数，所有的参数前面必须加上 @Param(\"id\")注解\n    @Select(\"select * from user where id = #{id}\")\n    User getUserByID(@Param(\"id\") int id);\n\n    @Insert(\"insert into user(id,name,pwd) values (#{id},#{name},#{password})\")\n    int addUser(User user);\n    \n    @Update(\"update user set name=#{name},pwd=#{password} where id = #{id}\")\n    int updateUser(User user);\n\n    @Delete(\"delete from user where id = #{uid}\")\n    int deleteUser(@Param(\"uid\") int id);\n}\n```\n\n**注解的总结**\n\n* 注意事项：\n\n  * 使用注解可以在mapper.xml文件中编写sql语句，甚至不使用mapper.xml文件。\n  * 使用注解的同时也可以使用mapper.xml文件。两者可以同时使用。但切记不要重复。\n  * mybatis配置文件中，接口的注册一定要绑定。推荐使用下面的方式进行绑定。\n\n  ```xml\n  <!-- 使用映射器接口实现类的完全限定类名 -->\n  <mappers>\n    <mapper class=\"org.mybatis.builder.AuthorMapper\"/>\n  </mappers>\n  ```\n\n\n**关于@Param() 注解**\n\n* 基本类型的参数或者String类型，需要加上。引用类型不需要加。\n* @Param() 注解的作用：\n  * 将参数的名字设置为明确的固定的名字。\n  * 在sql语句中占位符使用的就是这个参数的名字。\n* 一般除了引用类型外推荐都加上。为了规范。\n\n## 3.5 #{}和${}的区别\n\n* #{}表示占位符，用于动态的取值。\n* ${}也表示占位符，用于动态的拼接sql。\n* 一个很大的区别是：\n  * #{}能防止sql注入问题。\n  * ${}不能防止sql注入问题。\n* 因此推荐使用#{}。\n\n#  第四章 mybatis配置解析\n\n* 概览\n\n  ```\n  configuration（配置）\n    - properties（属性）\n    - settings（设置）\n    - typeAliases（类型别名）\n    - typeHandlers（类型处理器）\n    - objectFactory（对象工厂）\n    - plugins（插件）\n    - environments（环境配置）\n      - environment（环境变量）\n        - transactionManager（事务管理器）\n        - dataSource（数据源）\n    - databaseIdProvider（数据库厂商标识）\n    - mappers（映射器）\n  ```\n\n* 注意：mybatis配置文件的标签是有顺序的。顺序如下\n\n  ```xml-dtd\n  configuration (properties?, settings?, typeAliases?, typeHandlers?, objectFactory?, objectWrapperFactory?, reflectorFactory?, plugins?, environments?, databaseIdProvider?, mappers?)\n  ```\n\n## 4.1 属性(properties)\n\n* 属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。\n\n* 方式一：在外部文件中配置，然后通过properties属性引入到mybatis配置文件中\n\n  * db.properties\n\n  ```properties\n  driver=com.mysql.jdbc.Driver\n  url=jdbc:mysql://localhost:3306/mybatis?useSSL=false\n  username=root\n  password=root\n  ```\n\n  * mybatis配置文件\n\n  ```xml\n  <!--引入外部配置文件-->\n  <properties resource=\"db.properties\"></properties>\n  ```\n\n* 方式二：在外部文件中配置同时mybatis中也配置。然后再mybatis配置文件中使用。\n\n  * db.properties\n\n  ```properties\n  driver=com.mysql.jdbc.Driver\n  url=jdbc:mysql://localhost:3306/mybatis?useSSL=false\n  ```\n\n  * mybatis配置文件\n\n  ```xml\n  <properties resource=\"db.properties\">\n    <property name=\"username\" value=\"root\"/>\n    <property name=\"password\" value=\"root\"/>\n  </properties>\n  ```\n\n* 上述两种方式配置后的使用方式如下：\n\n```xml\n<environment id=\"development\">\n  <transactionManager type=\"JDBC\"/>\n  <dataSource type=\"POOLED\">\n    <property name=\"driver\" value=\"${driver}\"/>\n    <property name=\"url\" value=\"${url}\"/>\n    <property name=\"username\" value=\"${username}\"/>\n    <property name=\"password\" value=\"${password}\"/>\n  </dataSource>\n</environment>\n```\n\n* 当引入的外部配置文件中的属性和配置文件的属性相同。则优先使用外部配置文件的。\n\n## 4.2 设置(settings)\n\n* 设置是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。\n* 常用设置如下\n\n| 设置名                   | 描述                                                         | 取值                                                         | 默认值 |\n| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------ |\n| cacheEnabled             | 是否开启缓存                                                 | true\\|false                                                  | true   |\n| lazyLoadingEnabled       | 是否开启懒加载                                               | true\\|false                                                  | false  |\n| useGeneratedKeys         | 允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键 | true\\|false                                                  | false  |\n| mapUnderscoreToCamelCase | 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 | true\\|false                                                  | false  |\n| logImpl                  | 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。        | SLF4J \\| LOG4J \\| LOG4J2 \\| JDK_LOGGING \\| COMMONS_LOGGING \\| STDOUT_LOGGING \\| NO_LOGGING | 无     |\n\n* 全部设置如下\n\n```xml\n<settings>\n  <setting name=\"cacheEnabled\" value=\"true\"/>\n  <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n  <setting name=\"multipleResultSetsEnabled\" value=\"true\"/>\n  <setting name=\"useColumnLabel\" value=\"true\"/>\n  <setting name=\"useGeneratedKeys\" value=\"false\"/>\n  <setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/>\n  <setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\"/>\n  <setting name=\"defaultExecutorType\" value=\"SIMPLE\"/>\n  <setting name=\"defaultStatementTimeout\" value=\"25\"/>\n  <setting name=\"defaultFetchSize\" value=\"100\"/>\n  <setting name=\"safeRowBoundsEnabled\" value=\"false\"/>\n  <setting name=\"mapUnderscoreToCamelCase\" value=\"false\"/>\n  <setting name=\"localCacheScope\" value=\"SESSION\"/>\n  <setting name=\"jdbcTypeForNull\" value=\"OTHER\"/>\n  <setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/>\n</settings>\n```\n\n## 4.3 类型别名\n\n* 类型别名是为 Java 类型设置一个短的名字。\n\n* 存在的意义仅在于用来减少类完全限定名的冗余。\n\n* 常在mapper的参数类型和结果类型中使用类型别名。\n\n  ```xml\n  <!-- 返回类型为user，user是User类的别名-->\n  <select id=\"selectAll\" resultType=\"user\">\n    select * from mybatis.user;\n  </select>\n  ```\n\n* 类型别名的配置\n\n  * 方式一\n\n  ```xml\n  <!--可以给实体类起别名-->\n  <typeAliases>\n    <!--type为指定类。alais为别名-->\n    <typeAlias type=\"com.lc.pojo.User\" alias=\"user\"/>\n  </typeAliases>\n  ```\n\n  * 方式二：也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean。默认别名为类名首字母小写。\n\n  ```xml\n  <!--扫描指定的包-->\n  <typeAliases>\n      <package name=\"com.lc.pojo\"/>\n  </typeAliases>\n  ```\n\n* 两种方式的对比\n\n  * 第一种可以自定义别名。\n  * 第二种不行，如果非要自定义别名，可以在实体类上加注解，在注解中明确指定别名\n\n  ```java\n  @Alias(\"user\")\n  public class User {}\n  ```\n\n## 4.4 类型处理器\n\n\n\n## 4.5 对象工厂\n\n\n\n## 4.6 插件\n\n* mybatis-generator-core\n* mybatis-plus\n* 通用mapper\n\n## 4.7 环境配置\n\n* MyBatis 可以配置成适应多种环境\n  * **不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。**\n* Mybatis默认的事务管理器就是 JDBC  ， 连接池 ： POOLED\n\n**事务管理器**\n\n* 在 MyBatis 中有两种类型的事务管理器（也就是 type=\"[JDBC|MANAGED]\"）\n  * JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。\n  * MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期。\n* 如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器，因为 Spring 模块会使用自带的管理器来覆盖前面的配置。\n\n**数据源**\n\n* 有三种内建的数据源类型（也就是 type=\"[UNPOOLED|POOLED|JNDI]\"）\n  * **UNPOOLED**– 这个数据源的实现会每次请求时打开和关闭连接。即不适用池技术。\n  * **POOLED**– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。\n  * **JNDI** – 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。\n\n## 4.8 数据库厂商标识\n\n\n\n## 4.9 映射器\n\n* mapper文件用于存放sql语句，映射器用于告诉mybatis去哪里找mapper映射文件。\n* 方式一(推荐使用)：\n  * 使用时mapper文件可以放在任何位置上，包括资源路径上。\n  * 使用时mapper文件和接口的名字可以不一致\n\n```xml\n<!-- 使用相对于类路径的资源引用 -->\n<mappers>\n  <mapper resource=\"org/mybatis/builder/AuthorMapper.xml\"/>\n</mappers>\n```\n\n* 方式二(不推荐使用)：\n\n```xml\n<!-- 使用完全限定资源定位符（URL） -->\n<mappers>\n  <mapper url=\"file:///var/mappers/AuthorMapper.xml\"/>\n</mappers>\n```\n\n* 方式三：\n  * 使用时要求，mapper文件和接口的文件名完全相同。\n  * 使用时要求，mapper文件和接口在同一个包下。\n\n```xml\n<!-- 使用映射器接口实现类的完全限定类名 -->\n<mappers>\n  <mapper class=\"org.mybatis.builder.AuthorMapper\"/>\n</mappers>\n```\n\n* 方式四：\n  * 使用时要求，mapper文件和接口的文件名完全相同。\n  * 使用时要求，mapper文件和接口在同一个包下。\n\n```xml\n<!-- 将包内的映射器接口实现全部注册为映射器 -->\n<mappers>\n  <package name=\"org.mybatis.builder\"/>\n</mappers>\n```\n\n# 第五章 mapper文件解析\n\n* 概览\n  * `cache` – 该命名空间的缓存配置。\n  * `cache-ref` – 引用其它命名空间的缓存配置。\n  * `resultMap` – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。\n  * <font color=\"grey\">`parameterMap` – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。</font>\n  * `sql` – 可被其它语句引用的可重用语句块。\n  * `insert` – 映射插入语句。\n  * `update` – 映射更新语句。\n  * `delete` – 映射删除语句。\n  * `select` – 映射查询语句。\n\n## 5.1 select\n\n\n\n## 5.2 insert\n\n\n\n## 5.3 update和delete\n\n\n\n## 5.4 参数(#{})\n\n\n\n## 5.5 结果映射(resultMap)\n\n* 结果映射是指将sql语句执行后的数据字段和Java实体的属性名进行映射。以保证字段和属性名不同时，能够正确的将数据装配到实体中。\n* 和结果映射作用相同的是数据库的别名。\n\n### 5.5.1 简单结果映射\n\n* 例如：\n\n  * sql语句\n\n  ```xml\n  <select id=\"selectUsers\" resultType=\"User\">\n    select\n      user_id,user_name,hashed_password     \n    from some_table\n    where id = #{id}\n  </select>\n  ```\n\n  * 实体类\n\n  ```java\n  public class User {\n    private int id;\n    private String username;\n    private String hashedPassword;\n  }\n  ```\n\n* 它们的字段和属性并不匹配。\n\n* 解决方法\n\n  * 使用别名。对于简单的推荐使用别名。\n\n  ```xml\n  <select id=\"selectUsers\" resultType=\"User\">\n    select\n      user_id             as \"id\",\n      user_name           as \"userName\",\n      hashed_password     as \"hashedPassword\"\n    from some_table\n    where id = #{id}\n  </select>\n  ```\n\n  * 使用结果映射。对于复杂的的推荐使用结果映射。\n\n  ```xml\n  <!--type：表示对应的实体类。id：表示结果映射的唯一标识-->\n  <resultMap id=\"userResultMap\" type=\"User\">\n    <!--property：表示对应的属性名。column：表示对应的字段名-->\n    <!--id标签，只适用于映射数据库的主键-->\n    <id property=\"id\" column=\"user_id\" />\n    <!--result标签：适用于数据库的普通字段。-->\n    <result property=\"username\" column=\"user_name\"/>\n    <result property=\"password\" column=\"hashed_password\"/>\n  </resultMap>\n  ```\n\n### 5.5.2 高级结果映射\n\n* 多个学生对应一个老师\n* 对于学生这边而言，  **关联** ..  多个学生，关联一个老师  【多对一】\n* 对于老师而言， **集合** ， 一个老师，有很多学生 【一对多】\n\n**多对一查询实例**\n\n* 学生表\n\n```java\npublic class Student{\n  private int id;\n  private String name;\n  private Teacher teacher;\n}\n```\n\n* 老师表\n\n```java\npublic class Teacher{\n  private int id;\n  private String name;\n}\n```\n\n* 查询sql语句示例一：使用查询嵌套的方式\n\n```xml\n<!--\n    思路:\n        1. 查询所有的学生信息\n        2. 根据查询出来的学生的tid，寻找对应的老师！  子查询\n    -->\n<select id=\"getStudent\" resultMap=\"StudentTeacher\">\n    select * from student\n</select>\n\n<resultMap id=\"StudentTeacher\" type=\"Student\">\n    <result property=\"id\" column=\"id\"/>\n    <result property=\"name\" column=\"name\"/>\n    <!--对于复杂的属性，我们需要单独处理。\n\t\t\t\t属性为对象时： 使用association \n\t\t\t\t属性为集合时： 使用collection -->\n  <!--property：表示属性名  column：表示字段名。javaType：表示属性的类型。\n\t\t\tselect：表示要子查询语句。-->\n    <association property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/>\n</resultMap>\n\n<select id=\"getTeacher\" resultType=\"Teacher\">\n    select * from teacher where id = #{id}\n</select>\n```\n\n* 查询sql语句示例二：使用结果嵌套的方式\n\n```xml\n<!--按照结果嵌套处理-->\n<select id=\"getStudent2\" resultMap=\"StudentTeacher2\">\n    select s.id sid,s.name sname,t.name tname\n    from student s,teacher t\n    where s.tid = t.id;\n</select>\n\n<resultMap id=\"StudentTeacher2\" type=\"Student\">\n    <result property=\"id\" column=\"sid\"/>\n    <result property=\"name\" column=\"sname\"/>\n    <association property=\"teacher\" javaType=\"Teacher\">\n        <result property=\"name\" column=\"tname\"/>\n    </association>\n</resultMap>\n```\n\n**一对多查询实例**\n\n* 学生表\n\n```java\n@Data\npublic class Student {\n    private int id;\n    private String name;\n    private int tid;\n}\n\n```\n\n* 老师表\n\n```java\n@Data\npublic class Teacher {\n    private int id;\n    private String name;\n    //一个老师拥有多个学生\n    private List<Student> students;\n}\n```\n\n* 查询sql语句示例一：使用查询嵌套的方式\n\n```xml\n<resultMap id=\"TeacherStudent2\" type=\"Teacher\">\n  <!--javaType：表示属性的类型为list。ofType：表示list的元素的类型为Student-->\n    <collection property=\"students\" javaType=\"ArrayList\" ofType=\"Student\" select=\"getStudentByTeacherId\" column=\"id\"/>\n</resultMap>\n\n<select id=\"getTeacher2\" resultMap=\"TeacherStudent2\">\n    select * from mybatis.teacher where id = #{tid}\n</select>\n\n<select id=\"getStudentByTeacherId\" resultType=\"Student\">\n    select * from mybatis.student where tid = #{tid}\n</select>\n```\n\n* 查询sql语句示例二：使用结果嵌套的方式\n\n```xml\n\n<!--按结果嵌套查询-->\n<select id=\"getTeacher\" resultMap=\"TeacherStudent\">\n  select s.id sid, s.name sname, t.name tname,t.id tid\n  from student s,teacher t\n  where s.tid = t.id and t.id = #{tid}\n</select>\n\n<resultMap id=\"TeacherStudent\" type=\"Teacher\">\n  <result property=\"id\" column=\"tid\"/>\n  <result property=\"name\" column=\"tname\"/>\n  <!--集合中的元素的类型，使用ofType获取-->\n  <collection property=\"students\" ofType=\"Student\">\n    <result property=\"id\" column=\"sid\"/>\n    <result property=\"name\" column=\"sname\"/>\n    <result property=\"tid\" column=\"tid\"/>\n  </collection>\n</resultMap>\n```\n\n## 5.6 自动映射\n\n\n\n## 5.7 缓存(cache)\n\n### 5.7.1 简介\n\n1. 什么是缓存 [ Cache ]？\n   - 存在内存中的临时数据。\n   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。\n2. 为什么使用缓存？\n\n   - 减少和数据库的交互次数，减少系统开销，提高系统效率。\n3. 什么样的数据能使用缓存？\n\n   - 经常查询并且不经常改变的数据。【可以使用缓存】\n\n- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。\n- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**\n  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）\n\n  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存，即基于指定接口的缓存。\n\n  - 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存。\n\n### 5.7.2 一级缓存\n\n* 一级缓存也叫本地缓存：  SqlSession\n  * 与数据库同一次会话期间查询到的数据会放在本地缓存中。\n  * 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；\n* 一级缓存在SqlSession连接存在时存在，当链接关闭时，缓存会被清除。\n* 例如：在同一个连接中，连续查询两个相同的数据时，sql语句只会被执行一次。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210309191914.png)\n\n* 缓存更新的情况：挡在连续查询中，使用更新，删除等语句对此数据进行了更新，缓存会被刷新。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210309191954.png)\n\n* 手动清理缓存的方法：clearCache()方法。通过SqlSession对象调用。 \n\n### 5.7.3 二级缓存\n\n* 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存。\n\n* 基于namespace级别的缓存，一个名称空间，对应一个二级缓存；\n\n* 二级缓存工作机制\n\n  - 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；\n  - 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；\n  - 新的会话查询信息，就可以从二级缓存中获取内容；\n  - 不同的mapper查出的数据会放在自己对应的缓存（map）中；\n\n* 启用二级缓存的方法。在mapper文件中添加如下的一行。\n\n  ```xml\n  <cache/>\n  ```\n\n* 这样就开启了二级缓存。此时的二级缓存的配置是：\n\n  * 映射语句文件中的所有 select 语句的结果将会被缓存。\n  * 映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。\n  * 缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。\n  * 缓存不会定时进行刷新（也就是说，没有刷新间隔）。\n  * 缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。\n  * 缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。\n\n* 当我们想要修改如上的二级缓存的设定时，我们可以这样做：\n\n  ```xml\n  <cache\n    eviction=\"FIFO\"\n    flushInterval=\"60000\"\n    size=\"512\"\n    readOnly=\"true\"/>\n  ```\n\n  * 这个配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的。\n\n* 二级缓存的属性：\n\n  * eviction：指缓存清除策略。二级缓存有四个清除策略。默认为LRU。\n    * `LRU` – 最近最少使用：移除最长时间不被使用的对象。\n    * `FIFO` – 先进先出：按对象进入缓存的顺序来移除它们。\n    * `SOFT` – 软引用：基于垃圾回收器状态和软引用规则移除对象。\n    * `WEAK` – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。\n  * flushInterval（刷新间隔）属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量。 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新。\n  * size（引用数目）属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024。\n  * readOnly（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。默认为false.\n\n* 注意事项：\n\n  * 开启二级缓存时，我们需要将会使用到的实体类进行序列化。\n  * 二级缓存是事务性的，因此当SqlSession关闭时，二级缓存会被刷新。\n\n### 5.7.4 缓存的原理\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210309185033.png)\n\n### 5.7.5 自定义缓存\n\n* 除了上述自定义缓存的方式，你也可以通过实现你自己的缓存，或为其他第三方缓存方案创建适配器，来完全覆盖缓存行为。\n\n```xml\n<cache type=\"com.domain.something.MyCustomCache\"/>\n```\n\n* type 属性指定的类必须实现 org.apache.ibatis.cache.Cache 接口，且提供一个接受 String 参数作为 id 的构造器。\n\n**Ehcache缓存**\n\n* Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存。\n\n* 官网地址：https://www.ehcache.org/\n\n* 使用方式：\n\n  * 第一步：导入依赖\n\n  ```xml\n  <!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache -->\n  <dependency>\n      <groupId>org.mybatis.caches</groupId>\n      <artifactId>mybatis-ehcache</artifactId>\n      <version>1.1.0</version>\n  </dependency>\n  ```\n\n  * 第二步：在mapper中指定Ehcache为缓存实现。\n\n  ```xml\n  <!--在当前Mapper.xml中使用二级缓存-->\n  <cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/>\n  ```\n\n  * 第三步：配置Ehcache的配置文件。\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n           updateCheck=\"false\">\n      <!--\n         diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：\n         user.home – 用户主目录\n         user.dir  – 用户当前工作目录\n         java.io.tmpdir – 默认临时文件路径\n       -->\n      <diskStore path=\"./tmpdir/Tmp_EhCache\"/>\n      \n      <defaultCache\n              eternal=\"false\"\n              maxElementsInMemory=\"10000\"\n              overflowToDisk=\"false\"\n              diskPersistent=\"false\"\n              timeToIdleSeconds=\"1800\"\n              timeToLiveSeconds=\"259200\"\n              memoryStoreEvictionPolicy=\"LRU\"/>\n   \n      <cache\n              name=\"cloud_user\"\n              eternal=\"false\"\n              maxElementsInMemory=\"5000\"\n              overflowToDisk=\"false\"\n              diskPersistent=\"false\"\n              timeToIdleSeconds=\"1800\"\n              timeToLiveSeconds=\"1800\"\n              memoryStoreEvictionPolicy=\"LRU\"/>\n      <!--\n         defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。\n       -->\n      <!--\n        name:缓存名称。\n        maxElementsInMemory:缓存最大数目\n        maxElementsOnDisk：硬盘最大缓存个数。\n        eternal:对象是否永久有效，一但设置了，timeout将不起作用。\n        overflowToDisk:是否保存到磁盘，当系统当机时\n        timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。\n        timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。\n        diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.\n        diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。\n        diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。\n        memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。\n        clearOnFlush：内存数量最大时是否清除。\n        memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。\n        FIFO，first in first out，这个是大家最熟的，先进先出。\n        LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。\n        LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。\n     -->\n  </ehcache>\n  ```\n\n## 5.8 SQL片段\n\n* mapper.xml文件中有一个标签为sql。这个标签的作用是：定义可被其它语句引用的可重用语句块。\n\n* 目的：为了将可以从重复使用的sql片段抽取出来，写在sql片段中，在使用的时候引入sql片段即可。\n\n* 例如：\n\n  ```xml\n  <sql id=\"if-title-author\">\n      <if test=\"title != null\">\n          title = #{title}\n      </if>\n      <if test=\"author != null\">\n          and author = #{author}\n      </if>\n  </sql>\n  <select id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\">\n      select * from mybatis.blog\n      <where>\n          <include refid=\"if-title-author\"></include>\n      </where>\n  </select>\n  ```\n\n* 引入sql片段使用include标签。意为包含的意思。\n\n* 注意事项：\n\n  * 最好基于单表来定义SQL片段！\n  * SQL片段中不要存在where标签。\n\n# 第六章 动态SQL\n\n* **什么是动态SQL：动态SQL就是指利用不同的sql标签根据不同的条件生成不同的SQL语句**\n\n* 动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。\n\n* sql标签有：\n\n  ```\n  if\n  choose (when, otherwise)\n  trim (where, set)\n  foreach\n  ```\n\n## 6.1 if标签\n\n* if标签的作用相当于Java的if判断语句。\n\n```xml\n<select id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\">\n  select * from mybatis.blog where 1=1\n  <if test=\"title != null\">\n    and title = #{title}\n  </if>\n  <if test=\"author != null and author.name != null\">\n    AND author_name like #{author.name}\n  </if>\n</select>\n```\n\n* 对于上面的示例：\n  * 基础sql语句是select * from mybatis.blog where 1=1。\n  * if标签表示：当test中的判断为true时，将if标签中的sql语句拼接到基础SQL中。\n\n## 6.2 choose标签\n\n* MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。\n\n```xml\n<select id=\"findActiveBlogLike\"\n        resultType=\"Blog\">\n  SELECT * FROM BLOG WHERE state = ‘ACTIVE’\n  <choose>\n    <when test=\"title != null\">\n      AND title like #{title}\n    </when>\n    <when test=\"author != null and author.name != null\">\n      AND author_name like #{author.name}\n    </when>\n    <otherwise>\n      AND featured = 1\n    </otherwise>\n  </choose>\n</select>\n```\n\n* choose 标签的使用原则是：\n  * 当when中的test条件成立，则将when中的sql语句拼接到基础sql中。\n  * 若所有的when中的test都没有成立，则将otherwise中的sql语句拼接到基础sql中。\n\n## 6.3 trim标签\n\n* trim标签是一个基础标签，它的两个常用的引申标签是where标签,set标签。\n\n**where标签**\n\n* where标签：主要作用是充当sql中的where功能。但作为标签他还有一些 引申功能。\n  * 在where语句中，如果拼接的第一个sql以and开头或以or开头，where标签会在拼接的时候将and或or去除。\n* 例如：\n\n```xml\n<select id=\"findActiveBlogLike\"\n        resultType=\"Blog\">\n  SELECT * FROM BLOG\n  <where>\n    <if test=\"state != null\">\n      state = #{state}\n    </if>\n    <if test=\"title != null\">\n      AND title like #{title}\n    </if>\n    <if test=\"author != null and author.name != null\">\n      AND author_name like #{author.name}\n    </if>\n  </where>\n</select>\n```\n\n* 当title不为空时，其他的都为空。则拼接后的语句为：SELECT * FROM BLOG WHERE title like #{title}\n\n* where标签可以使用在任何需要where语句的sql上。\n\n* 由trim到where的实现过程：\n\n  ```xml\n  <!--下面标签的作用和where标签相同。prefix表示拼接时的在最前面拼接什么。\n  prefixOverrides：表示在子标签中拼接时最前面不能以什么开头。-->\n  <trim prefix=\"WHERE\" prefixOverrides=\"AND |OR \">\n    ...\n  </trim>\n  ```\n\n**set标签**\n\n* set标签：主要作用是充当sql中的set功能。但作为标签他还有一些 引申功能。\n  * 在set语句中，如果拼接的最后一个sql以符号逗号(,)结尾，set标签会在拼接的时候将最后的逗号去除。\n* 例如：\n\n```xml\n<update id=\"updateAuthorIfNecessary\">\n  update Author\n  <set>\n    <if test=\"username != null\">username=#{username},</if>\n    <if test=\"password != null\">password=#{password},</if>\n    <if test=\"email != null\">email=#{email},</if>\n    <if test=\"bio != null\">bio=#{bio}</if>\n  </set>\n  where id=#{id}\n</update>\n```\n\n* set标签一般使用在更新语句上。\n* 由trim到where的实现过程：\n\n```xml\n<trim prefix=\"SET\" suffixOverrides=\",\">\n  ...\n</trim>\n```\n\n## 6.4 foreach标签\n\n* foreach标签：通常是表示遍历功能。\n  * 使用场景如in语句，or语句中。\n* 例如：\n\n```xml\n<select id=\"selectPostIn\" resultType=\"domain.blog.Post\">\n  SELECT *\n  FROM POST P\n  WHERE ID in\n  <foreach item=\"item\" index=\"index\" collection=\"list\"\n      open=\"(\" separator=\",\" close=\")\">\n        #{item}\n  </foreach>\n</select>\n```\n\n* foreach标签属性的作用：\n  * item：表示集合的项，例如数组中的每一个数。\n  * index：表示集合的索引，例如数组中的下标。\n  * collection：值为集合的名字。\n  * open：表示拼接时以什么开头。\n  * close：表示拼接时以什么结尾。\n  * separator：表示拼接时以什么分割集合中的每一项。\n  * 特别的是：当集合为map或Map.Entry时。index表示集合的key,item表示集合的value。\n* \n\n\n\n# 第七章 日志\n\n* Mybatis 通过使用内置的日志工厂提供日志功能。内置日志工厂将会把日志工作委托给下面的实现之一。\n  * SLF4J\n  * Apache Commons Logging\n  * Log4j 2\n  * Log4j\n  * JDK logging\n* MyBatis 内置日志工厂会基于运行时检测信息选择日志委托实现\n* 它会（按上面**罗列的顺序**）使用第一个查找到的实现。\n* 当没有找到这些实现时，将会禁用日志功能。\n* 在mybatis配置文件中通过设置logImpl来选择日志的实现。\n\n```xml\n<settings>\n  <setting name=\"logImpl\" value=\"LOG4J\"/>\n</settings>\n```\n\n* logImpl的取值有SLF4J、LOG4J、LOG4J2、JDK_LOGGING、COMMONS_LOGGING、STDOUT_LOGGING、NO_LOGGING。\n\n## 7.1 STDOUT_LOGGING日志实现\n\n* STDOUT_LOGGING是一个标准日志输出。\n\n* 使用方式：\n\n  * 配置mybatis配置文件：\n\n  ```xml\n  <settings>\n    <setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/>\n  </settings>\n  ```\n\n* 输出样式\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210307163029.png)\n\n## 7.2 LOG4J日志实现\n\n* Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件\n\n* 我们也可以控制每一条日志的输出格式；\n\n* 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。\n\n* 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。\n\n* 使用方式：\n\n  * 第一步：在pom.xml中导入log4j的依赖\n\n  ```xml\n  <dependency>\n      <groupId>log4j</groupId>\n      <artifactId>log4j</artifactId>\n      <version>1.2.17</version>\n  </dependency>\n  ```\n\n  * 第二步：配置log4j的配置文件：log4j.properties。\n    * 文件名称固定。文件位于resources目录下。\n\n  ```properties\n  #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码\n  log4j.rootLogger=DEBUG,console,file\n  \n  #控制台输出的相关设置\n  log4j.appender.console = org.apache.log4j.ConsoleAppender\n  log4j.appender.console.Target = System.out\n  log4j.appender.console.Threshold=DEBUG\n  log4j.appender.console.layout = org.apache.log4j.PatternLayout\n  log4j.appender.console.layout.ConversionPattern=[%c]-%m%n\n  \n  #文件输出的相关设置\n  log4j.appender.file = org.apache.log4j.RollingFileAppender\n  log4j.appender.file.File=./log/mybatis.log\n  log4j.appender.file.MaxFileSize=10mb\n  log4j.appender.file.Threshold=DEBUG\n  log4j.appender.file.layout=org.apache.log4j.PatternLayout\n  log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n\n  \n  #日志输出级别\n  log4j.logger.org.mybatis=DEBUG\n  log4j.logger.java.sql=DEBUG\n  log4j.logger.java.sql.Statement=DEBUG\n  log4j.logger.java.sql.ResultSet=DEBUG\n  log4j.logger.java.sql.PreparedStatement=DEBUG\n  ```\n\n  * 第三步：在mybatis配置文件中配置log4j为日志的实现。\n\n  ```xml\n  <settings>\n    <setting name=\"logImpl\" value=\"LOG4J\"/>\n  </settings>\n  ```\n\n* 使用效果：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210307165309.png)\n\n# 第八章 额外功能\n\n## 8.1 分页功能\n\n* 有三种方式能实现分页\n  * 使用sql的limit语句。\n  * 使用mybatis的RowBounds。\n  * 使用mybatis插件\n\n### 8.1.1 使用sql的limit语句。\n\n* 使用Limit分页\n\n```mysql\n# 语法：SELECT * from user limit startIndex,pageSize;\nSELECT * from user limit 3;  #[0,n]\n```\n\n* 使用mybatis实现分页\n\n  * 接口\n\n  ```java\n  //分页\n  List<User> getUserByLimit(Map<String,Integer> map);\n  ```\n\n  * mapper.xml文件\n\n  ```xml\n  <!--//分页-->\n  <select id=\"getUserByLimit\" parameterType=\"map\" resultMap=\"UserMap\">\n      select * from  mybatis.user limit #{startIndex},#{pageSize}\n  </select>\n  ```\n\n  * 测试\n\n  ```java\n  @Test\n  public void getUserByLimit(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n  \n    HashMap<String, Integer> map = new HashMap<String, Integer>();\n    map.put(\"startIndex\",1);\n    map.put(\"pageSize\",2);\n  \n    List<User> userList =  mapper.getUserByLimit(map);\n    for (User user : userList) {\n      System.out.println(user);\n    }\n  \n    sqlSession.close();\n  }\n  ```\n\n### 8.1.2 使用mybatis的RowBounds。\n\n* 使用RowBounds时sql语句不用使用limit语句。\n\n  * 是在查询后在数据层上进行的分页。而limit是在查询时进行的分页。\n\n* 使用方式\n\n  * 接口\n\n  ```java\n  //分页2\n  List<User> getUserByRowBounds();\n  ```\n\n  * mapper.xml文件\n\n  ```xml\n  <!--分页2-->\n  <select id=\"getUserByRowBounds\" resultMap=\"UserMap\">\n      select * from  mybatis.user\n  </select>\n  ```\n\n  * 测试\n\n  ```java\n  @Test\n  public void getUserByRowBounds(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n  \n    //RowBounds实现\n    RowBounds rowBounds = new RowBounds(1, 2);\n  \n    //通过Java代码层面实现分页\n    List<User> userList = sqlSession.selectList(\"com.kuang.dao.UserMapper.getUserByRowBounds\",null,rowBounds);\n  \n    for (User user : userList) {\n      System.out.println(user);\n    }\n  \n    sqlSession.close();\n  }\n  ```\n\n### 8.1.3 使用mybatis插件\n\n* 插件官网：https://pagehelper.github.io/\n\n## 8.2 Lombok插件\n\n* Lombok 是一种 Java 实用工具，可用来帮助开发人员消除 Java 的冗长，尤其是对于简单的 Java 对象（POJO）。\n* 它通过注释实现这一目的。通过在开发环境中实现  Lombok，开发人员可以节省构建诸如 hashCode() 和 equals() 这样的方法以及以往用来分类各种 accessor 和 mutator 的大量时间。\n\n**使用方式**\n\n* 第一步：IDEA下载lombok插件。最新版本的idea已经内置了lombok插件\n\n* 第二步：在项目中导入lombok依赖。\n\n```xml\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.10</version>\n</dependency>\n```\n\n* 第三步：在实体类上添加注解即可。\n\n```java\n@Data\npublic class User{\n  private String name;\n  private int age;\n}\n```\n\n* lombok包含的注解\n\n```java\n@Getter and @Setter\n@FieldNameConstants\n@ToString\n@EqualsAndHashCode\n@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor\n@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger\n@Data\n@Builder\n@Singular\n@Delegate\n@Value\n@Accessors\n@Wither\n@SneakyThrows\n```\n\n* 常见注解的含义\n\n```java\n@Data\t\t//辅助实体类生成无参构造方法，get,set方法，toString方法，hashCode方法，equals方法\n@Getter  //辅助实体类生成get方法\n@Setter  //辅助实体类生成set方法\n@ToString    //辅助实体类生成toString方法\n@EqualsAndHashCode    //辅助实体类生成hashCode方法，equals方法\n@AllArgsConstructor   //辅助实体类生成全参构造方法\n@NoArgsConstructor    //辅助实体类生成无参构造方法\n```\n\n# 第九章：通常配置文件\n\n* mybatis配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n  <!--\n        1.Mybatis可以使用properties标签来引入外部properties配置文件的内容\n            resource属性：引入类路径下的配置文件\n            url属性：引入网络或磁盘上的配置文件\n    -->\n  <properties resource=\"db.properties\">\n    <property name=\"username\" value=\"root\"/>\n    <property name=\"password\" value=\"root\"/>\n  </properties>\n<!--2.设置-->\n<settings>\n  <setting name=\"cacheEnabled\" value=\"true\"/>\n  <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n  <setting name=\"multipleResultSetsEnabled\" value=\"true\"/>\n  <setting name=\"useColumnLabel\" value=\"true\"/>\n  <setting name=\"useGeneratedKeys\" value=\"false\"/>\n  <setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/>\n  <setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\"/>\n  <setting name=\"defaultExecutorType\" value=\"SIMPLE\"/>\n  <setting name=\"defaultStatementTimeout\" value=\"25\"/>\n  <setting name=\"defaultFetchSize\" value=\"100\"/>\n  <setting name=\"safeRowBoundsEnabled\" value=\"false\"/>\n  <setting name=\"mapUnderscoreToCamelCase\" value=\"false\"/>\n  <setting name=\"localCacheScope\" value=\"SESSION\"/>\n  <setting name=\"jdbcTypeForNull\" value=\"OTHER\"/>\n  <setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/>\n</settings>\n\n  <!--3.类型别名-->\n  <typeAliases>\n    <!--\n            通过package标签的name指定需要生成别名的包，默认会创建一个别名，就是类名的小写\n        -->\n    <package name=\"com.sunxiaping\"/>\n    <!-- 自定义别名\n  <typeAlias alias=\"Author\" type=\"domain.blog.Author\"/>\n  <typeAlias alias=\"Blog\" type=\"domain.blog.Blog\"/>\n-->\n  </typeAliases>\n    <!-- 4、类型处理器：定义Java类型与数据库中的数据类型之间的转换关系 -->\n    <typeHandlers></typeHandlers>\n  \n      <!-- 5、对象工厂 -->\n    <objectFactory type=\"\"></objectFactory>\n\n    <!-- 6、插件：mybatis的插件，支持自定义插件 -->\n    <plugins>\n        <plugin interceptor=\"\"></plugin>\n    </plugins>\n  <!--\n       7. environments，Mybatis可以配置多种环境\n            environment：配置一个具体的环境信息；必须有transactionManager和dataSource标签。属性id代表当前环境的标识，可以达到快速切换环境\n                transactionManager：事务管理器\n                    type：事务管理器的类型，有JDBC和MANAGED两种类型，还可以自定义事务管理器\n                dataSource：数据源\n                    type：数据源的类型，有UNPOOLED、POOLED、JNDI和自定义类型。\n\n    -->\n  <environments default=\"development\">\n    <environment id=\"test\">\n      <transactionManager type=\"JDBC\"/>\n      <dataSource type=\"POOLED\">\n        <!-- 使用${}引入db.properties属性文件中的内容 -->\n        <property name=\"driver\" value=\"${jdbc.driverClass}\"/>\n        <property name=\"url\" value=\"${jdbc.url}\"/>\n        <property name=\"username\" value=\"${jdbc.username}\"/>\n        <property name=\"password\" value=\"${jdbc.password}\"/>\n      </dataSource>\n    </environment>\n    <environment id=\"development\">\n      <transactionManager type=\"JDBC\"/>\n      <dataSource type=\"POOLED\">\n        <!-- 使用${}引入db.properties属性文件中的内容 -->\n        <property name=\"driver\" value=\"${jdbc.driverClass}\"/>\n        <property name=\"url\" value=\"${jdbc.url}\"/>\n        <property name=\"username\" value=\"${jdbc.username}\"/>\n        <property name=\"password\" value=\"${jdbc.password}\"/>\n      </dataSource>\n    </environment>\n  </environments>\n\n  <!--\n       8. databaseIdProvider：支持多数据库厂商\n            type=\"DB_VENDOR\"：VendorDatabaseIdProvider\n                - 作用： 得到数据库厂商的标识（驱动，Connection接口中的getMetaData()返回了DatabaseMetaData，DatabaseMetaData中有getDatabaseProductName()方法），\n                        Mybatis就能数据数据库厂商标识来指定不同的SQL\n    -->\n  <databaseIdProvider type=\"DB_VENDOR\">\n    <!--\n            为不同的数据库厂商起别名\n        -->\n    <property name=\"MySQL\" value=\"mysql\"/>\n    <property name=\"Oracle\" value=\"oracle\"/>\n    <property name=\"SQL Server\" value=\"sqlserver\"/>\n  </databaseIdProvider>\n<!-- 9、映射器：指定映射文件或者映射类 -->\n  <mappers>\n    <mapper resource=\"com/sunxiaping/mapper/EmployeeMapper.xml\"/>\n  </mappers>\n</configuration>\n```\n\n* mapper配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org/DTD Mapper 3.0\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"\">\n\n  <cache/>\n  <cache-ref namespace=\"\"/>\n  <resultMap id=\"\" type=\"\">\n    <id column=\"\" property=\"\"></id>\n    <result column=\"\" property=\"\"></result>\n    <association property=\"\" column=\"\" javaType=\"\" select=\"\"/>\n    <association property=\"\" javaType=\"\"></association>\n    <collection property=\"\" javaType=\"\" ofType=\"\" select=\"\" column=\"\"/>\n    <collection property=\"\" ofType=\"\"></collection>\n  </resultMap>\n  <sql id=\"\">\n    <if test=\"\">\n\n    </if>\n  </sql>\n  <delete id=\"\" parameterType=\"\"></delete>\n  <insert id=\"\" parameterType=\"\"></insert>\n  <select id=\"\" parameterType=\"\" resultMap=\"\">\n    <where>\n      <if test=\"\"></if>\n      <foreach collection=\"\" item=\"\" index=\"\" open=\"\" close=\"\" separator=\"\"></foreach>\n    </where>\n  </select>\n  <update id=\"\">\n    <where>\n      <set>\n      </set>\n      <choose></choose>\n    </where>\n    <include refid=\"\"></include>\n  </update>\n</mapper>    \n```\n\n* log4j日志配置文件\n\n```properties\nlog4j.rootLogger=INFO,consoleAppender,logfile,MAIL\nlog4j.addivity.org.apache=true\n#ConsoleAppender，控制台输出\n#FileAppender，文件日志输出\n#SMTPAppender，发邮件输出日志\n#SocketAppender，Socket 日志\n#NTEventLogAppender，Window NT 日志\n#SyslogAppender，\n#JMSAppender，\n#AsyncAppender，\n#NullAppender\n#文件输出：RollingFileAppender\n#log4j.rootLogger = INFO,logfile\nlog4j.appender.logfile = org.apache.log4j.RollingFileAppender\nlog4j.appender.logfile.Threshold = INFO\n# 输出以上的 INFO 信息\nlog4j.appender.logfile.File = INFO_log.html\n#保存 log 文件路径\nLog4j 从入门到详解\n10\nlog4j.appender.logfile.Append = true\n# 默认为 true，添加到末尾，false 在每次启动时进行覆盖\nlog4j.appender.logfile.MaxFileSize = 1MB\n# 一个 log 文件的大小，超过这个大小就又会生成 1 个日志 # KB ，MB，GB\nlog4j.appender.logfile.MaxBackupIndex = 3\n# 最多保存 3 个文件备份\nlog4j.appender.logfile.layout = org.apache.log4j.HTMLLayout\n# 输出文件的格式\nlog4j.appender.logfile.layout.LocationInfo = true\n#是否显示类名和行数\nlog4j.appender.logfile.layout.Title\n=title:\\u63d0\\u9192\\u60a8\\uff1a\\u7cfb\\u7edf\\u53d1\\u751f\\u4e86\\u4e25\\u91cd\\u9519\\u8b\nef\n#html 页面的 < title >\n############################## SampleLayout ####################################\n# log4j.appender.logfile.layout = org.apache.log4j.SampleLayout\n############################## PatternLayout ###################################\n# log4j.appender.logfile.layout = org.apache.log4j.PatternLayout\n# log4j.appender.logfile.layout.ConversionPattern =% d % p [ % c] - % m % n % d\n############################## XMLLayout #######################################\n# log4j.appender.logfile.layout = org.apache.log4j.XMLLayout\n# log4j.appender.logfile.layout.LocationInfo = true #是否显示类名和行数\n############################## TTCCLayout ######################################\n# log4j.appender.logfile.layout = org.apache.log4j.TTCCLayout\n# log4j.appender.logfile.layout.DateFormat = ISO8601\n#NULL, RELATIVE, ABSOLUTE, DATE or ISO8601.\n# log4j.appender.logfile.layout.TimeZoneID = GMT - 8 : 00\n# log4j.appender.logfile.layout.CategoryPrefixing = false ##默认为 true 打印类别名\n# log4j.appender.logfile.layout.ContextPrinting = false ##默认为 true 打印上下文信息\n# log4j.appender.logfile.layout.ThreadPrinting = false ##默认为 true 打印线程名\n# 打印信息如下：\n#2007 - 09 - 13 14 : 45 : 39 , 765 [http - 8080 - 1 ] ERROR com.poxool.test.test -\nerror 成功关闭链接\n###############################################################################\n#每天文件的输出：DailyRollingFileAppender\n#log4j.rootLogger = INFO,errorlogfile\nlog4j.appender.errorlogfile = org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.errorlogfile.Threshold = ERROR\nlog4j.appender.errorlogfile.File = ../logs/ERROR_log\nlog4j.appender.errorlogfile.Append = true\n#默认为 true，添加到末尾，false 在每次启动时进行覆盖\nlog4j.appender.errorlogfile.ImmediateFlush = true\n#直接输出，不进行缓存\n# ' . ' yyyy - MM: 每个月更新一个 log 日志\n# ' . ' yyyy - ww: 每个星期更新一个 log 日志\n# ' . ' yyyy - MM - dd: 每天更新一个 log 日志\n# ' . ' yyyy - MM - dd - a: 每天的午夜和正午更新一个 log 日志\n# ' . ' yyyy - MM - dd - HH: 每小时更新一个 log 日志\n# ' . ' yyyy - MM - dd - HH - mm: 每分钟更新一个 log 日志\nLog4j 从入门到详解\n11\nlog4j.appender.errorlogfile.DatePattern = ' . ' yyyy - MM - dd ' .log '\n#文件名称的格式\nlog4j.appender.errorlogfile.layout = org.apache.log4j.PatternLayout\nlog4j.appender.errorlogfile.layout.ConversionPattern =%d %p [ %c] - %m %n %d\n#控制台输出：\n#log4j.rootLogger = INFO,consoleAppender\nlog4j.appender.consoleAppender = org.apache.log4j.ConsoleAppender\nlog4j.appender.consoleAppender.Threshold = ERROR\nlog4j.appender.consoleAppender.layout = org.apache.log4j.PatternLayout\nlog4j.appender.consoleAppender.layout.ConversionPattern =%d %-5p %m %n\nlog4j.appender.consoleAppender.ImmediateFlush = true\n# 直接输出，不进行缓存\nlog4j.appender.consoleAppender.Target = System.err\n# 默认是 System.out 方式输出\n#发送邮件：SMTPAppender\n#log4j.rootLogger = INFO,MAIL\nlog4j.appender.MAIL = org.apache.log4j.net.SMTPAppender\nlog4j.appender.MAIL.Threshold = INFO\nlog4j.appender.MAIL.BufferSize = 10\nlog4j.appender.MAIL.From = yourmail@gmail.com\nlog4j.appender.MAIL.SMTPHost = smtp.gmail.com\nlog4j.appender.MAIL.Subject = Log4J Message\nlog4j.appender.MAIL.To = yourmail@gmail.com\nlog4j.appender.MAIL.layout = org.apache.log4j.PatternLayout\nlog4j.appender.MAIL.layout.ConversionPattern =%d - %c -%-4r [%t] %-5p %c %x - %m %n\n#数据库：JDBCAppender\nlog4j.appender.DATABASE = org.apache.log4j.jdbc.JDBCAppender\nlog4j.appender.DATABASE.URL = jdbc:oracle:thin:@ 210.51 . 173.94 : 1521 :YDB\nlog4j.appender.DATABASE.driver = oracle.jdbc.driver.OracleDriver\nlog4j.appender.DATABASE.user = ydbuser\nlog4j.appender.DATABASE.password = ydbuser\nlog4j.appender.DATABASE.sql = INSERT INTO A1 (TITLE3) VALUES ( ' %d - %c %-5p %c %x - %m%n\n' )\nlog4j.appender.DATABASE.layout = org.apache.log4j.PatternLayout\nlog4j.appender.DATABASE.layout.ConversionPattern =% d - % c -%- 4r [ % t] %- 5p % c %\nx - % m % n\n#数据库的链接会有问题，可以重写 org.apache.log4j.jdbc.JDBCAppender 的 getConnection() 使用数\n据库链接池去得链接，可以避免 insert 一条就链接一次数据库\n```\n\n* 注解\n\n```java\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["Java学习","JavaEE框架"]},{"title":"Spring5的学习","url":"/2021/03/06/尚硅谷说Java/JavaEE框架/spring5/","content":"\nSpring的使用，IOC容器，AOP功能，jdbcTemplate,事务功能，动态代理，单元测试，webFlux\n\n<!--more-->\n\n# 第一章 Spring框架概述\n\n* Spring 是轻量级的开源的 JavaEE 框架。\n\n* Spring 可以解决企业应用开发的复杂性\n\n* Spring 有两个核心部分：IOC 和 Aop\n\n  * (1) IOC：控制反转，把创建对象过程交给 Spring 进行管理。\n  * (2) Aop：面向切面，不修改源代码进行功能增强。\n\n* Spring特点：\n\n  * (1) 方便解耦，简化开发\n    * 通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。\n  * (2) Aop编程支持\n    * 通过Spring提供的AOP功能，方便进行面向切面的编程，\n  * (3) 方便程序测试\n    * 可以用非容器依赖的编程方式进行几乎所有的测试工作，在Spring里，测试不再是昂贵的操作，而是随手可做的事情。例如：Spring对Junit4支持，可以通过注解方便的测试Spring程序。\n  * (4) 方便和其他框架进行整合\n    * Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如Struts,Hibernate、Hessian、Quartz）等的直接支持。\n  * (5) 降低API开发难度\n    * Spring对很多难用的Java EE API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些Java EE API的使用难度大为降低。\n\n* Spring的基本功能需要的包的图示如下\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210301120510.jpg)\n\n## 1.1 Spring的入门实现\n\n* 以Spring2.5.6版本为例。\n\n* 下载地址：[下载](https://repo.spring.io/release/org/springframework/spring/5.2.6.RELEASE/)\n\n  * 下载dist.zip结尾的文件。下载后解压。\n\n* 文件结构如下\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210301120717.png)\n\n**在IDEA中使用Spring**\n\n* 使用IDEA创建一个简单的Java工程，然后创建lib目录。如下\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210301120828.png)\n\n* 使用Spring时，还需要使用一个辅助包logging。下载地址：[下载](https://plumriver.lanzous.com/izZfYmdxm6b)\n\n* 将Spring的基本包和辅助包复制到到lib文件中。如上图\n\n* 打开IDEA的项目设置。添加jar,把lib目录为项目的依赖jar包目录。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210301121023.png)\n\n* 在项目中创建两个类：User类和Test类。创建spring的配置文件。如上面的图\n\n* 示例代码如下\n\n* User类\n\n```java\npublic class User {\n  public void add(){\n    System.out.println(\"user-add\");\n  }\n}\n```\n\n* test类\n\n```java\npublic class TestSpring5 {\n  @Test\n  public void test1(){\n    //1.加载配置文件\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"bean-config.xml\");\n    //2.通过配置文件创建对象\n    User user = context.getBean(\"user\", User.class);\n    System.out.println(user);\n    user.add();\n  }\n}\n```\n\n* 配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n  <!--配置User对象的创建。id表示User的标识符。class为User的类路径-->\n  <bean id=\"user\" class=\"com.lc.beans.User\"></bean>\n</beans>\n```\n\n* 执行结果如下\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210301122307.png)\n\n# 第二章 IOC容器\n\n## 2.1 IOC底层原理\n\n* 控制反转：就是把对象创建和对象之间的调用过程，交给 Spring 进行管理。\n\n* 使用IOC目的：降低耦合度。\n\n* IOC的原理：使用的<font color=\"red\">xml解析</font>技术。以<font color=\"red\">工厂模式</font>通过<font color=\"red\">反射</font>完成。\n\n* 实现在Service中调用dao类：原始方式和工厂模式。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210301133809.png)\n\n* IOC的实现模式：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210301133843.png)\n\n## 2.2 IOC接口：BeanFactory\n\n* IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂。\n* Spring 提供 IOC 容器实现两种方式：（两个接口）\n  * BeanFactory：IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用。\n    * 加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象。\n  * ApplicationContext：BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人员进行使用。\n    * 加载配置文件时候就会把在配置文件对象进行创建。\n* 往后的使用中：由于spring框架适合web服务器一起使用的。\n  * 因此会优先选择ApplicationContext接口。因为在服务器启动时就创建好bean。会节省使用时再创建bean的时间。\n* ApplicationContext 接口的主要实现类：\n  * FileSystemXmlApplicationContext：用于解析xml文件。以绝对路径为参数。一般从盘符开始指明路径。\n  * ClassPathXmlApplicationContext：用于解析xml文件。以相对路径为参数。一般从src目录下开始指明路径。\n\n## 2.3 IOC操作Bean管理：\n\n* Bean管理是指两个操作：\n  * Spring创建对象：即通过IOC的方式创建出实体类的对象。而不是new出对象。\n  * Spring注入属性：即通过IOC的方式设置对象的属性值。而不是通过setXxx()的方法。\n    * 依赖注入（Dependency Injection）简称DI。就是注入属性。\n* Bean 管理操作有两种方式：\n  * 基于 xml 配置文件方式实现。\n  * 基于 xml 配置文件方式实现。\n\n### 2.3.1 基于xml的方式---创建对象\n\n```xml\n<bean id=\"user\" class=\"com.lc.beans.User\"></bean>\n```\n\n* 在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建。\n* 在 bean 标签有很多属性，介绍常用的属性：\n  * id：是bean标签的唯一标识符。具有相同作用的属性是name。\n    * 不同的是：id的值不能含有符号，例如/-之类的。而name中可以含有符号。\n  * class：类全路径（包类路径）。是实体类在src目录下的路径。\n* 创建对象时候，默认也是执行无参数构造方法完成对象创建。\n  * 因此注意：在编写Bean的实体类时一定要有无参构造方法。\n\n### 2.3.2 基于xml的方式---注入属性\n\n第一种注入方式：使用set方法进行注入 -property\n\n* 首先需要满足前提条件：定义属性和对应的set方法。在配置文件中创建对象。\n\n```xml\n<bean id=\"user\" class=\"com.lc.beans.User\">\n  <!--使用property完成属性注入：\n        name：实体类中的属性名称。\n        value：向属性中注入的值。-->\n  <property name=\"name\" value=\"cl\"></property>\n  <property name=\"age\" value=\"18\"></property>\n</bean>\n```\n\n第二种注入方式：使用有参构造注入 -constructor\n\n* 首先需要满足前提条件：定义属性和对应的有参构造方法。在配置文件中创建对象。\n\n```xml\n<bean id=\"user\" class=\"com.lc.beans.User\">\n  <!--使用property完成属性注入：\n        name：实体类中的属性名称。\n        value：向属性中注入的值-->\n  <constructor-arg name=\"name\" value=\"lc\"></constructor-arg>\n  <constructor-arg name=\"age\" value=\"18\"></constructor-arg>\n</bean>\n```\n\n第三种注入方式：p名称空间注入(了解)\n\n* 作用：可以简化xml配置\n* 首先需要满足前提条件：在xml文件的头配置中加上xmlns:p=\"http://www.springframework.org/schema/p\"\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans    \n                           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n  <bean id=\"user\" class=\"com.lc.beans.User\" p:name=\"cl\" p:age=\"18\"></bean>\n</beans>\n```\n\n### 2.3.3 基于xml的方式---注入其他类型属性\n\n**1.字面量**\n\n* null值\n\n```xml\n<bean id=\"user\" class=\"com.lc.beans.User\">\n  <property name=\"name\">\n    <null/>\n  </property>\n  <property name=\"age\" value=\"18\"></property>\n</bean>\n```\n\n* 属性值包含特殊符号\n\n```xml\n<!--属性值包含特殊符号\n    方法一：把<>进行转义。使用转义字符代替特殊符号。\n    方法二：把特殊符号内容写到CDATA中。CDATA格式为： <![CDATA[值]]>-->\n<bean id=\"user\" class=\"com.lc.beans.User\">\n  <property name=\"name\">\n    <value><![CDATA[<<cl>>]]></value>\n  </property>\n  <property name=\"age\" value=\"18\"></property>\n</bean>\n```\n\n**2.注入属性-外部bean**\n\n* 第一步：创建service类，dao接口和实现类。\n* 第二步：在service类中创建dao属性和set方法。\n* 第三步：在配置文件中进行配置。\n\n```xml\n<!--外部bean注入\n    ref属性值：创建userDao对象bean标签的id值-->\n<bean id=\"userService\" class=\"com.lc.services.UserService\">\n  <property name=\"userDao\" ref=\"userDao\"></property>\n</bean>\n<bean id=\"userDao\" class=\"com.lc.daos.UserDaoImpl\"></bean>\n```\n\n**3.注入属性-内部bean**\n\n* 常用于一对多关系\n\n```xml\n<bean id=\"userService\" class=\"com.lc.services.UserService\">\n  <property name=\"userDao\" >\n    <bean id=\"userDao1\" class=\"com.lc.daos.UserDaoImpl\"></bean>\n  </property>\n</bean>\n```\n\n**4.注入属性-级联赋值**\n\n* 一级级联赋值(类似于外部bean)：\n\n```xml\n<bean id=\"userService\" class=\"com.lc.services.UserService\">\n  <property name=\"userDao\" ref=\"userDao\"></property>\n</bean>\n<bean id=\"userDao\" class=\"com.lc.daos.UserDaoImpl\"></bean>\n```\n\n* 二级级联赋值:\n  * 需要在people中有getUser()的方法。\n  * people的bean中需要先设置user的外部bean。\n  * 需要有外部bean存在。\n\n```xml\n<bean id=\"people\" class=\"com.lc.beans.People\">\n  <property name=\"name\" value=\"cl\"></property>\n  <property name=\"user\" ref=\"user\"></property>\n  <!--二级赋值-->\n  <property name=\"user.age\" value=\"18\"></property>\n  <property name=\"user.name\" value=\"asd\"></property>\n</bean>\n<bean id=\"user\" class=\"com.lc.beans.User\"></bean>\n```\n\n### 2.3.4 基于xml的方式---注入集合属性\n\n* 注入数组类型/List集合Map集合/Set集合。\n* 集合的值可以是基本数据类型，也可以是引用数据类型。\n\n```xml\n<bean id=\"student\" class=\"com.lc.beans.Student\">\n  <property name=\"array\">\n    <array>\n      <!--当数组类型是引用对象时可以采用<ref/>设置值。或者使用内部bean方式-->\n      <value>a</value>\n      <value>b</value>\n      <value>c</value>\n    </array>\n  </property>\n  <property name=\"list\">\n    <list>\n      <!--当list类型是引用对象时可以采用<ref/>设置值。或者使用内部bean方式-->\n      <value>a</value>\n      <value>b</value>\n      <value>c</value>\n    </list>\n  </property>\n  <property name=\"map\">\n    <map>\n      <!--当map类型的key是引用类型时：entry的属性可以用key-ref-->\n      <!--当map类型的value是引用类型时：entry的属性可以用value-ref-->\n      <entry key=\"a\" value=\"a\"></entry>\n      <entry key=\"b\" value=\"b\"></entry>\n      <entry key=\"c\" value=\"c\"></entry>\n    </map>\n  </property>\n  <property name=\"set\">\n    <set>\n      <!--当set类型是引用对象时可以采用<ref/>设置值。或者使用内部bean方式-->\n      <value>a</value>\n      <value>b</value>\n      <value>c</value>\n    </set>\n  </property>\n</bean>\n```\n\n### 2.3.5 基于xml的方式---提取公共部分。\n\n* 以集合为例。\n  * 首先要在配置文件的头部引入名称空间util。\n  * 然后提取公共部分。\n  * 最后在bean的property标签中使用ref引入。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:util=\"http://www.springframework.org/schema/util\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\n                           http://www.springframework.org/schema/util\n                           http://www.springframework.org/schema/util/spring-util.xsd\">\n  <!--提取公共部分-->\n  <util:list id=\"list\">\n    <value>a</value>\n    <value>b</value>\n    <value>c</value>\n  </util:list>\n  <!--集合的使用-->\n  <bean id=\"student\" class=\"com.lc.beans.Student\">\n    <property name=\"list\" ref=\"list\"></property>\n  </bean>\n</beans>\n```\n\n### 2.3.6 基于注解的方式---创建对象\n\n* 什么是注解？\n\n  * （1）注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值..)\n  * （2）使用注解，注解作用在类上面，方法上面，属性上面\n  * （3）使用注解目的：简化 xml 配置\n\n* Spring针对Bean管理中创建对象提供的注解\n\n  * @Component ：一般用于实体类上\n  * @Service：一般用于业务类上\n  * @Controller：一般用于控制层的类上\n  * @Repository：一般用于数据访问层的类上\n\n* 上面四个注解功能是一样的，都可以用来创建 bean 实例\n\n* 案例\n\n  * 第一步 引入spring-aop.jar包到项目的lib文件中\n  * 第二步 在配置文件中加上context名称空间，并且配置：开启组件扫描\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <beans xmlns=\"http://www.springframework.org/schema/beans\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xmlns:context=\"http://www.springframework.org/schema/context\"\n         xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n         http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\">\n    <!--开启组件扫描\n        1.多个包之间以逗号隔开。\n        2.写多个包的父包。\n        base-package：表示扫描当前包及包下的包中的所有类-->\n    <context:component-scan base-package=\"com.lc\"></context:component-scan>\n  </beans>\n  ```\n\n  * 第三步 创建类，并在类上添加创建对象的注解\n\n  ```java\n  /**\n   * 在注解中的value属性值可以省略不写。默认值时类名称首字母小写。\n   */\n  @Service(\"studentService\")\n  public class StudentService {\n    public void test() {\n      System.out.println(\"service test-----\");\n    }\n  }\n  ```\n\n  * 第四步 测试\n\n  ```java\n  ApplicationContext context = new ClassPathXmlApplicationContext(\"bean2-config.xml\");\n  StudentService studentService = context.getBean(\"studentService\", StudentService.class);\n  studentService.test();\n  ```\n\n* 在配置文件中开启组件扫描的细节配置\n\n```xml\n<!--实例一\n  use-default-filters：为false表示不使用spring自带的扫描机制。而使用自定义的扫描机制。\n  include-filter：表示当前组件扫描要使用哪种方式进行扫描。\n    类型为annotation(意为注解)。expression指向Service注解类，\n  此实例的意思为：只扫描com.lc包下带Service注解的类\n-->\n<context:component-scan base-package=\"com.lc\" use-default-filters=\"false\">\n  <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Service\"/>\n</context:component-scan>\n<!--实例二\n  use-default-filters：为true表示使用spring自带的扫描机制。默认为true\n  exclude-filter：表示当前组件扫描不使用哪种方式进行扫描。\n    类型为annotation(意为注解)。expression指向Service注解类，\n  此实例的意思为：根据spring自带机制扫描com.lc包下所有的注解，但Service注解不扫描\n-->\n<context:component-scan base-package=\"com.lc\" >\n  <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Service\"/>\n</context:component-scan>\n</beans>\n```\n\n### 2.3.7基于注解的方式---注入属性\n\n* @Autowired：根据属性类型进行自动装配。\n  * 不需要添加set方法。\n* @Qualifier：根据名称进行注入。\n  * @Qualifier注解需要和@Autowired注解一起使用。\n  * 常用于多个相同类型的bean匹配时，以名称区分。\n* @Resource：可以根据类型注入，可以根据名称注入。\n  * @Resource注解不加name时，是根据类型注入。\n  * @Resource注解加name时，是根据名称注入。\n  * @Resource是javax.annotation包下的不属于spring注解，但也能使用。不推荐使用。\n* @Value：注入普通类型属性。\n  * @Value注解是适用于注入基本数据类型或字符串类型，不适用于注入引用类型。\n\n```java\n@Service\npublic class UserService {\n  @Autowired\n  @Qualifier(\"userDao\")\n  private UserDao userDao;\n  @Resource(\"userDao2\")\n  private UserDao userDao2;\n}\n@Component\npublic class User{\n  @Value(\"asd\")\n  private String name;\n}\n```\n\n### 2.3.8 全注解方式开发\n\n* 全注解开发即项目中没有一个配置文件。\n* 第一步：创建配置类，用于替代xml配置文件\n\n```java\n/**\n * @Configuration 注解用于表示这个类是注解类，可以代替xml配置文件。\n * @ComponentScan 的作用相当于xml中的组件扫描功能。\n */\n@Configuration\n@ComponentScan(basePackages = {\"com.lc\"})\npublic class MyConfig {\n}\n```\n\n* 第二步：使用配置类。\n\n```java\n@Test\npublic void test2(){\n  //AnnotationConfigApplicationContext：通过配置类来配置spring的context\n  ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);\n  StudentService studentService = context.getBean(\"studentService\", StudentService.class);\n  studentService.test();\n}\n```\n\n## 2.4 Bean的两种类型\n\n* Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean）\n  * 普通 bean：在配置文件中定义的bean类型就是getBean()方法的返回类型\n  * 工厂 bean：在配置文件定义bean 类型和getBean()方法的返回类型不一样。\n\n**普通Bean**\n\n* xml配置\n\n```xml\n<bean id=\"user\" class=\"com.lc.beans.User\">\n  <property name=\"name\" value=\"cl\"></property>\n  <property name=\"age\" value=\"18\"></property>\n</bean>\n```\n\n* Java代码\n\n```java\nApplicationContext context = new ClassPathXmlApplicationContext(\"bean-config.xml\");\n//配置文件中的class类型就是User,这里的返回值还是User类型\nUser user = context.getBean(\"user\", User.class);\nSystem.out.println(user);\n```\n\n**工厂Bean**\n\n* 工厂Bean的实现方式\n  * 第一步：创建实现FactoryBean接口的类，让这个类作为工厂Bean.\n  * 第二部：实现接口的方法，在实现的方法中定义返回的Bean类型。\n\n* xml配置文件\n\n```xml\n<bean id=\"factory\" class=\"com.lc.beans.Factory\"></bean>\n```\n\n* 工厂Bean\n\n```java\npublic class Factory implements FactoryBean<User> {\n  //此方法用于返回创建的Bean\n  @Override\n  public User getObject() throws Exception {\n    return new User(\"Asd\",15);\n  }\n  //此方法用于返回此工厂Bean创建的Bean类型\n  @Override\n  public Class<?> getObjectType() {\n    return null;\n  }\n  //此方法用于设置是否是单例的\n  @Override\n  public boolean isSingleton() {\n    return true;\n  }\n}\n```\n\n* 测试代码\n\n```java\nApplicationContext context = new ClassPathXmlApplicationContext(\"bean-config.xml\");\n//配置文件中的class类型是Factory,而这里的返回值是User类型\nUser user = context.getBean(\"factory\", User.class);\nSystem.out.println(user);\n```\n\n## 2.5 Bean的作用域\n\n* Bean的作用域实际上就是指Bean是否单例的。还是多实例的。\n* 在Spring中Bean默认是单例对象。即获取多个Bean时，实际上获取的是同一个Bean对象。\n* 在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例。\n* scope 属性值\n  * 第一个值 默认值，singleton，表示当前Bean是单实例对。\n  * 第二个值 prototype，表示当前Bean是多实例对象。\n* singleton 和 prototype 区别\n  * singleton 单实例，prototype 多实例\n  * 设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象。\n  * 设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建 对象，在调用getBean 方法时候创建多实例对象。\n* 多实例的体现：\n\n```xml\n<bean id=\"user\" class=\"com.lc.beans.User\" scope=\"prototype\"></bean>\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210302192831.png)\n\n## 2.6 Bean的生命周期\n\n* 生命周期：从对象创建到对象销毁的过程。\n\n* Bean生命周期(一般包含五个过程)：\n\n  * （1）通过构造器创建 bean 实例（无参数构造）\n  * （2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）\n  * （3）调用 bean 的初始化的方法（需要进行配置初始化的方法）\n  * （4）bean 可以使用了（对象获取到了）\n  * （5）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）\n\n* 当加上Bean的后置处理器后。Bean的生命周期变成了七个过程：\n\n  * （1）通过构造器创建 bean 实例（无参数构造）\n  * （2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）\n  * （3）后置处理器在初始化前的操作\n  * （4）调用 bean 的初始化的方法（需要进行配置初始化的方法）\n  * （5）后置处理器在初始化后的操作\n  * （6）bean 可以使用了（对象获取到了）\n  * （7）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）\n\n* 实例\n\n  * 创建后置处理器。实现BeanPostProcessor接口。实现接口的方法\n\n  ```java\n  public class MyBeanPost implements BeanPostProcessor {\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n      System.out.println(\"在初始化前执行的方法\");\n      return bean;\n    }\n  \n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n      System.out.println(\"在初始化后执行的方法\");\n      return bean;\n    }\n  }\n  ```\n\n  * 创建Bean类，并创建初始化，销毁等方法\n\n  ```java\n  public class Teacher {\n    private String name;\n    public Teacher() {\n      System.out.println(\"第一步 执行无参构造方法\");\n    }\n    public void setName(String name) {\n      System.out.println(\"第二步 调用set方法设置属性值\");\n      this.name = name;\n    }\n    public void initMethod(){\n      System.out.println(\"第三步 执行初始化方法\");\n    }\n    public void destroyMethod(){\n      System.out.println(\"第五步 执行销毁方法\");\n    }\n  }\n  ```\n\n  * 配置文件\n\n  ```xml\n  <!--Bean的生命周期\n        init-method:用于指定此Bean的初始化方法是哪个\n        destroy-method:用于指定此Bean的销毁方法是哪个\n        -->\n  <bean id=\"teacher\" class=\"com.lc.beans.Teacher\"\n        init-method=\"initMethod\" destroy-method=\"destroyMethod\">\n    <property name=\"name\" value=\"asd\"></property>\n  </bean>\n  <!--配置后置处理器-->\n  <bean id=\"myBeanPost\" class=\"com.lc.services.MyBeanPost\"></bean>\n  ```\n\n  * 测试\n\n  ```java\n  ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"bean-config.xml\");\n  //配置文件中的class类型是Factory,而这里的返回值是User类型\n  Teacher teacher = context.getBean(\"teacher\", Teacher.class);\n  System.out.println(\"第四步 获取Bean实例对象\");\n  System.out.println(teacher);\n  //手动销毁应用上下文\n  context.close();\n  ```\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210306154933.png)\n\n## 2.7 Bean的自动装配功能\n\n* 什么是自动装配？\n\n  * 根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入。\n\n* 使用方式\n\n  * 根据属性名称自动装配：即Bean的属性名和它的值的id相同。\n\n  ```xml\n  <!--autowire属性：配置自动装配\n          常用值byName：根据属性名称注入，注入值bean的id值和类属性名称一样\n          常用值byType：根据属性类型注入，若存在多个相同类型的bean则会报错-->\n  <bean id=\"people\" class=\"com.lc.beans.People\" autowire=\"byName\">\n    <property name=\"name\" value=\"asd\"></property>\n  </bean>\n  <bean id=\"user\" class=\"com.lc.beans.User\">\n    <property name=\"name\" value=\"qwe\"></property>\n    <property name=\"age\" value=\"15\"></property>\n  </bean>\n  ```\n\n  * 根据属性类型自动装配：即Bean的属性类型和它的值的属性类型相同。\n\n  ```xml\n  <bean id=\"people\" class=\"com.lc.beans.People\" autowire=\"byType\">\n    <property name=\"name\" value=\"asd\"></property>\n  </bean>\n  <bean id=\"user\" class=\"com.lc.beans.User\" >\n    <property name=\"name\" value=\"qwe\"></property>\n    <property name=\"age\" value=\"15\"></property>\n  </bean>\n  ```\n\n## 2.8 Bean操作-引入外部属性文件\n\n* 以配置德鲁伊数据连接池为例\n\n  * 第一步 引入德鲁伊连接池依赖jar包，放到lib下。下载地址：[下载](https://plumriver.lanzous.com/iuj4Vmdxucf)\n  * 第二步 创建外部属性文件，properties格式文件，编写数据库信息。\n\n  ```properties\n  driverClass=com.mysql.jdbc.Driver\n  url=jdbc:mysql://localhost:3306/test\n  userName=root\n  password=root\n  ```\n\n  * 第三步 在配置文件中引用外部属性文件，并配置数据库连接池。\n    * 引用外部属性文件，需要在配置文件中引入context名称空间\n\n  ```xml\n  <beans xmlns=\"http://www.springframework.org/schema/beans\"\n         xmlns:context=\"http://www.springframework.org/schema/context\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                             http://www.springframework.org/schema/beans/spring-beans.xsd\n                             http://www.springframework.org/schema/context\n                             http://www.springframework.org/schema/context/spring-context.xsd\">\n    <!--引入外部属性文件-->\n    <context:property-placeholder location=\"classpath:db.properties\"/>\n    <!--配置德鲁伊连接池-->\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n      <property name=\"driverClassName\" value=\"${driverClass}\"></property>\n      <property name=\"url\" value=\"${url}\"></property>\n      <property name=\"username\" value=\"${userName}\"></property>\n      <property name=\"password\" value=\"${password}\"></property>\n    </bean>\n  </beans>\n  ```\n\n# 第三章 Aop\n\n## 3.1 Aop的概念\n\n* Aop：面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n* 通俗描述：不通过修改源代码方式，在主干功能里面添加新功能。\n* 以登录功能为例：在实现和登录功能后，想添加一个权限的功能。可以在不修改源代码的基础上直接添加。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210304163738.png)\n\n* Aop的底层原理：使用动态代理方式实现。\n\n  * 当有接口时，使用JDK的动态代理(创建接口实现类代理对象，来增强实现类的方法)。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210304163725.png)\n\n  * 当没有接口时，使用CGLIB动态代理(创建子类代理对象，来增强子类的方法)。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210304163746.png)\n\n## 3.2 JDK动态代理\n\n* JDK已经封装好了动态代理的逻辑，因此只要使用包装类即可。\n\n  * 动态代理需要通过Proxy类的newProxyInstance()静态方法来获取代理对象。\n\n* newProxyInstance()静态方法由三个参数：\n\n  * ClassLoader loader：类加载器\n  *  Class<?>[] interfaces：增强方法所在的类，这个类实现的所有接口数组。\n  * InvocationHandler h：实现InvocationHandler 接口的代理对象，此代理对象用于增强方法。\n\n* 注意Proxy类和InvocationHandler 接口都是java.lang.reflect包下的。\n\n* 实例：\n\n  * 接口和实现类\n\n  ```java\n  public interface UserService {\n    int add(int a,int b);\n    int say(int c);\n  }\n  public class UserServiceImpl implements UserService{\n    @Override\n    public int add(int a, int b) {\n      System.out.println(\"执行add。。。\");\n      return a+b;\n    }\n  \n    @Override\n    public int say(int c) {\n      return c;\n    }\n  }\n  ```\n\n  * 对接口实现类进行增强的代理对象\n\n  ```java\n  public class UserServiceProxy implements InvocationHandler {\n  \n    //设置一个属性，用于接受受增强的类\n    private Object object;\n  \n    public UserServiceProxy(Object object) {\n      this.object = object;\n    }\n  \n    /**\n     * 此方法用于增强object类的某个方法\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n  \n      System.out.println(\"执行\" + method.getName() + \"方法前 : \" + \"此方法传入的参数为：\" + Arrays.toString(args));\n      //执行object类中原来的方法内容。返回值为\n      Object res = method.invoke(object, args);\n      System.out.println(\"执行\" + method.getName() + \"方法后\");\n      return res;\n    }\n  }\n  ```\n\n  * 使用方式\n\n  ```java\n  public class SpringTest {\n    public static void main(String[] args) {\n      //创建接口实现类实现的接口数组\n      Class[] interfaces = {UserService.class};\n      //创建接口实现类\n      UserServiceImpl service = new UserServiceImpl();\n      //创建接口实现类的代理对象\n      UserServiceProxy proxy = new UserServiceProxy(service);\n      //获取代理后的接口实现类对象\n      UserService userService = (UserService) Proxy.newProxyInstance(SpringTest.class.getClassLoader(), interfaces, proxy);\n  \n      //使用增强后的接口实现类\n      int result = userService.add(1, 2);\n      System.out.println(\"result =\" + result);\n    }\n  }\n  ```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210304170514.png)\n\n## 3.3 Aop的术语\n\n* 连接点：类里面哪些方法可以被增强，这些方法称为连接点。\n  * 例如上述实现类中的add方法和say方法。因为这些方法可以被增强。\n* 切入点：实际被真正增强的方法，称为切入点。\n  * 例如上述实现类的add方法。因为这个方法被增强了。\n* 通知(/增强)：实际增强的逻辑部分称为通知(增强)。通知有很多类型。\n  * 前置通知：在原方法的执行前，增强的代码被称为前置通知。\n    * 例如上述的输出\"执行add方法前\"的代码。\n  * 后置通知：在原方法的执行后，增强的代码被称为前置通知。\n    * 例如上述的输出\"执行add方法后\"的代码。\n  * 环绕通知：在原方法执行前和执行后，执行的代码被称为环绕通知。\n  * 异常通知：当原方法出现异常时，执行的代码被称为异常通知。\n  * 最终通知：原方法执行后或出现异常后都会执行的代码被称为后置通知。类比try-catch中的finally作用。\n* 切面：把通知应用到切入点过程。是一个动作。\n  * 例如在登录功能中添加权限判断的过程被称为切面。\n\n## 3.4 Aop操作-准备工作\n\n* Spring 框架一般都是基于AspectJ 实现 AOP 操作\n  * AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使用，进行 AOP 操作\n* 基于 AspectJ 实现 AOP 操作\n  * 基于 xml 配置文件实现\n  * 基于注解方式实现\n* 在项目工程中引入AOP相关依赖\n  * spring-aspects：[下载地址](https://plumriver.lanzous.com/iHSzImhvs3g)\n  * spring,net：[下载地址](https://plumriver.lanzous.com/ipTf4mhvpuf)\n  * spring.aop：[下载地址](https://plumriver.lanzous.com/iBZ8Dmhvprc)\n  * spring.sapectj：[下载地址](https://plumriver.lanzous.com/iFnwWmhvpte)\n* 切入点表达式\n  * 切入点表达式作用：知道对哪个类里面的哪个方法进行增强。\n  * 语法结构： execution([权限修饰符] [返回类型] [类全路径] \\[方法名称]([参数列表]) )\n* 举例 1：对 com.zut.dao.BookDao 类里面的 add 进行增强\n  * execution(* com.zut.dao.BookDao.add(..))\n  * 权限修饰符省略不写，返回类型以*代替表示全部，参数列表以..代替表示可变形参\n* 举例 2：对 com.zut.dao.BookDao 类里面的所有的方法进行增强\n  * execution(* com.zut.dao.BookDao.*(..))\n  * 方法名以*代替表示匹配全部\n* 举例 3：对 com.zut.dao 包里面所有类，类里面所有方法进行增强\n  * execution(* com.zut.dao.\\*.*(..))\n  * 类型以*代替表示匹配全部\n\n## 3.5 Aop操作-基于AspectJ注解方式\n\n### 3.5.1 基础使用\n\n* 创建原始的类\n\n```java\n@Component\npublic class User {\n  public void add(){\n    System.out.println(\"User add.....\");\n  }\n}\n```\n\n* 创建增强类\n\n```java\n/**\n * @Component 将当前类实例为bean\n * @Aspect 表示当前类用于生成代理对象。\n */\n@Component\n@Aspect\npublic class UserProxy {\n  /**\n   * Before注解表示当前方法中的代码为前置通知。\n   * Before注解中的值为切入点表达式，表示要对那哪个方法进行增强\n   */\n  @Before(\"execution(* com.lc.mode2.beans.User.add(..))\")\n  public void before(){\n    System.out.println(\"before......前置通知\");\n  }\n  /**\n   * AfterReturning注解表示当前方法中的代码为后置通知。也被称为返回通知\n   */\n  @AfterReturning(\"execution(* com.lc.mode2.beans.User.add(..))\")\n  public void afterReturning(){\n    System.out.println(\"afterReturning......后置通知\");\n  }\n  /**\n   * After注解表示当前方法中的代码为最终通知。\n   */\n  @After(\"execution(* com.lc.mode2.beans.User.add(..))\")\n  public void after(){\n    System.out.println(\"after......最终通知\");\n  }\n\n  /**\n   * AfterThrowing注解表示当前方法中的代码为异常通知。\n   */\n  @AfterThrowing(\"execution(* com.lc.mode2.beans.User.add(..))\")\n  public void afterThrowing(){\n    System.out.println(\"afterThrowing......异常通知\");\n  }\n  /**\n   * Around注解表示当前方法中的代码为环绕通知。\n   * ProceedingJoinPoint参数：表示连接点\n   */\n  @Around(\"execution(* com.lc.mode2.beans.User.add(..))\")\n  public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n    System.out.println(\"around......环绕通知...前\");\n    //原方法的执行\n    proceedingJoinPoint.proceed();\n    System.out.println(\"around......环绕通知...后\");\n  }\n}\n```\n\n* 配置相关配置\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n  <!--开启注解/组件扫描-->\n  <context:component-scan base-package=\"com.lc.mode2\"></context:component-scan>\n  <!--开启Aspect代理功能-->\n  <aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n</beans>\n```\n\n* 测试\n\n```java\nApplicationContext context = new ClassPathXmlApplicationContext(\"spring1-config.xml\");\nUser user = context.getBean(\"user\", User.class);\nuser.add();\n```\n\n* 无异常时的输出\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210305102753.png)\n\n* 有异常时的输出\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210305102806.png)\n\n### 3.5.2 相同切入点的提取\n\n* 在增强类上使用@Pointcut注解提取。\n\n```java\n//相同切入点提取\n@Pointcut(\"execution(* com.lc.mode2.beans.User.add(..))\")\npublic void point(){};\n//使用相同切入点的方法名代替切入点\n@Before(\"point()\")\npublic void before(){\n  System.out.println(\"before......前置通知\");\n}\n@AfterReturning(\"point()\")\npublic void afterReturning(){\n  System.out.println(\"afterReturning......后置通知\");\n}\n```\n\n### 3.5.3 多个增强类的优先级设置\n\n* 在各个增强类上使用@Order(数字)注解。数字值越小优先级就越高。\n\n```java\n@Component\n@Aspect\n@Order(1)\npublic class UserProxy {}\n```\n\n### 3.5.4 完全注解开发\n\n* 可以使用配置类来代替配置文件的作用。实例如下\n\n```java\n//EnableAspectJAutoProxy注解对应xml中的aop:aspectj-autoproxy功能，其中\n//proxyTargetClass默认为false，因此要设置为true。表示开启代理功能\n@Configuration\n@ComponentScan(basePackages = {\"com.atguigu\"})\n@EnableAspectJAutoProxy(proxyTargetClass = true)\npublic class ConfigAop {\n}\n```\n\n## 3.6 Aop操作-基于AspectJ配置xml方式\n\n* 创建类和增强类\n\n```java\npublic class Book{\n  public void add(){System.out.println(\"add...\");}\n}\npublic class BookProxy{\n  public void before(){System.out.println(\"before....\");}\n}\n```\n\n* 配置文件\n\n```xml\n<!--创建bean对象-->\n<bean id=\"book\" class=\"com.lc.mode.Book\"></bean>\n<bean id=\"bookProxy\" class=\"com.lc.mode.BookProxy\"></bean>\n<!--配置aop功能-->\n<aop:config>\n  <!--配置切入点-->\n  <aop:pointcut id=\"p\" expression=\"execution(* com.lc.mode.Book.add(..)\"/>\n  <!--配置切面。指明代理对象-->\n  <aop:aspect ref=\"bookProxy\">\n    <!--配置前置通知-->\n    <aop:before method=\"before\" pointcut-ref=\"p\"></aop:before>\n  </aop:aspect>\n</aop:config>\n```\n\n# 第四章 JdbcTemplate\n\n## 4.1 准备工作\n\n* Spring 框架对 JDBC 进行封装，使用封装后的 JdbcTemplate 可以方便实现对数据库操作。\n\n* 准备工作\n\n  * 第一步：引入相关jar包。\n    * 下载地址：[mysql](https://plumriver.lanzous.com/ioWXUmimioj)，[jdbc](https://plumriver.lanzous.com/iFq27mimlmf)，[orm](https://plumriver.lanzous.com/iZVLTmimlng)，[tx](https://plumriver.lanzous.com/iGhFymimlpi)\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210305121142.png)\n\n  * 第二步：创建dao类，service类\n\n  ```java\n  @Repository\n  public class BookDaoImpl implements BookDao{\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n  }\n  @Service\n  public class BookService {\n    @Autowired\n    private BookDao bookDao;\n  }\n  ```\n\n  * 第三步：配置xml文件\n\n  ```xml\n  <beans xmlns=\"http://www.springframework.org/schema/beans\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xmlns:context=\"http://www.springframework.org/schema/context\"\n         xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\">\n    <!--开启注解/组件扫描-->\n    <context:component-scan base-package=\"com.lc\"></context:component-scan>\n    <!--配置数据库连接池-->\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n      <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"></property>\n      <property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring-jdbc\"></property>\n      <property name=\"username\" value=\"root\"></property>\n      <property name=\"password\" value=\"root\"></property>\n    </bean>\n    <!--创建JdbcTemplate对象-->\n    <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n      <!--注入连接池-->\n      <property name=\"dataSource\" ref=\"dataSource\"></property>\n    </bean>\n  </beans>\n  ```\n\n## 4.2 JdbcTemplate操作-添加/修改/删除\n\n* JdbcTemplate类中有个update()方法，用于更新数据库的信息。\n\n  ```java\n  int update(String sql, Object... args)\n  ```\n\n  * 第一个参数sql，表示要执行的sql语句，可以是添加语句，修改语句，删除语句。\n  * 第二个参数args，是个可变形参，表示执行语句中的占位符的值。\n  * 返回值为int类型，表示数据库中受影响的数据量。为0时表示执行失败。\n\n* 注意：args的形参顺序要和sql语句中的占位符顺序相对应\n\n### 4.2.1 添加操作样例\n\n```java\nString sql = \"insert into book(name,author,price,date) values(?,?,?,?)\";\n//由于第二个参数是可变参数，因此可以将其写成object数组的形式\nObject[] args = {book.getName(),book.getAuthor(),book.getPrice(),book.getDate()};\nint insert = jdbcTemplate.update(sql, args);\n```\n\n### 4.2.2 修改操作样例\n\n```java\nString sql = \"update book set name=?,author=?,price=? where id=?\";\nObject[] args = {book.getName(),book.getAuthor(),book.getPrice(),book.getId()};\nint update = jdbcTemplate.update(sql, args);\nreturn update;\n```\n\n### 4.2.3 删除操作样例\n\n```java\nString sql = \"delete from book where id = ?\";\nint delete = jdbcTemplate.update(sql, id);\n```\n\n## 4.3 JdbcTemplate操作-查询\n\n### 4.3.1 查询返回对象\n\n* JdbcTemplate类中有个queryForObject()方法，用于查询数据库并返回某一个值。\n\n  ```java\n  queryForObject(String sql, RowMapper<T> rowMapper, Object... args)\n  ```\n\n  * 第一个参数sql表示查询语句\n  * 第二个参数rowMapper，映射器，表示将结果映射到哪个类中\n  * 第三个参数args，可变形参，用于填充占位符\n\n```java\nString sql = \"select * from book where id=?\";\nBook book = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper<Book>(Book.class), id);\n```\n\n### 4.3.2 查询某个值\n\n* JdbcTemplate类中有个queryForObject()方法，用于查询数据库并返回某一个值。\n\n  ```java\n  queryForObject(String sql, Class<T> requiredType)\n  ```\n\n  * 第一个参数sql表示查询语句\n  * 第二个参数requiredType，表示返回结果的class\n\n```java\nString sql = \"select count(*) from book\";\nInteger integer = jdbcTemplate.queryForObject(sql, Integer.class);\n```\n\n### 4.3.3 查询返回集合\n\n* JdbcTemplate类中有个queryForObject()方法，用于查询数据库并返回某一个值。\n\n  ```java\n  List<T> query(String sql, RowMapper<T> rowMapper)\n  ```\n\n  * 第一个参数sql表示查询语句\n  * 第二个参数rowMapper，映射器，表示将结果映射到哪个类中\n\n```java\nString sql = \"select * from book\";\nList<Book> books = jdbcTemplate.query(sql, new BeanPropertyRowMapper<Book>(Book.class));\n```\n\n## 4.4 JdbcTemplate操作-批量添加/修改/删除\n\n* 批量操作：指将一条sql语句执行多遍，每一次执行的占位符的值不同。\n* JdbcTemplate类中有个()方法，用于批量操作sql语句。\n\n### 4.4.1 批量添加\n\n```java\nString sql = \"insert into book(name,author,price,date) values(?,?,?,?)\";\nint[] ints = jdbcTemplate.batchUpdate(sql, objects);\n```\n\n### 4.4.2 批量修改\n\n```java\nString sql = \"update book set name=?,author=?,price=? where id=?\";\nint[] ints = jdbcTemplate.batchUpdate(sql, objects);\n```\n\n### 4.4.3 批量删除\n\n```java\nString sql = \"delete from book where id = ?\";\nint[] ints = jdbcTemplate.batchUpdate(sql, objects);\n```\n\n# 第五章 事务功能\n\n## 5.1 基础概念\n\n* 事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败。\n* 典型场景：\n  * 银行转账，A转账100给B，A少100，B多100。\n  * 但是当A少100后，网络异常或其他原因导致系统无法让B多100，此时就会发生混乱。\n  * 解决此问题就是用事务解决，把转账事件当成一个事务。\n* 事务四个特性（ACID）\n  * 原子性\n  * 一致性\n  * 隔离性\n  * 持久性\n* 事务的操作过程。\n  * 第一步：开启事务。\n  * 第二步：进行业务操作。\n  * 第三步：业务操作完成，提交事务。\n  * 第四步：业务操作发生中断，事务回滚将业务回滚到未执行业务前的状态。\n* 事务可以在任何地方使用，但一般事务用于 JavaEE 三层结构里面 Service 层（即业务逻辑层）。\n* 在Spring进行事务管理操作有两种方式\n  * 编程式事务管理：即通过代码的方式实现事务的操作过程。缺点是多个地方需要事务时，会造成代码冗余。\n  * 声明式事务管理：通过注解或xml配置的方式进行事务的操作过程。\n* **声明式事务的底层使用的是AOP原理。**\n* 事务管理的API\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210305162242.png)\n\n## 5.2 事务操作-基于注解方式\n\n* 第一步：在配置文件中配置事务管理功能，并开启事务注解功能\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\">\n\n  <!--开启注解/组件扫描-->\n  <context:component-scan base-package=\"com.lc\"></context:component-scan>\n  <!--配置数据库连接池-->\n  <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n    <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"></property>\n    <property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring-jdbc\"></property>\n    <property name=\"username\" value=\"root\"></property>\n    <property name=\"password\" value=\"root\"></property>\n  </bean>\n\n  <!--创建JdbcTemplate对象-->\n  <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n    <!--注入连接池-->\n    <property name=\"dataSource\" ref=\"dataSource\"></property>\n  </bean>\n\n<!--创建事务管理-->\n  <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n<!--注入数据源-->\n    <property name=\"dataSource\" ref=\"dataSource\"></property>\n  </bean>\n<!--开启事务注解功能-->\n  <tx:annotation-driven transaction-manager=\"transactionManager\"></tx:annotation-driven>\n\n</beans>\n```\n\n* 第二步：在service层中的service类上添加事务注解@Transactional\n  * 这个注解可以写在类上，也可以写在方法上。\n  * 如果把这个注解添加类上面，这个类里面所有的方法都添加事务。\n  * 如果把这个注解添加方法.上面，为这个方法添加事务。\n\n```java\n@Service\n@Transactional\npublic class UserService {}\n```\n\n* 此时事务的功能就开启了。\n\n## 5.3 注解的参数\n\n* @Transactional注解中有很多参数，可以配置事务的相关信息。如下\n  * propagation：用于设置事务传播行为\n  * isolation：用于设置事务隔离级别\n  * timeout：用于设置超时时间\n  * readOnly：用于设置是否只读\n  * rollbackFor：用于设置回滚\n  * noRollbackFor：用于设置不回滚\n\n**propagation：事务传播行为**\n\n* 事务方法：指对数据库进行变化的操作。\n\n* 事务传播行为：指一个方法调用另一个方法时，它们之间的事务传递方式。\n\n* 事务传播行为有七种：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210305174026.png)\n\n* 举例：方法add有事务注解，方法update没有事务注解。如下图：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210305174000.png)\n\n* 使用方式:\n\n```java\n@Transactional(propagation = Propagation.REQUIRED)\n```\n\n**isolation：事务隔离级别**\n\n* 事务的隔离性是指，多事务操作之间不会产生影响。不考虑隔离性会产生很多问题。\n\n  * 三个问题：脏读，不可重复度，幻读。\n\n* 脏读：一个未提交事务读取到另一个未提交事务的数据。\n\n* 不可重复度：一个未提交事务读取到另一提交事务修改数据。\n\n* 幻读：一个未提交事务读取到另一提交事务添加数据。\n\n* 事务隔离级别有四种:\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210305174454.png)\n\n* 使用方式如下\n\n```java\n@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.SERIALIZABLE)\n```\n\n**timeout：超时时间**\n\n* 事务需要在一定时间内进行提交，如果不提交进行回滚。\n* 默认值是 -1，设置时间以秒单位进行计算。\n\n**readOnly：是否只读**\n\n* 读：查询操作，写：添加修改删除操作。\n* readOnly 默认值 false，表示可以查询，可以添加修改删除操作。\n* 设置 readOnly 值为 true 之后，只能查询。\n\n**rollbackFor：回滚**\n\n* 设置出现哪些异常进行事务回滚\n\n**noRollbackFor：不回滚**\n\n* 设置出现哪些异常不进行事务回滚\n\n## 5.4 事务操作-基于xml方式\n\n* 第一步：配置事务管理器\n* 第二步：配置通知\n* 第三步：配置切入点和切面\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n  <!--开启注解/组件扫描-->\n  <context:component-scan base-package=\"com.lc\"></context:component-scan>\n  <!--配置数据库连接池-->\n  <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n    <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"></property>\n    <property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring-jdbc\"></property>\n    <property name=\"username\" value=\"root\"></property>\n    <property name=\"password\" value=\"root\"></property>\n  </bean>\n\n  <!--创建JdbcTemplate对象-->\n  <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n    <!--注入连接池-->\n    <property name=\"dataSource\" ref=\"dataSource\"></property>\n  </bean>\n\n  <!--第一步：创建事务管理-->\n  <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n    <!--注入数据源-->\n    <property name=\"dataSource\" ref=\"dataSource\"></property>\n  </bean>\n  <!--第二步：配置通知。即配置事务的类型和参数数据-->\n  <tx:advice id=\"transaction\">\n    <!--配置事务参数-->\n    <tx:attributes>\n      <!--配置以哪种犯法匹配事务。name表示方法名。account*表示匹配account开头字符串的方法名-->\n      <tx:method name=\"account*\" propagation=\"REQUIRED\"/>\n    </tx:attributes>\n  </tx:advice>\n  <!--第三步：配置切入点和切面-->\n  <aop:config>\n    <!--配置切入点，即事务作用于哪个类的哪个方法上-->\n    <aop:pointcut id=\"pt\" expression=\"execution(* com.lc.service.UserService.*(..))\"/>\n    <!--配置切面，即把事务和切入点连接在一起-->\n    <aop:advisor advice-ref=\"transaction\" pointcut-ref=\"pt\"></aop:advisor>\n  </aop:config>\n</beans>\n```\n\n## 5.5 事务操作-基于完全注解方式\n\n* 即将基于注解方式的xml配置文件也以注解的形式开发。\n* 以下的代码相当于5.2的xml配置文件的作用。\n\n```java\n@Configuration\n@ComponentScan(basePackages = \"com.lc\")\n@EnableTransactionManagement //开启事务注解功能\npublic class MyConfig {\n  //创建数据库连接池\n  public DruidDataSource getDruidDataSource(){\n    DruidDataSource druidDataSource = new DruidDataSource();\n    ////注入属性\n    druidDataSource.setUrl(\"jdbc:mysql://localhost:3306/spring-jdbc\");\n    druidDataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n    druidDataSource.setUsername(\"root\");\n    druidDataSource.setPassword(\"root\");\n    return druidDataSource;\n  }\n  //创建JdbcTeplate对象。dataSource是从ioc容器中传递过来的\n  public JdbcTemplate getJdbcTemplate(DruidDataSource dataSource){\n    JdbcTemplate jdbcTemplate = new JdbcTemplate();\n    //注入属性\n    jdbcTemplate.setDataSource(dataSource);\n    return jdbcTemplate;\n  }\n\n  //创建事务管理器。dataSource是从ioc容器中传递过来的\n  public DataSourceTransactionManager getDataSourceTransactionManager(DruidDataSource dataSource){\n    DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();\n    //注入属性\n    dataSourceTransactionManager.setDataSource(dataSource);\n    return dataSourceTransactionManager;\n  }\n}\n```\n\n# 第六章 Spring5新特性\n\n* 整个 Spring5 框架的代码基于 Java8，运行时兼容 JDK9**，**许多不建议使用的类和方法在代码库中删除。\n\n## 6.1 日志功能整合\n\n* Spring 5.0 框架自带了通用的日志封装\n\n* Spring5 已经移除 Log4jConfigListener，官方建议使用 Log4j2\n\n* 如果要使用Log4j低版本的话，需要将spring版本降低到4以下。\n\n* spring5整合log4j2\n\n  * 第一步：导入相关的日志jar包\n    * log4j2-api：[下载](https://plumriver.lanzous.com/iXSeCmkqv2b)\n    * log4j2-core：[下载](https://plumriver.lanzous.com/iydi2mkquzi)\n    * log4jw-slf4j：[下载](https://plumriver.lanzous.com/ipnAgmkqv0j)\n    * slf4j-api：[下载](https://plumriver.lanzous.com/ihtt0mkqv1a)\n  * 第二步：创建配置文件。文件名固定为log4j2.xml。文件内容如下\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <!--日志级别以及优先级排序: OFF > FATAL > ERROR > WARN > INFO > DEBUG > TRACE > ALL -->\n  <!--Configuration后面的status用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，可以看到log4j2内部各种详细输出-->\n  <configuration status=\"INFO\">\n    <!--先定义所有的appender-->\n    <appenders>\n      <!--输出日志信息到控制台-->\n      <console name=\"Console\" target=\"SYSTEM_OUT\">\n        <!--控制日志输出的格式-->\n        <PatternLayout pattern=\"%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\n      </console>\n    </appenders>\n    <!--然后定义logger，只有定义了logger并引入的appender，appender才会生效-->\n    <!--root：用于指定项目的根日志，如果没有单独指定Logger，则会使用root作为默认的日志输出-->\n    <loggers>\n      <root level=\"info\">\n        <appender-ref ref=\"Console\"/>\n      </root>\n    </loggers>\n  </configuration>\n  ```\n\n* 使用log4j2在控制台输出\n\n```java\npublic class MyLog {\n  private static final Logger logger = LoggerFactory.getLogger(MyLog.class);\n\n  public static void main(String[] args) {\n    logger.info(\"hello info logger\");\n    logger.warn(\"hello warn logger\");\n  }\n}\n```\n\n* 结果\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210306111003.png)\n\n## 6.2 @Nullable注解\n\n* Spring5框架核心容器支持@Nullable注解。\n* @Nullable 注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以为空，参数值可以为空。\n\n```java\n//在属性上使用@Nullable注解\n@Nullable\nprivate ResourceLoader resourceLoader;\n//在参数上使用@Nullable注解\npublic GenericApplicationContext(@Nullable ApplicationContext parent) {\n  this();\n  setParent(parent);\n}\n//在方法上使用@Nullable注解\n@Override\n@Nullable\npublic ClassLoader getClassLoader() {\n  if (this.resourceLoader != null && !this.customClassLoader) {\n    return this.resourceLoader.getClassLoader();\n  }\n  return super.getClassLoader();\n}\n```\n\n## 6.3 函数式编程风格\n\n* Spring5 核心容器支持函数式风格 GenericApplicationContext\n* 以将自己new出的对象放到bean中，而不是通过spring创建bean。\n\n```java\n//创建GenericApplicationContext对象\nGenericApplicationContext context = new GenericApplicationContext();\n//创建user对象并注册到ioc中\ncontext.refresh();\n//注册时不设置bean的name\ncontext.registerBean(User.class, ()->new User());\n//获取ioc中的bean.通过User的包路径\nUser user = (User) context.getBean(\"bean.User\");\nSystem.out.println(user);\n\n//第二种方式\ncontext.refresh();\n//注册时设置bean的name为user1\ncontext.registerBean(\"user1\",User.class, ()->new User());\nUser user1 = (User) context.getBean(\"user1\");\nSystem.out.println(user1);\n```\n\n## 6.4 单元测试\n\n* 第一步导入spring关于测试的依赖\n  * spring-text：[下载](https://plumriver.lanzous.com/ii4HPmkxpni)\n* 第二步：导入JUnit4和JUnit5相关的jar包\n  * JUnit4：[jar包1](https://plumriver.lanzous.com/icypxmkxsbe)，[jar包2](https://plumriver.lanzous.com/ituYNmkxseh)\n  * JUnit5：[jar包1](https://plumriver.lanzous.com/i4zQ5mkyapg)，[jar包2](https://plumriver.lanzous.com/ikzhrmkyf3e)\n\n### 6.4.1 JUnit4\n\n```java\n/*\n * @RunWith 表示运行时的环境\n * @ContextConfiguration 表示加载的spring配置文件\n */\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:spring-config.xml\")\npublic class JUnit4Test {\n  @Autowired\n  private User user;\n\n  @Test\n  public void test1(){\n    System.out.println(user);\n  }\n}\n```\n\n### 6.4.2 JUnit5\n\n* 普通写法\n\n```java\n@ExtendWith(SpringExtension.class)\n@ContextConfiguration(\"classpath:spring-config.xml\")\npublic class JUnit5Test {\n  @Autowired\n  private User user;\n  @Test\n  public void test1(){\n    System.out.println(user);\n  }\n}\n```\n\n* 使用复合注解\n\n```java\n@SpringJUnitConfig(locations = \"classpath:spring-config.xml\")\npublic class JUnit5Test {\n  @Autowired\n  private User user;\n  @Test\n  public void test1(){\n    System.out.println(user);\n  }\n}\n```\n\n## 6.5 webflux\n\n### WebFlus介绍\n\n* SpringWebFlux是 Spring5 添加新的模块，用于 web 开发的，功能和 SpringMVC 类似的，Webflux 使用当前一种比较流程响应式编程出现的框架。\n\n* 使用传统 web 框架，比如 SpringMVC，这些基于 Servlet 容器；Webflux 是一种异步非阻塞的框架，异步非阻塞的框架在 **Servlet3.1 以后**才支持，核心是基于 Reactor 的相关 API 实现的。\n\n  * 异步和同步：针对调用者。调用者发送请求，如果等着对方回应之后才去做其他事情就是同步，如果发送请求之后不等着对方回应就去做其他事情就是异步\n\n  * 阻塞和非阻塞：针对被调用者。被调用者受到请求之后，做完请求任务之后才给出反馈就是阻\n\n    塞，受到请求之后马上给出反馈然后再去做事情就是非阻塞。\n\n* WebFlux的特点：\n\n  * 第一 非阻塞式：在有限资源下，提高系统吞吐量和伸缩性，以 Reactor 为基础实现响应式编程。\n  * 第二 函数式编程：Spring5 框架基于 java8，Webflux 使用 Java8 函数式编程方式实现路由请求。\n\n* WebFlux与SpringMVC的区别：\n\n  * 第一 两个框架都可以使用注解方式，都运行在 Tomet 等容器中。\n  * 第二 SpringMVC 采用命令式编程，Webflux 采用异步响应式编程。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210427083625.png)\n\n* 创建springboot项目为例：\n\n### 响应式编程\n\n* 什么是响应式编程\n\n  * 响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便\n\n    地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。\n\n  * 电子表格程序就是响应式编程的一个例子。单元格可以包含字面值或类似\"=B1+C1\"的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变化。\n\n* Java8 及其之前版本\n\n  * 提供的**观察者模式**两个类 Observer 和 Observable.\n\n  ```java\n  /**\n   * 被观察者。\n   * 观察者 看 被观察者。\n   */\n  public class ObserverDemo extends Observable {\n    public static void main(String[] args) {\n      ObserverDemo observer = new ObserverDemo();\n      //添加观察者\n      observer.addObserver((o,arg)->{\n        System.out.println(\"被观察者动了\");\n      });\n      observer.addObserver((o,arg)->{\n        System.out.println(\"我看到被观察者动了，我要做。。。\");\n      });\n      //被观察者的数据变了\n      observer.setChanged();\n      //通知所有观察者。\n      observer.notifyObservers();\n    }\n  }\n  \n  ```\n\n* Java9版本：\n\n  * 使用Publisher接口实现。\n\n* Reactor实现响应式编程。\n\n  * 响应式编程操作中，所有操作都遵循Reactive 规范，Reactor就是遵循这个规范的框架。\n\n  * Reactor 有两个核心类，Mono 和 Flux，这两个类实现接口 Publisher，提供丰富操作\n    符。\n\n    * Flux 对象实现发布者，返回 N 个元素；\n    * Mono 实现发布者，返回 0 或者 1 个元素。\n    * 发布者类似于被观察者。\n\n  * Flux 和 Mono 都是数据流的发布者，使用 Flux 和 Mono 都可以发出三种数据信号：\n    元素值，错误信号，完成信号。\n\n    * 错误信号和完成信号都代表终止信号。\n    * 终止信号用于告诉订阅者数据流结束了。\n    * 错误信号终止数据流同时把错误信息传递给订阅者。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210427100117.png)\n\n  * 三种信号特点：\n    * 错误信号和完成信号都是终止信号，不能共存的。\n    * 如果没有发送任何元素值，而是直接发送错误或者完成信号，表示是空数据流。\n    * 如果没有错误信号，没有完成信号，表示是无限数据流。\n\n  * 演示：\n\n    * 第一步：引入依赖\n\n    ```xml\n    <dependency>\n      <groupId>io.projectreactor</groupId>\n      <artifactId>reactor-core</artifactId>\n      <version>3.1.5.RELEASE</version>\n    </dependency>\n    ```\n\n    * 第二步：编写代码\n\n    ```java\n    /**\n     * 使用Reactor实现响应式编程\n     */\n    public static void main(String[] args) {\n      //数据流的定义\n      Flux.just(1,2,3,4);\n      Mono.just(1);\n      //其他类型数据的\n      Integer[] array = {1,2,3,4};\n      Flux.fromArray(array);\n    \n      List<Integer> list = Arrays.asList(array);\n      Flux.fromIterable(list);\n    \n      Stream<Integer> stream = list.stream();\n      Flux.fromStream(stream);\n    \n      //终止信号\n      Flux.error(new RuntimeException());\n      Mono.error(new RuntimeException());\n    \n    }\n    ```\n\n  * 调用 just 或者其他方法只是声明数据流，数据流并没有发出，只有进行订阅之后才会触发数据流，不订阅什么都不会发生的。\n\n    * 订阅的内容类似于观察者看到被观察者变了之后要执行的业务。\n\n    ```java\n    Flux.just(1,2,3,4).subscribe(System.out::print);\n    Mono.just(1).subscribe(System.out::print)\n    ```\n\n* 操作符：对数据流进行一道道操作，成为操作符，比如工厂流水线。\n\n  * map操作符：将元素映射为新元素。\n    * 例如将1，2，3.按照平方的规则映射为1，4，9\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210427104447.png)\n\n  * flatmap操作符：将元素映射为流。把每个元素转换流，把转换之后多个流合并大的流。\n    * 顺序没有区别。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210427104451.png)\n\n### 执行流程和核心 API\n\n* SpringWebflux 基于 Reactor，默认使用容器是 Netty，Netty 是高性能的 NIO 框架，异步非阻塞的框架。\n\n  * 引入webflux的依赖\n\n  ```xml\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-webflux</artifactId>\n  </dependency>\n  ```\n\n* Netty\n\n  * 阻塞的过程\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210427144138.png)\n\n  * 非阻塞的过程\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210427144209.png)\n\n  * SpringWebflux 执行过程和 SpringMVC 相似的。\n\n    * SpringWebflux 核心控制器 DispatcherHandler，实现接口 WebHandler。\n\n    * 接口 WebHandler只有一个方法。\n\n      ```java\n      public interface WebHandler {\n        //核心业务处理方法\n        Mono<Void> handle(ServerWebExchange var1);\n      }\n      //其实现方法\n      public Mono<Void> handle(ServerWebExchange exchange) {\n        if (this.handlerMappings == null) {\n          return createNotFoundError();\n        }\n        if (CorsUtils.isPreFlightRequest(exchange.getRequest())) {\n          return handlePreFlight(exchange);\n        }\n        //加载mappers列表\n        return Flux.fromIterable(this.handlerMappings)\n          //根据请求地址获取对应mapping\n          .concatMap(mapping -> mapping.getHandler(exchange))\n          .next()\n          .switchIfEmpty(createNotFoundError())\n         \t//调用具体的业务方法\n          .flatMap(handler -> invokeHandler(exchange, handler))\n          //处理结果返回值\n          .flatMap(result -> handleResult(exchange, result));\n      }\n      ```\n\n  * SpringWebflux 里面 DispatcherHandler，负责请求的处理。\n\n    * HandlerMapping属性：请求查询到处理的方法。\n    * HandlerAdapter属性：真正负责请求处理。\n    * ResultHandler属性：响应结果处理。\n\n  * SpringWebflux 实现函数式编程，两个接口：\n\n    * RouterFunction（路由处理）。\n    * HandlerFunction（处理函数）。\n\n### SpringWebFlux(基于注解编程实现)\n\n* 使用注解编程模型方式，和之前 SpringMVC 使用相似的，只需要把相关依赖配置到项目中。\n\n* 示例使用springboot项目，会自动配置相关依赖。并且webflux场景默认使用netty服务器。\n\n* 第一步：创建Springboot项目，引入相关依赖。\n\n  ```xml\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-webflux</artifactId>\n  </dependency>\n  <dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n  </dependency>\n  ```\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210427185510.png)\n\n* 第二步：配置启动端口号\n\n  ```properties\n  server.port=8081\n  ```\n\n* 第三步：创建包和实体类\n\n  * 实体类\n\n    ```java\n    @Data\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public class UserDAO {\n      private String name;\n      private String gender;\n      private Integer age;\n    }\n    ```\n\n  * 服务层（注意写法，和MVC的写法有些不同）\n\n    * 接口\n\n    ```java\n    public interface UserServer {\n      /**\n       * 根据id查询用户信息。\n       * 由于返回值只有一个或者没有，因此使用Mono\n       */\n      Mono<UserDAO> getUserById(Integer id);\n      /**\n       * 获取全部的用户信息\n       * 由于返回值会有多个，因此使用Flux\n       */\n      Flux<UserDAO> listUsers();\n    \n      /**\n       * 往数据库中插入数据.\n       * 由于可以没有返回值，因此使用Void\n       * 参数只有一个，因此使用mono\n       */\n      Mono<Void> saveUser(Mono<UserDAO> user);\n    }\n    ```\n\n    * 实现类（由于不连接数据库）\n\n    ```java\n    @Service\n    public class UserServerImpl implements UserServer {\n      //由于不连接数据库，所以创建一些静态的数据，来模拟数据库的操作\n      private final HashMap<Integer,UserDAO> users = new HashMap<>();\n      public UserServerImpl(){\n        this.users.put(1, new UserDAO(\"ls\",\"男\",18));\n        this.users.put(2, new UserDAO(\"ww\",\"男\",20));\n        this.users.put(3, new UserDAO(\"zs\",\"女\",28));\n        this.users.put(4, new UserDAO(\"qq\",\"男\",38));\n      }\n    \n      @Override\n      public Mono<UserDAO> getUserById(Integer id) {\n        //如果有数据，就返回数据组成的流。如果没有数据，返回空流\n        return Mono.justOrEmpty(this.users.get(id));\n      }\n    \n      @Override\n      public Flux<UserDAO> listUsers() {\n        return Flux.fromIterable(this.users.values());\n      }\n    \n      @Override\n      public Mono<Void> saveUser(Mono<UserDAO> userMono) {\n        // doOnNext()方法表示取出数据域中的值，放到person中。\n        // 然后执行函数内的步骤。\n        // 最后，thenEmpty(Mono.empty())表示将当前数据域中的数据清空。\n        // 即返回一个空数据域\n        return userMono.doOnNext(person->{\n          int id = users.size()+1;\n          this.users.put(id,person);\n        }).thenEmpty(Mono.empty());\n      }\n    }\n    ```\n\n  * 控制层\n\n  ```java\n  @RestController\n  public class UserController {\n    @Autowired\n    private UserServer userServer;\n    //查询用户信息\n    @GetMapping(\"/user/{id}\")\n    public Mono<UserDAO> getUser(@PathVariable Integer id){\n      return userServer.getUserById(id);\n    }\n    //获取用户信息\n    @GetMapping(\"/users\")\n    public Flux<UserDAO> getUsers(){\n      return userServer.listUsers();\n    }\n    //添加用户信息\n    @PostMapping(\"/user/save\")\n    public Mono<Void> addUser(@RequestBody UserDAO userDAO){\n      Mono<UserDAO> userMono = Mono.just(userDAO);\n      return userServer.saveUser(userMono);\n    }\n  \n  }\n  ```\n\n* 第四步：启动SpringBoot。打印如下信息\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210427184619.png)\n\n### SpringWebFlux(基于函数式编程实现)\n\n* 在使用函数式编程模型操作时候，需要自己初始化服务器。\n\n* 基于函数式编程模型时候，有两个核心接口：\n\n  * RouterFunction（实现路由功能，请求转发给对应的 handler）和 HandlerFunction（处理请求生成响应的函数）。\n    * 理解：对比SpringMVC，\n    * RouterFunction的功能相当于将请求匹配到对应的控制层的方法上。比如mapping注解\n    * HandlerFunction的功能相当于这个方法。\n  * 核心任务定义两个函数式接口的实现并且启动需要的服务器。\n\n* SpringWebflux 请 求 和 响 应 不 再 是 **Servlet**Request 和 **Servlet**Response ，而是**Server**Request 和 **Server**Response。\n\n* 第一步：把注解编程模型工程复制一份 ，保留 pojo 和 service 内容。删除controller层。\n\n* 第二步：创建<font color=\"red\">Handler</font>(相当于UserController)\n\n  ```java\n  public class UserHandler {\n    private final UserServer userServer;\n    public UserHandler(UserServer userServer){\n      this.userServer = userServer;\n    }\n    //根据id查询\n    public Mono<ServerResponse> getUser(ServerRequest request){\n      //获取id值\n      int userId = Integer.valueOf(request.pathVariable(\"id\"));\n      //空值预处理\n      Mono<ServerResponse> notFound = ServerResponse.notFound().build();\n      //调用server方法得到数据\n      Mono<UserDAO> userMono= this.userServer.getUserById(userId);\n      /**\n       * 1.通过flatmap将userDAO转换成ServerResponse。\n       * 2.设置ServerResponse状态为ok.内容类型为json格式，内容为person.\n       * 3.person为从userMono中获取的单个元素\n       * 4.switchIfEmpty表示如果结果为空，则用notFound作为返回值结果\n       */\n      return userMono.flatMap(person->\n                              ServerResponse.ok()\n                              .contentType(MediaType.APPLICATION_JSON)\n                              .body(fromObject(person)))\n        .switchIfEmpty(notFound);\n    }\n    //查询所有\n    public Mono<ServerResponse> getUsers(ServerRequest request){\n      Flux<UserDAO> users = this.userServer.listUsers();\n      /**\n       * 1.body()方法的另一种用法\n       * 2.body()方法返回值：Mono<ServerResponse>类型\n       */\n      return ServerResponse.ok()\n        .contentType(MediaType.APPLICATION_JSON)\n        .body(users,UserDAO.class);\n    }\n    //添加user\n    public Mono<ServerResponse> addUser(ServerRequest request){\n      //bodyToMono()：将body中的内容提取根据UserDAO类型提取到Mono数据流中\n      Mono<UserDAO> userMono = request.bodyToMono(UserDAO.class);\n      //build()：构建响应。主体有参数充满。\n      //Mono<ServerResponse> build(Publisher<Void> voidPublisher);\n      return ServerResponse.ok()\n        .build(this.userServer.saveUser(userMono));\n    }\n  }\n  ```\n\n* 第三步：初始化服务器，编写RouterFunction\n\n  ```java\n  public class Server {\n    //1. 创建路由\n    public RouterFunction<ServerResponse> routerFunction(){\n      //创建handler对象\n      UserServer userServer = new UserServerImpl();\n      UserHandler handler = new UserHandler(userServer);\n      //设置路由\n      /**\n       * 添加了连个路由\n       * 第一个路由：请求路经”/user/{id}“且请求数据格式为json --> 对应handler方法的getUser\n       * 第二个路由：请求路经”/users“且请求数据格式为json --> 对应handler方法的getUsers\n       * 注意：handler中的方法要求带有参数(ServerRequest request)\n       */\n      return RouterFunctions\n          .route(RequestPredicates\n              .GET(\"/user/{id}\")\n              .and(RequestPredicates\n                      .accept(MediaType.APPLICATION_JSON)\n                  ), handler::getUser)\n          .andRoute(RequestPredicates\n              .GET(\"/users\")\n              .and(RequestPredicates\n                  .accept(MediaType.APPLICATION_JSON)\n                  ),handler::getUsers);\n    }\n  \n    /**\n     * 2. 创建适配器：\n     *  2.1 将路由和handler适配\n     *  2.2 创建服务器\n     */\n    public void createReactorServer(){\n      //路由和handler适配\n      RouterFunction<ServerResponse> route = routerFunction();\n      HttpHandler httpHandler = RouterFunctions.toHttpHandler(route);\n      ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(httpHandler);\n      //创建服务器\n      HttpServer httpServer = HttpServer.create();\n      //将适配器在服务器启动时立即绑定到服务器上\n      httpServer.handle(adapter).bindNow();\n    }\n  }\n  ```\n\n* 第四步：最终测试调用\n\n  ```java\n  public static void main(String[] args) throws IOException {\n    Server server = new Server();\n    //创建服务\n    server.createReactorServer();\n    System.out.println(\"enter to exit\");\n    //只要不输入数据，就能保证服务不关闭\n    System.in.read();\n  }\n  ```\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210427205845.png)\n\n* 使用WebClient调用\n\n  ```\n  public class Client {\n    public static void main(String[] args) {\n      //设置服务器地址，创建浏览器客户端\n      WebClient client = WebClient.create(\"http:127.0.0.1:14951\");\n      //根据id查询\n      String id = \"1\";\n      UserDAO userDAO = client.get()\n          .uri(\"/user/{id}\", id)\n          .accept(MediaType.APPLICATION_JSON)\n          .retrieve()\n          .bodyToMono(UserDAO.class)\n          .block();\n      System.out.println(userDAO);\n      //查询所有\n      Flux<? extends UserDAO> users = client.get()\n          .uri(\"/users\")\n          .accept(MediaType.APPLICATION_JSON)\n          .retrieve()\n          .bodyToFlux(userDAO.getClass());\n      /**\n       * map()：将user元素转换成user中的name\n       * buffer()：将数据流存到缓冲区中\n       * doOnNext()：订阅。订阅的业务为输出\n       * blockFirst()：当缓冲区有元素则输出直到终止信号\n       */\n      users.map(user->user.getName())\n          .buffer()\n          .doOnNext(System.out::println)\n          .blockFirst();\n    }\n  }\n  ```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["Java学习","JavaEE框架"]},{"title":"javaweb学习","url":"/2021/02/26/尚硅谷说Java/前端/JavaWeb-eclipse版/","content":"javaweb学习\n<!--more-->\n# 第一章 Web基础\n\n## 1.1 C/S与B/S结构\n\n### 1.1.1 C/S架构\n\n* C/S, Clent/Server, 客户端/服务器。客户端需要安装专用的客户端软件。客户端是针对某一具体业务专门开发的软件,是需要专门安装的软件。\n* 由于客户端是专用的软件,所以客户端程序一般也具有对具体业务进行处理的能力。从而减轻了服务端的处理压力，使得服务端的运算速度更快，对客户端的响应更快。\n* 也正是由于客户端是需要专门安装的专用软件,所以导致C/S架构的系统也出现了致命的问题:版本升级成本异常的高无论是由于客户端软件本身功能的升级,或是由于服务端的升级导致客户端也必须要进行升级,无论什么原因导致客户端需要升级，每-一个客户端机器_上都必须先获取到新版本软件，再将老版本进行卸载替换。C/S架构系统的每一次客户端升级，都需要企业为之付出人力、物力、财力上的成本代价。\n* 典型的C/S架构系统有:安装版的QQ、飞信等。 \n\n### 1.1.2 B/S架构\n\n* B/S, Browser/Server, 浏览器/服务器。B/S 架构，其实也是一种特殊的 C/S架构，只不过，这个Clent特指的就是浏览器。\n* 对于B/S架构的系统，只要客户端安装的有浏览器,那么客户端就可以访问服务端。而整个系统的升级，只需要升级服务端程序即可。所以，B/S 架构的系统最大的优点就是不存在客户端升级问题。\n* 由于客户端不是专门针对某一具体业务而设计的, 是一个通 用的客户端,所以客户端几乎没有任何对具体业务进行处理运算的能力。而对于具体业务的处理压力，全部加在了服务端，从而导致服务端程序运算速度降低，对客户端的响应速度降低，影响了客户体验。\n* 另外，B/S架构系统还存在一个问题：浏览器兼容问题。虽然客户端只需要一个浏览器即可访问服务端，但由于现在浏览器品牌、版本很多,而其实现技术千差万别，所以导致服务端需要想办法兼容各种浏览器版本。这无形中又增加了服务端的压力。\n* 典型的B/S架构系统有:网页版的QQ、飞信等。 \n\n## 1.2 Web访问中的角色与协议\n\n### 1.2.1 三协议四角色\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210205121836.png)\n\n* Web访问的整个过程中，从大的方面讲，具有四个角色。而它们之间的通信依赖的是三个协议。\n* 所谓协议，即是规范、规则，是通信双方事先的约定。\n* HTTP协议要求，通信双方，即浏览器与服务器双方，都需要按照指定的格式发出请求与响应。对方按照协议，即事先的约定，对对方发送来的信息进行解析。\n* Servlet协议要求,若程序员要开发完成某-具体业务的服务端程序,则必须实现Servlet接口，使用ServletAPI进行数据传递。\n* JDBC协议要求，服务器端程序若要连接并操作数据库，则需要按照JIDBC协议中规定的方式(接口方法)获取DB连接、进行SQL的执行、进行结果的获取。而JDBC协议(接口)的实现，均由数据库厂商完成，放于数据库厂商提供的数据库驱动Jar包中了。所以,我们连接不同的数据库，就需要导入不同的数据库驱动Jar包，就是这个原因。\n\n### 1.2.2 JavaEE协议\n\n* Servlet协议是JavaEE协议的一部分。JavaEE协议即进行JavaWeb 开发的一套API, 除了包含Servlet协议外,还包含JISP协议、JSTL协议、JPA协议等。目前使用较多的版本是JavaEE5.0o4\n* JavaEE5.0 包含的是Servlet2.5 协议。JavaEE6.0 包含是Servlet3.0 协议。而Servlet2.5与3.0版本的一个很大区别是，Servlet3.0 支持对Servlet、Filter. Listener 类的注解式开发。\n\n## 1.3 Tomcat服务器\n\n* 实际应用中实现了JavaEE 规范的Web服务器很多,如Oracle的WebLogic (需购买)、IBM的WebSphere(需购买)、RedHat公司的JBoss (不支持Servlet/JSP 规范,开源免费)等。这些都称为重量级服务器\n* Apache的Tomcat,只是JavaEE规范中Servlet/JSP规范的实现者，所以其是一-个轻量级服务器，它是开源免费的。我们现在的学习过程，使用的是Tomcat服务器。Tomcat 也称为Web容器，或Servlet容器，但不能称为JavaEE容器。\n\n### 1.3.1 Tomcat的下载\n\n* 官网：https://tomcat.apache.org/\n* Tomcat9压缩包下载地址：https://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.43/bin/apache-tomcat-9.0.43-windows-x64.zip\n* Tomcat9原码压缩包下载地址：https://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.43/bin/embed/apache-tomcat-9.0.43-embed.zip\n\n### 1.3.2 Tomcat的安装与目录结构\n\n* 安装：将压缩包解压到想要安装的位置即可\n* 目录结构：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210226172325.png)\n\n### 1.3.3 Tomcat的运行环境配置\n\n* Tomcat安装完毕后，需要安装JDK或JRE.对于Tomcat5及以前版本，要求必须要安装JDK,而Tomcat6及其后版本可以只安装JRE而不安装JDK。但,对于我们Java程序员来说，安装JDK是必须的。因为我们不仅仅是运行Java 程序,更重要的是,我们要开发Java程序，所以必须要安装JDK。|\n*  在系统环境变量中设置JAVA _HOME后，将其bin目录添加到path变量中即可。\n* JAVA _HOME这个路径必须配置，且不能改名。\n\n### 1.3.4 Tomcat的启动与访问\n\n* 打开Tomcat安装位置。打开bin文件。找到startup.bat。在出现的命令框中没有出啊先错误，警告。即启动成功。\n* 打开浏览器在地址栏输入localhost:8080出现tomcat网站即启动成功。\n\n# 第二章 JavaWeb项目结构\n\n## 2.1 第一个Web项目\n\n### 2.1.1 项目创建\n\n* 新建一个文件夹，名为myWeb。\n* 在文件夹中新建一个hello.html文件。在此文件中写入hello web html信息。\n\n### 2.1.2 项目的部署\n\n* 将上述的myWeb文件夹放到Tomcat安装目录下的webapps文件夹内。\n* 通过Tomcat的bin文件的startup.bat启动服务。\n\n### 2.1.3 项目的访问\n\n* 当cmd窗口出现[E:\\Java\\tomcat-9\\webapps\\myWeb]字样。即将myWeb文件夹发布到Tomcat服务器中。\n* 打开浏览器访问http://localhost:8080/myWeb/hello.html。即可看到hello.html页面。\n\n### 2.1.4 定义web.xml\n\n* 在myWeb文件夹内创建WEB-INF文件夹。此文件夹的名字是固定的\n* 在WEB-INF文件夹内创建web.xml文件。并且在文件中填入下面代码\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee\n                             http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n  <welcome-file-list>\n    <!--welcome-file标签内的值表示项目启动时访问的文件名-->\n    <welcome-file>index.html</welcome-file>\n    <welcome-file>index.htm</welcome-file>\n    <welcome-file>index.jsp</welcome-file>\n  </welcome-file-list>\n</web-app>\n```\n\n* 修改hello.html文件名为index.html\n* 再次启动tomcat。此时访问http://localhost:8080/myWeb/\n\n### 2.1.5 在命令行打包war包\n\n*  在cmd下，打开myWeb文件夹下。输入下面命令\n\n```\njar cvf d:\\myWeb.war .\n```\n\n* cvf 是命令参数，表示生成一个文档，显示生成工程，指定生成的文件名。\n* d:\\myWeb.war 为生成的文档的存放路径和文件名。\n* 最后一个点表示要将当前目录中的所有内容进行打包。\n\n## 2.2 使用Eclipse创建Web项目\n\n* 新建Dynamic Web Project项目。\n\n  * Target runtime选择新建的Tomcat v9.0。路径为安装的Tomcat.\n  * 项目起名为myWeb。点击完成即可。\n\n* 项目结构如下：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210205135759.png)\n\n* web.xml文件内容同上。在WEB-INF文件下创建index.html。内容如上。\n\n* 启动项目，以server启动，点击确定即可。\n\n* 项目打包方式：右击项目选择导出为war包即可。\n\n# 第三章 Tomcat核心\n\n* 核心文件为conf文件夹下的server.xml文件\n\n## 3.1 localhost主机域名\n\n```xml\n<Connector port=\"8080\" protocol=\"HTTP/1.1\"\n               connectionTimeout=\"20000\"\n               redirectPort=\"8443\" />\n<!--Connector:表示tomcat的一个连接配置。\n\t\tport表示连接端口为8080。\n\t\tprotocol表示连接协议为HTTP -->\n<Host name=\"localhost\"  appBase=\"webapps\"\n            unpackWARs=\"true\" autoDeploy=\"true\">\n<!--Host:表示域名解析\n\t\tname:表示识别的域名\n\t\tappBase:表示项目的位置-->\n```\n\n## 3.2 配置虚拟目录\n\n* 虚拟目录：可以将web项目放在别的文件夹下。同时tomcat也能访问到这个项目。\n\n```xml\n<!--在节点下填写如下代码-->\n<Context path=\"填写访问的路径\" docBase=\"填写项目的路径\"></Context>\n<Context path=\"/web\" docBase=\"d:/myWeb\"></Context>\n<!--此时的访问url就是localhost:8080/web。即可访问到myWeb项目的页面 -->\n```\n\n## 3.3 配置虚拟主机\n\n* 添加如下代码，同时在电脑中配置此域名的ip对应地址\n\n```xml\n<Host name=\"自定义域名\"  appBase=\"修改为不可重复的\"\n            unpackWARs=\"true\" autoDeploy=\"true\">\n```\n\n## 3.4 配置默认Tomcat应用管理\n\n* 修改Tomcat的conf文件夹下的tomcat-users.xml文件。添加下面信息\n\n```xml\n<!--rolename:表示身份信息。下面表示账户和密码 -->\n<role rolename=\"manager-gui\"/>\n<user username=\"1\" password=\"1\" roles=\"manager-gui\"/>\n```\n\n* 重启服务器。浏览器访问：localhost:8080。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210205152952.png)\n\n* 点击Manager App。输入配置的身份和密码。即可看到Tomcat的所有项目信息\n\n# 第四章 HTTP协议\n\n* HTTP, Hyper Text Transfer Protocol,超文本传输协议，是一个基于请求与响应模式的、无状态的网络协议，是浏览器和服务器间最常用的通讯协议。HTP协议是浏览器与服务器间的数据传递格式的一种约定，浏览器与服务器只要都遵循这个约定，就可进行数据通讯了。\n\n## 4.1 请求与响应\n\n* 由浏览器向服务器发送数据，称为请求Request。由服务器向浏览器发送数据，则称为响应Response。\n* 那么,什么才是浏览器向服务器发送的请求呢?在浏览器地址栏中通过地址访问是最典型的请求方式，另外还有点击表单的提交按钮、点击超链接、发送AJAX请求,那么还有其它形式的请求吗?\n* 我们要查看地址栏所发出的请求详情，可以通过抓包工县来拦截HTTP请求与响应，从工具中可以看到具体的请求与响应内容。抓包工县很多，最常用的是HttpWatch。\n* Firefox 35版本和HttpWatch 9.4.17版本。\n* HttpWatch是一个抓包工具，可以拦截HTTP请求与响应，查看其中通讯的信息。该工具是一个浏览器插件，安装后会自动嵌入到浏览器中。HttpWatch只能在IE与FireFox浏览器中使用。不过,需要注意一点，Win1o系统中需要使用HttpWatch10及其以上版本，否则无法使用。\n* 浏览器向服务器发送的请求除了URL地址的请求，还包括加载页面时页面的css,js,图片等资源时的请求。\n\n## 4.2 HTTP版本\n\n* 客户端若要向服务端发出请求，必须首先在它们之间创建一-个 TCP ( Transfer Control Protocal,传输控制协议)连接。而当客户端与服务端的通讯结束后，TCP连接将被关闭。而这个连接就是基于HTTP协议的。\n* 请注意-点:从“计算机网络通信”细节上来说, TCP连接的建立需要经过“三次握手”，TCP连接的关闭需要经过“四次通信”。\n* 在通讯中真正使用的HTTP协议，共有两种: HTTP1.0 版与HTTP1.1版。这两个版本目前都仍在使用中。\n\n### 4.2.1 HTTP1.0协议\n\n* HTTP1.0协议规定,客户端若要向服务端发出请求，必须首先在它们之间创建-一个τCP(Transfer Control Protocal ,传输控制协议)涟接。而当客户端接收到服务端所发出的响应后,服务端将关闭TCP连接。只有等待上-次的请求所对应的响应被客户端接收到后，客户端才可发出第二次请求。HTTP1.0 协议中的连接属于非持久连接，且服务器不跟踪和记录任何一次请求与响应。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210206191811.png)\n\n* 客户端和服务端每次建立和关闭连接都是-一个相对比较费时的过程，会严重影响客户端和服务端的性能。中单从前面的“浏览器自动发出的请求”例子中就可看到，一个简单的页面就发出了四次请求，使用HTTP1.0协议，就需要创建与关闭四次连接，严重影响了服务器的响应速度，降低了用户体验。\n\n### 4.2.2 HTTP1.1协议\n\n* HTTP 1.1 版本是目前浏览器默认采用的HTTP协议版本，是一种持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多css、JS、图片等资源的页面，其所发出的多个请求和响应可以在一个连接中传输。但每个单独的页面文件的请求和响应仍然需要使用各自的连接。\n\n* HTTP1.1还允许客户端不用等待上一次请求结果返回,就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果,以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。\n\n* HTTP1.0在客户端接收到服务端发送来的响应后，TCP连接马上关闭。而HTTP1.1的连接是什么时候关闭呢?客户端在发送创建TCP 连接请求之前首先计算出本次连接浏览器所要发送的请求数量，即一次手工请求加上其所携带的所有自动请求数量。当所有浏览器所发出的请求全部发送完毕后，客户端会再自动发送一个关闭TCP连接的请求。这个请求在HttpWatch中是看不到的。\n\n* 为了防止服务器主动将TCP连接关闭，在每一个请求中都携带了一个参数Connection,用于告诉服务器是否关闭连接。在HttpWatch中可以看到的这些请求中,其Connection参数用于告诉服务器是否关闭连接。在HttpWatch中可以看到的这些请求中，其Connection参数值均为Keep-Alive保持连接。只有当客户端发送了关闭TCP连接请求时，服务器才会将TCP连接关闭。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210226172414.png)\n\n* 当然，除了改进了HTTP1.0协议的性能问题外，HTTP 1.1还通过增加更多的请求大和响应头来改进和扩充HTTP 1.0 的功能。\n\n* 例如，由于HTTP1.0不支持Host请求头属性，WEB浏览器无法使用主机域名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个Ip地址和端口号上配置多个虚拟WEB站点。在HTTP1.1中增加Host请求头字段后,WEB浏览器可以使用主机域名来明确表示要访问服务器上的哪个WEB站点,这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虛拟WEB站点。\n\n* HTTP1.1的持续连接,也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive 时，客户端通知服务器返回本次请求的响应后后仍然保持连接; Connection请求头的值为close时，客户端通知服务器关闭连接。\n\n### 4.2.3 HTTP1.0与1.1的对比\n\n* 它们的共同点是，请求与响应是成对出现的，客户端的一次请求一定会对应服务端的一次响应。它们的区别如下。\n* HTTP1.0协议\n  * HTTP1.0协议中的连接属于非持久连接，一次TCP连接只能进行一次请求与响应。\n  * 一次请求与响应对应一个TCP连接。\n  * 客户端只有在接收到服务端对上一次请求的响应后，客户端才可发出第二次请求。\n  * HTTP1.0不支持对虚拟主机的访问。因为其没有HOST请求头属性，会将用户所发出的域名直接通过DNS转换为IP后，发送到服务端。也就是说，服务端接收到的直接就是一个IP而非域名。这样HTP1.0的请求就不支持对虚拟主机的访问了。\n  * HTTP1.0协议中在客户端接收到服务端的响应后，马上发送关闭τCP连接的请求，服务端关闭连接。\n* HTTP1.1协议\n  * HTTP 1.1支持持久连接，在一个TCP连接上可以传送多个请求和响应。\n  * 一般情况下，一个页面中的请求与响应对应一个TCP连接。\n  * HTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求。\n  * HTTP1.1支持对虚拟主机的访问。其在请求头属性中增加了HOST 属性，用于记录请求所要访问的虚拟域名。当然，请求中所携带的域名，肯定会通过DNS将其转换为IP,然后查找到相应的主机。但由于请求中还携带有HOST 属性，即要访问的域名仍然在请求中，这样的话，服务器就可以从请求中解析出请求所要访问的虚拟主机名。\n  * HTTP1.1协议中在客户端接收到对最后一次请求的响应后,马上发送关闭TCP连接请求，服务端关闭连接。\n\n## 4.3 HTTP协议组成\n\n* HTTP协议包括两部分:请求协议与响应协议。分别用于制定请求与响应信息的格式。\n\n### 4.3.1 请求协议\n\n* 在学习请求协议格式之前，首先要了解两个概念: URL 与URI。\n\n  * URL: Uniform Resource Locator, 统一资源定位符。是互联网上标准资源的地址，可以在全球范围内唯一的确定 一个资源。\n  * URI: Uniform Resource Identfier,统一资源标识符， 用于标识一一个资源的名称。通过这种名称命名的资源可以被互联网定位和访问。\n\n* 请求协议规定,请求的信息格式包括四部分:请求行、请求报头、空白行，与请求正文。\n\n  * 请求行:以请求提交方式名开头(大写)后跟请求的URI,最后是请求协议及版本号。\n  * 请求报头:存放着各种请求参数及值，其格式为“参数名:参数值”。\n  * 空白行:用于分离请求报头与请求正文。\n  * 请求正文:存放请求还携带的参数及值。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210206194646.png)\n\n### 4.3.2 响应协议\n\n\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210226172414-1.png)\n\n## 4.4 状态码\n\n* 当进行Web应用访问时，经常余看到一些4开头或5开头的提示信息页面。这些就是HTP协议制定的，让服务器传递给浏览器的状态码，表示服务器对当前请求的处理状态。\n\n* 常用的状态码以2、4/5开头，分别表示的意义为:\n\n  * 2xx:表示对请求计算与响应成功。其中常用的状态码是200。\n  * 4xx:表示请求错误。其中常见的状态码是404， 表示资源找不到。一般都是请求路径书写有问题。\n  * 5xx:表示服务端错误。其中常见的状态码是500， 表示服务器内部错误。一般都是服务端的Java代码发生错误。\n\n* 当发生诸如404、500错误时，Web容器给出一个英文提示的页面。若系统给出这样的页面，则说明系统设计的界面不友好。\n\n* 不过,在web.xml中允许应用指定默认的错误码所对应的错误页面。只要服务端向客户端浏览器发出指定的状态码，则系统就会自动跳转到指定页面。如下面代码：\n\n  ```xml\n  <error-page>\n  \t<error-code>404</error-code>\n    <location>xxx.html</location>\n  </error-page>\n  <error-page>\n  \t<error-code>500</error-code>\n    <location>xxx.html</location>\n  </error-page>\n  ```\n\n## 4.5 GET与POST请求\n\n* HTTP协议规定，浏览器向服务器提交请求的提交方式有8种。但GET与POST请求是最常用的两种请求提交方式。\n\n## 4.5.1 GET请求\n\n* 由于GET请求会将请求所携带的参数作为请求URL中的一部分出现，所以请求参数会显示在地址栏。而这就导致了GET提交的三点不足:\n  * 参数值 只能是字符串，而不能是其它类型。\n  * 可以携带的数据量小。\n  * 数据安全性低。\n* 但GET请求有一个很重要的特征:客户端--旦接收到“服务器向GET请求发送的响应”后,浏览器会自动缓存响应。当客户再次进行相同请求提交时，将直接读取本地浏览器缓存中数据,而不再向服务端真正发送数据，让用户感觉服务端的响应很快，提升用户体验，减轻了服务器压力。。\n\n## 4.5.2 POST请求\n\n* POST请求会将请求所携带的数据以请求正文的形式出现，所以与GET方式相比，就显示出了两点长处:。\n  * 数据类型可以是任意类型， 还可以是声音、视频、图片等文件。\n  * 请求可以携带 的数据量大。\n  * 数据安全性高。\n* 但发出POST请求的客户端浏览器不会对接收到的“服务器向POST请求发送的响应”进行缓存。当用户再次进行相同请求时，仍是真正向服务器发送的请求，从服务器读职的数据。\n* 为什么要设计为“GET请求的响应结果会被浏览器缓存，POST请求的响应结果不会被浏览器缓存”呢?主要有两点原因。\n* **一个原因**是,以不同的方式提交请求其目的也是不同的。|\n  * GET请求的目的一般是客户端要从服务端下载资源,发送相同的请求就代表要下载相同的资源。既然要下载相同的资源而这些资源已经被下载到了客户端，那么就无需再下载了。所以也就无需再向服务器发送真正的下载请求了。所以就将GET 提交方式设计为了“GET请求的响应结果会被浏览器缓存”。\n  * 但posT请求的目的一般是客户端要向服务器端上传资源。对于向服务器端上传资源后响应结果，浏览器是无需缓存的。\n* **另一个原因**是，是否是相同的请求，两种提交方式的比较难易程度是不同的。。\n  * GET提交方式的请求只包含请求行、请求头与空行三部分，请求体为空。所以第二次请求与前一次请求是否相同，浏览器很好做出比较。\n  * 但POST提交方式所包含的数据量比较大，主要体现在请求正文内容较多上。请求正文可以是图片、音频、视频等文件，而对第二次请求与前一次请求是否相同的比较，仅从这些内容来看就已经很不好比较了。即对于POST提交，是否是相同请求的提交是不好做出比较的，或者说是无法进行比较的。所以将POST提交方式设计为了“POST请求的响应结果不会被浏览器缓存”。\n  * (浏览器上传音频图片等资源时，上传的数据可能存在丢包现象，但如果不影响数据的完整性，则默认上传成功。因此POST无法比较)\n\n### 4.5.3 默认请求方式\n\n* 浏览器向服务器提交请求的方法常见的有五种，这五种方法所采用的提交方式要么是GET方式，要么是POST方式。具体提交方式如下:\n\n  |    请求方式     |       提交方式        |\n  | :-------------: | :-------------------: |\n  |    表单请求     | 默认GET，可以指定POST |\n  |    AJAX请求     | 默认GET，可以指定POST |\n  |   地址栏请求    |        GET请求        |\n  |   超链接请求    |        GET请求        |\n  | src资源路径请求 |        GET请求        |\n\n### 4.5.4 请求提交方式的选择\n\n* 根据以.上积述,具有以下几种情况之一的，选择POST提交方式。其它均采用GET提交\n  方式。。\n\n  * 提交时携带的数据类型不是字符串。\n  * 提交时所携带的数据量比较大。\n  * 提交时所携带的数据具有敏感性，安全性要求较高。\n\n* 为什么POST提交的安全性就高了?因为能够实现POST提交的方式只有两种:通过表单的POST提交，与通过AJAX的POST提交。其它方式均为GET提交方式。对于一个提供了POST登录页面的系统,若用户试图通过地址栏等方式进行登录,则说明其一定是非法登录。也就是说，只要我们设置系统的登录请求提交方式是POST,那么就会出现以下两种情况:。\n\n  * 若用户以 POST方式提交登录请求，我们无法判断其是否是非法登录。因为他有可能是通过其它表单的POST方式提交的登录请求。\n\n  * 若用户以GET方式提交登录请求，则马.上就可以判断其是非法登录。\n\n  * 基于以上原因，POST提交方式的安全性要高于GET提交方式。\n\n\n","categories":["Java学习","前端"]},{"title":"jquery学习","url":"/2021/02/26/尚硅谷说Java/前端/jquery/","content":"jquery学习\n<!--more-->\n# 1.jQuery介绍\n\n**什么是 jQuery ?** \n\njQuery，顾名思义，也就是 JavaScript 和查询（Query），它就是辅助 JavaScript 开发的 js 类库。 \n\n**jQuery 核心思想！！！**\n\n 它的核心思想是 write less,do more(写得更少,做得更多)，所以它实现了很多浏览器的兼容问题。\n\n **jQuery 流行程度** \n\njQuery 现在已经成为最流行的 JavaScript 库，在世界前 10000 个访问最多的网站中，有超过 55%在使用 jQuery。\n\n **jQuery 好处！！！**\n\n jQuery 是免费、开源的，jQuery 的语法设计可以使开发更加便捷，例如操作文档对象、选择 DOM 元素、 制作动画效果、事件处理、使用 Ajax 以及其他功能\n\n# 2.jQuery的初体验\n\n需求：使用 jQuery 给一个按钮绑定单击事件?\n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    <title>Insert title here</title>\n    <script type=\"text/javascript\" src=\"../script/jquery-1.7.2.js\"></script>\n    <script type=\"text/javascript\">\n        // window.onload = function () {\n        //     var btnObj = document.getElementById(\"btnId\");\n        //     // alert(btnObj);//[object HTMLButtonElement] ====>>> dom 对象 \n        //         btnObj.onclick = function () { // alert(\"js 原生的单击事件\"); \n        //     }\n        // }\n        $(function () { // 表示页面加载完成 之后，相当 window.onload = function () {} \n            var $btnObj = $(\"#btnId\");// 表示按 id 查询标签对象 \n                $btnObj.click(function () {// 绑定单击事件 alert(\"jQuery 的单击事件\"); \n            });\n        });\n    </script>\n</head>\n<body>\n<button id=\"btnId\">SayHello</button>\n</body>\n</html>\n```\n\n常见问题？ \n\n1、使用 jQuery 一定要引入 jQuery 库吗？ \t\t\t\n\n​\t\t\t\t答案： 是，必须 \n\n2、jQuery 中的$到底是什么？ \t\t\t\t\t\t\t\t\n\n​\t\t\t\t答案： 它是一个函数 \n\n3、怎么为按钮添加点击响应函数的？ 答案： \n\n​\t\t\t\t1、使用 jQuery 查询到标签对象 \n\n​\t\t\t\t2、使用标签对象.click( function(){} );\n\n# 3.jQuery核心函数\n\n$ 是 jQuery 的核心函数，能完成 jQuery 的很多功能。$()就是调用$这个函数\n\n1、传入参数为 [ 函数 ] 时： \n\n​\t\t\t表示页面加载完成之后。相当于 window.onload = function(){} \n\n2、传入参数为 [ HTML 字符串 ] 时： \n\n​\t\t\t会对我们创建这个 html 标签对象 \n\n3、传入参数为 [ 选择器字符串 ] 时： \n\n​\t\t$(“#id 属性值”); \t\t\t\tid 选择器，根据 id 查询标签对象 \n\n​\t\t$(“标签名”); \t\t\t\t\t\t标签名选择器，根据指定的标签名查询标签对象 \n\n​\t\t$(“.class 属性值”);\t\t\t 类型选择器，可以根据 class 属性查询标签对象 \n\n4、传入参数为 [ DOM 对象 ] 时： \n\n​\t\t\t会把这个 dom 对象转换为 jQuery 对象 \n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>Insert title here</title>\n<script type=\"text/javascript\" src=\"../script/jquery-1.7.2.js\"></script>\n<script type=\"text/javascript\">\n\n\t//核心函数的4个作用\n    $(function () {\n        // alert(\"页面加载完成之后，自动调用\");\n\n        $(\"    <div>\" +\n            \"        <span>div-span1</span>\" +\n            \"        <span>div-span2</span>\" +\n            \"    </div>\").appendTo(\"body\");\n\n        // alert($(\"button\").length);\n\n        var btnObj = document.getElementById(\"btn01\");\n        // alert(btnObj);\n        // alert( $(btnObj) );\n\n        // alert( $(\"<h1></h1>\") );\n        alert($(\"button\"));\n\n    });\n\t//传入参数为[函数]时：在文档加载完成后执行这个函数\n\t//传入参数为[HTML字符串]时：根据这个字符串创建元素节点对象\n\t//传入参数为[选择器字符串]时：根据这个字符串查找元素节点对象\n\t//传入参数为[DOM对象]时：将DOM对象包装为jQuery对象返回\n\n</script>\n</head>\n<body>\n    <button id=\"btn01\">按钮1</button>\n    <button>按钮2</button>\n    <button>按钮3</button>\n</body>\n</html>\n```\n\n# 4.jQuery对象和DOM对象的区分\n\n## 4.1什么是jQuery对象，什么是DOM对象\n\n**Dom** **对象** \n\n​\t\t1.通过 getElementById()查询出来的标签对象是 Dom 对象 \n\n​\t\t2.通过 getElementsByName()查询出来的标签对象是 Dom 对象 \n\n​\t\t3.通过 getElementsByTagName()查询出来的标签对象是 Dom 对象 \n\n​\t\t4.通过 createElement() 方法创建的对象，是 Dom 对象 \n\n​\t\t\t\t\tDOM 对象 Alert 出来的效果是：*[object HTML* *标签名* *Element]*\n\n**jQuery** **对象** \n\n​\t\t1.通过 JQuery 提供的 API 创建的对象，是 JQuery 对象 \n\n​\t\t2.通过 JQuery 包装的 Dom 对象，也是 JQuery 对象 \n\n​\t\t3.通过 JQuery 提供的 API 查询到的对象，是 JQuery 对象 \n\n​\t\t\t\t\tjQuery 对象 Alert 出来的效果是：[object Object]\n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>Insert title here</title>\n<script type=\"text/javascript\" src=\"../script/jquery-1.7.2.js\"></script>\n<script type=\"text/javascript\">\n\n\t$(function(){\n\t\t//testDiv.css(\"color\",\"red\")\n\t\t//testDiv.style.color = \"blue\";\n\n\t\t// var arr = [12,\"abc\",true];\n\t\t//\n\t\t// var $btns = $(\"button\");\n\t\t//\n\t\t// for (var i = 0; i < $btns.length; i++){\n\t\t// \talert($btns[i]);\n\t\t// }\n\n\t\t// document.getElementById(\"testDiv\").innerHTML = \"这是dom对象的属性InnerHTML\";\n\t\t// $(\"#testDiv\").innerHTML = \"这是dom对象的属性InnerHTML\";\n\n\t\t// $(\"#testDiv\").click(function () {\n\t\t// \talert(\"click()是jQuery对象的方法\");\n\t\t// });\n\n\t\t// document.getElementById(\"testDiv\").click(function () {\n\t\t// \talert(\"click()是jQuery对象的方法\");\n\t\t// });\n\n\t\t// alert( $(document.getElementById(\"testDiv\"))[0] );\n\n\t\talert( $(\"button:first\") );\n\t});\n\n</script>\n</head>\n<body>\n\t<div id=\"testDiv\">Atguigu is Very Good!</div>\n\t\n\t<button id=\"dom2dom\">使用DOM对象调用DOM方法</button>\n\t<button id=\"dom2jQuery\">使用DOM对象调用jQuery方法</button>\n\t<button id=\"jQuery2jQuery\">使用jQuery对象调用jQuery方法</button>\n\t<button id=\"jQuery2dom\">使用jQuery对象调用DOM方法</button>\n</body>\n</html>\n```\n\n\n\n## 4.2问题：jQuery对象的本质是什么？\n\n​\t\tjQuery 对象是 dom 对象的数组 + jQuery 提供的一系列功能函数\n\n## 4.3jQuery **对象和** Dom 对象使用区别\n\n​\t\t\tjQuery 对象不能使用 DOM 对象的属性和方法 \n\n​\t\t\tDOM 对象也不能使用 jQuery 对象的属性和方法 \n\n## 4.4Dom对象和jQuery对象互转\n\n1、dom 对象转化为 jQuery 对象\n\n​\t\t1、先有 DOM 对象 \n\n​\t\t2、$( DOM 对象 ) 就可以转换成为 jQuery 对象\n\n2、jQuery 对象转为 dom 对象\n\n​\t\t1、先有 jQuery 对象 \n\n​\t\t2、jQuery 对象[下标]取出相应的 DOM 对象\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210534.png)\n\n# 5.jQuery选择器\n\n## 5.1基本选择器\n\n|              选择器               |                作用                 |\n| :-------------------------------: | :---------------------------------: |\n|               \\#ID                |    选择器：根据 id 查找标签对象     |\n|              .class               |   选择器：根据 class 查找标签对象   |\n|              element              |   选择器：根据标签名查找标签对象    |\n|                \\*                 |   选择器：表示任意的，所有的元素    |\n| selector1，selector2 组合选择器： | 合并选择器 1，选择器 2 的结果并返回 |\n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n<html>\n\t<head>\n\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n\t\t<title>Untitled Document</title>\n\t\t<style type=\"text/css\">\n\t\t\tdiv, span, p {\n\t\t\t    width: 140px;\n\t\t\t    height: 140px;\n\t\t\t    margin: 5px;\n\t\t\t    background: #aaa;\n\t\t\t    border: #000 1px solid;\n\t\t\t    float: left;\n\t\t\t    font-size: 17px;\n\t\t\t    font-family: Verdana;\n\t\t\t}\n\t\t\t\n\t\t\tdiv.mini {\n\t\t\t    width: 55px;\n\t\t\t    height: 55px;\n\t\t\t    background-color: #aaa;\n\t\t\t    font-size: 12px;\n\t\t\t}\n\t\t\t\n\t\t\tdiv.hide {\n\t\t\t    display: none;\n\t\t\t}\n\t\t</style>\n\t\t<script type=\"text/javascript\" src=\"../script/jquery-1.7.2.js\"></script>\n\t\t<script type=\"text/javascript\">\n\t\t\t\n\t\t\t\t$(function () {\n\t\t\t\t\t//1.选择 id 为 one 的元素 \"background-color\",\"#bbffaa\"\n\t\t\t\t\t$(\"#btn1\").click(function () {\n\t\t\t\t\t\t// css() 方法 可以设置和获取样式\n\t\t\t\t\t\t$(\"#one\").css(\"background-color\",\"#bbffaa\");\n\t\t\t\t\t});\n\n\n\t\t\t\t\t//2.选择 class 为 mini 的所有元素\n\t\t\t\t\t$(\"#btn2\").click(function () {\n\t\t\t\t\t\t$(\".mini\").css(\"background-color\",\"#bbffaa\");\n\t\t\t\t\t});\n\n\t\t\t\t\t//3.选择 元素名是 div 的所有元素\n\t\t\t\t\t$(\"#btn3\").click(function () {\n\t\t\t\t\t\t$(\"div\").css(\"background-color\",\"#bbffaa\");\n\t\t\t\t\t});\n\n\t\t\t\t\t//4.选择所有的元素\n\t\t\t\t\t$(\"#btn4\").click(function () {\n\t\t\t\t\t\t$(\"*\").css(\"background-color\",\"#bbffaa\");\n\t\t\t\t\t});\n\n\t\t\t\t\t//5.选择所有的 span 元素和id为two的元素\n\t\t\t\t\t$(\"#btn5\").click(function () {\n\t\t\t\t\t\t$(\"span,#two\").css(\"background-color\",\"#bbffaa\");\n\t\t\t\t\t});\n\n\t\t\t\t});\n\n\t\t</script>\n\t</head>\n\t<body>\n<!-- \t<div>\n\t\t<h1>基本选择器</h1>\n\t</div>\t -->\t\n\t\t<input type=\"button\" value=\"选择 id 为 one 的元素\" id=\"btn1\" />\n\t\t<input type=\"button\" value=\"选择 class 为 mini 的所有元素\" id=\"btn2\" />\n\t\t<input type=\"button\" value=\"选择 元素名是 div 的所有元素\" id=\"btn3\" />\n\t\t<input type=\"button\" value=\"选择 所有的元素\" id=\"btn4\" />\n\t\t<input type=\"button\" value=\"选择 所有的 span 元素和id为two的元素\" id=\"btn5\" />\n\t\t\n\t\t<br>\n\t\t<div class=\"one\" id=\"one\">\n\t\t\tid 为 one,class 为 one 的div\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t</div>\n\t\t<div class=\"one\" id=\"two\" title=\"test\">\n\t\t\tid为two,class为one,title为test的div\n\t\t\t<div class=\"mini\" title=\"other\">class为mini,title为other</div>\n\t\t\t<div class=\"mini\" title=\"test\">class为mini,title为test</div>\n\t\t</div>\n\t\t<div class=\"one\">\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\"></div>\n\t\t</div>\n\t\t<div class=\"one\">\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\" title=\"tesst\">class为mini,title为tesst</div>\n\t\t</div>\n\t\t<div style=\"display:none;\" class=\"none\">style的display为\"none\"的div</div>\n\t\t<div class=\"hide\">class为\"hide\"的div</div>\n\t\t<div>\n\t\t\t包含input的type为\"hidden\"的div<input type=\"hidden\" size=\"8\">\n\t\t</div>\n\t\t<span class=\"one\" id=\"span\">^^span元素^^</span>\n\t</body>\n</html>\n```\n\n​\t\t\tp.myClass      表示标签名必须是 p 标签，而且 class 类型还要是 myClass\n\n## 5.2层次选择器\n\n|       选择器        |                             作用                             |\n| :-----------------: | :----------------------------------------------------------: |\n| ancestor descendant |      后代选择器 ：在给定的祖先元素下匹配所有的后代元素       |\n|   parent > child    |        子元素选择器：在给定的父元素下匹配所有的子元素        |\n|     prev + next     |    相邻元素选择器：匹配所有紧接在 prev 元素后的 next 元素    |\n|   prev ~ sibings    | 之后的兄弟元素选择器：匹配 prev 元素之后的所有 siblings 元素 |\n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n<html>\n\t<head>\n\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n\t\t<title>Untitled Document</title>\n\t\t<style type=\"text/css\">\n\t\t\tdiv, span, p {\n\t\t\t    width: 140px;\n\t\t\t    height: 140px;\n\t\t\t    margin: 5px;\n\t\t\t    background: #aaa;\n\t\t\t    border: #000 1px solid;\n\t\t\t    float: left;\n\t\t\t    font-size: 17px;\n\t\t\t    font-family: Verdana;\n\t\t\t}\n\t\t\t\n\t\t\tdiv.mini {\n\t\t\t    width: 55px;\n\t\t\t    height: 55px;\n\t\t\t    background-color: #aaa;\n\t\t\t    font-size: 12px;\n\t\t\t}\n\t\t\t\n\t\t\tdiv.hide {\n\t\t\t    display: none;\n\t\t\t}\t\t\t\n\t\t</style>\n\t\t<script type=\"text/javascript\" src=\"../script/jquery-1.7.2.js\"></script>\n\t\t<script type=\"text/javascript\">\n\t\t\t$(document).ready(function(){\n\t\t\t\t//1.选择 body 内的所有 div 元素\n\t\t\t\t$(\"#btn1\").click(function(){\n\t\t\t\t\t$(\"body div\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\n\t\t\t\t//2.在 body 内, 选择div子元素  \n\t\t\t\t$(\"#btn2\").click(function(){\n\t\t\t\t\t$(\"body > div\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\n\t\t\t\t//3.选择 id 为 one 的下一个 div 元素 \n\t\t\t\t$(\"#btn3\").click(function(){\n\t\t\t\t\t$(\"#one+div\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\n\t\t\t\t//4.选择 id 为 two 的元素后面的所有 div 兄弟元素\n\t\t\t\t$(\"#btn4\").click(function(){\n\t\t\t\t\t$(\"#two~div\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\t\t\t});\n\t\t</script>\n\t</head>\n\t<body>\t\n\t\n<!-- \t<div>\n\t\t<h1>层级选择器:根据元素的层级关系选择元素</h1>\n\t\tancestor descendant  ：\n\t\tparent > child \t\t   ：\n\t\tprev + next \t\t   ：\n\t\tprev ~ siblings \t   ：\n\t</div>\t -->\n\t\t<input type=\"button\" value=\"选择 body 内的所有 div 元素\" id=\"btn1\" />\n\t\t<input type=\"button\" value=\"在 body 内, 选择div子元素\" id=\"btn2\" />\n\t\t<input type=\"button\" value=\"选择 id 为 one 的下一个 div 元素\" id=\"btn3\" />\n\t\t<input type=\"button\" value=\"选择 id 为 two 的元素后面的所有 div 兄弟元素\" id=\"btn4\" />\n\t\t<br><br>\n\t\t<div class=\"one\" id=\"one\">\n\t\t\tid 为 one,class 为 one 的div\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t</div>\n\t\t<div class=\"one\" id=\"two\" title=\"test\">\n\t\t\tid为two,class为one,title为test的div\n\t\t\t<div class=\"mini\" title=\"other\">class为mini,title为other</div>\n\t\t\t<div class=\"mini\" title=\"test\">class为mini,title为test</div>\n\t\t</div>\n\t\t<div class=\"one\">\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\"></div>\n\t\t</div>\n\t\t<div class=\"one\">\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\" title=\"tesst\">class为mini,title为tesst</div>\n\t\t</div>\n\t\t<div style=\"display:none;\" class=\"none\">style的display为\"none\"的div</div>\n\t\t<div class=\"hide\">class为\"hide\"的div</div>\n\t\t<div>\n\t\t\t包含input的type为\"hidden\"的div<input type=\"hidden\" size=\"8\">\n\t\t</div>\n\t\t<span id=\"span\">^^span元素^^</span>\n\t</body>\n</html>\n```\n\n## 5.3过滤选择器\n\n### 基本过滤器\n\n|     过滤器     |                   作用                    |\n| :------------: | :---------------------------------------: |\n|     :first     |              获取第一个元素               |\n|     :last      |              获取最后个元素               |\n| :not(selector) |      去除所有与给定选择器匹配的元素       |\n|     :even      | 匹配所有索引值为偶数的元素，从 0 开始计数 |\n|      :odd      | 匹配所有索引值为奇数的元素，从 0 开始计数 |\n|   :eq(index)   |         匹配一个给定索引值的元素          |\n|   :gt(index)   |       匹配所有大于给定索引值的元素        |\n|   :lt(index)   |       匹配所有小于给定索引值的元素        |\n|    :header     |     匹配如 h1, h2, h3 之类的标题元素      |\n|   :animated    |      匹配所有正在执行动画效果的元素       |\n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n<html>\n\t<head>\n\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n\t\t<title>Untitled Document</title>\n\t\t<style type=\"text/css\">\n\t\t\tdiv, span, p {\n\t\t\t    width: 140px;\n\t\t\t    height: 140px;\n\t\t\t    margin: 5px;\n\t\t\t    background: #aaa;\n\t\t\t    border: #000 1px solid;\n\t\t\t    float: left;\n\t\t\t    font-size: 17px;\n\t\t\t    font-family: Verdana;\n\t\t\t}\n\t\t\t\n\t\t\tdiv.mini {\n\t\t\t    width: 55px;\n\t\t\t    height: 55px;\n\t\t\t    background-color: #aaa;\n\t\t\t    font-size: 12px;\n\t\t\t}\n\t\t\t\n\t\t\tdiv.hide {\n\t\t\t    display: none;\n\t\t\t}\t\t\t\n\t\t</style>\n\t\t<script type=\"text/javascript\" src=\"../script/jquery-1.7.2.js\"></script>\n\t\t<script type=\"text/javascript\">\n\t\t\t$(document).ready(function(){\n\t\t\t\tfunction anmateIt(){\n\t\t\t\t\t$(\"#mover\").slideToggle(\"slow\", anmateIt);\n\t\t\t\t}\n\t\t\t\tanmateIt();\n\t\t\t});\n\t\t\t\n\t\t\t$(document).ready(function(){\n\t\t\t\t//1.选择第一个 div 元素  \n\t\t\t\t$(\"#btn1\").click(function(){\n\t\t\t\t\t$(\"div:first\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\n\t\t\t\t//2.选择最后一个 div 元素\n\t\t\t\t$(\"#btn2\").click(function(){\n\t\t\t\t\t$(\"div:last\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\n\t\t\t\t//3.选择class不为 one 的所有 div 元素\n\t\t\t\t$(\"#btn3\").click(function(){\n\t\t\t\t\t$(\"div:not(.one)\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\n\t\t\t\t//4.选择索引值为偶数的 div 元素\n\t\t\t\t$(\"#btn4\").click(function(){\n\t\t\t\t\t$(\"div:even\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\n\t\t\t\t//5.选择索引值为奇数的 div 元素\n\t\t\t\t$(\"#btn5\").click(function(){\n\t\t\t\t\t$(\"div:odd\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\n\t\t\t\t//6.选择索引值为大于 3 的 div 元素\n\t\t\t\t$(\"#btn6\").click(function(){\n\t\t\t\t\t$(\"div:gt(3)\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\n\t\t\t\t//7.选择索引值为等于 3 的 div 元素\n\t\t\t\t$(\"#btn7\").click(function(){\n\t\t\t\t\t$(\"div:eq(3)\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\n\t\t\t\t//8.选择索引值为小于 3 的 div 元素\n\t\t\t\t$(\"#btn8\").click(function(){\n\t\t\t\t\t$(\"div:lt(3)\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\n\t\t\t\t//9.选择所有的标题元素\n\t\t\t\t$(\"#btn9\").click(function(){\n\t\t\t\t\t$(\":header\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\n\t\t\t\t//10.选择当前正在执行动画的所有元素\n\t\t\t\t$(\"#btn10\").click(function(){\n\t\t\t\t\t$(\":animated\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\t\t\t\t//11.选择没有执行动画的最后一个div\n\t\t\t\t$(\"#btn11\").click(function(){\n\t\t\t\t\t$(\"div:not(:animated):last\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\t\t\t});\n\t\t</script>\n\t</head>\n\t<body>\n\t\t<input type=\"button\" value=\"选择第一个 div 元素\" id=\"btn1\" />\n\t\t<input type=\"button\" value=\"选择最后一个 div 元素\" id=\"btn2\" />\n\t\t<input type=\"button\" value=\"选择class不为 one 的所有 div 元素\" id=\"btn3\" />\n\t\t<input type=\"button\" value=\"选择索引值为偶数的 div 元素\" id=\"btn4\" />\n\t\t<input type=\"button\" value=\"选择索引值为奇数的 div 元素\" id=\"btn5\" />\n\t\t<input type=\"button\" value=\"选择索引值为大于 3 的 div 元素\" id=\"btn6\" />\n\t\t<input type=\"button\" value=\"选择索引值为等于 3 的 div 元素\" id=\"btn7\" />\n\t\t<input type=\"button\" value=\"选择索引值为小于 3 的 div 元素\" id=\"btn8\" />\n\t\t<input type=\"button\" value=\"选择所有的标题元素\" id=\"btn9\" />\n\t\t<input type=\"button\" value=\"选择当前正在执行动画的所有元素\" id=\"btn10\" />\t\t\n\t\t<input type=\"button\" value=\"选择没有执行动画的最后一个div\" id=\"btn11\" />\n\n\n\t\t<h3>基本选择器.</h3>\n\t\t<br><br>\n\t\t<div class=\"one\" id=\"one\">\n\t\t\tid 为 one,class 为 one 的div\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t</div>\n\t\t<div class=\"one\" id=\"two\" title=\"test\">\n\t\t\tid为two,class为one,title为test的div\n\t\t\t<div class=\"mini\" title=\"other\">class为mini,title为other</div>\n\t\t\t<div class=\"mini\" title=\"test\">class为mini,title为test</div>\n\t\t</div>\n\t\t<div class=\"one\">\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\"></div>\n\t\t</div>\n\t\t<div class=\"one\">\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\" title=\"tesst\">class为mini,title为tesst</div>\n\t\t</div>\n\t\t<div style=\"display:none;\" class=\"none\">style的display为\"none\"的div</div>\n\t\t<div class=\"hide\">class为\"hide\"的div</div>\n\t\t<div>\n\t\t\t包含input的type为\"hidden\"的div<input type=\"hidden\" size=\"8\">\n\t\t</div>\n\t\t<div id=\"mover\">正在执行动画的div元素.</div>\n\t</body>\n</html>\n```\n\n### 内容过滤器\n\n|     过滤器      |                 作用                 |\n| :-------------: | :----------------------------------: |\n| :contains(text) |        匹配包含给定文本的元素        |\n|     :empty      | 匹配所有不包含子元素或者文本的空元素 |\n|     :parent     |     匹配含有子元素或者文本的元素     |\n| :has(selector)  |   匹配含有选择器所匹配的元素的元素   |\n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n<html>\n\t<head>\n\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n\t\t<title>Untitled Document</title>\n\t\t<style type=\"text/css\">\n\t\t\tdiv, span, p {\n\t\t\t    width: 140px;\n\t\t\t    height: 140px;\n\t\t\t    margin: 5px;\n\t\t\t    background: #aaa;\n\t\t\t    border: #000 1px solid;\n\t\t\t    float: left;\n\t\t\t    font-size: 17px;\n\t\t\t    font-family: Verdana;\n\t\t\t}\n\t\t\t\n\t\t\tdiv.mini {\n\t\t\t    width: 55px;\n\t\t\t    height: 55px;\n\t\t\t    background-color: #aaa;\n\t\t\t    font-size: 12px;\n\t\t\t}\n\t\t\t\n\t\t\tdiv.hide {\n\t\t\t    display: none;\n\t\t\t}\t\t\t\n\t\t</style>\n\t\t<script type=\"text/javascript\" src=\"../script/jquery-1.7.2.js\"></script>\n\t\t<script type=\"text/javascript\">\n\t\t\t$(document).ready(function(){\n\t\t\t\tfunction anmateIt(){\n\t\t\t\t\t$(\"#mover\").slideToggle(\"slow\", anmateIt);\n\t\t\t\t}\n\t\n\t\t\t\tanmateIt();\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\t/** \n\t\t\t:contains(text)   \n\t\t\t:empty \t\t\t  \n\t\t\t:has(selector) \t\n\t\t\t:parent \t\t\t\n\t\t\t*/\n\t\t\t$(document).ready(function(){\n\t\t\t\t//1.选择 含有文本 'di' 的 div 元素\n\t\t\t\t$(\"#btn1\").click(function(){\n\t\t\t\t\t$(\"div:contains('di')\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\n\t\t\t\t//2.选择不包含子元素(或者文本元素) 的 div 空元素\n\t\t\t\t$(\"#btn2\").click(function(){\n\t\t\t\t\t$(\"div:empty\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\n\n\n\t\t\t\t//3.选择含有 class 为 mini 元素的 div 元素\n\t\t\t\t$(\"#btn3\").click(function(){\n\t\t\t\t\t$(\"div:has(.mini)\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\n\t\t\t\t//4.选择含有子元素(或者文本元素)的div元素\n\t\t\t\t$(\"#btn4\").click(function(){\n\t\t\t\t\t$(\"div:parent\").css(\"background\", \"#bbffaa\");\n\t\t\t\t});\n\t\t\t});\n\t\t</script>\n\t</head>\n\t<body>\t\t\n\t\t<input type=\"button\" value=\"选择 含有文本 'di' 的 div 元素\" id=\"btn1\" />\n\t\t<input type=\"button\" value=\"选择不包含子元素(或者文本元素) 的 div 空元素\" id=\"btn2\" />\n\t\t<input type=\"button\" value=\"选择含有 class 为 mini 元素的 div 元素\" id=\"btn3\" />\n\t\t<input type=\"button\" value=\"选择含有子元素(或者文本元素)的div元素\" id=\"btn4\" />\n\t\t\n\t\t<br><br>\n\t\t<div class=\"one\" id=\"one\">\n\t\t\tid 为 one,class 为 one 的div\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t</div>\n\t\t<div class=\"one\" id=\"two\" title=\"test\">\n\t\t\tid为two,class为one,title为test的div\n\t\t\t<div class=\"mini\" title=\"other\">class为mini,title为other</div>\n\t\t\t<div class=\"mini\" title=\"test\">class为mini,title为test</div>\n\t\t</div>\n\t\t<div class=\"one\">\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\"></div>\n\t\t</div>\n\t\t<div class=\"one\">\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\" title=\"tesst\">class为mini,title为tesst</div>\n\t\t</div>\n\t\t<div style=\"display:none;\" class=\"none\">style的display为\"none\"的div</div>\n\t\t<div class=\"hide\">class为\"hide\"的div</div>\n\t\t<div>\n\t\t\t包含input的type为\"hidden\"的div<input type=\"hidden\" size=\"8\">\n\t\t</div>\n\t\t<div id=\"mover\">正在执行动画的div元素.</div>\n\t</body>\n</html>\n```\n\n### 属性过滤器\n\n|             过滤器             |                          作用                          |\n| :----------------------------: | :----------------------------------------------------: |\n|          [attribute]           |                匹配包含给定属性的元素。                |\n|       [attribute=value]        |            匹配给定的属性是某个特定值的元素            |\n|       [attribute!=value]       | 匹配所有不含有指定的属性，或者属性不等于特定值的元素。 |\n|       [attribute^=value]       |           匹配给定的属性是以某些值开始的元素           |\n|       [attribute$=value]       |           匹配给定的属性是以某些值结尾的元素           |\n|       [attribute*=value]       |           匹配给定的属性是以包含某些值的元素           |\n| [attrSel1][attrSel2][attrSelN] |      复合属性选择器，需要同时满足多个条件时使用。      |\n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>Untitled Document</title>\n<style type=\"text/css\">\ndiv,span,p {\n\twidth: 140px;\n\theight: 140px;\n\tmargin: 5px;\n\tbackground: #aaa;\n\tborder: #000 1px solid;\n\tfloat: left;\n\tfont-size: 17px;\n\tfont-family: Verdana;\n}\n\ndiv.mini {\n\twidth: 55px;\n\theight: 55px;\n\tbackground-color: #aaa;\n\tfont-size: 12px;\n}\n\ndiv.hide {\n\tdisplay: none;\n}\n</style>\n<script type=\"text/javascript\" src=\"../script/jquery-1.7.2.js\"></script>\n<script type=\"text/javascript\">\n\t/**\n[attribute] \t\t\t\n[attribute=value] \t\t\n[attribute!=value] \t\t \n[attribute^=value] \t\t\n[attribute$=value] \t\t\n[attribute*=value] \t\t\n[attrSel1][attrSel2][attrSelN]  \n\t\n\t\n\t*/\n\t$(function() {\n\t\t//1.选取含有 属性title 的div元素\n\t\t$(\"#btn1\").click(function() {\n\t\t\t$(\"div[title]\").css(\"background\", \"#bbffaa\");\n\t\t});\n\t\t//2.选取 属性title值等于'test'的div元素\n\t\t$(\"#btn2\").click(function() {\n\t\t\t$(\"div[title='test']\").css(\"background\", \"#bbffaa\");\n\t\t});\n\t\t//3.选取 属性title值不等于'test'的div元素(*没有属性title的也将被选中)\n\t\t$(\"#btn3\").click(function() {\n\t\t\t$(\"div[title!='test']\").css(\"background\", \"#bbffaa\");\n\t\t});\n\t\t//4.选取 属性title值 以'te'开始 的div元素\n\t\t$(\"#btn4\").click(function() {\n\t\t\t$(\"div[title^='te']\").css(\"background\", \"#bbffaa\");\n\t\t});\n\t\t//5.选取 属性title值 以'est'结束 的div元素\n\t\t$(\"#btn5\").click(function() {\n\t\t\t$(\"div[title$='est']\").css(\"background\", \"#bbffaa\");\n\t\t});\n\t\t//6.选取 属性title值 含有'es'的div元素\n\t\t$(\"#btn6\").click(function() {\n\t\t\t$(\"div[title*='es']\").css(\"background\", \"#bbffaa\");\n\t\t});\n\t\t\n\t\t//7.首先选取有属性id的div元素，然后在结果中 选取属性title值 含有'es'的 div 元素\n\t\t$(\"#btn7\").click(function() {\n\t\t\t$(\"div[id][title*='es']\").css(\"background\", \"#bbffaa\");\n\t\t});\n\t\t//8.选取 含有 title 属性值, 且title 属性值不等于 test 的 div 元素\n\t\t$(\"#btn8\").click(function() {\n\t\t\t$(\"div[title][title!='test']\").css(\"background\", \"#bbffaa\");\n\t\t});\n\t});\n</script>\n</head>\n<body>\n\t<input type=\"button\" value=\"选取含有 属性title 的div元素.\" id=\"btn1\" style=\"display: none;\"/>\n\t<input type=\"button\" value=\"选取 属性title值等于'test'的div元素.\" id=\"btn2\" />\n\t<input type=\"button\"\n\t\tvalue=\"选取 属性title值不等于'test'的div元素(没有属性title的也将被选中).\" id=\"btn3\" />\n\t<input type=\"button\" value=\"选取 属性title值 以'te'开始 的div元素.\" id=\"btn4\" />\n\t<input type=\"button\" value=\"选取 属性title值 以'est'结束 的div元素.\" id=\"btn5\" />\n\t<input type=\"button\" value=\"选取 属性title值 含有'es'的div元素.\" id=\"btn6\" />\n\t<input type=\"button\"\n\t\tvalue=\"组合属性选择器,首先选取有属性id的div元素，然后在结果中 选取属性title值 含有'es'的 div 元素.\"\n\t\tid=\"btn7\" />\n\t<input type=\"button\"\n\t\tvalue=\"选取 含有 title 属性值, 且title 属性值不等于 test 的 div 元素.\" id=\"btn8\" />\n\n\t<br>\n\t<br>\n\t<div class=\"one\" id=\"one\">\n\t\tid 为 one,class 为 one 的div\n\t\t<div class=\"mini\">class为mini</div>\n\t</div>\n\t<div class=\"one\" id=\"two\" title=\"test\">\n\t\tid为two,class为one,title为test的div\n\t\t<div class=\"mini\" title=\"other\">class为mini,title为other</div>\n\t\t<div class=\"mini\" title=\"test\">class为mini,title为test</div>\n\t</div>\n\t<div class=\"one\">\n\t\t<div class=\"mini\">class为mini</div>\n\t\t<div class=\"mini\">class为mini</div>\n\t\t<div class=\"mini\">class为mini</div>\n\t\t<div class=\"mini\"></div>\n\t</div>\n\t<div class=\"one\">\n\t\t<div class=\"mini\">class为mini</div>\n\t\t<div class=\"mini\">class为mini</div>\n\t\t<div class=\"mini\">class为mini</div>\n\t\t<div class=\"mini\" title=\"tesst\">class为mini,title为tesst</div>\n\t</div>\n\t<div style=\"display: none;\" class=\"none\">style的display为\"none\"的div</div>\n\t<div class=\"hide\">class为\"hide\"的div</div>\n\t<div>\n\t\t包含input的type为\"hidden\"的div<input type=\"hidden\" value=\"123456789\"\n\t\t\tsize=\"8\">\n\t</div>\n\t<div id=\"mover\">正在执行动画的div元素.</div>\n</body>\n</html>\n```\n\n### 表单过滤器\n\n|  过滤器   |                         作用                         |\n| :-------: | :--------------------------------------------------: |\n|  :input   |   匹配所有 input, textarea, select 和 button 元素    |\n|   :text   |                 匹配所有 文本输入框                  |\n| :password |                 匹配所有的密码输入框                 |\n|  :radio   |                   匹配所有的单选框                   |\n| :checkbox |                   匹配所有的复选框                   |\n|  :submit  |                   匹配所有提交按钮                   |\n|  :image   |                  匹配所有 img 标签                   |\n|  :reset   |                   匹配所有重置按钮                   |\n|  :button  |       匹配所有 input type=button <button>按钮        |\n|   :file   |          匹配所有 input type=file 文件上传           |\n|  :hidden  | 匹配所有不可见元素 display:none 或 input type=hidden |\n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n<html>\n\t<head>\n\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n\t\t<title>Untitled Document</title>\n\t\t<script type=\"text/javascript\" src=\"../script/jquery-1.7.2.js\"></script>\n\t\t<script type=\"text/javascript\">\n\t\t\t$(function(){\n\t\t\t\t\n\t\t\t\t\n\t\t/**\n\t\t:input \t\t\n\t\t:text \t\t\n\t\t:password \t\n\t\t:radio \t\t\n\t\t:checkbox \t\n\t\t:submit \t\n\t\t:image \t\t\n\t\t:reset \t\t\n\t\t:button \t\n\t\t:file \t\t\n\t\t:hidden \t\n\t\t\n\t\t表单对象的属性\n\t\t:enabled \t\t\n\t\t:disabled \t\t\n\t\t:checked \t\t\n\t\t:selected \t\t\n\t\t*/\n\n\t\t\t\t\t\n\t\t\t\t//1.对表单内 可用input 赋值操作\n\t\t\t\t$(\"#btn1\").click(function(){\n\t\t\t\t\t// val()可以操作表单项的value属性值\n\t\t\t\t\t// 它可以设置和获取\n\t\t\t\t\t$(\":text:enabled\").val(\"我是万能的程序员\");\n\t\t\t\t});\n\t\t\t\t//2.对表单内 不可用input 赋值操作\n\t\t\t\t$(\"#btn2\").click(function(){\n\t\t\t\t\t$(\":text:disabled\").val(\"管你可用不可用，反正我是万能的程序员\");\n\t\t\t\t});\n\t\t\t\t//3.获取多选框选中的个数  使用size()方法获取选取到的元素集合的元素个数\n\t\t\t\t$(\"#btn3\").click(function(){\n\t\t\t\t\talert( $(\":checkbox:checked\").length );\n\t\t\t\t});\n\t\t\t\t//4.获取多选框，每个选中的value值\n\t\t\t\t$(\"#btn4\").click(function(){\n\t\t\t\t\t// 获取全部选中的复选框标签对象\n\t\t\t\t\tvar $checkboies = $(\":checkbox:checked\");\n\t\t\t\t\t// 老式遍历\n\t\t\t\t\t// for (var i = 0; i < $checkboies.length; i++){\n\t\t\t\t\t// \talert( $checkboies[i].value );\n\t\t\t\t\t// }\n\n\t\t\t\t\t// each方法是jQuery对象提供用来遍历元素的方法\n\t\t\t\t\t// 在遍历的function函数中，有一个this对象，这个this对象，就是当前遍历到的dom对象\n\t\t\t\t\t$checkboies.each(function () {\n\t\t\t\t\t\talert( this.value );\n\t\t\t\t\t});\n\n\t\t\t\t});\n\t\t\t\t//5.获取下拉框选中的内容  \n\t\t\t\t$(\"#btn5\").click(function(){\n\t\t\t\t\t// 获取选中的option标签对象\n\t\t\t\t\tvar $options = $(\"select option:selected\");\n\t\t\t\t\t// 遍历，获取option标签中的文本内容\n\t\t\t\t\t$options.each(function () {\n\t\t\t\t\t\t// 在each遍历的function函数中，有一个this对象。这个this对象是当前正在遍历到的dom对象\n\t\t\t\t\t\talert(this.innerHTML);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t})\t\n\t\t</script>\n\t</head>\n\t<body>\n\t\t<h3>表单对象属性过滤选择器</h3>\n\t\t <button id=\"btn1\">对表单内 可用input 赋值操作.</button>\n  \t\t <button id=\"btn2\">对表单内 不可用input 赋值操作.</button><br /><br />\n\t\t <button id=\"btn3\">获取多选框选中的个数.</button>\n\t\t <button id=\"btn4\">获取多选框选中的内容.</button><br /><br />\n         <button id=\"btn5\">获取下拉框选中的内容.</button><br /><br />\n\t\t \n\t\t<form id=\"form1\" action=\"#\">\t\t\t\n\t\t\t可用元素: <input name=\"add\" value=\"可用文本框1\"/><br>\n\t\t\t不可用元素: <input name=\"email\" disabled=\"disabled\" value=\"不可用文本框\"/><br>\n\t\t\t可用元素: <input name=\"che\" value=\"可用文本框2\"/><br>\n\t\t\t不可用元素: <input name=\"name\" disabled=\"disabled\" value=\"不可用文本框\"/><br>\n\t\t\t<br>\n\t\t\t\n\t\t\t多选框: <br>\n\t\t\t<input type=\"checkbox\" name=\"newsletter\" checked=\"checked\" value=\"test1\" />test1\n\t\t\t<input type=\"checkbox\" name=\"newsletter\" value=\"test2\" />test2\n\t\t\t<input type=\"checkbox\" name=\"newsletter\" value=\"test3\" />test3\n\t\t\t<input type=\"checkbox\" name=\"newsletter\" checked=\"checked\" value=\"test4\" />test4\n\t\t\t<input type=\"checkbox\" name=\"newsletter\" value=\"test5\" />test5\n\t\t\t\n\t\t\t<br><br>\n\t\t\t下拉列表1: <br>\n\t\t\t<select name=\"test\" multiple=\"multiple\" style=\"height: 100px\" id=\"sele1\">\n\t\t\t\t<option>浙江</option>\n\t\t\t\t<option selected=\"selected\">辽宁</option>\n\t\t\t\t<option>北京</option>\n\t\t\t\t<option selected=\"selected\">天津</option>\n\t\t\t\t<option>广州</option>\n\t\t\t\t<option>湖北</option>\n\t\t\t</select>\n\t\t\t\n\t\t\t<br><br>\n\t\t\t下拉列表2: <br>\n\t\t\t<select name=\"test2\">\n\t\t\t\t<option>浙江</option>\n\t\t\t\t<option>辽宁</option>\n\t\t\t\t<option selected=\"selected\">北京</option>\n\t\t\t\t<option>天津</option>\n\t\t\t\t<option>广州</option>\n\t\t\t\t<option>湖北</option>\n\t\t\t</select>\n\t\t</form>\t\t\n\t</body>\n</html>\n```\n\n### 表单属性过滤器\n\n|  过滤器   |                             作用                             |\n| :-------: | :----------------------------------------------------------: |\n| :enabled  |                       匹配所有可用元素                       |\n| :disabled |                      匹配所有不可用元素                      |\n| :checked  | 匹配所有选中的单选，复选，和下拉列表中选中的 option 标签对象 |\n| :selected |                    匹配所有选中的 option                     |\n\n# 6.jQuery元素筛选\n\n|     筛选      |                             作用                             |\n| :-----------: | :----------------------------------------------------------: |\n|     eq()      |             获取给定索引的元素 功能跟 :eq() 一样             |\n|    first()    |              获取第一个元素 功能跟 :first 一样               |\n|    last()     |              获取最后一个元素 功能跟 :last 一样              |\n|  filter(exp)  |                        留下匹配的元素                        |\n|    is(exp)    |     判断是否匹配给定的选择器，只要有一个匹配就返回，true     |\n|   has(exp)    |      返回包含有匹配选择器的元素的元素 功能跟 :has 一样       |\n|   not(exp)    |            删除匹配选择器的元素 功能跟 :not 一样             |\n| children(exp) |     返回匹配给定选择器的子元素 功能跟 parent>child 一样      |\n|   find(exp)   | 返回匹配给定选择器的后代元素 功能跟 ancestor descendant 一样 |\n|    next()     |   返回当前元素的下一个兄弟元素 功能跟 prev + next 功能一样   |\n|   nextAll()   | 返回当前元素后面所有的兄弟元素 功能跟 prev ~ siblings 功能一样 |\n|  nextUntil()  |          返回当前元素到指定匹配的元素为止的后面元素          |\n|   parent()    |      返回父元素 prev(exp) 返回当前元素的上一个兄弟元素       |\n|   prevAll()   |                返回当前元素前面所有的兄弟元素                |\n| prevUnit(exp) |          返回当前元素到指定匹配的元素为止的前面元素          |\n| siblings(exp) |                       返回所有兄弟元素                       |\n|     add()     |      把 add 匹配的选择器的元素添加到当前 jquery 对象中       |\n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n<html>\n\t<head>\n\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n\t\t<title>DOM查询</title>\n\t\t<style type=\"text/css\">\n\t\t\tdiv, span, p {\n\t\t\t    width: 140px;\n\t\t\t    height: 140px;\n\t\t\t    margin: 5px;\n\t\t\t    background: #aaa;\n\t\t\t    border: #000 1px solid;\n\t\t\t    float: left;\n\t\t\t    font-size: 17px;\n\t\t\t    font-family: Verdana;\n\t\t\t}\n\t\t\t\n\t\t\tdiv.mini {\n\t\t\t    width: 55px;\n\t\t\t    height: 55px;\n\t\t\t    background-color: #aaa;\n\t\t\t    font-size: 12px;\n\t\t\t}\n\t\t\t\n\t\t\tdiv.hide {\n\t\t\t    display: none;\n\t\t\t}\t\t\t\n\t\t</style>\n\t\t<script type=\"text/javascript\" src=\"../script/jquery-1.7.2.js\"></script>\n\t\t<script type=\"text/javascript\">\n\t\t\t$(document).ready(function(){\n\t\t\t\tfunction anmateIt(){\n\t\t\t\t\t$(\"#mover\").slideToggle(\"slow\", anmateIt);\n\t\t\t\t}\n\t\t\t\tanmateIt();\n\t\t\t\t\n\t/**\n\t\t\t\t\t\n\t过滤\n\teq(index|-index) \t\t\t\n\tfirst() \t\t\t\t\t\n\tlast() \t\t\t\t\t\t\n\thasClass(class) \t\t\t\n\tfilter(expr|obj|ele|fn) \t\n\tis(expr|obj|ele|fn)1.6* \t\n\thas(expr|ele) \t\t\t\t\n\tnot(expr|ele|fn) \t\t\t\n\tslice(start,[end]) \t\t\t\n\t\n\t查找\n\tchildren([expr]) \t\t\t\n\tclosest(expr,[con]|obj|ele)1.6*   \n\tfind(expr|obj|ele) \t\t\t\t\n\tnext([expr]) \t\t\t\t\t\n\tnextall([expr]) \t\t\t\t\n\tnextUntil([exp|ele][,fil])1.6* \t\n\tparent([expr]) \t\t\t\t\t\n\tparents([expr]) \t\t\t\t\n\tparentsUntil([exp|ele][,fil])1.6*  \n\tprev([expr]) \t\t\t\t\t\n\tprevall([expr]) \t\t\t\t\n\tprevUntil([exp|ele][,fil])1.6* \t\n\tsiblings([expr]) \t\t\t\t\n\t\n\t串联\n\tadd(expr|ele|html|obj[,con]) \t\n\t\t\t\t\t\t\t\n\t\n\t*/\n\t\t\t\t\n\t\t\t\t//(1)eq()  选择索引值为等于 3 的 div 元素\n\t\t\t\t$(\"#btn1\").click(function(){\n\t\t\t\t\t$(\"div\").eq(3).css(\"background-color\",\"#bfa\");\n\t\t\t\t});\n\t\t\t\t//(2)first()选择第一个 div 元素\n\t\t\t\t $(\"#btn2\").click(function(){\n\t\t\t\t\t //first()   选取第一个元素\n\t\t\t\t\t$(\"div\").first().css(\"background-color\",\"#bfa\");\n\t\t\t\t});\n\t\t\t\t//(3)last()选择最后一个 div 元素\n\t\t\t\t$(\"#btn3\").click(function(){\n\t\t\t\t\t//last()  选取最后一个元素\n\t\t\t\t\t$(\"div\").last().css(\"background-color\",\"#bfa\");\n\t\t\t\t});\n\t\t\t\t//(4)filter()在div中选择索引为偶数的\n\t\t\t\t$(\"#btn4\").click(function(){\n\t\t\t\t\t//filter()  过滤   传入的是选择器字符串\n\t\t\t\t\t$(\"div\").filter(\":even\").css(\"background-color\",\"#bfa\");\n\t\t\t\t});\n\t\t\t\t //(5)is()判断#one是否为:empty或:parent\n\t\t\t\t//is用来检测jq对象是否符合指定的选择器\n\t\t\t\t$(\"#btn5\").click(function(){\n\t\t\t\t\talert( $(\"#one\").is(\":empty\") );\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t//(6)has()选择div中包含.mini的\n\t\t\t\t$(\"#btn6\").click(function(){\n\t\t\t\t\t//has(selector)  选择器字符串    是否包含selector\n\t\t\t\t\t$(\"div\").has(\".mini\").css(\"background-color\",\"#bfa\");\n\t\t\t\t});\n\t\t\t\t//(7)not()选择div中class不为one的\n\t\t\t\t$(\"#btn7\").click(function(){\n\t\t\t\t\t//not(selector)  选择不是selector的元素\n\t\t\t\t\t$(\"div\").not('.one').css(\"background-color\",\"#bfa\");\n\t\t\t\t});\n\t\t\t\t//(8)children()在body中选择所有class为one的div子元素\n\t\t\t\t$(\"#btn8\").click(function(){\n\t\t\t\t\t//children()  选出所有的子元素\n\t\t\t\t\t$(\"body\").children(\"div.one\").css(\"background-color\",\"#bfa\");\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//(9)find()在body中选择所有class为mini的div元素\n\t\t\t\t$(\"#btn9\").click(function(){\n\t\t\t\t\t//find()  选出所有的后代元素\n\t\t\t\t\t$(\"body\").find(\"div.mini\").css(\"background-color\",\"#bfa\");\n\t\t\t\t});\n\t\t\t\t//(10)next() #one的下一个div\n\t\t\t\t$(\"#btn10\").click(function(){\n\t\t\t\t\t//next()  选择下一个兄弟元素\n\t\t\t\t\t$(\"#one\").next(\"div\").css(\"background-color\",\"#bfa\");\n\t\t\t\t});\n\t\t\t\t//(11)nextAll() #one后面所有的span元素\n\t\t\t\t$(\"#btn11\").click(function(){\n\t\t\t\t\t//nextAll()   选出后面所有的元素\n\t\t\t\t\t$(\"#one\").nextAll(\"span\").css(\"background-color\",\"#bfa\");\n\t\t\t\t});\n\t\t\t\t//(12)nextUntil() #one和span之间的元素\n\t\t\t\t$(\"#btn12\").click(function(){\n\t\t\t\t\t//\n\t\t\t\t\t$(\"#one\").nextUntil(\"span\").css(\"background-color\",\"#bfa\")\n\t\t\t\t});\n\t\t\t\t//(13)parent() .mini的父元素\n\t\t\t\t$(\"#btn13\").click(function(){\n\t\t\t\t\t$(\".mini\").parent().css(\"background-color\",\"#bfa\");\n\t\t\t\t});\n\t\t\t\t//(14)prev() #two的上一个div\n\t\t\t\t$(\"#btn14\").click(function(){\n\t\t\t\t\t//prev()  \n\t\t\t\t\t$(\"#two\").prev(\"div\").css(\"background-color\",\"#bfa\")\n\t\t\t\t});\n\t\t\t\t//(15)prevAll() span前面所有的div\n\t\t\t\t$(\"#btn15\").click(function(){\n\t\t\t\t\t//prevAll()   选出前面所有的元素\n\t\t\t\t\t$(\"span\").prevAll(\"div\").css(\"background-color\",\"#bfa\")\n\t\t\t\t});\n\t\t\t\t//(16)prevUntil() span向前直到#one的元素\n\t\t\t\t$(\"#btn16\").click(function(){\n\t\t\t\t\t//prevUntil(exp)   找到之前所有的兄弟元素直到找到exp停止\n\t\t\t\t\t$(\"span\").prevUntil(\"#one\").css(\"background-color\",\"#bfa\")\n\t\t\t\t});\n\t\t\t\t//(17)siblings() #two的所有兄弟元素\n\t\t\t\t$(\"#btn17\").click(function(){\n\t\t\t\t\t//siblings()    找到所有的兄弟元素，包括前面的和后面的\n\t\t\t\t\t$(\"#two\").siblings().css(\"background-color\",\"#bfa\")\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//(18)add()选择所有的 span 元素和id为two的元素\n\t\t\t\t$(\"#btn18\").click(function(){\n\t\n\t\t\t\t\t//   $(\"span,#two,.mini,#one\")\n\t\t\t\t\t$(\"span\").add(\"#two\").add(\"#one\").css(\"background-color\",\"#bfa\");\n\t\t\t\t\t\n\t\t\t\t});\n\t\t\t\t\n\n\n\t\t\t});\n\t\t\t\n\t\t\t\n\t\t</script>\n\t</head>\n\t<body>\t\t\n\t\t<input type=\"button\" value=\"eq()选择索引值为等于 3 的 div 元素\" id=\"btn1\" />\n\t\t<input type=\"button\" value=\"first()选择第一个 div 元素\" id=\"btn2\" />\n\t\t<input type=\"button\" value=\"last()选择最后一个 div 元素\" id=\"btn3\" />\n\t\t<input type=\"button\" value=\"filter()在div中选择索引为偶数的\" id=\"btn4\" />\n\t\t<input type=\"button\" value=\"is()判断#one是否为:empty或:parent\" id=\"btn5\" />\n\t\t<input type=\"button\" value=\"has()选择div中包含.mini的\" id=\"btn6\" />\n\t\t<input type=\"button\" value=\"not()选择div中class不为one的\" id=\"btn7\" />\n\t\t<input type=\"button\" value=\"children()在body中选择所有class为one的div子元素\" id=\"btn8\" />\n\t\t<input type=\"button\" value=\"find()在body中选择所有class为mini的div后代元素\" id=\"btn9\" />\n\t\t<input type=\"button\" value=\"next()#one的下一个div\" id=\"btn10\" />\n\t\t<input type=\"button\" value=\"nextAll()#one后面所有的span元素\" id=\"btn11\" />\n\t\t<input type=\"button\" value=\"nextUntil()#one和span之间的元素\" id=\"btn12\" />\n\t\t<input type=\"button\" value=\"parent().mini的父元素\" id=\"btn13\" />\n\t\t<input type=\"button\" value=\"prev()#two的上一个div\" id=\"btn14\" />\n\t\t<input type=\"button\" value=\"prevAll()span前面所有的div\" id=\"btn15\" />\n\t\t<input type=\"button\" value=\"prevUntil()span向前直到#one的元素\" id=\"btn16\" />\n\t\t<input type=\"button\" value=\"siblings()#two的所有兄弟元素\" id=\"btn17\" />\n\t\t<input type=\"button\" value=\"add()选择所有的 span 元素和id为two的元素\" id=\"btn18\" />\n\n\t\t\n\t\t<h3>基本选择器.</h3>\n\t\t<br /><br />\n\t\t文本框<input type=\"text\" name=\"account\" disabled=\"disabled\" />\n\t\t<br><br>\n\t\t<div class=\"one\" id=\"one\">\n\t\t\tid 为 one,class 为 one 的div\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t</div>\n\t\t<div class=\"one\" id=\"two\" title=\"test\">\n\t\t\tid为two,class为one,title为test的div\n\t\t\t<div class=\"mini\" title=\"other\"><b>class为mini,title为other</b></div>\n\t\t\t<div class=\"mini\" title=\"test\">class为mini,title为test</div>\n\t\t</div>\n\t\t\n\t\t<div class=\"one\">\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\"></div>\n\t\t</div>\n\t\t<div class=\"one\">\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\">class为mini</div>\n\t\t\t<div class=\"mini\" title=\"tesst\">class为mini,title为tesst</div>\n\t\t</div>\n\t\t<div style=\"display:none;\" class=\"none\">style的display为\"none\"的div</div>\n\t\t<div class=\"hide\">class为\"hide\"的div</div>\n\t\t<span id=\"span1\">^^span元素 111^^</span>\n\t\t<div>\n\t\t\t包含input的type为\"hidden\"的div<input type=\"hidden\" size=\"8\">\n\t\t</div>\n\t\t<span id=\"span2\">^^span元素 222^^</span>\n\t\t<div id=\"mover\">正在执行动画的div元素.</div>\n\t</body>\n</html>     \n```\n\n# 7.jQuery的属性操作\n\n| 属性/函数 |                             作用                             |\n| :-------: | :----------------------------------------------------------: |\n|  html()   | 它可以设置和获取起始标签和结束标签中的内容。 跟 dom 属性 innerHTML 一样。 |\n|  text()   | 它可以设置和获取起始标签和结束标签中的文本。 跟 dom 属性 innerText 一样。 |\n|   val()   | 它可以设置和获取表单项的 value 属性值。 跟 dom 属性 value 一样 |\n|  attr()   | 可以设置和获取属性的值，不推荐操作 checked、readOnly、selected、disabled 等等。attr 方法还可以操作非标准的属性。比如自定义属性：abc,bbj |\n|  prop()   | 可以设置和获取属性的值,只推荐操作 checked、readOnly、selected、disabled 等等 |\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh_CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\" src=\"script/jquery-1.7.2.js\"></script>\n    <script type=\"text/javascript\">\n        $(function () {\n            /*\n            // 批量操作单选 $(\":radio\").val([\"radio2\"]);\n            // 批量操作筛选框的选中状态 $(\":checkbox\").val([\"checkbox3\",\"checkbox2\"]);\n            // 批量操作多选的下拉框选中状态 $(\"#multiple\").val([\"mul2\",\"mul3\",\"mul4\"]);\n            // 操作单选的下拉框选中状态 $(\"#single\").val([\"sin2\"]);\n            */\n            $(\"#multiple,#single,:radio,:checkbox\").val([\"radio2\", \"checkbox1\", \"checkbox3\", \"mul1\", \"mul4\", \"sin3\"]);\n        });\n    </script>\n</head>\n<body>\n    单选： \n    <input name=\"radio\" type=\"radio\" value=\"radio1\"/>radio1\n    <input name=\"radio\" type=\"radio\" value=\"radio2\"/>radio2\n    <br/>\n    多选： \n    <input name=\"checkbox\" type=\"checkbox\" value=\"checkbox1\"/>checkbox1\n    <input name=\"checkbox\" type=\"checkbox\" value=\"checkbox2\"/>checkbox2\n    <input name=\"checkbox\" type=\"checkbox\" value=\"checkbox3\"/>checkbox3\n    <br/> \n    下拉多选 ：\n    <select id=\"multiple\" multiple=\"multiple\" size=\"4\">\n        <option value=\"mul1\">mul1</option>\n        <option value=\"mul2\">mul2</option>\n        <option value=\"mul3\">mul3</option>\n        <option value=\"mul4\">mul4</option>\n    </select>\n    <br/>\n下拉单选 ： \n    <select id=\"single\">\n        <option value=\"sin1\">sin1</option>\n        <option value=\"sin2\">sin2</option>\n        <option value=\"sin3\">sin3</option>\n    </select>\n</body>\n</html>\n```\n\n# 8.jQuery练习\n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    <title>Insert title here</title>\n    <script type=\"text/javascript\" src=\"../../script/jquery-1.7.2.js\"></script>\n    <script type=\"text/javascript\">\n        $(function () {\n            // 给全选绑定单击事件\n            $(\"#checkedAllBtn\").click(function () {\n                $(\":checkbox\").prop(\"checked\", true);\n            });\n            // 给全不选绑定单击事件\n            $(\"#checkedNoBtn\").click(function () {\n                $(\":checkbox\").prop(\"checked\", false);\n            });\n            // 反选单击事件\n            $(\"#checkedRevBtn\").click(function () {\n                // 查询全部的球类的复选框\n                $(\":checkbox[name='items']\").each(function () {\n                    // 在 each 遍历的 function 函数中，有一个 this 对象。这个 this 对象是当前正在遍历到的 dom 对象\n                     this.checked = !this.checked; \n                });\n                // 要检查 是否满选\n                // 获取全部的球类个数\n                var allCount = $(\":checkbox[name='items']\").length;\n                // 再获取选中的球类个数\n                var checkedCount = $(\":checkbox[name='items']:checked\").length;\n                //if (allCount == checkedCount) {\n                // $(\"#checkedAllBox\").prop(\"checked\",true);\n                // } else {\n                // $(\"#checkedAllBox\").prop(\"checked\",false);\n                // }\n                $(\"#checkedAllBox\").prop(\"checked\", allCount == checkedCount);\n            });\n            // 【提交】按钮单击事件\n            $(\"#sendBtn\").click(function () {\n                // 获取选中的球类的复选框\n                $(\":checkbox[name='items']:checked\").each(function () {\n                    alert(this.value);\n                });\n            });\n            // 给【全选/全不选】绑定单击事件\n            $(\"#checkedAllBox\").click(function () {\n                // 在事件的 function 函数中，有一个 this 对象，这个 this 对象是当前正在响应事件的 dom 对象\n                // alert(this.checked);\n                $(\":checkbox[name='items']\").prop(\"checked\", this.checked);\n            });\n            // 给全部球类绑定单击事件\n            $(\":checkbox[name='items']\").click(function () {\n                // 要检查 是否满选\n                // 获取全部的球类个数\n                var allCount = $(\":checkbox[name='items']\").length;\n                // 再获取选中的球类个数\n                var checkedCount = $(\":checkbox[name='items']:checked\").length;\n                $(\"#checkedAllBox\").prop(\"checked\", allCount == checkedCount);\n            });\n        });\n    </script>\n</head>\n<body>\n    <form method=\"post\" action=\"\">\n        你爱好的运动是？<input type=\"checkbox\" id=\"checkedAllBox\"/>全选/全不选\n        <br/>\n        <input type=\"checkbox\" name=\"items\" value=\"足球\"/>足球\n        <input type=\"checkbox\" name=\"items\" value=\"篮球\"/>篮球\n        <input type=\"checkbox\" name=\"items\" value=\"羽毛球\"/>羽毛球\n        <input type=\"checkbox\" name=\"items\" value=\"乒乓球\"/>乒乓球\n        <br/>\n        <input type=\"button\" id=\"checkedAllBtn\" value=\"全 选\"/>\n        <input type=\"button\" id=\"checkedNoBtn\" value=\"全不选\"/>\n        <input type=\"button\" id=\"checkedRevBtn\" value=\"反 选\"/>\n        <input type=\"button\" id=\"sendBtn\" value=\"提 交\"/>\n    </form>\n</body>\n</html>\n```\n\n# 9.jQuery的增删改查\n\n**内部插入：** \n\n​\t\tappendTo() \ta.appendTo(b) 把 a 插入到 b 子元素末尾，成为最后一个子元素prependTo() a.\n\n​\t\tprependTo(b) \t\t\t\t\t\t\t把 a 插到 b 所有子元素前面，成为第一个子元素 \n\n**外部插入：** \n\n​\t\tinsertAfter() \t\ta.insertAfter(b) \t\t\t  得到 ba \n\n​\t\tinsertBefore() \t\ta.insertBefore(b) \t\t得到 ab \n\n**替换:**\n\n​\t\treplaceWith() \t\ta.replaceWith(b) \t\t用 b 替换掉 a \n\n​\t\treplaceAll() \t\ta.replaceAll(b) \t\t\t\t用 a 替换掉所有 b \n\n**删除：** \n\n​\t\tremove() \t\ta.remove(); \t\t\t\t删除 a 标签 \n\n​\t\tempty() \t\t\ta.empty(); \t\t\t\t 清空 a 标签里的内容\n\n# 10.jQuery练习二\n\n练习一：从左到右，从右到左\n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>Insert title here</title>\n\t<style type=\"text/css\">\n\t\tselect {\n\t\t\twidth: 100px;\n\t\t\theight: 140px;\n\t\t}\n\t\t\n\t\tdiv {\n\t\t\twidth: 130px;\n\t\t\tfloat: left;\n\t\t\ttext-align: center;\n\t\t}\n\t</style>\n\t<script type=\"text/javascript\" src=\"script/jquery-1.7.2.js\"></script>\n\t<script type=\"text/javascript\">\t\n\t\t$(function(){\n\t\t\t//选中添加到右边\n\t\t\t$(\"button:eq(0)\").click(function(){\n\t\t\t\t$(\"select[name=sel01] :selected\").each(function(){\n\t\t\t\t\t//alert(this);\n\t\t\t\t\t$(this).appendTo(\"select[name=sel02]\");\n\t\t\t\t});\n\t\t\t});\n\t\t\t\n\t\t\t//全部添加到右边\n\t\t\t$(\"button:eq(1)\").click(function(){\n\t\t\t\t$(\"select[name=sel01] option\").each(function(){\n\t\t\t\t\t//alert(this);\n\t\t\t\t\t$(this).appendTo(\"select[name=sel02]\");\n\t\t\t\t});\n\t\t\t});\n\t\t\t\n\t\t\t//选中删除到左边\n\t\t\t$(\"button:eq(2)\").click(function(){\n\t\t\t\t$(\"select[name=sel02] :selected\").each(function(){\n\t\t\t\t\t//alert(this);\n\t\t\t\t\t$(this).appendTo(\"select[name=sel01]\");\n\t\t\t\t});\n\t\t\t});\n\t\t\t//全部删除到左边\n\t\t\t$(\"button:eq(3)\").click(function(){\n\t\t\t\t$(\"select[name=sel02] option\").each(function(){\n\t\t\t\t\t//alert(this);\n\t\t\t\t\t$(this).appendTo(\"select[name=sel01]\");\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t\n\t</script>\n</head>\n<body>\n\n\t<div id=\"left\">\n\t\t<select multiple=\"multiple\" name=\"sel01\">\n\t\t\t<option value=\"opt01\">选项1</option>\n\t\t\t<option value=\"opt02\">选项2</option>\n\t\t\t<option value=\"opt03\">选项3</option>\n\t\t\t<option value=\"opt04\">选项4</option>\n\t\t\t<option value=\"opt05\">选项5</option>\n\t\t\t<option value=\"opt06\">选项6</option>\n\t\t\t<option value=\"opt07\">选项7</option>\n\t\t\t<option value=\"opt08\">选项8</option>\n\t\t</select>\n\t\t\n\t\t<button>选中添加到右边</button>\n\t\t<button>全部添加到右边</button>\n\t</div>\n\t<div id=\"rigth\">\n\t\t<select multiple=\"multiple\" name=\"sel02\">\n\t\t</select>\n\t\t<button>选中删除到左边</button>\n\t\t<button>全部删除到左边</button>\n\t</div>\n\n</body>\n</html>\n```\n\n练习二：动态添加，删除表格记录\n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>Untitled Document</title>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"styleB/css.css\" />\n<script type=\"text/javascript\" src=\"../../script/jquery-1.7.2.js\"></script>\n<script type=\"text/javascript\">\n\t\n\t$(function(){\n\t\t\n\t\t//删除用户的方法\n\t\tfunction delA(){\n\t\t\t//获取要删除员工的名字\n\t\t\tvar name = $(this).parents(\"tr\").find(\"td:eq(0)\").text();\n\t\t\t//弹出一个确认框\n\t\t\tvar flag = confirm(\"确认删除\"+name+\"吗？\");\n\t\t\tif(flag){\n\t\t\t\t//删除当前a所在的tr\n\t\t\t\t$(this).parents(\"tr\").remove();\n\t\t\t}\n\t\t\t//取消默认行为\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t//删除用户\n\t\t//$(\"a\").click(delA);\n\t\t$(\"a\").live(\"click\" , delA);\n\t\t\n\t\t//添加员工\n\t\t$(\"#addEmpButton\").click(function(){\n\t\t\t//获取用户填写的内容\n\t\t\tvar name = $(\"#empName\").val();\n\t\t\tvar email = $(\"#email\").val();\n\t\t\tvar salary = $(\"#salary\").val();\n\t\t\t\n\t\t\t//创建tr\n\t\t\t/*\n\t\t\t\t<tr>\n\t\t\t\t\t<td>Tom</td>\n\t\t\t\t\t<td>tom@tom.com</td>\n\t\t\t\t\t<td>5000</td>\n\t\t\t\t\t<td><a href=\"#\">Delete</a></td>\n\t\t\t\t</tr>\n\t\t\t*/\n\t\t\t$(\"<tr></tr>\").append(\"<td>\"+name+\"</td>\")\n\t\t\t\t\t\t  .append(\"<td>\"+email+\"</td>\")\n\t\t\t\t\t\t  .append(\"<td>\"+salary+\"</td>\")\n\t\t\t\t\t\t  .append(\"<td><a href='#'>Delete</a></td>\")\n\t\t\t\t\t\t  .appendTo(\"#employeeTable\");\n\t\t\t\n\t\t});\n\t});\n\t\n\t\n</script>\n</head>\n<body>\n\n\t<table id=\"employeeTable\">\n\t\t<tr>\n\t\t\t<th>Name</th>\n\t\t\t<th>Email</th>\n\t\t\t<th>Salary</th>\n\t\t\t<th>&nbsp;</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Tom</td>\n\t\t\t<td>tom@tom.com</td>\n\t\t\t<td>5000</td>\n\t\t\t<td><a href=\"#\">Delete</a></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Jerry</td>\n\t\t\t<td>jerry@sohu.com</td>\n\t\t\t<td>8000</td>\n\t\t\t<td><a href=\"#\">Delete</a></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Bob</td>\n\t\t\t<td>bob@tom.com</td>\n\t\t\t<td>10000</td>\n\t\t\t<td><a href=\"#\">Delete</a></td>\n\t\t</tr>\n\t</table>\n\n\t<div id=\"formDiv\">\n\t\n\t\t<h4>添加新员工</h4>\n\n\t\t<table>\n\t\t\t<tr>\n\t\t\t\t<td class=\"word\">name: </td>\n\t\t\t\t<td class=\"inp\">\n\t\t\t\t\t<input type=\"text\" name=\"empName\" id=\"empName\" />\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td class=\"word\">email: </td>\n\t\t\t\t<td class=\"inp\">\n\t\t\t\t\t<input type=\"text\" name=\"email\" id=\"email\" />\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td class=\"word\">salary: </td>\n\t\t\t\t<td class=\"inp\">\n\t\t\t\t\t<input type=\"text\" name=\"salary\" id=\"salary\" />\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td colspan=\"2\" align=\"center\">\n\t\t\t\t\t<button id=\"addEmpButton\" value=\"abc\">\n\t\t\t\t\t\tSubmit\n\t\t\t\t\t</button>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</table>\n\n\t</div>\n\n</body>\n</html>\n```\n\n# 11.jQuery的操作CSS样式\n\n​\t\taddClass() \t\t\t\t添加样式 \n\n​\t\tremoveClass() \t\t删除样式 \n\n​\t\ttoggleClass()\t\t   有就删除，没有就添加样式。 \n\n​\t\toffset() \t\t\t\t\t获取和设置元素的坐标。\n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>Insert title here</title>\n<style type=\"text/css\">\n\t\n\tdiv{\n\t\twidth:100px;\n\t\theight:260px;\n\t}\n\t\n\tdiv.border{\n\t\tborder: 2px white solid;\n\t}\n\t\n\tdiv.redDiv{\n\t\tbackground-color: red;\n\t}\n\t\n\tdiv.blackDiv{\n\t\tborder: 5px blue solid;\n\t}\n\t\n\t\n\t\n\t\n</style>\n\n<script type=\"text/javascript\" src=\"script/jquery-1.7.2.js\"></script>\n<script type=\"text/javascript\">\n\t\n\n\t$(function(){\n\t\t/*\nCSS\ncss(name|pro|[,val|fn])       读写匹配元素的样式属性。 \n\t\t\t\t\t\t\t\ta.css('color')取出a元素的color\n\t\t\t\t\t\t\t\ta.css('color',\"red\")设置a元素的color为red\n\nCSS 类\n\naddClass(class|fn) \t\t\t为元素添加一个class值;<div class=\"mini big\">\nremoveClass([class|fn]) \t删除元素的class值；传递一个具体的class值，就会删除具体的某个class\n\t\t\t\t\t\t\ta.removeClass()：移除所有的class值\n\n**/\n\t\t\n\t\tvar $divEle = $('div:first');\n\t\t\n\t\t$('#btn01').click(function(){\n\t\t\t//addClass() - 向被选元素添加一个或多个类\n\t\t\t$divEle.addClass(\"redDiv blackDiv\");\n\t\t});\n\t\t\n\t\t$('#btn02').click(function(){\n\t\t\t//removeClass() - 从被选元素删除一个或多个类 \n\t\t\t$divEle.removeClass()\n\t\t});\n\n\t\t\n\t\t$('#btn03').click(function(){\n\t\t\t//toggleClass() - 对被选元素进行添加/删除类的切换操作 \n\t\t\t//切换就是如果具有该类那么删除，如果没有那么添加上\n\t\t\t$divEle.toggleClass(\"redDiv\");\n\t\t});\n\t\t\n\t\t$('#btn04').click(function(){\n\t\t\t//offset() - 返回第一个匹配元素相对于文档的位置。\n\t\t\tvar os = $divEle.offset();\n\t\t\t//注意通过offset获取到的是一个对象，这个对象有两个属性top表示顶边距，left表示左边距\n\t\t\talert(\"顶边距：\"+os.top+\" 左边距：\"+os.left);\n\t\t\t\n\t\t\t//调用offset设置元素位置时，也需要传递一个js对象，对象有两个属性top和left\n\t\t\t//offset({ top: 10, left: 30 });\n\t\t\t $divEle.offset({\n\t\t\t\t top:50,\n\t\t\t\t left:60\n\t\t\t }); \n\t\t});\n\t\t\n\t})\n</script>\n</head>\n<body>\n\n\t<table align=\"center\">\n\t\t<tr>\n\t\t\t<td>\n\t\t\t\t<div class=\"border\">\n\t\t\t\t</div>\n\t\t\t</td>\n\t\t\t\n\t\t\t<td>\n\t\t\t\t<div class=\"btn\">\n\t\t\t\t\t<input type=\"button\" value=\"addClass()\" id=\"btn01\"/>\n\t\t\t\t\t<input type=\"button\" value=\"removeClass()\" id=\"btn02\"/>\n\t\t\t\t\t<input type=\"button\" value=\"toggleClass()\" id=\"btn03\"/>\n\t\t\t\t\t<input type=\"button\" value=\"offset()\" id=\"btn04\"/>\n\t\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\t</table>\n\t<br /> <br />\n\t<br /> <br />\n</body>\n</html>\n```\n\n# 12.jQuery动画\n\n**基本动画** \n\n​\t\tshow() \t\t\t将隐藏的元素显示 \n\n​\t\thide() \t\t\t 将可见的元素隐藏。 \n\n​\t\ttoggle() \t\t 可见就隐藏，不可见就显示。 \n\n​\t以上动画方法都可以添加参数。 \n\n​\t\t\t1、第一个参数是动画 执行的时长，以毫秒为单位 \n\n​\t\t\t2、第二个参数是动画的回调函数 (动画完成后自动调用的函数) \n\n**淡入淡出动画** \n\n​\t\tfadeIn() \t\t\t淡入（慢慢可见） \n\n​\t\tfadeOut() \t\t淡出（慢慢消失） \n\n​\t\tfadeTo() \t\t在指定时长内慢慢的将透明度修改到指定的值。0 透明，1 完成可见，0.5 半透明 \n\n​\t\tfadeToggle() \t淡入/淡出 切换 \n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n<html>\n\t<head>\n\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n\t\t<title>Untitled Document</title>\n\t\t<link href=\"css/style.css\" type=\"text/css\" rel=\"stylesheet\" />\n\t\t<script type=\"text/javascript\" src=\"script/jquery-1.7.2.js\"></script>\n\t\n<script type=\"text/javascript\">\n\t/* \t\n\t\t基本\n\t\tshow([speed,[easing],[fn]]) \n\t\thide([speed,[easing],[fn]]) \n\t\ttoggle([speed],[easing],[fn]) \n\t\t滑动\n\t\tslideDown([spe],[eas],[fn]) \n\t\tslideUp([speed,[easing],[fn]]) \n\t\tslideToggle([speed],[easing],[fn]) \n\t\t淡入淡出\n\t\tfadeIn([speed],[eas],[fn]) \n\t\tfadeOut([speed],[eas],[fn]) \n\t\tfadeTo([[spe],opa,[eas],[fn]]) \n\t\tfadeToggle([speed,[eas],[fn]])\n\t\t*/\n\t\t$(function(){\n\t\t\t//显示   show()\n\t\t\t$(\"#btn1\").click(function(){\n\t\t\t\t$(\"#div1\").show(1000);\n\t\t\t});\t\t\n\t\t\t//隐藏  hide()\n\t\t\t$(\"#btn2\").click(function(){\n\t\t\t\t$(\"#div1\").hide(1000);\n\t\t\t});\t\n\t\t\t//切换   toggle()\n\t\t\t$(\"#btn3\").click(function(){\n\t\t\t\t$(\"#div1\").toggle(1000);\n\t\t\t});\t\n\t\t\t\n\t\t\t\n\t\t\t//淡入   fadeIn()\n\t\t\t$(\"#btn4\").click(function(){\n\t\t\t\t$(\"#div1\").fadeIn(500);\n\t\t\t});\t\n\t\t\t//淡出  fadeOut()\n\t\t\t$(\"#btn5\").click(function(){\n\t\t\t\t$(\"#div1\").fadeOut(500);\n\t\t\t});\t\n\t\t\t\n\t\t\t//淡化到  fadeTo()\n\t\t\t$(\"#btn6\").click(function(){\n\t\t\t\t$(\"#div1\").fadeTo(\"slow\",Math.random());\n\t\t\t});\t\n\t\t\t//淡化切换  fadeToggle()\n\t\t\t$(\"#btn7\").click(function(){\n\t\t\t\t$(\"#div1\").fadeToggle(\"slow\",\"linear\");\n\t\t\t});\t\n\t\t})\n</script>\n\t\n\t</head>\n\t<body>\n\t\t<table style=\"float: left;\">\n\t\t\t<tr>\n\t\t\t\t<td><button id=\"btn1\">显示show()</button></td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td><button id=\"btn2\">隐藏hide()</button></td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td><button id=\"btn3\">显示/隐藏切换 toggle()</button></td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td><button id=\"btn4\">淡入fadeIn()</button></td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td><button id=\"btn5\">淡出fadeOut()</button></td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td><button id=\"btn6\">淡化到fadeTo()</button></td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td><button id=\"btn7\">淡化切换fadeToggle()</button></td>\n\t\t\t</tr>\n\t\t</table>\n\t\t\n\t\t<div id=\"div1\" style=\"float:left;border: 1px solid;background-color: blue;width: 300px;height: 200px;\">\n\t\t\tjquery动画定义了很多种动画效果，可以很方便的使用这些动画效果\n\t\t</div>\n\t</body>\n\n</html>\n\n```\n\n\n\n**练习** 、CSS动画 品牌展示\n\n​\t需求：\n\n​\t\t1.点击按钮的时候，隐藏和显示卡西欧之后的品牌。 \n\n​\t\t2.当显示全部内容的时候，按钮文本为“显示精简品牌” 然后，小三角形向上。所有品牌产品为默认颜色。 \n\n​\t\t3.当只显示精简品牌的时候，要隐藏卡西欧之后的品牌，按钮文本为“显示全部品牌” 然后小三形向下。并且把 佳能，尼康的品牌颜色改为红色（给 li 标签添加 promoted 样式即可） \n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n        \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n    <title>品牌展示练习</title>\n    <style type=\"text/css\">\n        * {\n            margin: 0;\n            padding: 0;\n        }\n\n        body {\n            font-size: 12px;\n            text-align: center;\n        }\n\n        a {\n            color: #04D;\n            text-decoration: none;\n        }\n\n        a:hover {\n            color: #F50;\n            text-decoration: underline;\n        }\n\n        .SubCategoryBox {\n            width: 600px;\n            margin: 0 auto;\n            text-align: center;\n            margin-top: 40px;\n        }\n\n        .SubCategoryBox ul {\n            list-style: none;\n        }\n\n        .SubCategoryBox ul li {\n            display: block;\n            float: left;\n            width: 200px;\n            line-height: 20px;\n        }\n\n        .showmore {\n            clear: both;\n            text-align: center;\n            padding-top: 10px;\n        }\n\n        .showmore a {\n            display: block;\n            width: 120px;\n            margin: 0 auto;\n            line-height: 24px;\n            border: 1px solid #AAA;\n        }\n\n        .showmore a span {\n            padding-left: 15px;\n            background: url(img/down.gif) no-repeat 0 0;\n        }\n\n        .promoted a {\n            color: #F50;\n        }\n    </style>\n    <script type=\"text/javascript\" src=\"script/jquery-1.7.2.js\"></script>\n    <script type=\"text/javascript\">\n        $(function () {\n            var category = $(\"ul:first li:gt(5):not(:last)\");\n            category.hide();\n\n            var $promoptedCategory = $(\"ul:first li\").filter(\":contains('佳能'), :contains('尼康'), :contains('奥林巴斯')\");\n\n            $(\".showmore a\").click(function () {\n                if (category.is(\":hidden\")) {\n                    category.show();\n                    $promoptedCategory.addClass(\"promoted\");\n                    $(\".showmore a span\").text(\"显示精简品牌\")\n                        .css(\"background\", \"url(img/up.gif) no-repeat 0 0\");\n                } else {\n                    category.hide();\n                    $promoptedCategory.removeClass(\"promoted\");\n                    $(\".showmore a span\").text(\"显示全部品牌\")\n                        .css(\"background\", \"url(img/down.gif) no-repeat 0 0\");\n                }\n\n                return false;\n            });\n        });\n    </script>\n</head>\n<body>\n<div class=\"SubCategoryBox\">\n    <ul>\n        <li><a href=\"#\">佳能</a><i>(30440) </i></li>\n        <li><a href=\"#\">索尼</a><i>(27220) </i></li>\n        <li><a href=\"#\">三星</a><i>(20808) </i></li>\n        <li><a href=\"#\">尼康</a><i>(17821) </i></li>\n        <li><a href=\"#\">松下</a><i>(12289) </i></li>\n        <li><a href=\"#\">卡西欧</a><i>(8242) </i></li>\n        <li><a href=\"#\">富士</a><i>(14894) </i></li>\n        <li><a href=\"#\">柯达</a><i>(9520) </i></li>\n        <li><a href=\"#\">宾得</a><i>(2195) </i></li>\n        <li><a href=\"#\">理光</a><i>(4114) </i></li>\n        <li><a href=\"#\">奥林巴斯</a><i>(12205) </i></li>\n        <li><a href=\"#\">明基</a><i>(1466) </i></li>\n        <li><a href=\"#\">爱国者</a><i>(3091) </i></li>\n        <li><a href=\"#\">其它品牌相机</a><i>(7275) </i></li>\n    </ul>\n    <div class=\"showmore\">\n        <a href=\"more.html\"><span>显示全部品牌</span></a>\n    </div>\n</div>\n</body>\n</html>\n```\n\n# 13.jQuery事件操作\n\n​\t\t**$( function(){} );和window.onload = function(){}的区别？** \n\n他们分别是在什么时候触发？ \n\n​\t1、jQuery 的页面加载完成之后是浏览器的内核解析完页面的标签创建好 DOM 对象之后就会马上执行。 \n\n​\t2、原生 js 的页面加载完成之后，除了要等浏览器内核解析完标签创建好 DOM 对象，还要等标签显示时需要的内容加载 完成。\n\n他们触发的顺序？ \n\n​\t1、jQuery 页面加载完成之后先执行 \n\n​\t2、原生 js 的页面加载完成之后 \n\n他们执行的次数？ \n\n​\t1、原生 js 的页面加载完成之后，只会执行最后一次的赋值函数。 \n\n​\t2、jQuery 的页面加载完成之后是全部把注册的 function 函数，依次顺序全部执行。\n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>Insert title here</title>\n<script type=\"text/javascript\"></script>\n<script type=\"text/javascript\" src=\"../../script/jquery-1.7.2.js\"></script>\n<script type=\"text/javascript\">\n\t//$(function(){}) 和  window.onload = function(){}的区别\n \twindow.onload = function(){\n\t\t//会在整个页面加载完毕之后调用\n\t\talert(\"abc\")\n\t}\n/*\n\t$(function(){\n\t\talert(\"abc\")//会在当前文档加载完毕之后调用\n\t})\n\t\n\t*/\n\t$(function(){\n\t\talert(\"edf\")//会在当前文档加载完毕之后调用\n\t})\n\t\n/* \t$(function(){\n\t\talert(\"我是jQuery核心函数\");\n\t});\n\twindow.onload = function(){\n\t\talert(\"window.onload出来了\");\n\t}; */\n\t\n\t//1、导入jquery的.js文件\n\t//2、可以在导入文件后的任意位置\n\t//   1）、可以写在head里面，如果写在head里面可能导致元素查找不到等问题\n\t//\t\t\t1-1、只需要把代码写在$(function(){ jquery代码  })\n\t//   2）、可以写在head之后的任意位置，我们一般不采用这种写法。\n\t//\t 3）、综合以上考虑，1-1\n\t//3、window.onload & $(function(){})\n\t//window.onload只可以使用一次\n\t//$(function(){})可以使用多次\n</script>\n</head>\n<body>\n\t<button>我是按钮</button>\n\t\n\t<!-- <iframe src=\"http://www.baidu.com\"></iframe> -->\n\t\n</body>\n</html>\n```\n\n**jQuery中其他的事件处理方法：**\n\nclick() \t\t\t\t\t\t\t\t\t\t它可以绑定单击事件，以及触发单击事件 \n\nmouseover() \t\t\t\t\t\t\t鼠标移入事件 \n\nmouseout() \t\t\t\t\t\t\t\t鼠标移出事件 \n\nbind() \t\t\t\t\t\t\t\t\t\t可以给元素一次性绑定一个或多个事件。 \n\none() \t\t\t\t\t\t\t\t\t\t\t使用上跟 bind 一样。但是 one 方法绑定的事件只会响应一次。 \n\nunbind() \t\t\t\t\t\t\t\t\t跟 bind 方法相反的操作，解除事件的绑定 \n\nlive() \t\t\t\t\t\t\t\t\t\t\t也是用来绑定事件。它可以用来绑定选择器匹配的所有元素的事件。哪怕这个元素是后面动态创建出 来的也有效 \n\n**事件的绑定：bind**\n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    <title>Untitled Document</title>\n    <link href=\"css/style.css\" type=\"text/css\" rel=\"stylesheet\"/>\n    <script type=\"text/javascript\" src=\"../../script/jquery-1.7.2.js\"></script>\n    <script type=\"text/javascript\">\n\n        $(function () {\n            //*1.通常绑定事件的方式\n            //给元素绑定事件  \n            //jquery对象.事件方法(回调函数(){ 触发事件执行的代码 }).事件方法(回调函数(){ 触发事件执行的代码 }).事件方法(回调函数(){ 触发事件执行的代码 })\n            //绑定事件可以链式操作\n            $(\".head\").click(function () {\n                $(\".content\").toggle();\n            }).mouseover(function () {\n                $(\".content\").toggle();\n            });\n\n            //*2.jQuery提供的绑定方式：bind(type,[data],fn)函数把元素和事件绑定起来\n            //type表示要绑定的事件   [data]表示传入的数据   fn表示事件的处理方法\n            //bind(事件字符串,回调函数),后来添加的元素不会绑定事件\n            //使用bind()绑定多个事件   type可以接受多个事件类型，使用空格分割多个事件\n            /* $(\".head\").bind(\"click mouseover\",function(){\n                $(\".content\").toggle();\n            }); */\n\n\n            //3.one()只绑定一次,绑定的事件只会发生一次one(type,[data],fn)函数把元素和事件绑定起来\n            //type表示要绑定的事件   [data]表示传入的数据   fn表示事件的处理方法\n            /* \t$(\".head\").one(\"click mouseover\",function(){\n                    $(\".content\").toggle();\n                }); */\n\n            //4.live方法会为现在及以后添加的元素都绑定上相应的事件\n            /**    $(\".head\").live(\"click\",function(){\n\t\t\t\t\t$(\".content\").toggle();\n\t\t\t\t});\n\n             $(\"#panel\").before(\"<h5 class='head'>什么是jQuery?</h5>\");\n             */\n        });\n\n    </script>\n</head>\n<body>\n<div id=\"panel\">\n    <h5 class=\"head\">什么是jQuery?</h5>\n    <div class=\"content\">\n        jQuery是继Prototype之后又一个优秀的JavaScript库，它是一个由 John Resig\n        创建于2006年1月的开源项目。jQuery凭借简洁的语法和跨平台的兼容性，极大地简化了JavaScript开发人员遍历HTML文档、操作DOM、处理事件、执行动画和开发Ajax。它独特而又优雅的代码风格改变了JavaScript程序员的设计思路和编写程序的方式。\n    </div>\n</div>\n</body>\n\n</html>\n\n```\n\n**事件移除：unbind**\n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    <title>Untitled Document</title>\n    <link href=\"css/style.css\" type=\"text/css\" rel=\"stylesheet\"/>\n    <script type=\"text/javascript\" src=\"../../script/jquery-1.7.2.js\"></script>\n    <script type=\"text/javascript\">\n\n        $(function () {\n            //*1.通常绑定事件的方式\n            //给元素绑定事件  \n            //jquery对象.事件方法(回调函数(){ 触发事件执行的代码 }).事件方法(回调函数(){ 触发事件执行的代码 }).事件方法(回调函数(){ 触发事件执行的代码 })\n            //绑定事件可以链式操作\n            $(\".head\").click(function () {\n                $(\".content\").toggle();\n            }).mouseover(function () {\n                $(\".content\").toggle();\n            });\n\n            //*2.jQuery提供的绑定方式：bind(type,[data],fn)函数把元素和事件绑定起来\n            //type表示要绑定的事件   [data]表示传入的数据   fn表示事件的处理方法\n            //bind(事件字符串,回调函数),后来添加的元素不会绑定事件\n            //使用bind()绑定多个事件   type可以接受多个事件类型，使用空格分割多个事件\n            /* $(\".head\").bind(\"click mouseover\",function(){\n                $(\".content\").toggle();\n            }); */\n\n\n            //3.one()只绑定一次,绑定的事件只会发生一次one(type,[data],fn)函数把元素和事件绑定起来\n            //type表示要绑定的事件   [data]表示传入的数据   fn表示事件的处理方法\n            /* \t$(\".head\").one(\"click mouseover\",function(){\n                    $(\".content\").toggle();\n                }); */\n\n            //4.live方法会为现在及以后添加的元素都绑定上相应的事件\n            /**    $(\".head\").live(\"click\",function(){\n\t\t\t\t\t$(\".content\").toggle();\n\t\t\t\t});\n\n             $(\"#panel\").before(\"<h5 class='head'>什么是jQuery?</h5>\");\n             */\n        });\n\n    </script>\n</head>\n<body>\n<div id=\"panel\">\n    <h5 class=\"head\">什么是jQuery?</h5>\n    <div class=\"content\">\n        jQuery是继Prototype之后又一个优秀的JavaScript库，它是一个由 John Resig\n        创建于2006年1月的开源项目。jQuery凭借简洁的语法和跨平台的兼容性，极大地简化了JavaScript开发人员遍历HTML文档、操作DOM、处理事件、执行动画和开发Ajax。它独特而又优雅的代码风格改变了JavaScript程序员的设计思路和编写程序的方式。\n    </div>\n</div>\n</body>\n\n</html>\n\n```\n\n\n\n事件对象：\n\n\n\n**事件的冒泡** \n\n什么是事件的冒泡？ \n\n​\t\t事件的冒泡是指，父子元素同时监听同一个事件。当触发子元素的事件的时候，同一个事件也被传递到了父元素的事件里去 响应。 \n\n那么如何阻止事件冒泡呢？ \n\n​\t\t在子元素事件函数体内，return false; 可以阻止事件的冒泡传递\n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    <title>Untitled Document</title>\n    <style type=\"text/css\">\n        * {\n            margin: 0;\n            padding: 0;\n        }\n\n        body {\n            font-size: 13px;\n            line-height: 130%;\n            padding: 60px;\n        }\n\n        #content {\n            width: 220px;\n            border: 1px solid #0050D0;\n            background: #96E555;\n        }\n\n        span {\n            width: 200px;\n            margin: 10px;\n            background: #666666;\n            cursor: pointer;\n            color: white;\n            display: block;\n        }\n\n        p {\n            width: 200px;\n            background: #888;\n            color: white;\n            height: 16px;\n        }\n    </style>\n    <script type=\"text/javascript\" src=\"jquery-1.7.2.js\"></script>\n    <script type=\"text/javascript\">\n        $(function () {\n\n            //冒泡就是事件的向上传导，子元素的事件被触发，父元素的响应事件也会触发\n            //解决冒泡问题：return false;\n\n            //给span绑定一个单击响应函数\n            $(\"span\").click(function () {\n                alert(\"我是span的单击响应函数\");\n                return false;\n            });\n\n            //给id为content的div绑定一个单击响应函数\n            $(\"#content\").click(function () {\n                alert(\"我是div的单击响应函数\");\n                return false;\n            });\n\n            //给body绑定一个单击响应函数\n            $(\"body\").click(function () {\n                //alert(\"我是body的单击响应函数\");\n            });\n\n            //取消默认行为\n            /* $(\"a\").click(function(){\n                return false;\n            }) */\n\n        })\n    </script>\n</head>\n<body>\n<div id=\"content\">\n    外层div元素\n    <span>内层span元素</span>\n    外层div元素\n</div>\n\n<div id=\"msg\"></div>\n\n<br><br>\n<a href=\"http://www.hao123.com\" onclick=\"return false;\">WWW.HAO123.COM</a>\n</body>\n</html>\n```\n\n**javaScript事件对象 **\n\n​\t事件对象，是封装有触发的事件信息的一个 javascript 对象。 \n\n​\t我们重点关心的是怎么拿到这个 javascript 的事件对象。以及使用。 \n\n如何获取呢 javascript 事件对象呢？ \n\n​\t在给元素绑定事件的时候，在事件的 function( event ) 参数列表中添加一个参数，这个参数名，我们习惯取名为 event。 \n\n​\t这个 event 就是 javascript 传递参事件处理函数的事件对象。\n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>Insert title here</title>\n<style type=\"text/css\">\n\n\t#areaDiv {\n\t\tborder: 1px solid black;\n\t\twidth: 300px;\n\t\theight: 50px;\n\t\tmargin-bottom: 10px;\n\t}\n\t\n\t#showMsg {\n\t\tborder: 1px solid black;\n\t\twidth: 300px;\n\t\theight: 20px;\n\t}\n\n</style>\n<script type=\"text/javascript\" src=\"jquery-1.7.2.js\"></script>\n<script type=\"text/javascript\">\n\t//当我们发生一个事件以后，某个事件其实就是一个对象。事件对象\n\t//使用jquery获取事件对象，在回调函数中传入event参数，event是jquery定义好的一个变量\n\t$(function(){\n\t\t$(\"#areaDiv\").mousemove(function(event){\n\t\t\t$(\"#showMsg2\").text(\"x=\"+event.screenX+\" y=\"+event.screenY)\t\n\t\t})\n\t})\n\n\twindow.onload = function(){\n\t\t//使用js获取事件对象\n\t\tvar areaDiv = document.getElementById(\"areaDiv\");\n\t\tvar showMsg = document.getElementById(\"showMsg\");\n\t\t//同样是将event传入回调函数\n\t\tareaDiv.onmousemove = function(event){\n\t\t\tvar x = event.pageX;//当前页面的坐标\n\t\t\tvar y = event.pageY;//Y\n\t\t\tshowMsg.innerHTML = \"x=\"+x+\" y=\"+y;\n\t\t};\n\t}\n\t\n\t\n\n \t/* window.onload = function(){\n\t\tvar areaDiv = document.getElementById(\"areaDiv\");\n\t\tvar showMsg = document.getElementById(\"showMsg\");\n\t\tareaDiv.onmousemove = function(event){\n\t\t\tvar x = event.pageX;\n\t\t\tvar y = event.pageY;\n\t\t\tshowMsg.innerHTML = \"x=\"+x+\" y=\"+y;\n\t\t};\n\t}\n\t\n\t$(function(){\n\t\t$(\"#areaDiv\").mousemove(function(event){\n\t\t\t$(\"#showMsg2\").text(\"x=\"+event.screenX+\" y=\"+event.screenY)\t\t\n\t\t})\n\t})  */\n</script>\n</head>\n<body>\n\n\t<div id=\"areaDiv\"></div>\n\t<div id=\"showMsg\"></div>\n\t<div id=\"showMsg2\"></div>\n\n</body>\n</html>\n```\n\n# 练习\n\n事件图片跟随：\n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>Insert title here</title>\n<style type=\"text/css\">\n\tbody {\n\t\ttext-align: center;\n\t}\n\t#small {\n\t\tmargin-top: 150px;\n\t}\n\t#showBig {\n\t\tposition: absolute;\n\t\tdisplay: none;\n\t}\n</style>\n<script type=\"text/javascript\" src=\"script/jquery-1.7.2.js\"></script>\n<script type=\"text/javascript\">\n\t$(function(){\n\t\t$(\"#small\")\n\t\t\t.mouseover(function(event){\n\t\t\t\t$(\"#showBig\")\n\t\t\t\t\t.show()\n\t\t\t\t\t.css(\"left\",event.pageX+10)\n\t\t\t\t\t.css(\"top\",event.pageY+10);\n\t\t\t})\n\t\t\t.mousemove(function(event){\n\t\t\t\t$(\"#showBig\")\n\t\t\t\t\t.css(\"left\",event.pageX+10)\n\t\t\t\t\t.css(\"top\",event.pageY+10);\n\t\t\t})\n\t\t\t.mouseout(function(){\n\t\t\t\t$(\"#showBig\").hide();\n\t\t\t});\n\t});\n</script>\n</head>\n<body>\n\n\t<img id=\"small\" src=\"img/small.jpg\" />\n\t\n\t<div id=\"showBig\">\n\t\t<img src=\"img/big.jpg\">\n\t</div>\n\n</body>\n</html>\n```\n\n\n\n","categories":["Java学习","前端"]},{"title":"Jsp学习","url":"/2021/02/22/尚硅谷说Java/前端/JSP/","content":"Jsp学习\n<!--more-->\n# 第一章 JSP基础\n\n## 1.1 什么是JSP\n\n* JSP,即Java Server Pages, Java服务器页面,即运行在服务器端的页面。它是由Sun公司倡导，许多国际性大公司参与, -起建立的一种动态网页技术。JSP技术是在传统的静态网页HTML文件中插入Java代码片断和JSP标签后形成的一种文件，其后缀名为.jsp。使用JSP开发的Web应用是跨平台的，既能在Linux上运行，也能在其他操作系統上运行。\n\n* 特别注意的是，JSP文件的本质是Servlet。只不过，JSP 与servlet不同的是，JSP是专门用于进行数据展示的Servlet,其有特殊的写法。而普通的Servlet是用于完成业务逻辑处理的。由于servlet是运行在单例多线程环境下的,所以JSP同样也是运行在单例多线程环境下的。\n\n* 例如index.jsp被翻译后变成index_jsp.java\n\n  ```java\n  public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase\n      implements org.apache.jasper.runtime.JspSourceDependent,\n                   org.apache.jasper.runtime.JspSourceImports {\n                   }\n  ```\n\n## 1.2 JSP规范\n\n* 将JSP页面翻译为servlet 的过程，是由Tomcat完成。在Tomcat中内置了一个JSP翻译引擎，当第一次访问该JSP页面时，翻译引擎会将JISP 页面翻译为Servlet 的java文件，再将其编译为.class文件进行运行。\n* SUN公司制定的JavaEE规范中包含两个很重要的子规范: Servlet 规范，及JSP规范。其中JSP规范中就包含了如何将JSP页面翻译为Senvlet。例如,JSP页面中的HTML CSS JavaScript,及普通文本部分，均会被翻译到out. writer ()中。\n* Tomcat中的JSP翻译引擎，就遵循了这个JSP规范。\n\n## 1.3 JSP注释\n\n* 在JSP页面中使用注释，可以将要注释的内容使用<%-  -%>括起来。 \n* 当然，在JSP页面中也可以使用HTML的注释<!-  ->。 但它们的使用效果是 不同的。\n  * (1) HTML注释会被JSP翻译引擎翻译到Servlet 的out.write()中; 而JSP注释则会被JSP翻译引擎忽略，在Servlet中是看不到的。\n  * (2) 在客户端浏览器查看源码时, HTML注释是可以查看到的;但JISP 注释在客户端是查看不到的。\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%@ page isELIgnored=\"false\" %>\n<html>\n<head>\n  <title>Title</title>\n</head>\n<body>\n  <%--这是JSP注释--%>\n  <!--这是HTML注释。不推荐在JSP文件中添加此注释-->\n</body>\n</html>\n```\n\n## 1.4 JSP的Java代码块\n\n* JSP的Java代码块也称为JSP小脚本，是以<% %>括起来的部分， 其中可以编写Java代码。编写在Java代码块中的代码，会被JSP翻译引擎将其置入到Serlet的_jspservice()方法中作为方法中的Java语句出现。所以，其中存放的必须是以分号结尾的Java语句。\n\n  ```jsp\n  <% JSP的Java代码块 %>   ==> Serlet的_jspservice()方法中\n  ```\n\n* 需要注意的是，JSP代码块可以放置在JSP页面的任意位置，可以放置任意数量。但它们都会被按照顺序放置到Servlet 的_jspservicel()方法中 。也就是说,其执行顺序是与其在JSP页面中的出现顺序是一致的。\n\n* 由于JSP小脚本是被翻译到了Servlet 的_jspserice()方法中,所以JSP小脚本中是不能出现如下内容的: \n\n  * (1)声明的变量是不能添加权限访问控制符的。\n  * (2)不能定义方法。\n  * (3)不能定义静态语句块。\n\n1.5 JSP的声明语句块\n\n* 在JSP页面中使用<%!  %>括起来的部分 ,称为声明语句块。声明语句块中的内容,将被JSP引擎翻译到Servlet 的类体中，没有包含到哪个方法体中。\n\n  ```jsp\n  <%! JSP的声明语句块  %>  ==> Servlet的类体中\n  ```\n\n* 这样的话，在JSP的声明语句块中就可声明实例变量、实例方法、静态方法、静态代码块等内容。并且，这些内容均可被JISP 的Java代码块中代码访问。因为它们原本就是一个Servlet类中的代码。\n\n* 不过，还是不建议在JSP的声明语句块中声明实例变量。因为JSP是运行在单例多线程环境下的，实例变量将会引起线程安全问题。\n\n* 需要注意的是，在JSP的声明语句块中，是不能编写普通的Java语句的。否则的话，这些语句将会直接出现在Servlet的类体虫。\n\n* 声明语句块也可以定义在JSP页面的任意位置，且可以定义任意多个。\n\n## 1.6 JSP的表达式块\n\n* 在JSP页面中使用<%= %>括起来的部分,称为表达式块。其可在JSP页面中输出变量、常量,及它们组成的各种表达式的值。注意，是表达式，而不是语句，是没有分号的。该表达式将被JSP引擎翻译到_ jspservice()方法的 out.writel()方法中输出。例如\n\n  ```jsp\n  <%=name %>   ==>Servlet中的_jspservice()方法中的out.print(name);\n  ```\n\n# 第二章 JSP核心\n\n## 2.1 内置对象\n\n* 在JSP的Java代码块、表达式块等中可以直接使用的引用，称为JSP的内置对象肛常用的内置对象有九个，分别是:\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210215184106.png)\n\n* 这九个对象在JSP的Java代码块、表达式块中可以直接使用。只所以可以直接使用，是因为Java代码块与表达式块被JSP引擎翻译后均出现在了Servlet 的_ jspService()方法中。 而这九个对象，就是_ jspService()方法中的局部变量。在JSP的Java代码块、表达式块中的代码就是_ jspservice()方法中的代码， 所以在其中可以直接使用。\n\n  ```java\n  //JSP的Servlet部分源码\n  final javax.servlet.jsp.PageContext pageContext;\n  javax.servlet.http.HttpSession session = null;\n  final javax.servlet.ServletContext application;\n  final javax.servlet.ServletConfig config;\n  javax.servlet.jsp.JspWriter out = null;\n  final java.lang.Object page = this;\n  ```\n\n**pageContext**\n\n* pageContext,页面上下文，其具有一个只在当前页面范围的戴属性空间,即其具有settribute()方法与gettribute()方法。 但，由于在当前页面范围,数据不在放到域属性空间也可直接使用，将数据存放到域属性空间反而感觉“多此一举”， 所以这些方法并不常用。\n* 不过，在同一页面中，为了使用EL表达式(后面学习)来访问某变量的值，此时一般使用pageContext。\n* pageContext具有一些get方法,可以获取到Request、Response .Session、ServletContext、ServletConfig、page (即当前Servlet)、 exception、 out 等另外八个内置对象。\n\n**out**\n\n* out,类型为javax.servlet.jspJspWriter.查看JavaEE 文档，发现JspWriter 类继承自10流的Writer类。即out就是一一个输出流对象。\n\n**page**\n\n* 查看JSP翻译为的Servlet,可以看到page对象即Servlet 对象本身。这个对象在实际应用中并不常用。\n\n  ```java\n  final java.lang.Object page = this;\n  ```\n\n**application**\n\n* application,即ServletContext。所以ServletContext所具有的方法，applcation都具有。\n\n**exception**\n\n* 在普通的JSP页面中是不能使用exception内置对象的。因为打开JSP翻译为的Servlet,发现其中并没有exception对象。若要在页面中直接使用exception 对象，则需要配合着page指令使用。page 指令后面讲解。\n\n**其他对象**\n\n* 其它对象，还有request. response. session, 及config。它们的用法与之前Servlet 学习时的用法相同。只不过是直接使用在了JSP 页面中了。\n\n## 2.2 JSP指令\n\n* JSP指令的作用是为当前页面做-些基本 的属性设置,为当前的页面的运行提供基本的环境。\n\n* 根据功能的不同，JSP中包含三类指令: \n\n  * page指令，即页面指令; \n  * include 指令，即包含指令;\n  * 及taglib指令,即标签库指令。\n\n* 无论哪种指令,其使用的语法格式均为如下形式:\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210215185540.png)\n\n### 2.2.1 page指令\n\n* page指令用于设置当前JISP页面的相关信息。一个JSP文件中可以包含多个page指令。\n* 常用的page指令的属性意义及用法如下: \n  * language属性可有可无，且language属性只能设置为java\n\n**pageEncoding属性**\n\n* pageEncoding属性用于设置当前JSP页面所使用的字符编码格式。即,用户在浏览器中\n  通过右击查看编码所看到的编码格式。\n\n  ```jsp\n  <%@ page  pageEncoding=\"UTF-8\" %>\n  ```\n\n* 其被JISP翻译引擎翻译到servlet 中的语句，是_jspService()方注中的setContentType()。\n\n  ```java\n  response.setContentType(\"text/html;charset=UTF-8\");\n  ```\n\n**contentType属性**\n\n* contentType属性也是用于设置当前JSP页面所使用的字符编码格式。\n* 与pageEncoding属性属性不同的是：\n  * pageEncoding属性默认设置为text/html格式。\n  * 而contentType属性还可以将其设置为其他格式。例如text/xml\n\n**import属性**\n\n* import属性用于完成在JSP页面中导入指定的类。其被JSP引擎翻译为Servlet 中的import语句。例如\n\n  ```jsp\n  <%@ page import=\"java.util.Date\" %>\n  ```\n\n* 其被JISP翻译引擎翻译到servlet 中的语句为\n\n  ```java\n  import java.util.Date;\n  ```\n\n* 若要导入多个包，则需要以逗号隔开多个包。\n\n  ```jsp\n  <%@ page import=\"java.util.Date,java.text.*\" %>\n  ```\n\n**errorPage属性**\n\n* errorPage属性用于指定当前页面发生错误，异常时跳转到哪个页面。\n\n  ```jsp\n  <%@ page errorPage=\"/error.jsp\" %>\n  ```\n\n* 其被JISP翻译引擎翻译到servlet 中的语句为：\n\n  ```java\n  pageContext = _jspxFactory.getPageContext(this, request, response,\"/error.jsp\", true, 8192, true);\n  ```\n\n**isErrorPage属性**\n\n* isErrorPage属性用于指定此页面是错误页面。属性值默认为false.\n\n  ```jsp\n  <%@ page isErrorPage=\"true\" %>\n  ```\n\n* 当页面设置为此属性为true时，其其被JISP翻译引擎翻译的servlet 中就会出现如下代码。\n\n  ```java\n  java.lang.Throwable exception = org.apache.jasper.runtime.JspRuntimeLibrary.getThrowable(request);\n  if (exception != null) {\n    response.setStatus(javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n  }\n  ```\n\n* 此时就可以使用exception对象来获取错误信息。\n\n  ```jsp\n  ex = <%=exception.getMessage()%>\n  ```\n\n**session属性**\n\n* session属性用于指定JSP页面是否使用session。默认为true。\n\n  ```jsp\n  <%@ page session=\"true\" %>\n  ```\n\n  * 当session属性为true时，jsp自带新建的Session对象。此时只能往里面存放数据。\n  * 当session属性为false时，jsp中不含有session对象。此时需要自己获取session。然后获取session中的数据。如下：\n\n  ```jsp\n  <%\n    //使用request的getSession()的原则\n    //若向Session域中存放数据，则使用getSession(true),即getSession()\n    //若向Session域中读取数据，则使用getSession(false)\n    HttpSession session = request.getSession(false);\n    if (session != null){\n      Object name = session.getAttribute(\"name\");\n      out.print(name);\n    }\n  %>\n  ```\n\n* session属性默认为true，此时使用的是getSession(true)获取的session对象。\n\n### 2.2.2 include指令\n\n* include指令,即包含指令，用于将指定的文件包含到当前的JSP文件中。该指令只有一个属性file,用于指定要包含的文件。\n\n  ```jsp\n  <%@include file=\"next.jsp\" %>\n  ```\n\n* 特点：\n\n  * 被包含的页面会依附在父页面中，父页面和被包含的页面只会翻译成一个Servlet。\n  * 因此被包含的页面和父页面的数据是相通的。\n\n* include指令相当于html中的ifarme标签。\n\n## 2.3 JSP动作\n\n* 在JSP页面中大量使用Java代码块表达式块等内容,会使JSP页面看起来“杂乱无章”。为了使JSP页面看得简洁明了,为了简化Java代码, -般情况下，我们会尽量少的使用Java代码块与表达式块。取而代之的则是使用EL表达式、JSTL 标签,及JSP动作。\n* JSP动作是指，使用系统定义好的标签来完成本应由Java代码来完成的功能。\n* JSP动作的语法格式为:\n\n```html\n<jsp:动作名称 属性名=属性值 属性名=属性值 ...></jsp:动作名称>\n//或\n<jsp:动作名称 属性名=属性值 属性名=属性值 .../>\n```\n\n* JSP动作很多,但在实际开发时常用的就两个:转发动作与包含动作。\n* 这两份个动作的完成，底层使用的是RequestDispatcher的forward(|与include()方法实现的。而这两份种请求转发方式的本质区别是，标准输出流的开启时间不同。forward()方式的标准输出流是在目标资源中开启的标准输出流,而include()方式的标准输出流则是在当前发出包含运作的页面中开启的。所以，forward(动作的发起页面中是无法向标准输出流中写入数据的;而include()动作的发起页面及目标页面中均可向标准输出流中写入数据。\n* 这两份个动作都具有一个page属性，用于指定要转向的页面。\n\n### 2.3.1 forward动作\n\n* 页面中一旦具有了forward 动作，那么当前页面中的所有要显示的内容都将无法显示。因为页面直接转发到了下一个页面。\n\n  ```jsp\n  <jsp:forward page=\"next.jsp\"></jsp:forward>\n  <%--\n  等价于Java代码\n  if (true) {\n  \t_jspx_page_context.forward(\"next.jsp\");\n  \treturn;\n  }\n  --%>\n  ```\n\n* 特点：\n\n  * 与servlet的请求转发的forward相似，当前的页面的数据无法显示在，只有请求的页面的数据才能显示。\n  * 当前页面和请求的页面都会被编译成Servlet。\n\n### 2.3.2 include动作\n\n* include动作用于完成将指定页面包含到当前页面中的功能。\n\n  ```jsp\n  <jsp:include page=\"next.jsp\"></jsp:include>\n  <%-- \n   等价于Java代码\n  org.apache.jasper.runtime.JspRuntimeLibrary.include(request, response, \"next.jsp\", out, false);  \n    --%>\n  ```\n\n* 特点：\n\n  * 与servlet的请求转发的include相似，当前的页面和请求的页面的数据都能显示，且按照代码的顺序显示。\n  * 当前页面和请求的页面都会被编译成Servlet。\n\n**动态联编**\n\n* 由于当前页面和请求的页面都会被编译成Servlet，也就是说会有两个Servlet存在。包含动作的包含，是在运行期完成的，而非在编译期。这个包含动作,是在程序运行过程中，由当前页面的.java文件中的_ jspService()方法通过JspRuntimeLibrary类的include()方法调用了请求页面的.java文件中的jspService()方法 。在运行期所执行的这种包含,称.为动态联编。\n* include指令的执行方式被称为静态联编。\n* 在静态联编与动态联编均可使用时，一般使用静态联编。因为在程序运行时只存在一个Servlet，对资源的消耗较少，且不存在调用问题，执行效率较高。\n  * 若在两个文件间需要共享同一变量，此时只能使用静态联编。\n  * 若在两个文件间存在同名变量，且不能混淆，此时只能使用动态联编。\n\n## 2.4 EL表达式\n\n* EL, Expression Language,表达式语言,是一种在JSP页面中获取数据的简单方式。EL表达式是从JSP2.0版本开始才引入的概念。\n* EL表达式的基本语法形式很简单:在JSP页面的任何<font color=\"red\">静态部分</font>均可通过S{expression}的形式获取到指定表达式的值。\n\n### 2.4.1 获取数据\n\n**1.从四大域中依次查找数据**\n\n* EL只能从pageConext、request, session、 application 四大域属性空间中获取数据。\n\n  * 且查找的顺序是pageConext、request, session、 application 。\n\n  ```jsp\n  <%--EL只能从四大域中获取数据。\n  其查找数据的顺序是：依次按照由小到大的顺序从四大域中查找指定名称的属性值--%>\n  <%\n  pageContext.setAttribute(\"name\", \"lisi\");\n  request.setAttribute(\"name\", \"zhangsan\");\n  session.setAttribute(\"name\", \"wangwu\");\n  application.setAttribute(\"name\", \"songliu\");\n  %>\n  \n  name = ${name}\n  ```\n\n**2.从指定域中获取数据**\n\n* 从pageContext依次查找到application 域空间，会降低执行效率。若某属性确定存放在某个域属性空间，则可指定直接从该空间中查找。此时需要借助EL的四个域属性空间相关的内置对象。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210217210925.png)\n\n  ```jsp\n  <%--通过EL的内置对象，可以指定查找数据的范围是在哪个域中--%>\n  name = ${applicationScope.name}\n  ```\n\n**3.访问Bean/对象的属性**\n\n* EL可以通过$key,属性} 的方式获取到指定对象的指定属性值。其底层实际调用的是该对象的相应属性的get方法。\n* 当然，也可以使用$key[属性]或${key[\"属性\"]的方式获取。该方式不常用。\n* 若要访问一个对象的域属性的值,则可多次使用点号运算符,依次取出相应的属性值。\n\n```jsp\n<%\n  School school = new School(\"清华大学\",\"北京\");\n  Student student = new Student(\"lisi\", 18, school);\n  pageContext.setAttribute(\"student\", student);\n%>\nstudent = ${student}<br>\n<%--  获取对象的属性值，普遍使用.获取。\n      属性的名称是指：对象的getXxx()方法中去掉get，且第一个子母小写的字母。有时可能和对象的属性不同。--%>\nname = ${student.name}<br>\nage = ${student.age}<br>\n<%--  另一种获取方法--%>\nname = ${student['name']}<br>\nage = ${student['age']}<br>\n\nsname = ${student.school.sname}<br>\naddress = ${student.school.address}<br>\n<%--当student2为null时，EL时不会抛出空指针异常的，仅仅是不会显示而已--%>\nstudent = ${student2.name}<br>\n```\n\n**4.获取数组中的元素**\n\n* EL可以通过${key[索引]} 的方式获取到指定索引的元素。不过，需要注意的是，若数组中不存在该指定索引的元素，系统并不会抛出数组越界异常。\n\n```jsp\n<% String[] names = {\"张三\",\"李四\"};\npageContext.setAttribute(\"names\", names);%>\nnames[0] = ${names[0]}<br>\nnames[1] = ${names[1]}<br>\n<%--  若访问的数组下标超过数组下标上限，EL不会抛出异常--%>\nnames[2] = ${names[2]}<br>\n\n<%\n  School[] schools = new School[3];\n  schools[0] = new School(\"清华\",\"北京\");\n  schools[1] = new School(\"北京\",\"北京\");\n  schools[2] = new School(\"北师大\",\"北京\");\n  pageContext.setAttribute(\"schools\", schools);\n%>\nschools = ${pageScope.schools}\n```\n\n**5.获取list中的元素**\n\n* 与获取数组中的元素相同，通过${key[索引]}的方式可以获取List 中指定索引的元素。若List中不存在该指定索引的元素，系统并不会抛出越界异常。\n\n```jsp\n<%\n  //EL表达式能够通过索引访问list，但无法访问set。\n  //因为set中没有索引的概念\n  List<String> names = new ArrayList<>();\n  names.add(\"李四\");\n  names.add(\"王五\");\n  names.add(\"张三\");\n  pageContext.setAttribute(\"names\", names);\n%>\nnames0 = ${pageScope.names[0]}<br>\nnames1 = ${pageScope.names[1]}<br>\nnames2 = ${pageScope.names[2]}<br>\nnames3 = ${pageScope.names[3]}<br>\n```\n\n**6.获取Map中的元素**\n\n* 通过${key.key1}的方式可以获取List 中指定key1的value元素。\n\n```jsp\n<%\n//map中的value是object类型，但在访问map.school.sname时会将object强转为school类型\nMap<String ,Object> map = new HashMap<>();\nmap.put(\"school\", new School(\"清华大学\",\"北京\"));\nmap.put(\"mobile\", \"2312312\");\nmap.put(\"age\", 18);\npageContext.setAttribute(\"map\", map);\n%>\nschool.name = ${map.school.sname}<br>\nmobile = ${map.mobile}<br>\nage = ${map.age}<br>\n```\n\n### 2.4.2 运算符\n\n* EL表达式可以进行各种运算，其中常用的运算符有: \n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210220104735.png)\n\n* 除了上述运算符外，还有一个非常有用的运算符empty, 其用法为${empty 变量}，结果为布尔值。\n\n  * 若变量未定义，则返回值为true。\n  * 若变量为 String 类型，且其值为空串，则返回值为true。\n  * 若变量为引用类型，且其值为null,则返回值为true。 \n  * 若变量为集合类型，且其不包含任何元素，则返回值为true。 \n\n```jsp\n<%\nString username = null;\nString name = \"\";\nList<Student> students = new ArrayList<>();\npageContext.setAttribute(\"username\",username);\npageContext.setAttribute(\"name\",name);\npageContext.setAttribute(\"students\",students);\n%>\n<%--  显示皆为true--%>\nempty s = ${ empty s};<br>\nempty username = ${ empty pageScope.username};<br>\nempty name = ${ empty pageScope.name};<br>\nempty students = ${empty pageScope.students};<br>\n```\n\n### 2.4.3 EL内置对象\n\n* 就像JSP的Java代码块及表达式块中可以使用九个内置对象一样，EL 表达式中，同样也存在有内置对象，并且存在11个内置对象。常用的内置对象，除了前面使用过的四个域属性空间相关的内置对象外，还有如下几个。\n\n**1.pageContext**\n\n* 该pageContext与JISP内置对象中的pageContext 是同一个对象。通过该对象，可以获取到request、 response< session、senvletContext、 servletConfig 等对象。注意，这些对象在EL中不是内置对象。这些对象只能通过pageContext 获取。\n\n* 在EL中直接SlpageContext.request即可获职request对象。当然，其底层实际调用的是pageContext.getRequest)方法。同理，也可以通过类似方式获取到其它对象。\n\n* 在这些获职的对象中，有一个是实际工程中最常用的:\n\n  * ${pageContext.request.contextPath} ,用于获取当前项目的发布到服务器的名称。一般会用在JSP页面的路径前。\n\n  ```jsp\n  <form action=\"${pageContext.request.contextPath}/loginServlet\" method=\"post\">\n  ```\n\n* 在EL的11个内置对象中，除了pageContext 外，其它10个内置对象,其类型均为java.util.Map类型。\n\n**2.param**\n\n* 获取请求中指定参数的值。相当于request.getParameter(string)；\n* 例如：${param.name}。获取登陆表单中的name的值\n\n**3.paramValues**\n\n* 获取请求中指定参数的所有值。相当于request.getParameterNames();\n* 例如：${paramValues.hobby}。获取hobby的所有值\n\n**4.initParam**\n\n* 获取项目的初始化参数值。相当于ServletContext.getInitParameter(string);\n* 初始化参数值是设置在wen.xml中的。例如${initParam.name}\n\n### 2.4.4 自定义EL函数\n\n* 当EL的功能不能满足我们的需要时，我们可以自定义一些功能让他在JSP页面中生效。\n\n* 第一步：自定义函数类\n\n  ```java\n  //自定义函数：使用在jsp页面中\n  public class ELFunctions {\n    //函数功能：将字符串小写变大写\n    public static String lowerToUpper(String source){\n      return source.toUpperCase();\n    }\n  }\n  ```\n  \n* 第二步：在tld文件中注册\n\n  * 自定义的类和函数，需要在一个扩展名为.tld的XML文件中进行注册\n    * tld tag library definition:标签库定义\n  * XML文件是需要约束的，即需要配置文件头部。这个头部约束可以从下面文件中复制：\n    * 在Tomcat安装目录下：\\webapps\\examples\\WEB-INF\\jsp2\\jsp2-example-taglib.tld\n  * 注册文件的位置需要定义在当前web项目的WEB-INF下，与web.xml同级\n\n  ```tld\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\"\n          version=\"2.0\">\n    <!--以下标签作用为：定义标签库信息  -->\n    <description>这是一个自定义标签库测试</description>\n    <tlib-version>1.0</tlib-version>\n    <!-- short-name：表示标签库的名称，\n    一般一个tld文件一个标签库\n    一个标签库一个short-name. -->\n    <short-name>myFt</short-name>\n    <!--uri：自定义，随便写 -->\n    <uri>http://www.lc.com/jsp/el/functions</uri>\n  \n  <!--以下标签用于注册函数  -->\n    <function>\n      <description>此函数用于转换字符大小写</description>\n      <name>myLowerToUpper</name>\n      <!--函数类所在的位置    -->\n      <function-class>com.lc.jsp.ELFunctions</function-class>\n      <!--函数的方法的签名：包含返回值，方法名，方法参数类型    -->\n      <function-signature>java.lang.String lowerToUpper( java.lang.String )</function-signature>\n    </function>\n  \n  </taglib>\n  ```\n\n* 第三步：在jsp页面中引用并使用\n\n  ```jsp\n  <%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n  <%@ page isELIgnored=\"false\" %>\n  <%--引入自定义标签库。uri为标签库的uri。prefix为标签库的short-name --%>\n  <%@ taglib uri =\"http://www.lc.com/jsp/el/functions\" prefix=\"myFt\"%>\n  <html>\n  <head>\n    <title>Title</title>\n  </head>\n  <body>\n    <%--使用自定义的标签库--%>\n    ${myFt:myLowerToUpper(\"abcdef\")}\n  </body>\n  </html>\n  ```\n\n\n### 2.4.5 JSTL中的EL函数\n\n* Apache已经定义好了-套标准的标签库规范， 称为JSTL, JSP Standard Tag Library,即JSP标准标签库。该规范已通过JCP审核认定。\n\n* 在JSTL中,已经定义好了一套对于字符串进行处理的函数标签库，这个函数标签库中定义了16个对于字符串进行处理的函数。我们在JSP页面中可以直接使用。\n\n* 当然，需要使用JSTL,首先需要将其Jar包导入。\n\n  * jstl.jar：[https://plumriver.lanzous.com/it69Elwr73a]()\n  * standard.jar：[https://plumriver.lanzous.com/i4nJVlwr74b]()\n\n* JSTL函数标签库的.tld文件存放于standard的jar包的META-INF目录中,以文件名为fn.tld为例。\n\n  * 此文件中定义了关于字符串操作的十六种函数。\n\n  | 函数名                               | 功能说明                                                     |\n  | ------------------------------------ | ------------------------------------------------------------ |\n  | fn:contains(String, String)          | 判断在源字符串中是否包含目标字符串。                         |\n  | fn:containslgnoreCase(string,String) | 判断在源字符串中是否包含目标字符串，并且在判断时忽略大小写   |\n  | fn: endsWith(String,String)          | 判断源字符串是否以指定的目标字符串结尾。                     |\n  | fn:startsWith(String,tring)          | 判断源字符串是否以指定的目标字符串开头。                     |\n  | fn:indexOf(String,String)            | 在源字符串中查找目标字符串，并返回源字符串中最先与目标字符串匹配的第一个字符的素引 |\n  | fn:replace(String,String,String)     | 把源字符串中的一部分替换为另外的字符串并返回替换后的字符串。 |\n  | fn:substring(String,int,int)         | 获取源字符串中的从第二个参数指定下标开始，到第三个参数减1后的下标结束的子串。 |\n  | fn:substringBefore(String,String)    | 获取源字符串中指定子字符串之前的子字符串。                   |\n  | fn:substringAfter(String,String)     | 获取源字符串中指定子字符串之后的子字符串。                   |\n  | fn:split(String,String)              | 将源字符串拆分为一个字符串数组。                             |\n  | fn:join(String[],String)             | 将源字符串数组中的所有字符串连接为一个字符串                 |\n  | fn:toLowerCase(String)               | 将源字符串中的所有字符改为小写。                             |\n  | fn: toUpperCase(String)              | 将源字符串中的所有字符改为大写。                             |\n  | fn:trim(String)                      | 将源字符串中的开头和末尾的空格删除。                         |\n  | fn:escapeXml(String)                 | 将源字符串中的字符“<”,“>”、” \" “和“&”等转换为转义字符。      |\n  | fn:length(Object)                    | 返回字符串中的字符的个数，或者集合和数组的元素的个数。       |\n\n* 使用方法：\n\n  * 第一步：jsp页面导入标签库。\n\n  ```jsp\n  <%@taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\"%>\n  ```\n\n  * 第二步：使用标签库的函数。\n\n  ```jsp\n  ${fn:substring(\"abcdefgh\",2 ,6 )}\n  ```\n\n### 2.4.6 总结\n\n* EL不能出现在Java 代码块、表达式块等JSP的动态代码部分。\n\n* EL只能从pageConext、request、 session、 application 四大域属性空间中获取数据。\n\n* EL不会抛出空指针异常。若访问一个null对象的属性,则什么也不显示。\n\n  EL不会抛出数组访问越界异常。若访问一个数组中的不存在的元素,则什么也不显示。\n\n* EL不具有对字对串进行处理的能力，就连简单的字符串拼接都不行。\n\n## 2.5 自定义标签\n\n* JSP中支持自定义标签。自定义标签是为了简化代码，使用自定义标签替换一个 Java代码片断，完成相同的功能。\n\n### 2.5.1 基本用法\n\n* 以“获取客户端IP”为例：\n\n* 第一步：自定义标签类和标签函数。\n\n  ```java\n  public class ClientTag extends SimpleTagSupport {\n    @Override\n    public void doTag() throws JspException, IOException {\n      //获取pageContext对象\n      PageContext pageContext = (PageContext) this.getJspContext();\n      //获取请求对象\n      ServletRequest request = pageContext.getRequest();\n      //获取客户端IP\n      String addr = request.getRemoteAddr();\n      //获取标准输出流\n      JspWriter out = pageContext.getOut();\n      //将客户端IP写入到输出流中\n      out.print(addr);\n    }\n  }\n  ```\n\n* 第二步：注册标签。\n\n  * tld文件的创建方式和注册EL函数的方式一样。\n\n  ```tld\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\"\n          version=\"2.0\">\n    <!--以下标签作用为：定义标签库信息  -->\n    <description>这是一个自定义标签库测试</description>\n    <tlib-version>1.0</tlib-version>\n    <short-name>ct</short-name>\n    <uri>http://www.lc.com/jsp/tag</uri>\n    <!-- 注册标签-->\n    <tag>\n      <description>获取客户端IP</description>\n      <name>ClientTag</name>\n      <tag-class>com.lc.tag.ClientTag</tag-class>\n  <!--  body-content：表示此标签是否有标签体。默认empty表示没有  -->\n      <body-content>empty</body-content>\n    </tag>\n  \n  </taglib>\n  ```\n\n* 第三步：引用标签库，并使用。\n\n  ```jsp\n  <%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n  <%@ page isELIgnored=\"false\" %>\n  <%@ taglib uri=\"http://www.lc.com/jsp/tag\" prefix=\"ct\"%>\n  <html>\n  <head>\n    <title>Title</title>\n  </head>\n  <body>\n    <ct:ClientTag/>\n  </body>\n  </html>\n  ```\n\n### 2.5.2 定义带标签体的标签\n\n* body-content的使用：\n  * empty:表示当前标签没有标签体\n  * scriptless:表示当前标签有标签体。但该标签体中不能出现Java脚本(java代码块，JSP表达式)，但可以出现EL表达式\n  * jsp:(已过时，不能使用)表示当前标签有标签体，且会将标签体原样显示到浏览器\n  * ctagdependent:表示当前标签有标签体，且会将标签体原样显示到浏览器，即使有EL表达式，也不会生效\n\n* 实现具有将字符串小写转换成大写的标签。\n\n* 第一步：\n\n  ```java\n  public class LowerToUpperTag extends SimpleTagSupport {\n    @Override\n    public void doTag() throws JspException, IOException {\n      //创建一个输出流。原因：该流中的内容可以通过toString()方法获取其文本形式\n      StringWriter writer = new StringWriter();\n      //获取标签体对象\n      JspFragment jspBody = this.getJspBody();\n      //将标签体内容写入输出流\n      jspBody.invoke(writer);\n      //获取缓冲区流的字符串形式数据\n      String string = writer.toString();\n      //将字符串变成大写\n      String aCase = string.toUpperCase();\n      //获取标签输出流并将字符串放到流中\n      this.getJspContext().getOut().print(aCase);\n    }\n  }\n  ```\n\n* 第二步：\n\n  ```tld\n  <!--  注册标签-->\n  <tag>\n    <description>将字符串小写变大写</description>\n    <name>LowerToUpperTag</name>\n    <tag-class>com.lc.tag.LowerToUpperTag</tag-class>\n    <body-content>scriptless</body-content>\n  </tag>\n  ```\n\n* 第三步：\n\n  ```jsp\n  <ct:LowerToUpperTag>asd</ct:LowerToUpperTag><br>\n  <%\n  String name = \"abcde\";\n  pageContext.setAttribute(\"name\", name);\n  %>\n  <ct:LowerToUpperTag>${name}</ct:LowerToUpperTag>\n  ```\n\n### 2.5.3 定义带属性的标签\n\n* 实现if-else功能的标签\n\n* 第一步：\n\n  ```java\n  public class IfTag extends SimpleTagSupport {\n  //  jsp中标签的属性对应的是标签注册器的setXxx方法\n    private boolean test;\n    public void setTest(boolean test) {\n      this.test = test;\n    }\n    @Override\n    public void doTag() throws JspException, IOException {\n      if (test){\n        //获取标签体\n        JspFragment jspBody = this.getJspBody();\n        //显示标签体\n        jspBody.invoke(this.getJspContext().getOut());\n        //以下代码等价于上述代码。\n        //如果invoke里写null，表示默认输出标签体的内容\n        this.getJspBody().invoke(null);\n      }\n    }\n  }\n  ```\n\n* 第二步：\n\n  ```tld\n  <tag>\n    <name>IfTag</name>\n    <tag-class>com.lc.tag.IfTag</tag-class>\n    <body-content>tagdependent</body-content>\n    <attribute>\n      <name>test</name>\n      <!--required:为true表示此属性必须存在-->\n      <required>true</required>\n      <!--runtime expression value : 运行时表达式的值\n      为true,则该属性的值支持EL与JSP的表达式-->\n      <rtexprvalue>true</rtexprvalue>\n    </attribute>\n  </tag>\n  ```\n\n* 第三步：\n\n  ```jsp\n  <%\n    boolean gender = true;\n    pageContext.setAttribute(\"gender\", gender);\n  %>\n  <ct:IfTag test=\"${gender}\">男</ct:IfTag>\n  <ct:IfTag test=\"${ not gender}\">女</ct:IfTag>\n  <ct:IfTag test=\"<%= gender%>\">女</ct:IfTag>\n  ```\n\n### 2.5.4 定以具有”跳过JSP“功能的标签\n\n\n\n### 2.5.5 定义forEachList功能的标签\n\n* 注意定义的var的类型\n\n* 第一步\n\n  ```java\n  public class ForEachListTag extends SimpleTagSupport {\n    private List items;\n    //注意此处的类型不能是object，可以是string类型，var只起到标识作用\n    private String var;\n  \n    public void setItems(List items) {\n      this.items = items;\n    }\n  \n    public void setVar(String var) {\n      this.var = var;\n    }\n  \n    @Override\n    public void doTag() throws JspException, IOException {\n      for (Object o : items) {\n        //将当前遍历的对象放入域属型中，第二次遍历便开始更新遍历的值\n        this.getJspContext().setAttribute(var, o);\n        this.getJspBody().invoke(null);\n      }\n    }\n  }\n  ```\n\n* 第二步\n\n  ```tld\n    <tag>\n      <name>forEachList</name>\n      <tag-class>com.lc.tag.ForEachListTag</tag-class>\n      <body-content>scriptless</body-content>\n      <attribute>\n        <name>items</name>\n        <required>true</required>\n        <rtexprvalue>true</rtexprvalue>\n      </attribute>\n      <attribute>\n        <name>var</name>\n        <required>true</required>\n        <rtexprvalue>false</rtexprvalue>\n      </attribute>\n    </tag>\n  ```\n\n* 第三步\n\n  ```jsp\n  <%\n    List names = new ArrayList();\n    names.add(\"张三\");\n    names.add(\"李四\");\n    names.add(\"王五\");\n    pageContext.setAttribute(\"names\", names);\n  %>\n  <ct:forEachList items=\"${names}\" var=\"name\">\n    ${name}<br>\n  </ct:forEachList>\n  ```\n\n### 2.5.6 定义forEach功能的标签\n\n* 第一步\n\n  ```java\n  public class ForEachTag2 extends SimpleTagSupport {\n    //此处定义的类型是Object\n    private Object items;\n    private String var;\n  \n    public void setItems(Object items) {\n      this.items = items;\n    }\n  \n    public void setVar(String var) {\n      this.var = var;\n    }\n  \n    public Collection getCollection(){\n      if (items instanceof List){\n        return (List)items;\n      }else if (items instanceof Set){\n        return (Set)items;\n      }else if (items instanceof Map){\n        return ((Map)items).entrySet();\n      }else if (items.getClass().isArray()){\n        //判断items是否是一个数组类型的数据。包括引用数组和基本数据数组\n        List nums = new ArrayList();\n        //通过反射的功能实现数组的转换\n        for (int i = 0; i < Array.getLength(items); i++) {\n          nums.add(Array.get(items,i));\n        }\n        return nums;\n      }\n      return null;\n    }\n  \n    @Override\n    public void doTag() throws JspException, IOException {\n      for (Object o : getCollection()) {\n        this.getJspContext().setAttribute(var, o);\n        System.out.println(o);\n        this.getJspBody().invoke(null);\n      }\n    }\n  }\n  ```\n\n* 第二步：与forEachList功能的标签的第二步类似\n\n* 第三步\n\n  ```jsp\n  <%\n    List names = new ArrayList();\n    names.add(\"张三\");\n    names.add(\"李四\");\n    names.add(\"王五\");\n    pageContext.setAttribute(\"names\", names);\n  %>\n  <ct:forEach items=\"${names}\" var=\"name\">\n    ${name}<br>\n  </ct:forEach>\n  <%--set--%>\n  <%\n    Set schools = new HashSet();\n    schools.add(\"清华\");\n    schools.add(\"北京\");\n    schools.add(\"河南\");\n    pageContext.setAttribute(\"schools\", schools);\n  %>\n  <ct:forEach items=\"${schools }\" var=\"school\">\n    ${school}<br>\n  </ct:forEach>\n  <%--map--%>\n  <%\n    Map<String,Object> persons = new HashMap<>();\n    persons.put(\"name\", \"李四\");\n    persons.put(\"age\", 18);\n    persons.put(\"address\", \"beijing\");\n    pageContext.setAttribute(\"persons\", persons);\n  %>\n  <ct:forEach items=\"${persons}\" var=\"person\">\n    ${person}<br>\n  </ct:forEach>\n  <%--引用类型数组--%>\n  <%\n    Object[] objects = {\"清华\",\"北大\",\"南大\"};\n    pageContext.setAttribute(\"objects\", objects);\n  %>\n  <ct:forEach items=\"${objects}\" var=\"object\">\n    ${object}<br>\n  </ct:forEach>\n  <%--基本数据类型数组--%>\n  <%\n    int[] nums = {1,2,3,4};\n    pageContext.setAttribute(\"nums\", nums);\n  %>\n  <ct:forEach items=\"${nums}\" var=\"num\">\n    ${num}<br>\n  </ct:forEach>\n  ```\n\n### 2.5.7 将自定义标签库打包发行\n\neclipse方式：\n\n* 右击项目-->选择Export-->选择Export。\n* 在弹窗中选择java-->选择JAR file-->点击Next。\n* 去掉窗口右边的.classPath和.project。选择要打包的项目，将除源码外的所有对号都去掉。\n* 在弹窗中选择打包后的文件位置，输入文件名为Xxx.jar。然后一直按确定即可。\n* 用解压软件打开打包后的jar包，将配置文件添加到jar包中的META-INF目录下。\n\n# 第三章 JSTL标签库\n\n* JSP Standard Tag Library,即JSP标准标签库。JSTL 中定义了五个标签库:。\n  * 核心标签库:主要用于完成基本的逻辑运算。\n  * 格式化标签库:主要用于完成日期、数字的格式化显示。\n  * EL函数标签库:定义了若干EL函数。\n  * SQL操作标签库:用于完成SQL操作。(不推荐使用。对于SQL操作，已经完全由Java代码完成。）\n  * XML操作标签库:完成XML操作。（不推荐使用。对于XML操作，已经完全由Java代码完成。）\n* 下载位置：\n  * jstl.jar：[https://plumriver.lanzous.com/it69Elwr73a]()\n  * standard.jar：[https://plumriver.lanzous.com/i4nJVlwr74b]()\n\n## 3.1 核心标签库\n\n* 使用JSTL的核心标签库，需要在页面中通过taglib指令首先将标签库导入。\n\n```jsp\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n```\n\n**c:set**\n\n* 用于进行变量定义，并将变量存放到指定域属性空间:为Bean的属性赋值;设置Map的key与value等。该标签在实际开发中并不常用。\n\n```jsp\n<%--设置域属型request中有一个name值为李四的属性--%>\n<c:set var=\"name\" value=\"李四\" scope=\"request\"/>\nname = ${requestScope.name}<br>\n```\n\n* value:变量的值\n* var;变量名\n* scope:将变量存放的域属性空间，取值为page. request. session. application。 默认为page范围\n\n```jsp\n<%--为bean的属性赋值--%>\n<%\n  Student student = new Student();\n  session.setAttribute(\"student\", student);\n%>\n\n<c:set value=\"李四\" property=\"name\" target=\"${sessionScope.student}\"/>\n<c:set value=\"15\" property=\"age\" target=\"${sessionScope.student}\"/>\nstudent = ${student.toString()}\n```\n\n* target:指定的Bean对象\n* property:指定对象的指定属性。\n* value:为指定对象的指定属性所赋的值。\n\n```jsp\n<%\n  Map<String ,Object> map = new HashMap<>();\n  pageContext.setAttribute(\"map\", map);\n%>\n<c:set value=\"北京\" property=\"address\" target=\"${pageScope.map}\"/>\n<c:set value=\"18\" property=\"age\" target=\"${pageScope.map}\"/>\nmap = ${map.address}  ${map.age}<br>\n```\n\n* target:指定的map\n* property:指定map的指定的key\n* value:为指定map的指定的key所赋的值\n\n**c:remove**\n\n* 从域属性空间中删除指定变量,该标签不常用。\n\n```jsp\n<%--c:remove  删除域中的属性--%>\n<%\n  String name = \"asd\";\n  pageContext.setAttribute(\"name\", name);\n%>\nname = ${name}<br>\n<%--删除指定域中的指定属性--%>\n<c:remove var=\"name\" scope=\"page\"/>\nname = ${name}<br>\n<%--删除所有域中的指定属性--%>\n<c:remove var=\"name\"/>\n```\n\n* var：要删除的属性名。\n* scope:要删除的域。\n\n**c:out**\n\n* 用于在页面。上输出EL表达式的值。该标签不常用。\n* EL表达式不用\\<c:out/>标签,就可以直接在页面上输出，那么使用这个\\<c:out/>标签有什么更强的作用呢? \n\n```jsp\n<%--c:out的使用--%>\n<c:set var=\"name\" value=\"李四\"/>\nname = <c:out value=\"${name}\" default=\"名字\" ></c:out><br>\nname = ${name}<br>\n<c:set var=\"age\" value=\"<h1>15</h1>\"/>\nage = <c:out value=\"${age}\"/><br>\n<%--下面两行代码效果相同。都会显示变大后的数字--%>\nage = ${age}<br>\nage = <c:out value=\"${age}\" escapeXml=\"false\"/><br>\n```\n\n* value:指定要输出的EL表达式。\n* default：当EL表达式的变量没有定义，默认值为default的值\n* escapeXml;是否忽略HTML标签。\n  * 若为true,则不解析HTML标签,将按原样输出,为默认值。\n  * 若为false,则解析HTML标签。EL表达式本身也是解析HTML标签的。\n\n**c:catch**\n\n* 捕获标签体内的Java代码出现的异常\n\n```jsp\n<%--c:catch 的使用--%>\n<c:catch var=\"ex\">\n  <%\n    int i = 1/0;\n  %>\n</c:catch>\n异常 = ${ex.message}<br>\n```\n\n* var：异常的引用名称\n\n**c:if**\n\n* 用于实现对于条件的判断。\n\n```jsp\n<%--c:if的使用--%>\n<% boolean gender = true; pageContext.setAttribute(\"gender\", gender);%>\n<c:if test=\"gender\">\n  男\n</c:if>\n```\n\n* test:判断的条件。若为true,则执行标签体，否则不执行\n* var:存储test的判断结果。不常用。\n* scope:存储test判断结果的变量的存放范围。不常用。\n\n**c:choose**\n\n* 相当于java中的switch-case-default语句\n\n```jsp\n<%--c:choose的使用--%>\n<%\n int currentPage = 1;\n pageContext.setAttribute(\"currentPage\", currentPage);\n\n%>\n<%--c:choose 表示是否满足以下情况。当某一情况满足时，就不比较剩下的情况了--%>\n<c:choose>\n  <%--c:when表示当test为true时，显示标签体中的内容--%>\n  <c:when test=\"${currentPage == 1}\">\n    首页 上一页 <a href=\"#\">下一页</a> <a href=\"#\">末页</a>\n  </c:when>\n  <c:when test=\"${currentPage == 5}\">\n    <a href=\"#\">首页</a> <a href=\"#\">上一页</a> 下一页 末页\n  </c:when>\n  <%--c:otherwise：表示上述都不满足时，显示此标签体中的内容--%>\n  <c:otherwise>\n    <a href=\"#\">首页</a> <a href=\"#\">上一页</a> <a href=\"#\">下一页</a> <a href=\"#\">末页</a>\n  </c:otherwise>\n</c:choose>\n```\n\n**c:forEach**\n\n* 用于循环遍历数组、List, Set、 Map集合。在实际应用中使用非常频繁。\n* varStatus:代表循环状态的变量名称\n\n```jsp\n<% int[] nums = {1,2,3,4,5}; pageContext.setAttribute(\"nums\", nums);%>\n<%--遍历nums数组，从下标1开始，到下标4结束，每搁两个下标输出--%>\n<c:forEach items=\"${nums}\" var=\"num\" begin=\"1\" end=\"4\" step=\"2\">\n  ${num}<br>\n</c:forEach>\nasd<br>\n<%--遍历1到9，每隔两个输出。即：1,3,5,7,9--%>\n<c:forEach var=\"num\" begin=\"1\" end=\"9\" step=\"2\">\n  ${num}<br>\n</c:forEach>\n```\n\n## 3.2 格式化标签库\n\n* 使用JSTL的核心标签库，需要在页面中通过tagib指令首先将标签库导入。\n\n  ```jsp\n  <%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %>\n  ```\n\n**fmt:formatDate**\n\n* 该标签用于使用不同的模式格式化日期。其常用属性有;\n  * value:将要被格式化的数据\n  * pattern:格式化的模式。其与SimpleDateFormat的参数设置方式相同。\n  * var:格式化后的字符串所要存放的变量。若不指定var, 则会将格式化过的结果直接显示在页面。\n  * scope:变量存放的域属性空间，取值为page、 request、 session，application。 默认为page范围。\n  * type:其取值为date、time, 或both,表示给出的value是日期、时间,还是两者都包含。默认为date\n\n```jsp\n<%--fmt:formatDate的使用--%>\n<% Date date = new Date(); pageContext.setAttribute(\"date\", date);%>\ndate = <fmt:formatDate value=\"${date}\" pattern=\"yyyy-MM-dd\"/><br>\n<%--var:当加上var属性后，格式化的日期不会显示在浏览器上而是赋予birth域属型--%>\ndate = <fmt:formatDate value=\"${date}\" pattern=\"yyyy-MM-dd\" var=\"birth\"/><br>\n生日：<input type=\"text\" name=\"birth\" value=\"${birth}\"><br>\n```\n\n**fmt:parseDate**\n\n* 该标签用于将指定字符串转换为日期类型。主要用于解析字符串。常用的属性有:\n  * value:将要被转换的数据。\n  * pattern:将要被转换的数据的模式。其与SimpleDateFormat的参数设置方式相同。\n  * var:转换后的日期类型数据所要存放的变量。若不指定var,则会将转换过的结果直接显示在页面。\n  * scope:变量存放的域属性空间，职值为page. request、 session、 applcation。 默认为page范围\n\n```jsp\n<%--fmt:parseDate:字符串转换成日期--%>\n<fmt:parseDate value=\"2000/2/6\" pattern=\"yyyy/MM/dd\"/><br>\n```\n\n**fmt:formatNumber**\n\n* 该标签用于按照指定格式对数字进行格式化。常用的属性有:\n  * value:要显示的数字\n  * groupingUsed：是否对数字分组 (TRUE 或 FALSE)。默认true\n  * type:NUMBER，CURRENCY,或PERCENT类型。默认NUMBER类型\n  * pattern:指定一个自定义的格式化模式用与输出。\n  * var：存储格式化数字的变量\n  * scope：var属性的作用域\n  * maxIntegerDigits\t整型数最多的位数\t\n  * minIntegerDigits\t整型数最少的位数\t\n  * maxFractionDigits\t小数点后最多的位数\n  * minFractionDigits\t小数点后最少的位数\n\n```jsp\n<fmt:formatNumber value=\"${12345678}\"/><br>\n<fmt:formatNumber value=\"${12345678}\" groupingUsed=\"false\"/><br>\n```\n\n**fmt:parseNumber**\n\n* 该标签用于将指肃字符串转换为数值类型。常用的属性有: \n  * value：要解析的数字\t\n  * type：NUMBER,CURRENCY，或 PERCENT\n  * integerOnly：是否只解析整型数（true）或浮点数（false）\n  * pattern：自定义解析模式\n  * var：存储待解析数字的变量\t\n  * scope：var属性的作用域\n\n```jsp\n<fmt:parseNumber value=\"123.456\" integerOnly=\"true\"/>\n```\n\n# 第四章 系统开发模型\n\n* 系统开发模型，即系统架构,是指整合应用系统程序大的结构。经常提到的系统结构有两种:三层架构与MVC。这两种结构既有区别，又有联系。但这两种结构的使用均是为了降低系统模块间的耦合度。\n* 传统的JavaWeb项目的系统开发模型大体经历了四个阶段:纯JSP、JSP+JavaBean 的Model1、MVC的Model2、MVC+三层架构。\n\n## 4.1 开发模式\n\n### 4.1.1 纯JSP开发\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222090656.png)\n\n* “纯JSP”开发模型中将所有业务处理、数据显示功能都由JSP页面完成。其缺点是很明显的: JSP页面中的代码结构很乱，显示功能与业务处理功能代码没有划分，维护与升级相当麻烦..... .\n\n### 4.1.2 JSP+JavaBean的Model1\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222091600.png)\n\n* 这种开发模型将绝大多数业务处理功能交给了专[的JavaBean来完成,而JSP页面主要来完成数据显示功能。已经较“纯JSP页面”的开发模型有了很大改进。但该开发模式对于来自客户端的请求的解析, 及对于JavaBean对象的选择与创建,仍然是由JSP页面通过Java代码块等来完成的。也就是说，JSP页面还承担着大量的请求解析、业务处理功能。\n* JavaBean根据其具体的概念的不同，可以分为两大类:广义JavaBean与狭义JavaBean。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222092034.png)\n\n* 所谓广义JavaBean,就是指一般意义上的Java类其主要功能有两个:承载数据与业务处理,所以广义的JavaBean又分为两类:数据承载Bean与业务处理Bean，数据承载Bean就是指实体类，专门用于承载业务数据的，如Student、User 等。而业务处理Bean则是指Service或Dao对象，专门用于处理用户提交请求的。\n* 狭义JavaBean,是指符合SUN公司提出的“JavaBean规范”的Java类。JavaBean 规范规定，满足以下四点的Java类，称为JavaBean: \n  * 该类需要是公共的，即public class ...\n  * 该类需要实现Serialiable接口。\n  * 该类需要具备无参构造器，无论是默认的，还是显示定义的。\n  * 该类若有成员变量,则这些成员变量必须是私有的，且需要提供这些私有成员变量的公共getter与setter。\n* 在实际项目中，实体类-般会被定义为狭义的JavaBean。即，广义的JavaBean的数据承载Bean一般会被定义为满足“JavaBean规范”的狭义JavaBean。\n\n### 4.1.3 MVC的Model2\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222092700.png)\n\n* MVC,即Model模型、View视图，及Controller控制器。\n  * View:视图，为用户提供使用界面，与用户直接进行交互。\n  * Model:模型，承载数据,并对用户提交请求进行计算的模块。其分为两类，一类称为数据承载Bean, 一类称为业务处理Bean。所谓数据承载Bean是指实体类，专门用户承载业务数据的，如Student, User等。而业务处理Bean则是指Service 或Dao对象，专门用于处理用户提交请求的。\n  * Controller:控制器，用于将用户请求转发给相应的Model进行处理，并根据Model的计算结果向用户提供相应响应。\n* MVC架构程序的工作流程是这样的:\n* 1)用户通过View页面向服务端提出请求，可以是表单请求、超链接请求、AJAX请求，\n* 2) 服务端Contoller控制器接收到请求后对请求进行解析,找到相应的Model对用户请求进行业务处理。并把响应结果给View。\n\n### 4.1.4 三层架构\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222092841.png)\n\n* 三层架构是指:视图层View、服务层Service, 与持久层Dao.它们分别完成不同的功能。\n* View层:表现层、视图层，对于Web开发,也称为Wweb层。用于接收用户提交请求的代码在这里编写。\n* Service层:业务层、逻辑层，系统的业务逻辑主要在这里完成。\n* Dao层:持久层、数据访问层,直接操作数据库的代码在这里编写。DAO,即Data Access Object,数据访问对象。\n* 为了更好的降低各层间的耦合度，在三层架构程序设计中，采用面向抽象编程。即上层对下层的调用,是通过接口实现的。而下层对上层的真正服务提供者，是下层接口的实现类。服务标准(接口)是相同的，服务提供者(实现类)可以更换。这就实现了层间解耦合。\n\n### 4.1.5 MVC+三层架构\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222093153.png)\n\n* 所谓“MVC+三层架构”的开发模型，主要是指将MVC的业务处理Model分为了两层:Service层与Dao层，分别用于处理业务逻辑与持久化操作。\n* MVC+ 三层架构” 的开发模型，是传统的JavaWeb项目的最常用开发模型。 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["Java学习","前端"]},{"title":"xml学习","url":"/2021/02/04/尚硅谷说Java/前端/xml/","content":"xml学习\n<!--more-->\n# 第一章 XML文件\n\n*  xml 是可扩展标识语言，(Extensible Markup Language)就是开发者在符合xml命名规则的基础之上，可以根据自己的需求定义自己的标签;\n* 命名规则：标签需要成对出现。\n* xml文件的作用：主要用来传输数据。\n* 解析xml文件的方法：DOM，DOM4J，SAX(边读边解析,适合大文件解析)。\n\n# 第二章 Dom4J解析xml文件\n\n* 导入Dom4J.jar包：dom4j-1.6.1.jar\n\n* Dom4J常用的对象：\n\n  * SAXReader:读取xml文件到Document树结构文件对象\n  * Document:是一个xml文档对象树，类比Html文档对象。\n  * Element:元素节点。通过Document对象可以查找单个元素\n\n* Dom4J解析步骤：\n\n  ```\n  第一步：创建解析器。\n  SAXReader reader = new SAXReader();\n  第二步：通过解析器read方法获取Document对象。\n  Document doc = readerread( studentInfo.xml\");\n  第三步：获取xml根节点。\n  Element root = doc.getRootElement( );\n  第四步：遍历解析子节点。\n  ```\n\n## 实例一：使用Dom4J解析students.xml文件\n\n* IDEA创建java项目。文件结构如下:\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204201057.png)\n\n* 导入jar包\n\n  ```xml\n  <dependency>\n    <groupId>dom4j</groupId>\n    <artifactId>dom4j</artifactId>\n    <version>1.6.1</version>\n  </dependency>\n  ```\n\n  * students.xml文件\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <students>\n      <student>\n        <name>张三</name>\n        <age>18</age>\n        <sex>男</sex>\n      </student>\n      <student>\n        <name>李四</name>\n        <age>20</age>\n        <sex>男</sex>\n      </student>\n      <student>\n        <name>小芳</name>\n        <age>22</age>\n        <sex>女</sex>\n      </student>\n    </students>\n    ```\n\n  * 编写Java代码\n\n    ```java\n    //1.创建解析器\n    SAXReader reader = new SAXReader();\n    //通过解析器的read方法将配置文件读取到内存中，生成一个Document[org.dom4j]对象树\n    Document document = reader.read(\"E:\\\\IDEAworkspace\\\\JavaAtguigu\\\\Java-Web-Xml\\\\src\\\\students.xml\");\n    //获取根节点：students节点\n    Element rootElement = document.getRootElement();\n    //遍历根节点的子节点\n    Iterator<Element> studentsIterator = rootElement.elementIterator();\n    while (studentsIterator.hasNext()){\n      //获取根节点下的每一个student节点\n      Element element = studentsIterator.next();\n      //遍历student的子节点\n      Iterator<Element> studentIterator = element.elementIterator();\n      while (studentIterator.hasNext()) {\n        Element inner = studentIterator.next();\n        String value = inner.getStringValue();\n        System.out.println(value);\n      }\n      System.out.println(\"*******************\");\n    }\n    ```\n\n# 第三章 Sax解析xml文件\n\n* 解析方式：事件驱动，边读边解析。\n\n* 优点：无需将整个文档加载到内存中，所以内存消耗少，适合解析特别大的xml文件。\n\n* 解析步骤：\n\n  ```\n  1.创建解析工厂：通过newInstance()方法获取\n  SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n  2.创建解析器\n  SAXParser saxParser = saxParserFactory.newSAXParser();\n  3.执行解析器的parser方法，传入两个参数：xml文件路径，事件处理器。\n  saxParser.parse(\"Java-Web-Xml\\\\src\\\\students.xml\", new MyDefaultHandler());\n  4.自定义事件处理器\n  ```\n\n## 实例二：使用SAX打印xml文件的内容\n\n* 文件结构图：类似上图\n\n* xml文件如上\n\n* Java代码：\n\n  ```java\n  //创建解析器工厂\n  SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n  //创建解析器\n  SAXParser saxParser = saxParserFactory.newSAXParser();\n  //通过解析器的parser方法\n  //第一个参数为文件路径，第二个参数为对xml文件解析的监听器\n  saxParser.parse(\"Java-Web-Xml\\\\src\\\\students.xml\", new MyDefaultHandler());\n  \n  class MyDefaultHandler extends DefaultHandler{\n    /**\n     *读取到开始标签时调用此方法\n     * @param qName 标签的名字\n     */\n    @Override\n    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n      System.out.print(\"<\"+qName+\">\");\n    }\n    /**\n     *读取到关闭标签时调用此方法\n     * @param qName 标签的名字\n     */\n    @Override\n    public void endElement(String uri, String localName, String qName) throws SAXException {\n      System.out.print(\"</\"+qName+\">\");\n    }\n    /**\n     *返回标签中的数据\n     */\n    @Override\n    public void characters(char[] ch, int start, int length) throws SAXException {\n      System.out.print(new String(ch,start,length));\n    }\n  }\n  ```\n\n# 第四章 使用Dom4J的xPath解析\n\n## 4.1 XPath语法\n\n* 官方地址：https://www.w3school.com.cn/xpath/xpath_syntax.asp\n* **XPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的**\n* **选取节点**\n\n|  表达式  |                            描述                            |\n| :------: | :--------------------------------------------------------: |\n| nodename |                  选取此节点的所有子节点。                  |\n|    /     |                       从根节点选取。                       |\n|    //    | 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 |\n|    .     |                       选取当前节点。                       |\n|    ..    |                   选取当前节点的父节点。                   |\n|    @     |                         选取属性。                         |\n\n* 实例\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<bookstore>\n  <book>\n    <title lang=\"eng\">Harry Potter</title>\n    <price>29.99</price>\n  </book>\n  <book>\n    <title lang=\"eng\">Learning XML</title>\n    <price>39.95</price>\n  </book>\n</bookstore>\n```\n\n|路径表达式\t|结果|\n| :------: | :--------------------------------------------------------: |\n| bookstore\t|选取 bookstore 元素的所有子节点。|\n| /bookstore\t|选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！|\n| bookstore/book\t|选取属于 bookstore 的子元素的所有 book 元素。|\n| //book\t|选取所有 book 子元素，而不管它们在文档中的位置。|\n| bookstore//book\t|选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于bookstore 之下的什么位置。|\n| //@lang\t|选取名为 lang 的所有属性。|\n\n* **谓语**\n  * 谓语用来查找某个特定的节点或者包含某个指定的值的节点。\n  * 谓语被嵌在方括号中。\n|路径表达式\t|结果|\n| :------: | :--------------------------------------------------------: |\n|/bookstore/book[1]\t|选取属于 bookstore 子元素的第一个 book 元素。|\n|/bookstore/book[last()]\t|选取属于 bookstore 子元素的最后一个 book 元素。|\n|/bookstore/book[last()-1]\t|选取属于 bookstore 子元素的倒数第二个 book 元素。|\n|/bookstore/book[position()<3]\t|选取最前面的两个属于 bookstore 元素的子元素的 book 元素。|\n|//title[@lang]\t|选取所有拥有名为 lang 的属性的 title 元素。|\n|//title[@lang='eng']\t|选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。|\n|/bookstore/book[price>35.00]\t|选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。|\n|/bookstore/book[price>35.00]/title\t|选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。|\n\n* **选取未知节点**\n* XPath 通配符可用来选取未知的 XML 元素。\n\n|通配符\t|描述|\n| :------: | :--------------------------------------------------------: |\n|*\t|匹配任何元素节点。|\n|@*\t|匹配任何属性节点。|\n|node()\t|匹配任何类型的节点。|\n\n  * 实例\n|路径表达式|\t结果|\n| :------: | :--------------------------------------------------------: |\n|/bookstore/*\t|选取 bookstore 元素的所有子元素。|\n|//*\t|选取文档中的所有元素。|\n|//title[@*]|\t选取所有带有属性的 title 元素。|\n* **选取若干路径**\n|路径表达式\t|结果|\n| :------: | :--------------------------------------------------------: |\n|//book/title \\| //book/price\t|选取 book 元素的所有 title 和 price 元素。|\n|//title \\| //price\t|选取文档中的所有 title 和 price 元素。|\n|/bookstore/book/title \\| //price\t|选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。|\n\n## 4.2 XPath与Dom4J的结合使用\n\n```java\n//1.创建解析器\nSAXReader reader = new SAXReader();\n//通过解析器的read方法将配置文件读取到内存中，生成一个Document[org.dom4j]对象树\nDocument document = reader.read(\"Java-Web-Xml\\\\src\\\\students.xml\");\n//查找<name>张三</name>这个节点\nElement element = (Element)document.selectSingleNode(\"students/student[1]/name\");\n//输出节点的文本内容\nSystem.out.println(element.getStringValue());\n//获取节点对象的name属性的值\nString name = element.attributeValue(\"name\");\n```\n\n## 4.3 使用XPath解析xml配置文件\n\n```java\n//创建解析工厂\nDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n//创建解析器\nDocumentBuilder documentBuilder = factory.newDocumentBuilder();\n//通过解析器读取配置文件\nDocument document = documentBuilder.parse(\"Java-Web-Xml\\\\src\\\\students.xml\");\n\n//通过XPath工厂创建XPath对象\nXPath xPath = XPathFactory.newInstance().newXPath();\n//输出<name>张三</name>这个节点的文本内容\nString nameXPath=\"students/student[1]/name\";\nString name = (String)xPath.evaluate(nameXPath, document, XPathConstants.STRING);\n```\n\n","categories":["Java学习","前端"]},{"title":"Vue学习-不全","url":"/2021/02/04/尚硅谷说Java/前端/Vuejs/","content":"Vue学习\n<!--more-->\n# 第一章：Vuejs的简介\n\n## 1.1 遇见Vuejs\n\n* Vue (读音 /vjuː/，类似于 view)，不要读错。\n* Vue是一个渐进式的框架，什么是渐进式的呢？\n  * 渐进式意味着你可以将Vue作为你应用的一部分嵌入其中，带来更丰富的交互体验。\n  * 或者如果你希望将更多的业务逻辑使用Vue实现，那么Vue的核心库以及其生态系统。\n  * 比如Core+Vue-router+Vuex，也可以满足你各种各样的需求。\n* Vue有很多特点和Web开发中常见的高级功能\n  * 解耦视图和数据\n  * 可复用的组件\n  * 前端路由技术\n  * 状态管理\n  * 虚拟DOM\n* 学习Vuejs的前提？\n  * 从零学习Vue开发，并不需要你具备其他类似于Angular、React，甚至是jQuery的经验。\n  * 但是你需要具备一定的HTML、CSS、JavaScript基础。\n\n## 1.2 安装Vuejs\n\n* 方式一：直接CDN引入\n\n  * 你可以选择引入开发环境版本还是生产环境版本\n\n  ```js\n  <!-- 开发环境版本，包含了有帮助的命令行警告 --> \n  <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n  <!-- 生产环境版本，优化了尺寸和速度 -->\n  <script src=\"https://cdn.jsdelivr.net/npm/vue\"></script>\n  ```\n\n* 方式二：下载和引入\n\n  * [网站](https://cn.vuejs.org/v2/guide/)\n  * [下载开发版本](https://cn.vuejs.org/js/vue.js)\n  * [下载生产版本](https://cn.vuejs.org/js/vue.min.js)\n  * 下载后放到项目下，页面通过script标签引入\n\n* 方式三：NPM安装\n\n  * npm install vue\n  * 或使用webpack和CLI\n\n## 1.3 体验Vuejs\n\n### 1.3.1 hello Vuejs\n\n* 第一个界面\n\n  ```html\n  <!DOCTYPE html>\n  <html lang=\"en\">\n  <head>\n      <meta charset=\"UTF-8\">\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n      <title>Document</title>\n  </head>\n  <body>\n      <!-- <div id=\"app\">{{message}}</div> -->\n      <div id=\"app\">\n          <h1>{{message}}</h1>\n          <h1>{{name}}</h1>\n      </div>\n       <!--引入vue.js 路径写自己的-->\n      <script src=\"../js/vue.js\"></script>\n      <script>\n          //编程思想：声明式开发\n          //es6中的let(变量)/const(常量)\n          const app = new Vue({\n              //用于挂载要管理的元素\n              el: '#app',\n              //定义数据\n              data: {\n                  message: '你好',\n                  name: 'vue'\n              }\n          });\n          //编程思想：命令式开发\n          //js的写法实现上述功能\n          //1.创建div元素，设置id属性\n          //2.定义一个变量叫message\n          //3.将message变量放到前面的div元素中显示\n          //4.修改message数据为：js\n          //5.将修改后的数据再次替换掉div元素\n      </script>\n  </body>\n  </html>\n  ```\n\n  * 效果\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204.png)\n\n* 实现原理\n\n  * 创建Vue对象的时候，传入了一些options：{}\n    * {}中包含了el属性：该属性决定了这个Vue对象挂载到哪一个元素上，很明显，我们这里是挂载到了id为app的元素上\n    * {}中包含了data属性：该属性中通常会存储一些数据\n      * 这些数据可以是我们直接定义出来的，比如像上面这样。\n      * 也可能是来自网络，从服务器加载的。\n  * 浏览器执行代码的流程：\n    * 执行到10~13行代码显然出对应的HTML\n    * 执行第16行代码创建Vue实例，并且对原HTML进行解析和修改。\n  * 并且，目前我们的代码是可以做到响应式的。\n\n* 实现修改message数据为：js\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-1.png)\n\n### 1.3.2 Vue显示列表\n\n* 页面代码\n\n  ```html\n  <body>\n      <div id=\"app\">\n          <ul>\n              <li v-for=\"item in movies\">{{item}}</li>\n          </ul>\n      </div>\n      <script src=\"../js/vue.js\"></script>\n      <script>\n          let app = new Vue({\n              el: '#app',\n              data: {\n                  movies: ['电影1','电影2','电影3','电影4']\n              }\n          });\n      </script>\n  </body>\n  ```\n\n* 页面\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-2.png)\n\n* 修改数据\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-3.png)\n\n* 总结\n\n  * HTML代码中，使用v-for指令\n  * 更重要的是，它还是响应式的。\n  * 也就是说，当我们数组中的数据发生改变时，界面会自动改变。\n\n### 1.3.3 实现计数器\n\n* 现在，我们来实现一个小的计数器\n\n  * 点击 + 计数器+1\n  * 点击 -  计数器 -1\n\n* 页面代码\n\n  ```html\n  <body>\n     <div id=\"app\">\n         <h2>当前计数：{{counter}}</h2>\n         <!-- <button v-on:click=\"counter++\">+</button>\n         <button v-on:click=\"counter--\">-</button> -->\n         <button v-on:click=\"add\">+</button>\n         <!-- @click为语法糖写法，是对v-on:click的简写 -->\n         <button @click=\"sub\">-</button>\n     </div>\n      <script src=\"../js/vue.js\"></script>\n      <script>\n         const app = new Vue({\n             el: '#app',\n             data: {\n                 counter: 0\n             },\n             methods: {\n                 add: function(){\n                     console.log(\"add被执行\");\n                     this.counter++;\n                 },\n                 sub: function(){\n                      console.log(\"sub被执行\");\n                     this.counter--;\n                 }\n  \n             }\n         });\n      </script>\n  </body>\n  ```\n\n* 页面\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-4.png)\n\n* 这里，我们又要使用新的指令和属性了\n\n  * 新的属性：methods，该属性用于在Vue对象中定义方法。\n  * 新的指令：@click, 该指令用于监听某个元素的点击事件，并且需要指定当发生点击时，执行的方法(方法通常是methods中定义的方法)\n\n## 1.4 MVVM架构\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-5.png)\n\n* View层：视图层\n  * 在前端开发中，通常就是DOM层。\n  * 主要的作用是给用户展示各种信息。\n* Model层：数据层\n  * 数据可能是我们固定的死数据，更多的是来自我们服务器，从网络上请求下来的数据。\n  * 在我们计数器的案例中，就是后面抽取出来的obj，当然，里面的数据可能没有这么简单。\n* VueModel层：视图模型层\n  * 视图模型层是View和Model沟通的桥梁。\n  * 一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中\n  * 另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data。\n* 以计数器为案例\n  * 我们的计数器中就有严格的MVVM思想\n    * View依然是我们的DOM\n    * Model就是我们我们抽离出来的obj\n    * ViewModel就是我们创建的Vue对象实例\n  * 它们之间如何工作呢？\n    * 首先ViewModel通过Data Binding让obj中的数据实时的在DOM中显示。\n    * 其次ViewModel通过DOM Listener来监听DOM事件，并且通过methods中的操作，来改变obj中的数据。\n\n## 1.5 Vue对象的options\n\n* 详细解析： https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE\n* el: \n  * 类型：string | HTMLElement\n  * 作用：决定之后Vue实例会管理哪一个DOM。\n* data: \n  * 类型：Object | Function （组件当中data必须是一个函数）\n  * 作用：Vue实例对应的数据对象。\n* methods: \n  * 类型：{ [key: string]: Function }\n  * 作用：定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中使用。\n\n## 1.6 Vue的生命周期\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-6.png)\n\n* 生命周期函数\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-7.png)\n\n# 第二章：Vuejs基础语法\n\n## 2.1 插值语法\n\n### 2.1.1 Mustache语法\n\n* Mustache语法(也就是双大括号)。\n* 我们可以像下面这样来使用，并且数据是响应式的\n\n```html\n<body>\n    <div id = \"app\">\n        <h2>{{message}}</h2>\n        <h2>{{message}},美女</h2>\n        <!-- mustache语法中，不仅仅可以直接写变量，也可以写简单的表达式 -->\n        <h2>{{firstName + lastName}}</h2>\n        <h2>{{firstName + ' ' + lastName}}</h2>\n        <h2>{{firstName}} {{lastName}}</h2>\n        <h2>{{counter * 2}}</h2>\n    </div>\n\n    <script src=\"../../js/vue.js\"></script>\n    <script>\n        const app = new Vue({\n            el: '#app',\n            data: {\n                message: \"你好\",\n                firstName: '姓',\n                lastName: '名',\n                counter: 100\n            }\n        });\n    </script>\n</body>\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-8.png)\n\n### 2.1.2 v-once\n\n* 作用：页面中的数据只会显示第一次加载的。当在浏览器控制台修改数据时，有v-once的页面标签里面的数据不会被修改。\n\n  * 该指令后面不需要跟任何表达式(比如之前的v-for后面是由跟表达式的)\n  * 该指令表示元素和组件(组件后面才会学习)只渲染一次，不会随着数据的改变而改变。\n\n* 代码\n\n  ```html\n  <div id=\"app\">\n      <h2>{{message}}</h2>\n      <h2 v-once>{{message}}</h2>\n  </div>\n  <script src=\"../../js/vue.js\"></script>\n  <script>\n      const app = new Vue({\n          el: '#app',\n          data: {\n              message: \"你好\"\n          }\n      });\n  </script>\n  ```\n\n* 效果\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-9.png)\n\n### 2.1.3 v-html\n\n* 作用：可以将数据中的带连接的字符串数据转化成对应的标签\n\n  * 该指令后面往往会跟上一个string类型\n  * 会将string的html解析出来并且进行渲染\n\n* 代码\n\n  ```html\n  <div id=\"app\">\n      <h2>{{url}}</h2>\n      <h2 v-html=\"url\"></h2>\n  </div>\n  <script src=\"../../js/vue.js\"></script>\n  <script>\n      const app = new Vue({\n          el: '#app',\n          data: {\n              url: '<a href=\"http://www.baidu.com\">百度一下</a>'\n          }\n      });\n  </script>\n  ```\n\n* 效果\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-10.png)\n\n### 2.1.4 v-text\n\n* 作用：将数据中的值以文本的形式显示出来。和Mustache类似，但不具有表达式的功能。\n\n  * v-text作用和Mustache一致：\n  * v-text通常情况下，接受一个string类型\n\n* 代码\n\n  ```html\n  <div id=\"app\">\n      <h2>{{message}}</h2>\n      <h2 v-text=\"message\"></h2>\n      <h2 v-text=\"url\"></h2>\n  </div>\n  <script src=\"../../js/vue.js\"></script>\n  <script>\n      const app = new Vue({\n          el: '#app',\n          data: {\n              message: \"你好\",\n              url: '<a href=\"http://www.baidu.com\">百度一下</a>'\n          }\n      });\n  </script>\n  ```\n\n* 效果\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-11.png)\n\n### 2.1.5 v-pre\n\n* 作用：当标签内有Mustache语法的数据时，会消除语法的渲染效果\n\n  * v-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法。\n\n* 代码\n\n  ```html\n  <div id=\"app\">\n      <h2>{{message}}</h2>\n      <h2 v-pre>{{message}}</h2>\n  </div>\n  <script src=\"../../js/vue.js\"></script>\n  <script>\n      const app = new Vue({\n          el: '#app',\n          data: {\n              message: \"你好\"\n          }\n      });\n  </script>\n  ```\n\n* 效果\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-12.png)\n\n### 2.1.6 v-block\n\n* 作用：当页面加载完，但vue未加载时，页面会显示页面的代码。当页面标签加上此命令，并在css样式中将此样式的标签设置为不可见。当vue加载完后，页面标签就会正常使用。\n\n  * 如果在vue解析之前，div中有一个v-cloak属性 \n  * 在解析vue之后，div标签中的v-bloak属性将全部被剔除\n\n* 代码\n\n  ```html\n  <head>\n      <meta charset=\"UTF-8\">\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n      <title>Document</title>\n      <style>\n          [v-bloak] {\n              display: none;\n          }\n      </style>\n  </head>\n  <body>\n      <div id=\"app\" v-bloak>\n          <h2 >{{message}}</h2>\n        \n      </div>\n      <script src=\"../../js/vue.js\"></script>\n      <script>\n          //如果在vue解析之前，div中有一个v-cloak属性\n          //在解析vue之后，div标签中的v-bloak属性将全部被剔除\n          setTimeout(() => {\n              const app = new Vue({\n                  el: '#app',\n                  data: {\n                  message: \"你好\"\n                  }\n              });\n          }, 1000);\n      </script>\n  </body>\n  ```\n\n* 效果\n\n  * 当页面加载完成后，页面空白。等待1秒后页面显示文本“你好”。\n\n## 2.2 绑定属性\n\n### 2.2.1 v-bind的介绍\n\n* 作用：动态绑定属性\n* 缩写：:\n* 预期：any (with argument) | Object (without argument)\n* 参数：attrOrProp (optional)\n\n### 2.2.2 v-bind的基础\n\n* v-bind用于绑定一个或多个属性值，或者向另一个组件传递props值\n\n* 在开发中，有哪些属性需要动态进行绑定呢？\n\n  * 还是有很多的，比如图片的链接src、网站的链接href、动态绑定一些类、样式等等\n\n* 比如通过Vue实例中的data绑定元素的src和href，代码如下：\n\n  ```html\n  <div id=\"app\">\n      <!-- 错误的写法：这里的musache语法是不会被解析的 -->\n      <!-- <img src=\"{{imgurl}}\" width=\"100dp\" height=\"100dp\"> -->\n      <!-- 正确的写法：使用v-bind命令动态绑定图片 -->\n      <img v-bind:src=\"imgurl\" width=\"100dp\" height=\"100dp\">\n      <a v-bind:href=\"ahref\" alt=\"\">百度一下</a>\n  </div>\n  <script src=\"../../js/vue.js\"></script>\n  <script>\n      const app = new Vue({\n          el: '#app',\n          data: {\n              imgurl: 'https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2604121389,1182698286&fm=15&gp=0.jpg',\n              ahref: 'http://www.baidu.com'\n          }\n      });\n  </script>\n  ```\n\n* 效果\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-13.png)\n\n### 2.2.3 v-bind的语法糖\n\n* 上述v-bind代码可以替换成语法糖的简写方式，效果一样\n\n  ```html\n  <img :src=\"imgurl\" width=\"100dp\" height=\"100dp\">\n  <a :href=\"ahref\" alt=\"\">百度一下</a> \n  ```\n\n### 2.2.4 绑定class\n\n* 很多时候，我们希望动态的来切换class，比如：\n  * 当数据为某个状态时，字体显示红色。\n  * 当数据另一个状态时，字体显示黑色。\n* 绑定class有两种方式：\n  * 对象语法\n  * 数组语法\n* 绑定方式：对象语法\n  * 对象语法的含义是:class后面跟的是一个对象。\n* 对象语法有下面这些用法：\n\n```html\n<!--  用法一：直接通过{}绑定一个类-->\n<h2 :class=\"{'active': isActive}\">Hello World</h2>\n\n<!--用法二：也可以通过判断，传入多个值-->\n<h2 :class=\"{'active': isActive, 'line': isLine}\">Hello World</h2>\n\n<!--用法三：和普通的类同时存在，并不冲突\n注：如果isActive和isLine都为true，那么会有title/active/line三个类-->\n<h2 class=\"title\" :class=\"{'active': isActive, 'line': isLine}\">Hello World</h2>\n\n<!--用法四：如果过于复杂，可以放在一个methods或者computed中\n注：classes是一个计算属性-->\n<h2 class=\"title\" :class=\"classes\">Hello World</h2>\n```\n\n* 绑定方式：数组语法\n  * 数组语法的含义是:class后面跟的是一个数组。\n* 数组语法有下面这些用法：\n\n```html\n<!--用法一：直接通过{}绑定一个类-->\n<h2 :class=\"['active']\">Hello World</h2>\n\n<!--用法二：也可以传入多个值-->\n<h2 :class=“[‘active’, 'line']\">Hello World</h2>\n\n<!--用法三：和普通的类同时存在，并不冲突\n注：会有title/active/line三个类-->\n<h2 class=\"title\" :class=“[‘active’, 'line']\">Hello World</h2>\n\n<!--用法四：如果过于复杂，可以放在一个methods或者computed中\n注：classes是一个计算属性-->\n<h2 class=\"title\" :class=\"classes\">Hello World</h2>\n```\n\n### 2.2.5 绑定样式style\n\n* 我们可以利用v-bind:style来绑定一些CSS内联样式。\n\n* 在写CSS属性名的时候，比如font-size\n\n  * 我们可以使用驼峰式 (camelCase)  fontSize \n  * 或短横线分隔 (kebab-case，记得用单引号括起来) ‘font-size’\n\n* 绑定class有两种方式：\n\n  * 对象语法\n  * 数组语法\n\n* 绑定方式一：对象语法\n\n  * style后面跟的是一个对象类型\n    * 对象的key是CSS属性名称\n    * 对象的value是具体赋的值，值可以来自于data中的属性\n\n  ```html\n  <div id=\"app\">\n      <!-- <h2 :style=\"{key(属性名): value(属性值)}\">{{message}}</h2> -->\n      <!-- fontSize和font-size的属性名效果相同 key只会当作属性解析不需要加上单引号  -->\n      <!-- 注意：属性值在vue中要加单引号，不加单引号的会以变量解析。key只会当作属性解析不需要加上单引号 -->\n      <h2 :style=\"{fontSize: '50px'}\">{{message}}</h2>\n      <h2 :style=\"{fontSize: finalSize + 'px',backgroundColor: finalColor}\">{{message}}</h2>\n      <h2 :style=\"getStyle()\">{{message}}</h2>\n  </div>\n  \n  <script src=\"../../js/vue.js\"></script>\n  <script>\n      const app = new Vue({\n          el: '#app',\n          data: {\n              message: '你好',\n              finalSize: 100,\n              finalColor: 'red'\n          },\n          methods: {\n  \n              getStyle: function(){\n                  return  {fontSize: this.finalSize + 'px',backgroundColor: this.finalColor}\n              }\n          }\n      });\n  </script>\n  ```\n\n* 绑定方式二：数组语法\n\n  * style后面跟的是一个数组类型\n    * 多个值以，分割即可\n\n  ```html\n  <div id=\"app\">\n      <h2 :style=\"[baseStyle,finalStyle]\">{{message}}</h2>\n  </div>\n  \n  <script src=\"../../js/vue.js\"></script>\n  <script>\n      const app = new Vue({\n          el: '#app',\n          data: {\n              message: '你好',\n              baseStyle: {backgroundColor: 'red'},\n              finalStyle: {fontSize: '100px'}\n          }\n  \n      });\n  </script>\n  ```\n\n## 补充：计算属性computed\n\n### 基础使用\n\n* 我们知道，在模板中可以直接通过插值语法显示一些data中的数据。\n* 但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示\n  * 比如我们有firstName和lastName两个变量，我们需要显示完整的名称。\n  * 但是如果多个地方都需要显示完整的名称，我们就需要写多个{{firstName}} {{lastName}}\n* 我们可以将上面的代码换成计算属性：\n  * OK，我们发现计算属性是写在实例的computed选项中的。\n\n```html\n<div id=\"app\">\n    <h2 >{{firstname + ' ' + finalname}}</h2>\n    <!-- 计算属性使用时不需要加上() -->\n    <h2 >{{fullname}}</h2>\n</div>\n<script src=\"../../js/vue.js\"></script>\n<script>\n    const app = new Vue({\n        el: '#app',\n        data: {\n            firstname: 'zhou',\n            finalname: 'jack'\n        },\n        // computed是vue的一个属性，主要定义一些和计算相关的工作。类似于方法但又不同于方法\n        // 此属性中的方法的返回值被当作自定义属性的值，不如fullname属性的值就是返回值    \n        computed: {\n            fullname: function(){\n                return this.firstname + ' ' + this.finalname\n            }\n        }\n\n    });\n</script>\n```\n\n### get和set\n\n* 每个计算属性都包含一个getter和一个setter\n  * 在上面的例子中，我们只是使用getter来读取。\n  * 在某些情况下，你也可以提供一个setter方法（不常用）。\n* 在需要写setter的时候，代码如下\n\n```html\n<div id=\"app\">\n    <h2 >{{firstname + ' ' + finalname}}</h2>\n\n    <h2 >{{fullname}}</h2>\n</div>\n<script src=\"../../js/vue.js\"></script>\n<script>\n    const app = new Vue({\n        el: '#app',\n        data: {\n            firstname: 'zhou',   \n            finalname: 'jack'\n        },\n        computed: {\n            // 默认情况\n            //计算属性一般没有set方法，因为不常使用。因此计算属性相当于只读属性\n            fullname: {\n                //newValue是默认的不可改变\n                set: function(newValue){\n                    const names = newValue.split(' ');\n                    this.firstname = names[0];\n                    this.finalname = names[1];\n                },\n                get: function(){\n                    return this.firstname + ' ' + this.finalname;\n                }\n            }\n            //没有set方法后，计算属性可以简写为\n            // fullname: function(){\n            //         return this.firstname + ' ' + this.finalname\n            // }\n        }\n    });\n</script>\n```\n\n### 和methods的区别\n\n* 我们可能会考虑这样的一个问题：\n  * methods和computed看起来都可以实现我们的功能，\n  * 那么为什么还要多一个计算属性这个东西呢？\n  * 原因：计算属性会进行缓存，如果多次使用computed属性时，计算属性只会调用一次。\n* 我们来看下面的代码：\n\n```html\n<div id=\"app\">\n    <!--方法一：语法太繁琐，不推荐使用  -->\n    <h2 >{{firstname + ' ' + finalname}}</h2>\n    <!-- 方法二:使用methods。特点：当有多个方法调用时，方法会多次调用。不推荐使用 -->\n    <h2 >{{name()}}</h2>\n    <h2 >{{name()}}</h2>\n    <h2 >{{name()}}</h2>\n    <h2 >{{name()}}</h2>\n    <!--方法三：使用computed。特点：当有多个属性被使用时，属性的方法只会被调用一次。推荐使用 -->\n    <h2 >{{fullname}}</h2>\n    <h2 >{{fullname}}</h2>\n    <h2 >{{fullname}}</h2>\n    <h2 >{{fullname}}</h2>\n</div>\n<script src=\"../../js/vue.js\"></script>\n<script>\n    const app = new Vue({\n        el: '#app',\n        data: {\n            firstname: 'zhou',   \n            finalname: 'jack'\n        },\n        computed: {\n\n            fullname: function(){\n                return this.firstname + ' ' + this.finalname\n            }\n        },\n        methods: {\n            name: function(){\n                return this.firstname + ' ' + this.finalname\n            } \n        }           \n    });\n</script>\n```\n\n## 补充：ES6语法\n\n### 块级作用域\n\n* 事实上var的设计可以看成JavaScript语言设计上的错误. 但是这种错误多半不能修复和移除, 以为需要向后兼容.\n  * 大概十年前, Brendan Eich就决定修复这个问题, 于是他添加了一个新的关键字: let.\n  * 我们可以将let看成更完美的var\n* 块级作用域\n  * JS中使用var来声明一个变量时, 变量的作用域主要是和函数的定义有关.\n  * 针对于其他块定义来说是没有作用域的，比如if/for等，这在我们开发中往往会引起一些问题。\n\n```html\n<button>按钮1</button>\n<button>按钮2</button>\n<button>按钮3</button>\n<button>按钮4</button>\n<button>按钮5</button>\n<script>\n  //es5没有(if/for)块级作用域\n  //es6有(if/for) 块级作用域\n  var btns = document.getElementsByTagName('button');\n  // es5写法：在解析下面代码时会有五个按钮触发的事件，\n  // 当循环走完时，i为5，按钮被触发时，打印的i都是5\n  //缺点：五个按钮都会打印5\n  // for (var i = 0; i < btns.length; i++) {\n  //     btns[i].addEventListener('click',function(){\n  //         console.log(i);\n  //     });\n  // }\n  //es6写法：在解析下面代码时会有五个按钮触发的事件，按钮被触发时，打印的i为当前循环的i\n  for (let i = 0; i < btns.length; i++) {\n    btns[i].addEventListener('click',function(){\n      console.log(i);\n    });\n  }\n  var name='asd';\n  {\n    var  name=\"asdf\";\n  }\n  //打印\"asdf\"\n  console.log(name);\n  let name='asd';\n  {\n    let  name=\"asdf\";\n  }\n  //打印\"asd\"\n  console.log(name);\n```\n\n### const的使用\n\n* const关键字\n  * 在很多语言中已经存在, 比如C/C++中, 主要的作用是将某个变量修饰为常量.\n  * 在JavaScript中也是如此, 使用const修饰的标识符为常量, 不可以再次赋值.\n* 什么时候使用const呢?\n  * 当我们修饰的标识符不会被再次赋值时, 就可以使用const来保证数据的安全性.\n  * 建议: 在ES6开发中,优先使用const, 只有需要改变某一个标识符的时候才使用let. \n* const的注意:\n\n```js\n//注意一：一旦给const修饰的标识符被赋值后，不能修改。\nconst name=\"ASd\";\n//这里会报错，因为重新赋值了\n//name=\"asdf\";\nconsole.log(name);\n//注意二：在使用const定义标识符后，编写赋值\n//const a;\n\n//注意三：const定义的一般为常量，如果这个常量是个对象的话，\n//这个常量指向的对象不能修改，但可以修改对象内部的属性值\nconst obj={\n  name: 'asd',\n  age: 18\n};\nobj.name='asdfr';\nobj.age=20;\n```\n\n### 对象字面量增强\n\n```js\n//1.属性的增强\n//es5之前\n// let name='asd';\n// let age=18;\n// let obj = {\n//     name: name,\n//     age: age\n// };\n// console.log(obj);\n//es6时\nlet name='asd';\nlet age=18;\nlet obj = {\n  name,\n  age\n};\nconsole.log(obj);\n//2.函数的增强\n//es5之前\nlet person = {\n  run: function(){  },\n  eat: function(){  }\n};\n//es6时\nlet person2 = {\n  run(){  },\n  eat(){  }\n};\n```\n\n## 2.3 事件监听\n\n### 2.3.1 v-on介绍\n\n* 在前端开发中，我们需要经常和用于交互。\n  * 这个时候，我们就必须监听用户发生的时间，比如点击、拖拽、键盘事件等等\n  * 在Vue中如何监听事件呢？使用v-on指令\n* v-on介绍\n  * 作用：绑定事件监听器\n  * 缩写：@\n  * 预期：Function | Inline Statement | Object\n  * 参数：event\n\n### 2.3.2 v-on基础\n\n```html\n<div id=\"app\">\n  <h2>{{count}}</h2>\n  <!-- v-on:为基本写法，click表示监听点击事件 -->\n  <!-- 方式一，按钮中写表达式 -->\n  <button v-on:click=\"count++\">+</button>\n  <button v-on:click=\"count--\">-</button>\n  <!-- 方法二：使用方法包装  此处的increment表示方法名-->\n  <button v-on:click=\"increment\">+</button>\n  <button v-on:click=\"decrement\">-</button>\n  <!-- v-on:的语法糖形式 @ -->\n  <button @click=\"increment\">+</button>\n  <button @click=\"decrement\">-</button>\n</div>\n<script src=\"../../js/vue.js\"></script>\n<script>\n  const app = new Vue({\n    el: '#app',\n    data: {\n      count: 0\n    },\n    methods: {\n      increment() {\n        this.count++;\n      },\n      decrement() {\n        this.count--;\n      }\n    }\n  });\n</script>\n```\n\n### 2.3.3 v-on参数\n\n* 当通过methods中定义方法，以供@click调用时，需要注意参数问题：\n* 情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。\n  * 但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去\n* 情况二：如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件。\n\n```html\n<div id=\"app\">\n  <!-- 注意：方法传参时，带''的表示值，不带''表示是个变量 -->\n  <!-- 1.在事件监听中当方法没有参数则可以不添加()。 -->\n  <button @click=\"butnclick1\">按钮1</button>\n  <!-- 2.在js中当函数需要参数时，但是没有传参，则默认参数值为undefined\n\t\t但是在vue中，当函数有多个参数时，第一个参数会传入浏览器产生的event对象\n\t\t其他参数都是undefined。 -->\n  <button @click=\"butnclick2\">按钮2</button>\n  <!-- 3.方法定义时，即需要event对象又需要传入其他参数，\n\t\t则再调用方法时使用$event获取浏览器产生的event对象。 -->\n  <button @click=\"butnclick3($event,'asd')\">按钮3</button>\n  <!--  -->\n  <button @click=\"butnclick4\">按钮4</button>\n</div>\n<script src=\"../../js/vue.js\"></script>\n<script>\n  const app = new Vue({\n    el: '#app',\n    data: {\n      count: 0\n    },\n    methods: {\n      butnclick1() {\n        console.log('butnclick1');\n      },\n      butnclick2(event,name) {\n        //建议当方法有参数时，第一个参数名写event\n        console.log(event);\n        console.log(name);\n      },\n      butnclick3(event,name) {\n        console.log(event);\n        console.log(name);\n      },\n      butnclick4(event) {\n        console.log(event);\n      } \n    }\n  });\n\n  function asd(name){\n    console.log(name);\n  };\n  asd();\n</script>\n```\n\n### 2.3.4 v-on修饰符\n\n* 在某些情况下，我们拿到event的目的可能是进行一些事件处理。\n* Vue提供了修饰符来帮助我们方便的处理一些事件：\n  * .stop - 调用 event.stopPropagation()。\n  * .prevent - 调用 event.preventDefault()。\n  * .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。\n  * .native - 监听组件根元素的原生事件。\n  * .once - 只触发一次回调。\n\n```html\n<div id=\"app\">\n  <!-- .stop修饰符的使用：阻止冒泡事件的发生。\n\t\t冒泡事件：当点击按钮时，按钮的监听事件发生了，\n\t\t但是按钮的父级的监听事件也会发生 -->\n  <div @click=\"divClcik\">\n    aaaaaa\n    <button @click.stop=\"btnClick\">按钮</button>\n  </div>\n  <br>\n  <!-- .prevent修饰符的使用：阻止默认事件的使用 -->\n  <form action=\"baudu\">\n    <!-- 不加修饰符时，点击后会自动提交，加修饰符后点击后不提交 -->\n    <input type=\"submit\" value=\"提交\" @click.prevent=\"submitClick\">\n  </form>\n  <!-- 监听键盘某个按键的点击。\n\t\t格式：.{keyCode/keyAlias}  keyCode表示按键的编码。keyAlias表示按键的别名 -->\n  <input type=\"text\" @keyup.enter=\"keyup\">\n  <!-- .once修饰符的使用：当前监听事件只执行一起，再触发也没反应 -->\n  <button @click.once=\"btn2Click\">按钮2</button>\n\n</div>\n<script src=\"../../js/vue.js\"></script>\n<script>\n  const app = new Vue({\n    el: '#app',\n    data: {\n\n    },\n    methods: {\n      divClcik() {\n        console.log('divClcik');\n      },\n      btnClick() {\n        console.log(\"btnClick\");\n      },\n      submitClick() {\n        console.log(\"submitClick\");\n      },\n      keyup() {\n        console.log(\"keyup\");\n      },\n      btn2Click() {\n        console.log(\"btn2Click\");\n      }\n    }\n  });\n</script>\n```\n\n## 2.4 条件和循环\n\n### 2.4.1 v-if和else-if和else条件渲染\n\n* v-if、v-else-if、v-else\n  * 这三个指令与JavaScript的条件语句if、else、else if类似。\n  * Vue的条件指令可以根据表达式的值在DOM中渲染或销毁元素或组件\n\n```html\n<div id=\"app\">\n  <!-- v-else后面不用加= -->\n  <h2 v-if=\"isShow\">为true显示</h2>\n  <h2 v-else>为false显示</h2>\n  <!-- 成绩的显示 -->\n  <h2 v-if=\"score >= 90\">A</h2>\n  <h2 v-else-if=\"score >= 80\">B</h2>\n  <h2 v-else-if=\"score >= 70\">C</h2>\n  <h2 v-else-if=\"score >= 60\">D</h2>\n  <h2 v-else>E</h2>\n</div>\n<script src=\"../../js/vue.js\"></script>\n<script>\n  const app = new Vue({\n    el: '#app',\n    data: {\n      isShow: true,\n      score: 95\n    }\n  });\n</script>\n```\n\n* v-if的原理：\n  * v-if后面的条件为false时，对应的元素以及其子元素不会渲染。\n  * 也就是根本没有不会有对应的标签出现在DOM中。\n\n### 2.4.2 v-show指令\n\n* v-show的用法和v-if非常相似，也用于决定一个元素是否渲染：\n\n```html\n<div id=\"app\">\n  <h2 v-show=\"isShow\">aaa</h2>\n</div>\n<script src=\"../../js/vue.js\"></script>\n<script>\n  const app = new Vue({\n    el: '#app',\n    data: {\n      isShow: true,\n      score: 95\n    }\n  });\n</script>\n```\n\n**v-if和v-show对比**\n\n* v-if和v-show都可以决定一个元素是否渲染，那么开发中我们如何选择呢？\n  * v-if当条件为false时，压根不会有对应的元素在DOM中。\n  * v-show当条件为false时，仅仅是将元素的display属性设置为none而已。\n* 开发中如何选择呢？\n  * 当需要在显示与隐藏之间切片很频繁时，使用v-show\n  * 当只有一次切换时，通过使用v-if\n\n### 2.4.3 v-for指令\n\n* 当我们有一组数据需要进行渲染时，我们就可以使用v-for来完成。\n  * v-for的语法类似于JavaScript中的for循环。\n  * 格式如下：item in items的形式。\n* 如果在遍历的过程中不需要使用索引值\n  * v-for=\"movie in movies\"\n  * 依次从movies中取出movie，并且在元素的内容中，我们可以使用Mustache语法，来使用movie\n* 如果在遍历的过程中，我们需要拿到元素在数组中的索引值呢？\n  * 语法格式：v-for=(item, index) in items\n  * 其中的index就代表了取出的item在原数组的索引值。\n* v-for可以用户遍历对象：\n  * 比如某个对象中存储着你的个人信息，我们希望以列表的形式显示出来。\n\n```html\n<div id=\"app\">\n  <!-- 在使用v-for时，推荐绑定key，并且将遍历的值作为key的值。作用是提高增删改查数据的效率 -->\n\n  <!-- 数组中能够做到响应式的方法：push(),pop(),shift(),unshift(),splice(),sort(),reverse() -->\n\n  <!-- 遍历数组 -->\n  <!-- 方式一：没有索引(下标)值 -->\n  <li v-for=\"items in names\" :key=\"items\">{{items}}</li><br>\n  <!-- 方式二：有索引(下标)值 -->\n  <li v-for=\"(items,index) in names\" :key=\"items\">{{index}} {{items}}</li><br>\n  <!-- 遍历对象 -->\n  <!-- 方法一：在遍历对象时，如果只读取一个值，那么获取到的是value -->\n  <li v-for=\"items in info\" :key=\"items\">{{items}}</li><br>\n  <!-- 方式二：获取对象的key和value -->\n  <li v-for=\"(value,key) in info\" :key=\"items\">{{value}} -- {{key}}</li><br>\n  <!-- 方式三：获取value,key,index -->\n  <li v-for=\"(value,key,index) in info\" :key=\"items\">{{value}} - {{key}} - {{index}}</li><br>\n</div>\n<script src=\"../../js/vue.js\"></script>\n<script>\n  const app = new Vue({\n    el: '#app',\n    data: {\n      names: ['a','b','c','d'],\n      info: {\n        name: 'asd',\n        age: 18,\n        sex: '男'\n      }\n    }\n  });\n</script>\n```\n\n* 官方推荐我们在使用v-for时，给对应的元素或组件添加上一个:key属性。\n* 为什么需要这个key属性呢（了解）？\n  * 这个其实和Vue的虚拟DOM的Diff算法有关系。\n  * 这里我们借用React’s diff algorithm中的一张图来简单说明一下：\n* 当某一层有很多相同的节点时，也就是列表节点时，我们希望插入一个新的节点\n  * 我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的。\n  * 即把C更新成F，D更新成C，E更新成D，最后再插入E，是不是很没有效率？\n* 所以我们需要使用key来给每个节点做一个唯一标识\n  * Diff算法就可以正确的识别此节点\n  * 找到正确的位置区插入新的节点。\n* 所以一句话，key的作用主要是为了高效的更新虚拟DOM。\n* 因为Vue是响应式的，所以当数据发生变化时，Vue会自动检测数据变化，视图会发生对应的更新。\n* Vue中包含了一组观察数组编译的方法，使用它们改变数组也会触发视图的更新。\n\n## 补充：高阶函数的应用\n\n* for循环的升级使用\n\n  ```js\n  let nums = ['a','b','c','d','e'];\n  // 普通的for循环\n  for (let i = 0; i < nums.length; i++) {\n    console.log(nums[i]);\n  \n  }\n  // 升级后的for循环：index表示下标\n  for (const index in nums) {\n    console.log(nums[index]);\n  }\n  // 再次升级后的for循环：item表示数组中的每一个元素\n  for (const item of nums) {\n    console.log(item);\n  }\n  ```\n\n* 数组的三个高阶函数\n\n  ```js\n  const nums = [1,2,3,4,5,6,7,8];\n  // 过滤函数：filter\n  // 过滤函数会拿到数组的每一个元素，并根据过滤器的返回值判断是否将\n  // 这个元素放到新数组中。\n  // 参数：过滤器函数。返回值：新数组\n  // 过滤器函数只能返回true或false。参数为数组的每一个元素\n  //实现获取数组中小于5的数。\n  let newNums1 = nums.filter(function(n){ return n<5; });\n  console.log(newNums1);\n  \n  //map函数：可以对数组中每一个元素进行操作\n  //实现将数组中的每一个元素都扩大一倍。\n  let newNums2 = newNums1.map(function(n){ return n*2; });\n  console.log(newNums2);\n  \n  //reduce函数：可以对数组中的值进行汇总\n  // 此函数的参数有两个，第一个为汇总函数，第二个默认为0。\n  // 第二个参数会作为第一次执行汇总函数的第一个参数的值\n  // 汇总函数有两个参数。第一个参数为上一次执行汇总函数的返回值，第二个参数为当前数组的元素。\n  //实现对数组的求和\n  let sum = newNums2.reduce(function (preValue,n) {\n    return preValue + n;\n  },0);\n  console.log(sum);\n  \n  //对上述函数的总结使用\n  let sum2 = nums.filter(function(n){\n    return n<5;\n  }).map(function(n){\n    return n*2;\n  }).reduce(function(preVlue,n){\n    return n+preVlue;\n  },0);\n  console.log(sum2);\n  //升级为箭头函数\n  let sum3 = nums.filter(n => n<5).map(n => n*2).reduce((preValue,n) => n+preValue);\n  console.log(sum3);\n  ```\n\n## 2.5 表单绑定\n\n### 2.5.1 基本使用\n\n* 表单控件在实际开发中是非常常见的。特别是对于用户信息的提交，需要大量的表单。\n* Vue中使用v-model指令来实现表单元素和数据的双向绑定。\n* 案例的解析：\n  * 当我们在输入框输入内容时\n  * 因为input中的v-model绑定了message，所以会实时将输入的内容传递给message，message发生改变。\n  * 当message发生改变时，因为上面我们使用Mustache语法，将message的值插入到DOM中，所以DOM会发生响应的改变。\n  * 所以，通过v-model实现了双向的绑定。\n* 当然，我们也可以将v-model用于textarea元素\n\n```html\n<div id=\"app\">\n  <input type=\"text\" v-model=\"message\">\n  <!-- 等价于 -->\n  <input type=\"text\" :value=\"message\" @input=\"valueChange\">\n  <input type=\"text\" :value=\"message\" @input=\"message = $event.target.value\">\n  <h1>{{message}}</h1>\n</div>\n<script src=\"../../js/vue.js\"></script>\n<script>\n  const app = new Vue({\n    el: '#app',\n    data: {\n      message: '你好'\n    },\n    methods: {\n      valueChange(event) {\n        this.message = event.target.value;\n      }\n    }\n  });\n</script>\n```\n\n### 2.5.2 v-model原理\n\n* v-model其实是一个语法糖，它的背后本质上是包含两个操作：\n\n  * 1.v-bind绑定一个value属性\n  * 2.v-on指令给当前元素绑定input事件\n\n  ```html\n  <input type=\"text\" v-model=\"message\">\n  <!-- 等价于 -->\n  <input type=\"text\" :value=\"message\" @input=\"valueChange\">\n  <input type=\"text\" :value=\"message\" @input=\"message = $event.target.value\">\n  ```\n\n### 2.5.3 和其他输入类型的使用\n\n* 复选框checkbox分为两种情况：单个勾选框和多个勾选框\n  * 单个勾选框：\n    * v-model即为布尔值。\n    * 此时input的value并不影响v-model的值。\n  * 多个复选框：\n    * 当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组。\n    * 当选中某一个时，就会将input的value添加到数组中。\n\n* 和checkbox一样，select也分单选和多选两种情况。\n  * 单选：只能选中一个值。\n    * v-model绑定的是一个值。\n    * 当我们选中option中的一个时，会将它对应的value赋值到mySelect中\n  * 多选：可以选中多个值。\n    * v-model绑定的是一个数组。\n    * 当选中多个值时，就会将选中的option对应的value添加到数组mySelects中\n\n```html\n<div id=\"app\">\n  <!-- 和radio单选框的结合使用 -->\n  <!-- 一般情况下，radio的互斥需要定义name，在有v-model后可以不需要定义name也可以保持互斥条件 -->\n  <label for=\"male\"><input type=\"radio\" value=\"男\" id=\"male\" v-model=\"sex\">男</label>\n  <label for=\"female\"><input type=\"radio\" value=\"女\" id=\"female\" v-model=\"sex\">女</label>\n  <h1>{{sex}}</h1>\n\n  <!-- 和checkbox复选框的使用 -->\n  <!-- 单个复选框：绑定的值为布尔型 -->\n  <label for=\"agree\"> <input type=\"checkbox\" id=\"agree\" v-model=\"isAgree\">请选择协议</label>\n  <button :disabled=\"!isAgree\">下一步</button>\n  <!-- 多个复选框：绑定的值为数组类型 -->\n  <input type=\"checkbox\"  value=\"篮球\" v-model=\"hobbies\">篮球\n  <input type=\"checkbox\"  value=\"羽毛球\" v-model=\"hobbies\">羽毛球\n  <input type=\"checkbox\"  value=\"足球\" v-model=\"hobbies\">足球\n  <input type=\"checkbox\"  value=\"乒乓球\" v-model=\"hobbies\">乒乓球\n  <h3>{{hobbies}}</h3>\n\n  <!-- 和select下拉框的使用 -->\n  <!-- 单选 -->\n  <select v-model=\"fruit\">\n    <option value=\"苹果\">苹果</option>\n    <option value=\"香蕉\">香蕉</option>\n    <option value=\"橘子\">橘子</option>\n  </select>\n  <h2>{{fruit}}</h2><br>\n  <!-- 多选 -->\n  <select v-model=\"fruits\" multiple>\n    <option value=\"苹果\">苹果</option>\n    <option value=\"香蕉\">香蕉</option>\n    <option value=\"橘子\">橘子</option>\n  </select>\n  <h2>{{fruits}}</h2>\n</div>\n<script src=\"../../js/vue.js\"></script>\n<script>\n  const app = new Vue({\n    el: '#app',\n    data: {\n      sex: '男',\n      isAgree: false,\n      hobbies: [],\n      fruit: '',\n      fruits:[]\n    }\n  });\n</script>\n```\n\n### 2.5.4 修饰符\n\n* lazy修饰符：\n  * 默认情况下，v-model默认是在input事件中同步输入框的数据的。\n  * 也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变。\n  * lazy修饰符可以让数据在失去焦点或者回车时才会更新：\n* number修饰符：\n  * 默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串类型进行处理。\n  * 但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。\n  * number修饰符可以让在输入框中输入的内容自动转成数字类型：\n* trim修饰符：\n  * 如果输入的内容首尾有很多空格，通常我们希望将其去除\n  * trim修饰符可以过滤内容左右两边的空格\n\n```html\n<div id=\"app\">\n  <!-- lazy修饰符的使用：当输入框失去焦点或按回车时才改变响应的数据 -->\n  <input type=\"text\" v-model.lazy=\"message\">\n  <h1>{{message}}</h1>\n  <!-- number修饰符的使用：保证输入框的数据类型是数字类型 -->\n  <!-- 但是当没有输入或输入+-等时，数据类型会变成string -->\n  <input type=\"number\" v-model.number=\"num\">\n  <h1>{{num}}  {{typeof num}}</h1>\n  <!-- trim修饰符的使用：取出输入的字符串后面的空格 -->\n  <input type=\"text\" v-model.trim=\"str\">\n  <h1>{{str}}</h1>\n</div>\n\n<script src=\"../../js/vue.js\"></script>\n<script>\n  const app = new Vue({\n    el: '#app',\n    data: {\n      message: 'asd',\n      num: 0,\n      str: 'asd'\n    }\n  });\n</script>\n```\n\n# 第三章：组件化开发\n\n## 3.1 认识组件化\n\n* 组件化的思想：\n  * 如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展。\n  * 但如果，我们讲一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易了。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210120220722.png)\n\n* 组件化是Vue.js中的重要思想\n\n  * 它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。\n  * 任何的应用都会被抽象成一颗组件树。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210120220840.png)\n\n* 组件化思想的应用：\n\n  * 有了组件化的思想，我们在之后的开发中就要充分的利用它。\n  * 尽可能的将页面拆分成一个个小的、可复用的组件。\n  * 这样让我们的代码更加方便组织和管理，并且扩展性也更强。\n\n## 3.2 注册组件\n\n### 3.2.1 注册的基本步骤\n\n* 组件的使用分成三个步骤：\n\n  * 创建组件构造器\n  * 注册组件\n  * 使用组件。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210120221356.png)\n\n* 这里的步骤都代表什么含义呢？\n\n* 1.Vue.extend()：\n\n  * 调用Vue.extend()创建的是一个组件构造器。 \n  * 通常在创建组件构造器时，传入template代表我们自定义组件的模板。\n  * 该模板就是在使用到组件的地方，要显示的HTML代码。\n\n* 事实上，这种写法在Vue2.x的文档中几乎已经看不到了，\n\n* 2.Vue.component()：\n\n  * 调用Vue.component()是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称。\n  * 所以需要传递两个参数：1、注册组件的标签名 2、组件构造器\n\n* 3.组件必须挂载在某个Vue实例下，否则它不会生效。\n\n```html\n<div id=\"app\">\n  <!-- 3.使用组件 -->\n  <my-cpn></my-cpn>\n</div>\n\n<script src=\"../../js/vue.js\"></script>\n<script>\n  //1.创建组件构造器\n  //template表示模板。`符号位于tab键上方，是es6新特性。能够换行编写字符串\n  const cpn = Vue.extend({\n    template: `\n<div>\n<h2> 我是标题</h2>\n<p>我是内容</p>\n<p>我是内容</p>\n  </div>`\n  });\n\n  //2.注册组件\n  //第一个为组件的名称，第二个为要注册的主键\n  Vue.component('my-cpn',cpn);\n\n  let app = new Vue({\n    el: '#app'\n  });\n</script>\n```\n\n### 3.2.2 全局组件和局部组件\n\n* 当我们通过调用Vue.component()注册组件时，组件的注册是全局的\n  * 这意味着该组件可以在任意Vue示例下使用。\n* 如果我们注册的组件是挂载在某个实例中, 那么就是一个局部组件\n\n```js\n//1.创建组件构造器\nconst cpn = Vue.extend({\n  template: `\n      <div>\n      <h2> 我是标题</h2>\n      <p>我是内容</p>\n      <p>我是内容</p>\n      </div>`\n});\n//2.注册组件\n//全局组件：可以在不同的vue实例中使用\nVue.component('my-cpn',cpn);\n\nlet app = new Vue({\n  el: '#app',\n  // 注册局部组件：只能在当前vue实例中使用\n  components: {\n    Mycpn: cpn\n  }\n});\n```\n\n### 3.2.3 父组件和子组件\n\n* 在前面我们看到了组件树：\n  * 组件和组件之间存在层级关系\n  * 而其中一种非常重要的关系就是父子组件的关系\n* 我们来看通过代码如何组成的这种层级关系：\n\n```html\n<script>\n  //创建组件构造器1(子组件)\n  const cpn1 = Vue.extend({\n    template: `\n      <div>\n        <h2> 我是标题1</h2>\n        <p>我是内容哈哈哈哈</p>\n      </div>`\n  });\n  //创建组件构造器2(父组件)\n  const cpn2 = Vue.extend({\n    template: `\n      <div>\n        <h2> 我是标题2</h2>\n        <p>我是内容呵呵呵</p>\n        <cpn1></cpn1>\n       </div>`,\n    // 加载了子组件，方便使用子组件的模板。但子组件仍未被注册\n    components: {\n      cpn1: cpn1\n    }\n  });\n  //vue实例可以是所有组件的父组件\n  let app = new Vue({\n    el: '#app',\n    // 注册局部组件：只能在当前vue实例中使用\n    components: {\n      Mycpn: cpn2\n    }\n  });\n</script>\n```\n\n* 父子组件错误用法：以子标签的形式在Vue实例中使用\n  * 因为当子组件注册到父组件的components时，Vue会编译好父组件的模块\n  * 该模板的内容已经决定了父组件将要渲染的HTML（相当于父组件中已经有了子组件中的内容了）\n  * \\<child-cpn>\\</child-cpn>是只能在父组件中被识别的。\n  * 类似这种用法，\\<child-cpn>\\</child-cpn>是会被浏览器忽略的。\n\n### 3.2.4 语法糖形式\n\n* 在上面注册组件的方式，可能会有些繁琐。\n  * Vue为了简化这个过程，提供了注册的语法糖。\n  * 主要是省去了调用Vue.extend()的步骤，而是可以直接使用一个对象来代替。\n* 语法糖注册全局组件和局部组件：\n\n```js\n//原来的写法\n//1.创建组件\nconst cpn1 = Vue.extend({\n  template: `\n      <div>\n        <h2> 我是标题1</h2>\n        <p>我是内容哈哈哈哈</p>\n      </div>`\n});\n//注册组件\nVue.component('mycpn1',cpn1);\n\n//语法糖的写法\nVue.component('mycpn2',{\n  template: `\n      <div>\n        <h2> 我是标题1</h2>\n        <p>我是内容哈哈哈哈</p>\n      </div>`\n})\n\n\nlet app = new Vue({\n  el: '#app',\n  // 局部组件原来的写法\n  // components: {\n  //   Mycpn: cpn2\n  // }\n  // 语法糖的写法\n  components: {\n    Mycpn: {\n      template: `\n      <div>\n        <h2> 我是标题1</h2>\n        <p>我是内容哈哈哈哈</p>\n      </div>`\n    }\n  }\n});\n```\n\n### 3.2.5 模板分离的写法\n\n* 刚才，我们通过语法糖简化了Vue组件的注册过程，另外还有一个地方的写法比较麻烦，就是template模块写法。\n* 如果我们能将其中的HTML分离出来写，然后挂载到对应的组件上，必然结构会变得非常清晰。\n* Vue提供了两种方案来定义HTML模块内容：\n  * 使用\\<script>标签\n  * 使用\\<template>标签\n\n```html\n<!-- 1.使用script标签定义模板 -->\n<script type=\"text/x-template\" id=\"cpn1\">\n<div>\n  <h2>我是标题1</h2>\n  </div>\n</script>\n<!-- 2.使用template标签定义模板 -->\n<template id=\"cpn2\">\n  <div>\n    <h2>我是标题2</h2>\n  </div>\n</template>\n\n<script src=\"../../js/vue.js\"></script>\n<script>\n  Vue.component('mycpn1',{\n    template: '#cpn1'\n  });\n  Vue.component('mycpn2',{\n    template: '#cpn2'\n  });\n  let app = new Vue({\n    el: '#app'\n  });\n</script>\n```\n\n### 3.2.6 组件的其他属性\n\n* 组件是一个单独功能模块的封装：\n  * 这个模块有属于自己的HTML模板，也应该有属性自己的数据data\n* 组件中的数据是保存在哪里呢？顶层的Vue实例中吗？\n  * 我们先来测试一下，组件中能不能直接访问Vue实例中的data。\n  * 我们发现不能访问，而且即使可以访问，如果将所有的数据都放在Vue实例中，Vue实例就会变的非常臃肿。\n  * 结论：Vue组件应该有自己保存数据的地方。\n* 组件自己的数据存放在哪里呢?\n  * 组件对象也有一个data属性(也可以有methods等属性，下面我们有用到)\n  * 只是这个data属性必须是一个函数\n  * 而且这个函数返回一个对象，对象内部保存着数据\n* 为什么data在组件中必须是一个函数呢?\n  * 首先，如果不是一个函数，Vue直接就会报错。\n  * 其次，原因是在于Vue让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响。\n\n```html\n<body>\n  <div id=\"app\">\n    <mycpn></mycpn>\n    <mycpn></mycpn>\n    <mycpn></mycpn>\n  </div>\n  <template id=\"cpn\">\n    <div>\n      <h2>{{counter}}</h2>\n      <button @click=\"add\">+</button>\n      <button @click=\"mov\">-</button>\n    </div>\n  </template>\n  <script src=\"../../js/vue.js\"></script>\n  <script>\n    //data数组只能存放在自己组件中。\n    //且data是一个函数，具体数据放在函数的返回对象中。\n    Vue.component('mycpn',{\n      template: '#cpn',\n      data() {\n        return {\n          counter: 0\n        }\n      },\n      methods: {\n        add(){\n          this.counter++;\n        },\n        mov(){\n          this.counter--;\n        }\n      }\n    });\n    let app = new Vue({\n      el: '#app'\n    });\n  </script>\n```\n\n## 3.3 组件间的数据传递\n\n* 在上一个小节中，我们提到了子组件是不能引用父组件或者Vue实例的数据的。\n* 但是，在开发中，往往一些数据确实需要从上层传递到下层：\n  * 比如在一个页面中，我们从服务器请求到了很多的数据。\n  * 其中一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示。\n  * 这个时候，并不会让子组件再次发送一个网络请求，而是直接让大组件(父组件)将数据传递给小组件(子组件)。\n* 如何进行父子组件间的通信呢？Vue官方提到\n  * 通过props向子组件传递数据\n  * 通过事件向父组件发送消息\n  \n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-14.png)\n\n### 3.3.1父级向子级传递\n\n* 在组件中，使用选项props来声明需要从父级接收到的数据。\n\n* props的值有两种方式：\n\n  * 方式一：字符串数组，数组中的字符串就是传递时的名称。\n  * 方式二：对象，对象可以设置传递时的类型，也可以设置默认值等。\n\n* 除了数组之外，我们也可以使用对象，当需要对props进行类型等验证时，就需要对象写法了。\n  验证都支持哪些数据类型呢？\n\n  * String；Number；Boolean；Array；Object；Date；Function；Symbol\n  * 当我们有自定义构造函数时，验证也支持自定义的类型。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210120222935.png)\n\n```html\n<div id=\"app\">\n  <!-- 使用子组件时，将信息传递给子组件属性。注意此处的写法 -->\n  <tem :tmessage=\"message\" :tmoves=\"moves\" :child-my-message=\"childMyMessage\"></tem>\n  {{moves}}\n</div>\n<template id=\"cpn\">\n  <div>\n    <ul>\n      <li v-for=\"items in tmoves\">{{items}}</li>\n    </ul>\n    <p>{{tmessage}}</p>\n    <p>{{childMyMessage}}</p>\n  </div>\n</template>\n<script src=\"../../js/vue.js\"></script>\n<script>\n  //1.父组件向子组件传递信息：方式一props\n  //注意事项：当子组件的属性命名形式为驼峰命名时，调用子组件的动态属性要用-将属性隔开。例如childMyMessage \n\n  //子组件\n  const tem = {\n    template: '#cpn',\n    //props的数组方式。数组的元素为信息的名\n    // props: ['tmessage','tmoves']\n\n    //props的对象方式\n    props: {\n      // 1.限制信息的类型\n      // tmessage: String,\n      // tmoves: Array\n\n      //2.不光限制类型还提供默认值，以及必传值\n      tmessage: {\n        type: String,\n        //default表示在父组件不传值时，子组件信息的默认值\n        default: 'aaaaa',\n        //required为true时，表示父组件必须给这个属性传值，如果不传值会报错 \n        required: true\n      },\n      //类型是对象或数组时，default必须是一个函数形式,默认值为函数的返回值。\n      tmoves: {\n        type: Array,\n        default() {\n          return ['a','b']\n        }\n      },\n      childMyMessage: {\n        type: String,\n        default: ''\n      }\n    }\n  };\n  //父组件\n  let app = new Vue({\n    el: '#app',\n    data: {\n      message: '你好',\n      moves: ['a','b','c','d'],\n      childMyMessage: '驼峰命名注意事项'\n    },\n    components: {\n      tem: tem\n    }\n  });\n</script>\n```\n\n### 3.3.2 子级向父级传递\n\n* 什么时候需要自定义事件呢？\n  * 当子组件需要向父组件传递数据时，就要用到自定义事件了。\n  * v-on不仅仅可以用于监听DOM事件，也可以用于组件间的自定义事件。\n* 自定义事件的流程：\n  * 在子组件中，通过$emit()来触发事件。\n  * 在父组件中，通过v-on来监听子组件事件。\n\n```html\n<div id=\"app\">\n  <!-- 父组件监听item-click事件，当此事件产生时调用父组件的itemClick函数 -->\n  <!-- 由于此事件是自定义事件，因此在不明确写参数时，默认参数的值不是event，而是子组件传递过来的值 -->\n  <!-- 此处的自定义事件有时可以使用驼峰命名法 -->\n  <tem @item-click=\"itemClick\"></tem>\n</div>\n<template id=\"cpn\">\n  <div>\n    <!-- 设置点击事件。点击后调用子组件中的btnClick函数 -->\n    <button v-for=\"item in menu\" @click=\"btnClick(item)\">{{item.name}}</button>\n  </div>\n</template>\n<script src=\"../../js/vue.js\"></script>\n<script>\n  //子组件传递数据给父组件：通过监听事件传递\n  //子组件的数据通过事件响应，在事件方法中发送一个自定义的事件并发送数据。\n  //父组件中使用这个自定义的事件，然后在事件方法中接受这个数据\n\n  //子组件\n  const tem = {\n    template: '#cpn',\n    data(){\n      return {\n        //数据为menu。是一个包含很多对象的数组\n        menu: [\n          {id: 1,name: '热门推荐'},\n          {id: 2,name: '手机数码'},\n          {id: 3,name: '家用家电'},\n          {id: 4,name: '电脑办公'}\n\n        ]\n      };\n    },\n    methods: {\n      btnClick(item){\n        //子组件向外发送一个名为itemc-click的事件。第二个参数是事件响应的数据\n        this.$emit('item-click',item);\n      }\n    }\n\n  };\n  //父组件\n  let app = new Vue({\n    el: '#app',\n    components: {\n      tem\n    },\n    methods: {\n      itemClick(item){\n        console.log(item);\n      }\n    }\n\n  });\n</script>\n```\n\n### 扩展：当使用v-model双向绑定数据时，子父组件间的数据传递方式\n\n```html\n<div id=\"app\">\n  <h2>{{num1}}</h2>\n  <tem :tnum1=\"num1\" @numchange=\"tnumChange\"></tem>\n</div>\n<template id=\"cpn\">\n  <div>\n    <h2>{{dnum1}}</h2>\n    <input type=\"text\" v-model=\"dnum1\">\n  </div>\n</template>\n<script src=\"../../js/vue.js\"></script>\n<script>\n  //子组件\n  const tem = {\n    template: '#cpn',\n    //props只能作用与接受父组件传来的数据，并且这个数据不建议进行改变\n    //如果要改变接受的数据，建议在data中在创建一个数据的副本\n    props: {\n      tnum1: Number\n    },\n    data(){\n      return {\n        dnum1: this.tnum1\n      };\n    },\n    //watch用于监听data中数据的变化，当数据发生变化时，会调用相关数据的函数。\n    //函数名要求和数据名一致。\n    watch:{\n      //newValue：表示改变后的数据\n      //oldValue：表示改变前的数据(可省略)\n      dnum1(newValue,oldValue){\n        this.$emit('numchange',newValue);\n      }\n    },\n  };\n  //父组件\n  let app = new Vue({\n    el: '#app',\n    data: {\n      num1: 1\n    },\n    components: {\n      tem\n    },\n    methods: {\n      //此处接受的是从子组件传递过来的值。\n      //value的类型是string类型的，因此在赋值给其他类型时，注意数据转换\n      tnumChange(value){\n        this.num1=parseInt(value);;\n      }\n    }\n\n  });\n</script>\n```\n\n### 3.3.3 父子组件的访问\n\n* 有时候我们需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问跟组件。\n  * 父组件访问子组件：使用$children或$refs\n  * 子组件访问父组件：使用$parent\n* 我们先来看下$children的访问\n  * this.$children是一个数组类型，它包含所有子组件对象。\n  * 我们这里通过一个遍历，取出所有子组件的message状态。\n\n```html\n<div id=\"app\">\n  <tem></tem>\n  <tem></tem>\n  <!--ref：相当于id，在使用refs时方便区分组件  -->\n  <tem ref=\"aaa\"></tem>\n  <button @click=\"btnClick\">按钮</button>\n</div>\n<template id=\"cpn\">\n  <div>\n    <h2>{{name}}</h2>\n  </div>\n</template>\n<script src=\"../../js/vue.js\"></script>\n<script>\n  //子组件\n  const tem = {\n    template: '#cpn',\n    data(){\n      return {\n        name: '子组件'\n      }\n    },\n    methods: {\n      showName(){\n        console.log('我是子组件');\n      }\n    }\n  };\n  //父组件\n  let app = new Vue({\n    el: '#app',\n    components: {\n      tem\n    },\n    methods: {\n      btnClick(){\n        //$children不建议使用，因为结果为数组，当添加子组件时，对数组下标的调用很难明确\n        //$children：值为当前组件的所有子组件对象的数组。子组件对象中含有子组件的所有信息。\n        // console.log(this.$children);\n        //打印第一个子组件的数据中的name\n        // console.log(this.$children[0].name);\n        //调用第一个子组件的showName方法\n        // this.$children[0].showName();\n\n        //$refs：获取当前组件的子组件，通过标识符区分\n        console.log(this.$refs.aaa);\n        //打印子组件的数据中的name\n        console.log(this.$refs.aaa.name);\n        //调用子组件的showName方法\n        this.$refs.aaa.showName();\n      }\n    }\n\n  });\n</script>\n```\n\n* $children的缺陷：\n  * 通过$children访问子组件时，是一个数组类型，访问其中的子组件必须通过索引值。\n  * 但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化。\n  * 有时候，我们想明确获取其中一个特定的组件，这个时候就可以使用$refs\n* $refs的使用：\n  * $refs和ref指令通常是一起使用的。\n  * 首先，我们通过ref给某一个子组件绑定一个特定的ID。\n  * 其次，通过this.$refs.ID就可以访问到该组件了。\n\n```html\n<!--同上$children的使用-->\n```\n\n* 如果我们想在子组件中直接访问父组件，可以通过$parent\n\n```html\n<div id=\"app\">\n  <h2>{{name}}</h2>\n  <tem ></tem>\n</div>\n<template id=\"cpn\">\n  <div>\n\n    <button @click=\"btnClick\">按钮</button>\n  </div>\n</template>\n\n<script src=\"../../js/vue.js\"></script>\n<script>\n  //子组件\n  const tem = {\n    template: '#cpn',\n    methods: {\n      btnClick(){\n        //$parent：访问当前组件的直系父组件。值为一个组件对象。\n        console.log(this.$parent);\n        this.$parent.showName('asd');\n        //$root：访问当前页面的根组件。即vue实例\n        console.log(this.$root);\n      }\n    }\n  };\n  //父组件\n  let app = new Vue({\n    el: '#app',\n    data: {\n      name: '父组件'\n    },\n    components: {\n      tem\n    },\n    methods: {\n      showName(value){\n        console.log(value);\n        console.log('我是父组件');\n      }\n    }\n\n  });\n</script>\n```\n\n* 注意事项：\n* 尽管在Vue开发中，我们允许通过$parent来访问父组件，但是在真实开发中尽量不要这样做。\n* 子组件应该尽量避免直接访问父组件的数据，因为这样耦合度太高了。\n* 如果我们将子组件放在另外一个组件之内，很可能该父组件没有对应的属性，往往会引起问题。\n* 另外，更不好做的是通过$parent直接修改父组件的状态，那么父组件中的状态将变得飘忽不定，很不利于我的调试和维护。\n\n### 3.3.4 非父子组件通信\n\n* 在Vue1.x的时候，可以通过$dispatch和$broadcast完成\n  * $dispatch用于向上级派发事件\n  * $broadcast用于向下级广播事件\n  * 但是在Vue2.x都被取消了\n* 在Vue2.x中，有一种方案是通过中央事件总线，也就是一个中介来完成。\n  * 但是这种方案和直接使用Vuex的状态管理方案还是逊色很多。\n  * 并且Vuex提供了更多好用的功能，所以这里我们暂且不讨论这种方案，后续我们专门学习Vuex的状态管理\n\n## 3.4 插槽slot\n\n### 3.4.1 编译作用域\n\n* 官方对于编译的作用域解析比较简单，我们自己来通过一个例子来理解这个概念：\n* 我们来考虑下面的代码是否最终是可以渲染出来的：\n  * \\<my-cpn v-show=\"isShow\">\\</my-cpn>中，我们使用了isShow属性。\n  * isShow属性包含在组件中，也包含在Vue实例中。\n* 答案：最终可以渲染出来，也就是使用的是Vue实例的属性。\n* 为什么呢？\n  * 官方给出了一条准则：父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。\n  * 而我们在使用<my-cpn v-show=\"isShow\"></my-cpn>的时候，整个组件的使用过程是相当于在父组件中出现的。\n  * 那么他的作用域就是父组件，使用的属性也是属于父组件的属性。\n  * 因此，isShow使用的是Vue实例中的属性，而不是子组件的属性。\n\n### 3.4.2 为什么使用slot\n\n* slot翻译为插槽：\n  * 在生活中很多地方都有插槽，电脑的USB插槽，插板当中的电源插槽。\n  * 插槽的目的是让我们原来的设备具备更多的扩展性。\n  * 比如电脑的USB我们可以插入U盘、硬盘、手机、音响、键盘、鼠标等等。\n* 组件的插槽：\n  * 组件的插槽也是为了让我们封装的组件更加具有扩展性。\n  * 让使用者可以决定组件内部的一些内容到底展示什么。\n* 例子：移动网站中的导航栏。\n  * 移动开发中，几乎每个页面都有导航栏。\n  * 导航栏我们必然会封装成一个插件，比如nav-bar组件。\n  * 一旦有了这个组件，我们就可以在多个页面中复用了。\n* 如何去封装这类的组件呢？\n  * 它们也很多区别，但是也有很多共性。\n  * 如果，我们每一个单独去封装一个组件，显然不合适：比如每个页面都返回，这部分内容我们就要重复去封装。\n  * 但是，如果我们封装成一个，好像也不合理：有些左侧是菜单，有些是返回，有些中间是搜索，有些是文字，等等。\n* 如何封装合适呢？抽取共性，保留不同。\n  * 最好的封装方式就是将共性抽取到组件中，将不同暴露为插槽。\n  * 一旦我们预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么内容。\n  * 是搜索框，还是文字，还是菜单。由调用者自己来决定。\n\n### 3.4.3 基本使用\n\n* 了解了为什么用slot，我们再来谈谈如何使用slot？\n  * 在子组件中，使用特殊的元素\\<slot>就可以为子组件开启一个插槽。\n  * 该插槽插入什么内容取决于父组件如何使用。\n* 我们通过一个简单的例子，来给子组件定义一个插槽：\n  * \\<slot>中的内容表示，如果没有在该组件中插入任何其他内容，就默认显示该内容\n  * 有了这个插槽后，父组件如何使用呢？\n\n```html\n<div id=\"app\">\n  <!-- \n当插槽没有名字时\n一：一个插槽内可以填充多个标签。\n二：当子组件的插槽内有默认标签时，父组件的填充物会替换调默认标签。\n如果父组件不填充，则显示默认标签。\n三：当插槽有多个时，父组件的填充物会填充填充每一个插槽。\n-->\n  <!-- button,h2,p等用于填充插槽 -->\n  <cpn></cpn>\n  <cpn><h2>文字</h2></cpn>\n  <cpn>\n    <h2>文字</h2>\n    <p>p元素</p>\n  </cpn>\n</div>\n\n<template id=\"cpn\">\n  <div>\n    <h2>子组件</h2>\n    <!-- slot为插槽标签 -->\n    <slot><button>默认按钮</button></slot>\n  </div>\n</template>\n\n<script src=\"../../js/vue.js\"></script>\n<script>\n  //子组件\n  const cpn = {\n    template: '#cpn'\n  };\n  //父组件\n  let app = new Vue({\n    el: '#app',\n    components: {\n      cpn\n    }\n  });\n</script>\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-15.png)\n\n### 3.4.4 具名插槽\n\n* 当子组件的功能复杂时，子组件的插槽可能并非是一个。\n  * 比如我们封装一个导航栏的子组件，可能就需要三个插槽，分别代表左边、中间、右边。\n  * 那么，外面在给插槽插入内容时，如何区分插入的是哪一个呢？\n  * 这个时候，我们就需要给插槽起一个名字\n* 如何使用具名插槽呢？\n  * 非常简单，只要给slot元素一个name属性即可\n  * \\<slot name='myslot'>\\</slot>\n\n```html\n<div id=\"app\">\n  <cpn><button slot=\"left\">左边按钮</button></cpn>\n  <cpn><h2 slot=\"right\">填充右边</h2></cpn>\n  <cpn>\n    <button slot=\"left\">左边按钮</button>\n    <h2 slot=\"center\">填充中间</h2>\n  </cpn>\n</div>\n\n<template id=\"cpn\">\n  <div>\n    <!-- 给插槽起名字，可以在填充给时指定填充哪个插槽 -->\n    <slot name=\"left\"><span >左边</span></slot>\n    <slot name=\"center\"><span >中间</span></slot>\n    <slot name=\"right\"><span >右边</span></slot>\n  </div>\n</template>\n\n<script src=\"../../js/vue.js\"></script>\n<script>\n  //子组件\n  const cpn = {\n    template: '#cpn'\n  };\n  //父组件\n  let app = new Vue({\n    el: '#app',\n    components: {\n      cpn\n    }\n  });\n</script>\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-16.png)\n\n### 3.4.5 作用域插槽\n\n* 作用域插槽是slot一个比较难理解的点，而且官方文档说的又有点不清晰。\n* 这里，我们用一句话对其做一个总结，然后我们在后续的案例中来体会：\n  * 父组件替换插槽的标签，但是内容由子组件来提供。\n* 我们先提一个需求：\n  * 子组件中包括一组数据，比如：pLanguages: ['JavaScript', 'Python', 'Swift', 'Go', 'C++']\n  * 需要在多个界面进行展示：\n    * 某些界面是以水平方向一一展示的，\n    * 某些界面是以列表形式展示的，\n    * 某些界面直接展示一个数组\n  * 内容在子组件，希望父组件告诉我们如何展示，怎么办呢？\n    * 利用slot作用域插槽就可以了\n* 我们来看看子组件的定义：\n* 在父组件使用我们的子组件时，从子组件中拿到数据：\n  * 我们通过\\<template slot-scope=\"slotProps\">获取到slotProps属性\n  * 在通过slotProps.data就可以获取到刚才我们传入的data了\n\n```html\n<div id=\"app\">\n  <cpn></cpn>\n\n  <cpn>\n    <!-- slot-scope为给子组件起个名字 -->\n    <template slot-scope=\"slot\">\n      <!-- 通过slot.data调用子组件的data数据。从而在父组件中使用子组件的数据 -->\n      <span v-for=\"item in slot.data\">{{item}} - </span>\n    </template>\n  </cpn>\n\n</div>\n\n<template id=\"cpn\">\n  <div>\n    <!-- 将nums数据绑定到子组件的data属性中。data可以是自定的名字 -->\n    <slot :data=\"nums\">\n      <ul>\n        <li v-for=\"item in nums\">{{item}}</li>\n      </ul>\n    </slot>\n  </div>\n</template>\n\n<script src=\"../../js/vue.js\"></script>\n<script>\n  //子组件\n  const cpn = {\n    template: '#cpn',\n    data(){\n      return {\n        nums: ['a','c','d','f']\n      };\n    }\n  };\n  //父组件\n  let app = new Vue({\n    el: '#app',\n    components: {\n      cpn\n    }\n  });\n</script>\n```\n\n## 3.5 动态组件\n\n## 3.6 异步组件\n\n## 3.7 组件的生命周期\n\n# 补充：前端模块化\n\n## JS模块化\n\n* 在网页开发的早期，js制作作为一种脚本语言，做一些简单的表单验证或动画实现等，那个时候代码还是很少的。\n\n  * 那个时候的代码是怎么写的呢？直接将代码写在<script>标签中即可\n\n* 随着ajax异步请求的出现，慢慢形成了前后端的分离\n\n  * 客户端需要完成的事情越来越多，代码量也是与日俱增。\n  * 为了应对代码量的剧增，我们通常会将代码组织在多个js文件中，进行维护。\n  * 但是这种维护方式，依然不能避免一些灾难性的问题。\n\n* 比如全局变量同名问题：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-17.png)\n\n* 另外，这种代码的编写方式对js文件的依赖顺序几乎是强制性的\n\n  * 但是当js文件过多，比如有几十个的时候，弄清楚它们的顺序是一件比较同时的事情。\n  * 而且即使你弄清楚顺序了，也不能避免上面出现的这种尴尬问题的发生。\n\n### 匿名函数的解决方案\n\n* 我们可以使用匿名函数来解决方面的重名问题\n  * 在aaa.js文件中，我们使用匿名函数\n\n```js\n(function() {\n  var flag = true;\n})()\n```\n\n* 但是如果我们希望在main.js文件中，用到flag，应该如何处理呢？\n\n  * 显然，另外一个文件中不容易使用，因为flag是一个局部变量。\n\n* 我们可以使用将需要暴露到外面的变量，使用一个模块作为出口，什么意思呢？\n\n* 来看下对应的代码：\n\n  ```js\n  //小红编写的js\n  //(function (){})()表示匿名函数，且这个函数是立即执行的。\n  //匿名函数的作用可以避免不同人在编写代码时引起的变量冲突，方法冲突，逻辑冲突的情况\n  \n  var modeleA = (function (){\n    //创建一个空对象\n    var obj={};\n    var flag = true;\n    function sum(a,b){\n      return a+b;\n    }\n    //将这个js中的主要代码和方法赋给obj。并返回给全局变量modelA。\n    //这样在别的js文件中也能使用此js中的变量和方法\n    //下述代码被称为导出\n    obj.flag=flag;\n    obj.sum=sum;\n    return obj;\n  })()\n  ```\n\n* 我们做了什么事情呢？\n\n  * 非常简单，在匿名函数内部，定义一个对象。\n  * 给对象添加各种需要暴露到外面的属性和方法(不需要暴露的直接定义即可)。\n  * 最后将这个对象返回，并且在外面使用了一个MoudleA接受。\n\n* 接下来，我们在man.js中怎么使用呢？\n\n  ```js\n  //小红编写的另一个js\n  var modeleC = (function (){\n    //创建一个空对象\n    var obj={};\n  \n    //调用其他js中的变量和方法\n    console.log(modeleA.flag);\n    console.log(modeleA.sum(10,20));\n  \n    return obj;\n  })()\n  ```\n\n  * 我们只需要使用属于自己模块的属性和方法即可\n\n* 这就是模块最基础的封装，事实上模块的封装还有很多高级的话题：\n\n  * 但是我们这里就是要认识一下为什么需要模块，以及模块的原始雏形。\n  * 幸运的是，前端模块化开发已经有了很多既有的规范，以及对应的实现方案。\n\n* 常见的模块化规范：\n\n  * CommonJS、AMD、CMD，也有ES6的Modules\n\n## CommonJS模块化\n\n* 模块化有两个核心：导出和导入\n* CommonJS的导出：\n\n```js\n//小红编写的js\n\nvar flag = true;\n\nfunction sum(a,b){\n  return a+b;\n}\n//commonJS的导出。此方式需要node的底层框架支持\nmodule.exports = {\n  flag,\n  sum\n}\n```\n\n* CommonJS的导入\n\n```js\n//小红编写的另一个js\n//commonJS的导入\n// var modeleA= require('aaa.js');\n// var flag = modeleA.flag;\n// var sum = modeleA.sum;\n//等价于/简写成\nvar {flag,sum} = require('./aaa.js');\n\n//使用方法:直接使用即可\nconsole.log(flag);\n```\n\n## ES6的模块化\n\n* 我们使用export指令导出了模块对外提供的接口，下面我们就可以通过import命令来加载对应的这个模块了\n\n* 首先，我们需要在HTML代码中引入两个js文件，并且类型需要设置为module\n\n  ```html\n  <!-- type=\"module\"：将引用的文件作为一个单独的模块，各模块之间互不影响。能解决变量等重复的问题 -->\n  <script src=\"aaa.js\" type=\"module\"></script>\n  <script src=\"ccc.js\" type=\"module\"></script>\n  ```\n\n* import指令用于导入模块中的内容，比如main.js的代码\n\n* 如果我们希望某个模块中所有的信息都导入，一个个导入显然有些麻烦：\n\n  * 通过\\*可以导入模块中所有的export变量\n  * 但是通常情况下我们需要给\\*起一个别名，方便后续的使用\n\n* 导出\n\n```js\n//小红编写的js\n\nvar flag = true;\n\nfunction sum(a,b){\n  return a+b;\n}\n//ES6的导出方式:可以导出变量，函数，类\n//方式一：先定义后导出\nexport{\n  flag,sum\n}\n//方式二：在定义时就导出\nexport var str = '字符串';\n\n//方式三：在导出时不指定导出的名字，而是由导入者定义\n// 使用default。default导出的有且只能有一个\nvar address = \"河南\";\nexport default address;\n```\n\n* 导入\n\n```js\n//小红编写的另一个js\n//ES6的导入\nimport {flag} from './aaa.js';\nconsole.log(flag);\n//导入default导出的内容，定义为ads\nimport ads from './aaa.js';\nconsole.log(ads);\n//导入来自aaa.js文件的所有导出的数据。并赋予对象aaa\nimport * as aaa from './aaa.js';\nconsole.log(aaa.sum(10,30));\n```\n\n# 第四章：Vue CLI(脚手架)详解\n\n## 1.webpack\n\n### 1.认识webpack\n\n####   1> 什么是webpack\n\n* 我们先看看官方的解释：\n\n  * At its core, webpack is a static module bundler for modern JavaScript applications. \n  * 从本质上来讲，webpack是一个现代的JavaScript应用的静态模块打包工具。\n\n* 但是它是什么呢？用概念解释概念，还是不清晰。\n\n  * 我们从两个点来解释上面这句话：模块 和 打包\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-18.png)\n\n* 前端模块化：\n\n  * 在前面学习中，我已经用了大量的篇幅解释了为什么前端需要模块化。\n  * 而且我也提到了目前使用前端模块化的一些方案：AMD、CMD、CommonJS、ES6。\n  * 在ES6之前，我们要想进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发。\n  * 并且在通过模块化开发完成了项目后，还需要处理模块间的各种依赖，并且将其进行整合打包。\n  * 而webpack其中一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系。\n  * 而且不仅仅是JavaScript文件，我们的CSS、图片、json文件等等在webpack中都可以被当做模块来使用（在后续我们会看到）。\n  * 这就是webpack中模块化的概念。\n\n* 打包如何理解呢？\n\n  * 理解了webpack可以帮助我们进行模块化，并且处理模块间的各种复杂关系后，打包的概念就非常好理解了。\n  * 就是将webpack中的各种资源模块进行打包合并成一个或多个包(Bundle)。\n  * 并且在打包的过程中，还可以对资源进行处理，比如压缩图片，将scss转成css，将ES6语法转成ES5语法，将TypeScript转成JavaScript等等操作。\n  * 但是打包的操作似乎grunt/gulp也可以帮助我们完成，它们有什么不同呢？\n\n####   2> webpack和gulp对比\n\n* grunt/gulp的核心是Task\n\n  * 我们可以配置一系列的task，并且定义task要处理的事务（例如ES6、ts转化，图片压缩，scss转成css）\n  * 之后让grunt/gulp来依次执行这些task，而且让整个流程自动化。\n  * 所以grunt/gulp也被称为前端自动化任务管理工具。\n\n* 我们来看一个gulp的task\n\n  * 下面的task就是将src下面的所有js文件转成ES5的语法。\n  * 并且最终输出到dist文件夹中。\n\n  ```js\n  const gu1p = require('gulp');\n  const babe1 = requi re(' gulp-babel');\n  gu1p. task('js', 0 =>\n    gu1p.src('src/*.js')\n    . pipe (babe1({\n   \t\tpresets: [ ' es2015 ']\n    })\n    .pipe(gu1p. dest('dist'))\n  );\n  ```\n\n* 什么时候用grunt/gulp呢？\n\n  * 如果你的工程模块依赖非常简单，甚至是没有用到模块化的概念。\n  * 只需要进行简单的合并、压缩，就使用grunt/gulp即可。\n  * 但是如果整个项目使用了模块化管理，而且相互依赖非常强，我们就可以使用更加强大的webpack了。\n\n* 所以，grunt/gulp和webpack有什么不同呢？\n\n  * grunt/gulp更加强调的是前端流程的自动化，模块化不是它的核心。\n  * webpack更加强调模块化开发管理，而文件压缩合并、预处理等功能，是他附带的功能。\n\n### 2.webpack安装\n\n* 安装webpack首先需要安装Node.js，Node.js自带了软件包管理工具npm\n\n* 查看自己的node版本：\n\n  ```\n  node -v\n  ```\n\n* 全局安装webpack(这里我先指定版本号3.6.0，因为vue cli2依赖该版本)\n\n  ```\n  npm install webpack@3.6.0 -g\n  ```\n\n* 局部安装webpack（后续才需要）\n\n  * --save-dev`是开发时依赖，项目打包后不需要继续使用的。\n\n  ```\n  cd 当前项目的路径下\n  npm install webpack@3.6.0 --save-dev\n  ```\n\n* 为什么全局安装后，还需要局部安装呢？\n\n  * 在终端直接执行webpack命令，使用的全局安装的webpack\n  * 当在package.json中定义了scripts时，其中包含了webpack命令，那么使用的是局部webpack\n\n### 3.webpack的起步\n\n* 我们创建如下文件和文件夹：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-19.png)\n\n* 文件和文件夹解析：\n\n  * dist文件夹：用于存放之后打包的文件\n  * src文件夹：用于存放我们写的源文件\n    * main.js：项目的入口文件。具体内容查看下面详情。\n    * mathUtils.js：定义了一些数学工具函数，可以在其他地方引用，并且使用。具体内容查看下面的详情。\n  * index.html：浏览器打开展示的首页html\n  * package.json：通过npm init生成的，npm包管理的文件（暂时没有用上，后面才会用上）\n\n* mathUtils.js文件中的代码：\n\n  ```js\n  const name='asd';\n  const age = 18;\n  export{\n    name,age\n  }\n  ```\n\n* main.js文件中的代码：\n\n  ```js\n  import {name,age} from './mainUtils';\n  console.log(name);\n  console.log(age);\n  ```\n\n* 现在的js文件中使用了模块化的方式进行开发，他们可以直接使用吗？不可以。\n\n  * 因为如果直接在index.html引入这两个js文件，浏览器并不识别其中的模块化代码。\n  * 另外，在真实项目中当有许多这样的js文件时，我们一个个引用非常麻烦，并且后期非常不方便对它们进行管理。\n\n* 我们应该怎么做呢？使用webpack工具，对多个js文件进行打包。\n\n  * 我们知道，webpack就是一个模块化的打包工具，所以它支持我们代码中写模块化，可以对模块化的代码进行处理。（如何处理的，待会儿在原理中，我会讲解）\n  * 另外，如果在处理完所有模块之间的关系后，将多个js打包到一个js文件中，引入时就变得非常方便了。\n\n* OK，如何打包呢？使用webpack的指令即可\n\n  ```\n  webpack src/main.js dist/bundle.js\n  ```\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-20.png)\n\n* 打包后会在dist文件下，生成一个bundle.js文件\n\n  * 文件内容有些复杂，这里暂时先不看，后续再进行分析。\n  * bundle.js文件，是webpack处理了项目直接文件依赖后生成的一个js文件，我们只需要将这个js文件在index.html中引入即可\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-21.png)\n\n### 4.webpack的配置\n\n* 我们考虑一下，如果每次使用webpack的命令都需要写上入口和出口作为参数，就非常麻烦，有没有一种方法可以将这两个参数写到配置中，在运行时，直接读取呢？\n\n* 当然可以，就是创建一个webpack.config.js文件\n\n  ```JS\n  //获取当前配置文件的绝对路径\n  const path = require('path');\n  module.exports = {\n    //打包的入口文件的位置\n    entry: './src/main.js',\n    //打包后生成的文件的位置\n    output: {\n      path:path.resolve(__dirname,'dist'),\n      filename: 'bundle.js'\n    }\n  }\n  ```\n\n* 目前，我们使用的webpack是全局的webpack，如果我们想使用局部来打包呢？\n\n  * 因为一个项目往往依赖特定的webpack版本，全局的版本可能很这个项目的webpack版本不一致，导出打包出现问题。\n  * 所以通常一个项目，都有自己局部的webpack。\n\n* 第一步，项目中需要安装自己局部的webpack\n\n  * 这里我们让局部安装webpack3.6.0\n\n  ```\n  npm install webpack@3.6.0 --save-dev\n  ```\n\n  * Vue CLI3中已经升级到webpack4，但是它将配置文件隐藏了起来，所以查看起来不是很方便。\n\n* 第二步，通过node_modules/.bin/webpack启动webpack打包\n\n* 但是，每次执行都敲这么一长串有没有觉得不方便呢？\n\n  * OK，我们可以在package.json的scripts中定义自己的执行脚本。\n\n  ```json\n  {\n    \"name\": \"meetwebpack\",\n    \"version\": \"1.0.0\",\n    \"description\": \"\",\n    \"main\": \"index.js\",\n    \"scripts\": {\n      \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n      \"build\": \"webpack\"\n    },\n    \"author\": \"\",\n    \"license\": \"ISC\",\n    \"devDependencies\": {\n      \"webpack\": \"^3.6.0\"\n    }\n  }\n  ```\n\n* package.json中的scripts的脚本在执行时，会按照一定的顺序寻找命令对应的位置。\n\n  * 首先，会寻找本地的node_modules/.bin路径中对应的命令。\n  * 如果没有找到，会去全局的环境变量中寻找。\n  * 如何执行我们的build指令呢？\n\n  ```\n  npm run build\n  ```\n\n### 5.loader的使用\n\n **什么是loader**\n\n* loader是webpack中一个非常核心的概念。\n* webpack用来做什么呢？\n  * 在我们之前的实例中，我们主要是用webpack来处理我们写的js代码，并且webpack会自动处理js之间相关的依赖。\n  * 但是，在开发中我们不仅仅有基本的js代码处理，我们也需要加载css、图片，也包括一些高级的\n  * 将ES6转成ES5代码，将TypeScript转成ES5代码，将scss、less转成css，将.jsx、.vue文件转成js文件等等。\n  * 对于webpack本身的能力来说，对于这些转化是不支持的。\n  * 那怎么办呢？给webpack扩展对应的loader就可以啦。\n* loader使用过程：\n  * 步骤一：通过npm安装需要使用的loader\n  * 步骤二：在webpack.config.js中的modules关键字下进行配置\n* 大部分loader我们都可以在webpack的官网中找到，并且学习对应的用法。\n\n**css文件处理 - 准备工作**\n\n* 项目开发过程中，我们必然需要添加很多的样式，而样式我们往往写到一个单独的文件中。\n\n* 在src目录中，创建一个css文件，其中创建一个normal.css文件。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-22.png)\n\n* 我们也可以重新组织文件的目录结构，将零散的js文件放在一个js文件夹中。\n\n* normal.css中的代码非常简单，就是将body设置为red\n\n* 但是，这个时候normal.css中的样式会生效吗？\n\n* 当然不会，因为我们压根就没有引用它。\n\n* webpack也不可能找到它，因为我们只有一个入口，webpack会从入口开始查找其他依赖的文件。\n\n* 在main.js入口文件中引用：\n\n```js\n//因此必须在此引用css文件\nrequire('../css/normal.css');\n```\n\n**css文件处理 – 打包报错信息**\n\n* 重新打包，会出现如下错误：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-23.png)\n\n* 这个错误告诉我们：加载normal.css文件必须有对应的loader。\n\n**css文件处理 – css-loader**\n\n* 在webpack的[官方](https://webpack.js.org/loaders/css-loader/)中，我们可以找到如下关于样式的loader使用方法：\n\n  * 注意一点：webpack的版本是3.6.0的，因此css-loader的版本也要降低。2.0.2\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210204135204-24.png)\n\n* 按照官方配置webpack.config.js文件\n\n  * 注意：配置中有一个style-loader，我们并不知道它是什么，所以可以暂时不进行配置。\n\n* 重新打包项目：npm run build\n\n* 但是，运行index.html，你会发现样式并没有生效。\n\n  * 原因是css-loader只负责加载css文件，但是并不负责将css具体样式嵌入到文档中。\n  * 这个时候，我们还需要一个style-loader帮助我们处理。\n\n**css文件处理 – style-loader**\n\n* 我们来安装style-loader。注意版本降低。0.23.1\n\n  ```\n  npm install --save-dev style-loader\n  ```\n\n* 注意：style-loader需要放在css-loader的前面。\n\n* 疑惑：不对吧？按照我们的逻辑，在处理css文件过程中，应该是css-loader先加载css文件，再由\n\n* style-loader来进行进一步的处理，为什么会将style-loader放在前面呢？\n\n* 答案：这次因为webpack在读取使用的loader的过程中，是按照从右向左的顺序读取的。\n\n* 目前，webpack.config.js的配置如下\n\n```js\nmodule: {\n  rules: [\n    { \n      // css-loader只负责将css文件加载\n      // style-loader负责将样式添加到dom中\n      // 使用多个loader从右向左读取\n      test: /\\.css$/, \n      use: ['style-loader','css-loader'] },\n  ]\n}\n```\n\n**less文件处理**\n\n* 如果我们希望在项目中使用less、scss、stylus来写样式，webpack是否可以帮助我们处理呢？\n\n  * 我们这里以less为例，其他也是一样的。\n\n* 我们还是先创建一个less文件，依然放在css文件夹中\n\n  ```less\n  @fontSize: 50px;\n  @fontColor: blue;\n  body{\n    font-size: @fontSize;\n    color: @fontColor;\n  }\n  ```\n\n* 继续在webpack官方中查找，我们会找到less-loader相关的使用说明\n\n* 首先，还是需要安装对应的loader\n\n  * 注意：我们这里还安装了less，因为webpack会使用less对less文件进行编译\n  * less:3.13.0   less-loader:4.1.0\n\n  ```\n  npm install less-loader@4.1.0 less@3.13.0  --save-dev\n  ```\n\n* 其次，修改对应的配置文件\n\n  * 添加一个rules选项，用于处理.less文件\n\n  ```js\n  {\n    test: /\\.less$/,\n      use: [\n        {\n          loader: \"style-loader\",\n        },\n        {\n          loader: \"css-loader\",\n        },\n        {\n          //编译less文件为css文件\n          loader: \"less-loader\",\n        },\n      ],\n  },\n  ```\n\n**图片文件处理**\n\n背景图片无法加载\n\n\n\n### 6.webpack中配置Vue\n\n\n\n### 7.plugin的使用\n\n\n\n### 8.搭建本地服务器\n\n\n\n## 2.Vue CLI\n\n###   1> Vue CLI是什么?\n\n\n\n###   2>Vue CLI依赖环境\n\n\n\n###   3> Vue CLI的安装\n\n\n\n## 3.Vue CLI2的使用\n\n###   1> Vue CLI2 配置过程\n\n\n\n###   2> Vue CLI2 目录结构\n\n\n\n###   3> 入口文件详解\n\n####   Vue渲染过程\n\n\n\n####   render函数的使用\n\n\n\n###   4> webpack配置解析\n\n\n\n## 4.Vue CLI3的使用\n\n### 1> Vue CLI3 配置过程\n\n\n\n### 2> Vue CLI3 目录结构\n\n\n\n### 3> Vue CLI配置修改\n\n#### Vue UI\n\n\n\n#### 配置存放路径\n\n\n\n#### 添加新的别名\n\n\n\n# 第五章：vue-router(路由的实现)\n\n# 第六章：Vuex详解\n\n# 第七章：网络封装\n\n# 第八章：项目实战\n\n# 第九章：项目部署\n\n# 第十章：Vuejs相关原理\n\n","categories":["Java学习","前端"]},{"title":"Ajax学习","url":"/2021/01/15/尚硅谷说Java/前端/Ajax/","content":"Ajax学习\n<!--more-->\n# 第 1 章：原生 AJAX\n\n## 1.1 Ajax简介\n\nAJAX 全称为 Asynchronous JavaScript And XML，就是异步的 JS 和 XML。\n\n通过 AJAX 可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据。\n\nAJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。\n\n## 1.2 Ajax相关的知识\n\n### 1.2.1 XML简介\n\nXML 可扩展标记语言。\n\nXML 被设计用来传输和存储数据。\n\n XML 和 HTML 类似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签， 全都是自定义标签，用来表示一些数据。\n\n比如说我有一个学生数据：name = \"孙悟空\" ; age = 18 ; gender = \"男\" ;\n用 XML 表示：\n\n```xml\n<student>\n    <name>孙悟空</name>\n    <age>18</age>\n    <gender>男</gender>\n</student>\n```\n\n现在已经被 JSON 取代了。\n\n用 JSON 表示：\n\n```json\n{\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"}\n```\n\n### 1.2.2 http简介\n\n* HTTP (hypertext transport protocol) 协议[超文本传输协议」：协议详细规定了浏览器和万维网服务器之间互相通信的规则。\n* 请求报文(重点是格式与参数)\n  * 当请求为get时，请求体一般没有内容\n\n```http\n行   POST  /s?ie=utf-8 HTTP/1.1\n头   Host: atguigu.com\n\t Cookie: name=guigu\n\t Content-type: application/x-www-from-urlencoded\n\t User-Agent: chrome 83\n空行\n体   username=admin&password=admin\n```\n\n* 响应报文\n\n```http\n行   HTTP/1.1  200 OK\n头   Content-type: text/html;charaset=utf-8\n\t Content-length: 2048\n\t Content-encoding: gzip\n空行\n体   <html>\n\t\t<head>\n\t\t</head>\n\t\t<body>\n\t\t\t<h1>结果</h1>\n\t\t</body>\n\t</html>\n```\n\n### 1.2.3 浏览器查看请求通信控制台\n\nheaders：头部信息\n\nRequest Headers：请求行和头\n\nResponse Headers：响应行和头\n\nQuery String Parameters：快速查看请求的参数。对请求的参数进行了解析，方便查看参数是否传递。\n\nResponse ：响应体\n\nFrom Data：请求体\n\n### 1.2.4 Node.js的安装\n\n[下载地址](https://nodejs.org/zh-cn/) \n\n下载后一直点击下一步即可。\n\nwindows电脑按win+R；输入cmd打开命令提示窗；输入node -v 出现版本号即为安装成功\n\n### 1.2.5 Express框架的使用\n\n[官网](https://www.expressjs.com.cn/)\n\n* 安装Express\n  * idea或其他工具打开项目，然后打开idea的总端\n  * 输入npm init --yes。用来初始化\n  * 在输入npm i express。等待安装完成即可\n* 使用Express\n  * 在项目中创建文件：express.js\n\n```js\n/*此文件即为服务端的配置文件*/\n//1.引入express\nconst express = require('express');\n//2.创建应用对象\nconst app = express();\n//3.创建get请求响应的路由规则\n//request 对请求报文的封装\n//response 对响应报文的封装\napp.get('/',(request,response)=>{\n    //设置响应\n    response.send('hello express');\n});\napp.get('/server',(request,response)=>{\n    //设置响应头 设置允许跨域\n    response.setHeader('Access-Control-Allow-Origin','*');\n    //设置响应体\n    response.send('hello ajax');\n});\napp.post('/server',(request,response)=>{\n    //设置响应头 设置允许跨域\n    response.setHeader('Access-Control-Allow-Origin','*');\n    //设置响应体\n    response.send('hello ajax post');\n});\napp.all('/json',(request,response)=>{\n    //设置响应头 设置允许跨域\n    response.setHeader('Access-Control-Allow-Origin','*');\n    //响应头\n    response.setHeader('Access-Control-Allow-Headers', '*');\n    //响应一个数据\n    const data = {\n        name: 'atuigu'\n    };\n    //将对象转化成json字符串\n    let str = JSON.stringify(data);\n    //设置响应体  响应体只能发送字符串数据\n    response.send(str);\n});\n//4.监听端口启动服务\napp.listen(8000,()=>{\n    console.log(\"服务8000端口已启动，监听中。。。。\")\n})\n```\n\n* 启动Express\n\n  * 打开终端，路径为express.js所在的路径。输入node express.js。回车\n  * 终端显示为\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210110200118.png)\n\n  * 浏览器显示为\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210110200118-1.png)\n\n### 1.2.6 nodemon的使用\n\n* 方便服务端的配置。当我们修改服务端的配置信息时，不需要重新启动服务，这个工具会自动帮我们启动服务。\n* 使用方法\n  * 总端下输入npm install -g nodemon\n  * 启动服务端时，不再是：node 配置文件。而是：nodemon 配置文件\n\n## 1.3 AJAX 的特点\n\n### 1.3.1AJAX 的优点\n\n* 1)可以无需刷新页面而与服务器端进行通信。\n* 2)允许你根据用户事件来更新部分页面内容。\n\n### 1.3.2AJAX 的缺点\n\n* 1)没有浏览历史，不能回退\n* 2)存在跨域问题(同源，即两个服务器之间不能发送ajax)\n* 3)SEO(搜索引擎优化)不友好\n\n## 1.4AJAX 的使用\n\n### 1.4.1核心对象\n\nXMLHttpRequest：AJAX 的所有操作都是通过该对象进行的。\n\n### 1.4.2使用步骤\n\n```js\n //1.创建对象\nconst xhr = new XMLHttpRequest();\n//设置响应体数据的类型\n/**\n *将对象json字符串转化成对象\n */\nxhr.responseType = 'json';\n\n//2.初始化 设置请求方法和 url\n//get请求传参方式：url拼接。\n//例如 http://127.0.0.1:8000/server?a=1&b=2&c=3\nxhr.open('GET','http://127.0.0.1:8000/server');\n//设置请求头 \nxhr.setRequestHeader('Content-type','application/x-www-from-urlencoded');\n//使用自定义请求头\n//此时服务端应有app.all()表示接受所有的请求\n//同时服务端应设置response.setHeader('Access-Control-Allow-Headers','*');表示接受所有类型的请求信息信息\n//xhr.setRequestHeader('name','atguigu');\n\n//3.发送\n//post请求传参方式：send()发送参数\n//例如  xhr.send('a=1&b=2&c=3');  xhr.send('a:1&b:2&c:3');\nxhr.send();\n\n//4.事件绑定  绑定服务端返回的结果\n/**\n * on  当……的时候\n * readystate 是xhr对象中的属性，表示状态0，1，2，3，4\n *   0表示未初始化；1表示未发送；2表示未绑定；3表示返回部分结果；4返回全部结果\n * change 改变 \n */\nxhr.onreadystatechange = function(){\n    //判断(服务器返回了所有的结果时)\n    if(xhr.readyState === 4){\n        //判断响应状态码 200 404 403 401 500\n        //2xx 都表示成功\n        if(xhr.status >= 200 && xhr.status < 300){\n            //处理结果 行 头 空行 体\n            //1.响应行\n            console.log(xhr.status);\n            console.log(xhr.statusText);\n            //2.响应头  获取所有的响应头\n            console.log(xhr.getAllResponseHeaders);\n            //3.响应体\n            console.log(xhr.response);\n            \n            //手动对数据转换 \n            // let data = JSON.parse(xhr.response);\n            // console.log(data);\n            // result.innerHTML = data.name;\n            //自动转换 -- 见上面设置响应体数据的类型\n            result.innerHTML = xhr.response.name;\n        }else{\n\n        }\n    }\n}\n```\n\n* 1)创建 XMLHttpRequest 对象\n\n  var xhr = new XMLHttpRequest();\n\n* 2)设置请求信息\n\n  xhr.open(method, url);\n\n  //可以设置请求头，一般不设置\n\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\n* 3)发送请求\n\n  xhr.send(body)\t//get 请求不传 body 参数，只有 post 请求使用\n\n* 4)接收响应\n\n  //xhr.responseXML 接收 xml 格式的响应数据\n\n  //xhr.responseText  接收文本格式的响应数据\n\n  xhr.onreadystatechange = function (){\n\n  ​\tif(xhr.readyState == 4 && xhr.status == 200){\n  ​\t\t\tvar text = xhr.responseText; console.log(text);\n  ​\t}\n\n  }\n\n### 1.4.3 AJAX 请求状态\n\n* xhr.readyState 可以用来查看请求当前的状态\n  * 0: 表示 XMLHttpRequest 实例已经生成，但是 open()方法还没有被调用。\n  * 1: 表示 send()方法还没有被调用，仍然可以使用setRequestHeader()，设定 HTTP请求的头信息。\n  * 2: 表示 send()方法已经执行，并且头信息和状态码已经收到。 \n  * 3: 表示正在接收服务器传来的 body 部分的数据。 \n  * 4: 表示服务器数据已经完全接收，或者本次接收已经失败了\n\n## 1.5 常见的问题\n\n### 1.5.1解决IE 缓存问题\n\n问题：在一些浏览器中(IE),由于缓存机制的存在，ajax 只会发送的第一次请求，剩余多次请求不会在发送给浏览器而是直接加载缓存中的数据。\n解决方式：浏览器的缓存是根据 url 地址来记录的，所以我们只需要修改 url 地址即可避免缓存问题\n\n```html\n//Date.now()表示获取当前时间的毫秒值\nxhr.open('get','http://127.0.0.1:8000/json?t='+Date.now());\n```\n\n### 1.5.2 超时和网络异常问题\n\n* 服务端\n\n```js\n//延迟响应\napp.get('/delay',(request,response)=>{\n    //设置响应头 设置允许跨域\n    response.setHeader('Access-Control-Allow-Origin','*');\n    setTimeout(() => {\n        //设置响应体\n        response.send('延迟响应');\n    }, 3000);\n    \n});\n```\n\n* 客户端\n\n```js\n//1.创建对象\nconst xhr = new XMLHttpRequest();\n//超时设置中断请求\nxhr.timeout = 2000;\n//超时回调\nxhr.ontimeout = function(){\nalert(\"超时\");\n};\n//网络异常回调\nxhr.onerror = function(){\nalert(\"你的网络似乎出现了问题\");\n}\n```\n\n### 1.5.3 手动取消请求\n\nabort()函数为取消请求的函数\n\n```html\n<button >点击发送请求</button>\n<button >点击取消请求</button>\n<script>\n    //获取button元素\n    const btn = document.querySelectorAll('button');\n    let x = null;\n    btn[0].onclick = function(){\n        x= new XMLHttpRequest();\n        x.open(\"GET\",'http://127.0.0.1:8000/delay');\n        x.send();\n    };\n    btn[1].onclick = function(){\n        //取消请求\n        x.abort();\n    };\n</script>\n```\n\n### 1.5.4 重复发送请求的问题\n\n定义一个变量。当第一次请求时允许请求。当第二次请求时取消第一次的请求，然后允许第二次请求。\n\n注意当请求接受到结果时即可回复变量。\n\n```html\n<button >点击发送请求</button>\n<script>\n    //获取button元素\n    const btn = document.querySelectorAll('button');\n    let x = null;\n    //表示变量\n    let isSending = false;\n    btn[0].onclick = function(){\n        //判断标识变量\n        if(isSending) x.abort();\n        x= new XMLHttpRequest();\n        //建立了新请求，修改标识变量\n        isSending = true;\n        x.open(\"GET\",'http://127.0.0.1:8000/delay');\n        x.send();\n        x.onreadystatechange = function(){\n            if(x.readyState === 4){\n                //恢复标识变量\n                isSending = false;\n            }\n        };\n    };\n</script>\n```\n\n# 第 2 章：jQuery 中的 AJAX \n\n## 2.1 get 请求 \n\n* $.get(url, [data], [callback], [type]) \n  * url:请求的 URL 地址。 \n  * data:请求携带的参数。 \n  * callback:载入成功时回调函数。 \n  * type:设置返回内容格式，xml, html, script, json, text, _default。\n\n## 2.2 post 请求\n\n* $.post(url, [data], [callback], [type]) \n  * url:请求的 URL 地址。 \n  * data:请求携带的参数。 \n  * callback:载入成功时回调函数。 \n  * type:设置返回内容格式，xml, html, script, json, text, _default。\n\n## 2.3 通用的ajax请求\n\n```html\n<body>\n    <div class=\"container\">\n        <h2 class=\"page-header\">jQuery发送AJAX请求 </h2>\n        <button class=\"btn btn-primary\">GET</button>\n        <button class=\"btn btn-danger\">POST</button>\n        <button class=\"btn btn-info\">通用型方法ajax</button>\n    </div>\n    <script>\n         $('button').eq(0).click(function(){\n            $.get('http://127.0.0.1:8000/jquery-server', {a:100, b:200}, function(data){\n                console.log(data);\n            },'json');\n        });\n\n        $('button').eq(1).click(function(){\n            $.post('http://127.0.0.1:8000/jquery-server', {a:100, b:200}, function(data){\n                console.log(data);\n            });\n        });\n        $('button').eq(1).click(function(){\n            $.ajax({\n                //url\n                url: '',\n                 //参数\n                 data: {a:100,b:200},\n                 //请求类型\n                type: 'GET',\n                 //响应体结果的类型\n                dataType: 'json',\n                //成功的回调\n                success:function(data){\n                    console.log(data);\n                } ,\n                //超时时间\n                timeout: 2000,\n                 //失败的回调\n                error:function(){\n                    console.log('出错啦');\n                },\n                //头信息\n                headers: {\n                    c:300,\n                    d:400\n                }\n            });\n        });\n    </script>\n</body>\n```\n\n# 第三章：ajax的工具包\n\n## 3.1 axios工具\n\n```html\n<body>\n    <button>GET</button>\n    <button>POST</button>\n    <button>AJAX</button>\n\n    <script>\n        // https://github.com/axios/axios\n        const btns = document.querySelectorAll('button');\n\n        //配置 baseURL 。请求时会自动在url前拼接这个baseURL\n        axios.defaults.baseURL = 'http://127.0.0.1:8000';\n\n        btns[0].onclick = function () {\n            //GET 请求\n            axios.get('/axios-server', {\n                //url 参数\n                params: {\n                    id: 100,\n                    vip: 7\n                },\n                //请求头信息\n                headers: {\n                    name: 'atguigu',\n                    age: 20\n                }\n            }).then(value => {\n\t\t\t\t//显示返回结果\n                console.log(value);\n            });\n        }\n\n        btns[1].onclick = function () {\n            axios.post('/axios-server', {\n                username: 'admin',\n                password: 'admin'\n            }, {\n                //url \n                params: {\n                    id: 200,\n                    vip: 9\n                },\n                //请求头参数\n                headers: {\n                    height: 180,\n                    weight: 180,\n                }\n            });\n        }\n    \n        btns[2].onclick = function(){\n            axios({\n                //请求方法\n                method : 'POST',\n                //url\n                url: '/axios-server',\n                //url参数\n                params: {\n                    vip:10,\n                    level:30\n                },\n                //头信息\n                headers: {\n                    a:100,\n                    b:200\n                },\n                //请求体参数\n                data: {\n                    username: 'admin',\n                    password: 'admin'\n                }\n            }).then(response=>{\n                //响应状态码\n                console.log(response.status);\n                //响应状态字符串\n                console.log(response.statusText);\n                //响应头信息\n                console.log(response.headers);\n                //响应体\n                console.log(response.data);\n            });\n        };\n    </script>\n</body>\n```\n\n## 3.2 fetch工具包\n\n```html\n<body>\n    <button>AJAX请求</button>\n    <script>\n        //文档地址\n        //https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/fetch\n        \n        const btn = document.querySelector('button');\n\n        btn.onclick = function(){\n            fetch('http://127.0.0.1:8000/fetch-server?vip=10', {\n                //请求方法\n                method: 'POST',\n                //请求头\n                headers: {\n                    name:'atguigu'\n                },\n                //请求体\n                body: 'username=admin&password=admin'\n            }).then(response => {\n                // return response.text();\n                return response.json();\n            }).then(response=>{\n                console.log(response);\n            });\n        }\n    </script>\n</body>\n```\n\n# 第 4 章：跨域\n\n## 4.1 同源策略\n\n同源策略(Same-Origin Policy)最早由 Netscape 公司提出，是浏览器的一种安全策略。\n同源： 协议、域名、端口号 必须完全相同。\n 违背同源策略就是跨域。\n\n同源：一个浏览器端向一个服务器端发送请求。\n\n跨域：一个浏览器端向连个服务器发送请求。这个两个服务器端口号不会一样\n\n**3.2** **如何解决跨域** \n\n**3.2.1 JSONP** \n\n* 1) JSONP 是什么 \n\n  * JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明 才智开发出来，只支持 get 请求。 \n\n* 2) JSONP 怎么工作的？ \n\n  * 在网页有一些标签天生具有跨域能力，比如：img link iframe script。 JSONP 就是利用 script 标签的跨域能力来发送请求的。 \n\n* 3) JSONP 的使用 \n\n  * 1.动态的创建一个 script 标签 \n\n    * var script = document.createElement(\"script\"); \n\n  * 2.设置 script 的 src，设置回调函数 \n\n    ```js\n    script.src = \"http://localhost:3000/testAJAX?callback=abc\"; \n    function abc(data) { \n    \talert(data.name); \n    }; \n    ```\n\n  * 3.将 script 添加到 body 中 \n\n    * document.body.appendChild(script); \n\n  * 4.服务器中路由的处理 \n\n    ```js\n    router.get(\"/testAJAX\" , function (req , res) { \n    \tconsole.log(\n            \"收到请求\"\n    \t); \n    \tvar callback = req.query.callback; \n    \tvar obj = {\n            name:\"孙悟空\", \n            age:18 \n    \t}\n    \tres.send(callback+\"(\"+JSON.stringify(obj)+\")\"); \n    }); \n    ```\n\n* 4) jQuery 中的 JSONP\n\n  ```html\n  <body>\n      <button id=\"btn\">按钮</button> \n      <ul id=\"list\"></ul> \n      <script type=\"text/javascript\" src=\"./jquery-1.12.3.js\"></script> \n      <script type=\"text/javascript\"> \n          window.onload = function () { \n              var btn = document.getElementById('btn') \n              btn.onclick = function () { \n                  $.getJSON(\"http://api.douban.com/v2/movie/in_theaters?callback=?\",function (data) { \n                      console.log(data); \n                      //获取所有的电影的条目 \n                      var subjects = data.subjects; \n                      //遍历电影条目\n                      for(var i=0 ; i<subjects.length ; i++){ \n                          $(\"#list\").append(\"<li>\"+ \n                                            subjects[i].title+ \"<br/>\"+ \n                                            \"<imgsrc=\\\"+\n                                            subjects[i].images.large+\"\\>\"+ \n                                           \"</li>\");                                   \n                     }                                                                          \n  \t\t\t\t});                          \n  \t\t\t}                                                         \n          } \n   </script> \n  </body>\n  ```\n\n### 4.2.2 CORS\n\n1) CORS 是什么？ \n\n​\tCORS（Cross\\-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方 案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些 源站通过浏览器有权限访问哪些资源 \n\n2) CORS 怎么工作的？ \n\nCORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应 以后就会对响应放行。 \n\n3) CORS 的使用 主要是服务器端的设置： \n\n```js\nrouter.get(\"/testAJAX\" , function (req , res) {\n    //通过 res 来设置响应头，来允许跨域请求 \n    //res.set(\"Access\\-Control\\-Allow\\-Origin\",\"http://127.0.0.1:3000\"); \n    //*表示全匹配\n    res.set(\"Access\\-Control\\-Allow\\-Origin\",\"*\"); \n    res.send(\"testAJAX 返回的响应\"); \n});\n```\n\n","categories":["Java学习","前端"]},{"title":"JavaScript学习","url":"/2021/01/09/尚硅谷说Java/前端/JavaScript/","content":"JavaScript学习\n<!--more-->\n# 1.JavaScript介绍\n\nJavascript 语言诞生主要是完成页面的数据验证。因此它运行在客户端，需要运行浏览器来解析执行 JavaScript 代码。 \n\nJS 是 Netscape 网景公司的产品，最早取名为 LiveScript;为了吸引更多 java 程序员。更名为 JavaScript。 \n\n<font color  = \"red\" >JS 是弱类型，Java 是强类型。 </font>\n\n特点： \n\n1. 交互性（它可以做的就是信息的动态交互）\n2. 安全性（不允许直接访问本地硬盘）\n3. 跨平台性（只要是可以解释 JS 的浏览器都可以执行，和平台无关）\n\n# 2.JavaScript和html代码的结合方式\n\n## 2.1第一种方式\n\n​\t\t\t只需要在 head 标签中，或者在 body 标签中， 使用 script 标签 来书写 JavaScript 代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\">\n        // alert是JavaScript语言提供的一个警告框函数。\n        // 它可以接收任意类型的参数，这个参数就是警告框的提示信息\n        alert(\"hello javaScript!\");\n    </script>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n## 2.2第二种方式\n\n​\t\t\t使用 script 标签引入 单独的 JavaScript 代码文件\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <!--\n        现在需要使用script引入外部的js文件来执行\n            src 属性专门用来引入js文件路径（可以是相对路径，也可以是绝对路径）\n\n        script标签可以用来定义js代码，也可以用来引入js文件\n        但是，两个功能二选一使用。不能同时使用两个功能\n    -->\n    <script type=\"text/javascript\" src=\"1.js\"></script>\n    <script type=\"text/javascript\">\n        alert(\"国哥现在可以帅了\");\n    </script>\n</head>\n<body>\n\n</body>\n</html>\n```\n\nJS代码\n\n```javascript\nalert(\"1125 hello!\");\n```\n\n# 3.JS中的变量\n\n什么是变量？变量是可以存放某些值的内存的命名。\n\nJavaScript 的变量类型： \n\n​\t数值类型： \t\t\tnumber \n\n​\t字符串类型： \t\tstring \n\n​\t对象类型： \t\t\tobject \n\n​\t布尔类型： \t\t\tboolean \n\n​\t函数类型： \t\t\tfunction \n\nJavaScript 里特殊的值： \n\nundefined \t\t\t未定义，所有 js 变量未赋于初始值的时候，默认值都是 undefined. \n\nnull \t\t\t\t\t\t空值 \n\nNaN \t\t\t\t\t\t全称是：Not a Number。非数字。非数值。\n\nJS 中的定义变量格式： \n\n​\t\tvar  变量名; \n\n​\t\tvar  变量名 = 值;\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\">\n        var i;\n        // alert(i); // undefined\n        i = 12;\n        // typeof()是JavaScript语言提供的一个函数。\n        // alert( typeof(i) ); // number\n\n        i = \"abc\";\n        // 它可以取变量的数据类型返回\n        // alert( typeof(i) ); // String\n\n        var a = 12;\n        var b = \"abc\";\n\n        alert( a * b ); // NaN是非数字，非数值。\n\n    </script>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n# 4.JS中的关系(比较)运算\n\n​\t\t基本与Java相同。不同的是：\n\n​\t\t等于： \t\t== \t\t\t  等于是简单的做字面值的比较 \n\n​\t\t全等于： \t=== \t\t\t除了做字面值的比较之外，还会比较两个变量的数据类型\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\">\n\n        var a = \"12\";\n        var b = 12;\n\n        alert( a == b ); // true\n        alert( a === b ); // false\n\n    </script>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n# 5.JS中的逻辑运算\n\n​\t\t且运算： && \n\n​\t\t或运算： || \n\n​\t\t取反运算： !\n\n在 JavaScript 语言中，所有的变量，都可以做为一个 boolean 类型的变量去使用。 \n\n<font color = \"red\">0 、null、 undefined、””(空串) 都认为是 false； </font>\n\n注意：\n\n&& 且运算。 \n\n第一种情况：当表达式全为真的时候。返回最后一个表达式的值。 \n\n第二种情况：当表达式中，有一个为假的时候。返回第一个为假的表达式的值 \n\n|| 或运算 \n\n第一种情况：当表达式全为假时，返回最后一个表达式的值 \n\n第二种情况：只要有一个表达式为真。就会把回第一个为真的表达式的值 并且 && 与运算 和 ||或运算有短路。 短路就是说，当这个&&或||运算有结果了之后 。后面的表达式不再执行 \n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\">\n   /*     在JavaScript语言中，所有的变量，都可以做为一个boolean类型的变量去使用。\n        0 、null、 undefined、””(空串) 都认为是 false；*/\n\n        // var a = 0;\n        // if (a) {\n        //     alert(\"零为真\");\n        // } else {\n        //     alert(\"零为假\");\n        // }\n\n        // var b = null;\n        // if (b) {\n        //     alert(\"null为真\");\n        // } else {\n        //     alert(\"null为假\");\n        // }\n\n        // var c = undefined;\n        // if (c) {\n        //     alert(\"undefined为真\");\n        // } else {\n        //     alert(\"undefined为假\");\n        // }\n\n        // var d = \"\";\n        // if (d) {\n        //     alert(\"空串为真\");\n        // } else {\n        //     alert(\"空串为假\");\n        // }\n\n\n/*         && 且运算。\n\t\t有两种情况：\n\t\t第一种：当表达式全为真的时候。返回最后一个表达式的值。\n\t\t第二种：当表达式中，有一个为假的时候。返回第一个为假的表达式的值*/\n\n        var a = \"abc\";\n        var b = true;\n        var d = false;\n        var c = null;\n\n        // alert( a && b );//true\n        // alert( b && a );//true\n        // alert( a && d ); // false\n        // alert( a && c ); // null\n\n /*      || 或运算\n       第一种情况：当表达式全为假时，返回最后一个表达式的值\n       第二种情况：只要有一个表达式为真。就会把回第一个为真的表达式的值*/\n        // alert( d || c ); // null\n        // alert( c|| d ); //false\n\n        // alert( a || c ); //abc\n        // alert( b || c ); //true\n\n    </script>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n# 6.JS中的数组\n\n## 6.1数组的定义方式\n\nJS 中 数组的定义： \n\n​\t格式： \n\n​\tvar 数组名 = []; \t// 空数组 \n\n​\tvar 数组名 = [1 , ’abc’ , true]; \t// 定义数组同时赋值元素 \n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\">\n\n        var arr = [true,1]; // 定义一个空数组\n        // alert( arr.length ); // 0\n\n        arr[0] = 12;\n        // alert( arr[0] );//12\n        // alert( arr.length ); // 0\n\n        // javaScript语言中的数组，只要我们通过数组下标赋值，那么最大的下标值，就会自动的给数组做扩容操作。\n        arr[2] = \"abc\";\n        alert(arr.length); //3\n\n        // alert(arr[1]);// undefined\n        // 数组的遍历\n        for (var i = 0; i < arr.length; i++){\n            alert(arr[i]);\n        }\n\n    </script>\n</head>\n<body>\n</body>\n</html>\n```\n\n# 7.JS中的函数\n\n## 7.1函数的第一种定义方式\n\n​\t\t\t可以使用function关键字来定义函数。\n\n使用的格式如下: \n\n​\tfunction 函数名(形参列表){ \n\n​\t\t\t函数体 \n\n​\t}\n\n在 JavaScript 语言中，如何定义带有返回值的函数？ \n\n只需要在函数体内直接使用 return 语句返回值即可！ \n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\">\n        // 定义一个无参函数\n        function fun(){\n            alert(\"无参函数fun()被调用了\");\n        }\n        // 函数调用===才会执行\n        // fun();\n\n        function fun2(a ,b) {\n            alert(\"有参函数fun2()被调用了 a=>\" + a + \",b=>\"+b);\n        }\n\n        // fun2(12,\"abc\");\n\n        // 定义带有返回值的函数\n        function sum(num1,num2) {\n            var result = num1 + num2;\n            return result;\n        }\n\n        alert( sum(100,50) );\n\n    </script>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n## 7.2函数的第二种定义方式\n\n使用格式如下： \n\n​\t\tvar 函数名 = function(形参列表) { 函数体 } \n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\">\n        var fun = function () {\n            alert(\"无参函数\");\n        }\n        // fun();\n\n        var fun2 = function (a,b) {\n            alert(\"有参函数a=\" + a + \",b=\" + b);\n        }\n        // fun2(1,2);\n\n        var fun3 = function (num1,num2) {\n            return num1 + num2;\n        }\n\n        alert( fun3(100,200) );\n    </script>\n\n</head>\n<body>\n\n</body>\n</html>\n```\n\n## 7.3JS函数的重载\n\n注：在 Java 中函数允许重载。但是在 JS 中函数的重载会直接覆盖掉上一次的定义 \n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\">\n\n\n        function fun(a,b) {\n            alert(\"有参函数fun(a,b)\");\n        }\n\n        function fun() {\n            alert(\"无参函数fun()\");\n        }\n\n        fun(1,\"ad\"); //输出无参函数fun()\n\n    </script>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n## 7.4 函数的 arguments 隐形参数（只在 function 函数内）\n\n就是在 function 函数中不需要定义，但却可以直接用来获取所有参数的变量。我们管它叫隐形参数。 \n\n隐形参数特别像 java 基础的可变长参数一样。 \n\npublic void fun( Object ... args ); \n\n可变长参数其他是一个数组。 \n\n那么 js 中的隐形参数也跟 java 的可变长参数一样。操作类似数组。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n\n    <script type=\"text/javascript\">\n        function fun(a) {\n            alert( arguments.length );//可看参数个数\n\n            alert( arguments[0] );\n            alert( arguments[1] );\n            alert( arguments[2] );\n\n            alert(\"a = \" + a);\n\n            for (var i = 0; i < arguments.length; i++){\n                alert( arguments[i] );\n            }\n\n            alert(\"无参函数fun()\");\n        }\n        // fun(1,\"ad\",true);\n\n        // 需求：要求 编写 一个函数。用于计算所有参数相加的和并返回\n        function sum(num1,num2) {\n            var result = 0;\n            for (var i = 0; i < arguments.length; i++) {\n                if (typeof(arguments[i]) == \"number\") {\n                    result += arguments[i];\n                }\n            }\n            return result;\n        }\n\n        alert( sum(1,2,3,4,\"abc\",5,6,7,8,9) );\n\n\n    </script>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n# 8.JS中的自定义对象\n\n## 8.1Object 形式的自定义对象\n\n对象的定义： \n\n​\t\t\tvar 变量名 = new Object(); // 对象实例（空对象） \n\n​\t\t\t变量名.属性名 = 值; // 定义一个属性 \n\n​\t\t\t变量名.函数名 = function(){} // 定义一个函数 \n\n对象的访问： \n\n​\t\t\t变量名.属性 / 函数名(); \n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\">\n\n        // 对象的定义：\n        //     var 变量名 = new Object();   // 对象实例（空对象）\n        //     变量名.属性名 = 值;\t\t  // 定义一个属性\n        //     变量名.函数名 = function(){}  // 定义一个函数\n        var obj = new Object();\n        obj.name = \"华仔\";\n        obj.age = 18;\n        obj.fun = function () {\n            alert(\"姓名：\" + this.name + \" , 年龄：\" + this.age);\n        }\n        // 对象的访问：\n        //     变量名.属性 / 函数名();\n        // alert( obj.age );\n        obj.fun();\n\n    </script>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n## 8.2{}花括号形式的自定义对象\n\n对象的定义： \n\n​\t\tvar 变量名 = { \t\t\t\t\t\t\t// 空对象 \n\n​\t\t\t\t属性名：值, \t\t\t\t\t\t// 定义一个属性 \n\n​\t\t\t\t属性名：值, \t\t\t\t\t\t// 定义一个属性 \n\n​\t\t\t\t函数名：function(){} \t\t// 定义一个函数\n\n​\t\t }; \n\n注意定义的时候，用英文标点隔开\n\n对象的访问： \n\n​\t\t\t变量名.属性 / 函数名(); \n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\">\n        // 对象的定义：\n        // var 变量名 = {\t\t\t// 空对象\n        //     属性名：值,\t\t\t// 定义一个属性\n        //     属性名：值,\t\t\t// 定义一个属性\n        //     函数名：function(){}\t// 定义一个函数\n        // };\n        var obj = {\n            name:\"国哥\",\n            age:18,\n                fun : function () {\n                alert(\"姓名：\" + this.name + \" , 年龄：\" + this.age);\n            }\n        };\n\n        // 对象的访问：\n        //     变量名.属性 / 函数名();\n        alert(obj.name);\n        obj.fun();\n    </script>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n# 9.JS中的事件\n\n​\t\t\t\t什么是事件？事件是电脑输入设备与页面进行交互的响应。我们称之为事件\n\n**常用的事件：** \n\n​\t\t\tonload 加载完成事件： \t\t\t\t   页面加载完成之后，常用于做页面 js 代码初始化操作 \n\n​\t\t\tonclick 单击事件： \t\t\t\t\t\t   常用于按钮的点击响应操作。 \n\n​\t\t\tonblur 失去焦点事件： \t\t\t\t\t常用用于输入框失去焦点后验证其输入内容是否合法。 \n\n​\t\t\tonchange 内容发生改变事件： \t   常用于下拉列表和输入框内容发生改变后操作 \n\n​\t\t\tonsubmit 表单提交事件：\t\t\t\t常用于表单提交前，验证所有表单项是否合法。\n\n​\t\t\tsetInterval(val1 ,val2);  表示每隔val2时间调用一次val1。\n\n​\t\t\t\t\tval2表示时间间隔单位毫秒，val1表示函数。va1样例：\"函数名()\"。\n\n**事件的注册又分为静态注册和动态注册两种**:\n\n​\t什么是事件的注册（绑定）？ \n\n​\t\t其实就是告诉浏览器，当事件响应后要执行哪些操作代码，叫事件注册或事件绑定。 \n\n静态注册事件：通过 html 标签的事件属性直接赋于事件响应后的代码，这种方式我们叫静态注册.\n\n动态注册事件：是指先通过 js 代码得到标签的 dom 对象，然后再通过 dom 对象.事件名 = function(){} 这种形式赋于事件 响应后的代码，叫动态注册。 \n\n​\t\t动态注册基本步骤： \n\n​\t\t\t\t1、获取标签对象 \n\n​\t\t\t\t2、标签对象.事件名 = fucntion(){} \n\n## 9.1onload加载完成事件\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\">\n        // onload事件的方法\n        function onloadFun() {\n            alert('静态注册onload事件，所有代码');\n        }\n\n        // onload事件动态注册。是固定写法\n        window.onload = function () {\n            alert(\"动态注册的onload事件\");\n        }\n\n    </script>\n</head>\n<!--静态注册onload事件\n        onload事件是浏览器解析完页面之后就会自动触发的事件\n       <body onload=\"onloadFun();\">\n-->\n<body>\n\n</body>\n</html>\n```\n\n## 9.2 onclick 单击事件\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\">\n        function onclickFun() {\n            alert(\"静态注册onclick事件\");\n        }\n\n        // 动态注册onclick事件\n        window.onload = function () {\n            // 1 获取标签对象\n            /*\n            * document 是JavaScript语言提供的一个对象（文档）<br/>\n            * get           获取\n            * Element       元素（就是标签）\n            * By            通过。。   由。。经。。。\n            * Id            id属性\n            *\n            * getElementById通过id属性获取标签对象\n            **/\n            var btnObj = document.getElementById(\"btn01\");\n            // alert( btnObj );\n            // 2 通过标签对象.事件名 = function(){}\n            btnObj.onclick = function () {\n                alert(\"动态注册的onclick事件\");\n            }\n        }\n\n    </script>\n</head>\n<body>\n    <!--静态注册onClick事件-->\n    <button onclick=\"onclickFun();\">按钮1</button>\n    <button id=\"btn01\">按钮2</button>\n</body>\n</html>\n```\n\n## 9.3 onblur 失去焦点事件\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\">\n        // 静态注册失去焦点事件\n        function onblurFun() {\n            // console是控制台对象，是由JavaScript语言提供，专门用来向浏览器的控制器打印输出， 用于测试使用\n            // log() 是打印的方法\n            console.log(\"静态注册失去焦点事件\");\n        }\n\n        // 动态注册 onblur事件\n        window.onload = function () {\n            //1 获取标签对象\n           var passwordObj = document.getElementById(\"password\");\n           // alert(passwordObj);\n            //2 通过标签对象.事件名 = function(){};\n            passwordObj.onblur = function () {\n                console.log(\"动态注册失去焦点事件\");\n            }\n        }\n\n    </script>\n</head>\n<body>\n    用户名:<input type=\"text\" onblur=\"onblurFun();\"><br/>\n    密码:<input id=\"password\" type=\"text\" ><br/>\n</body>\n</html>\n```\n\n## 9.4 onchange 内容发生改变事件\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n\n    <script type=\"text/javascript\">\n        function onchangeFun() {\n            alert(\"女神已经改变了\");\n        }\n\n        window.onload = function () {\n            //1 获取标签对象\n            var selObj = document.getElementById(\"sel01\");\n            // alert( selObj );\n            //2 通过标签对象.事件名 = function(){}\n            selObj.onchange = function () {\n                alert(\"男神已经改变了\");\n            }\n        }\n\n\n    </script>\n</head>\n<body>\n    请选择你心中的女神：\n    <!--静态注册onchange事件-->\n    <select onchange=\"onchangeFun();\">\n        <option>--女神--</option>\n        <option>芳芳</option>\n        <option>佳佳</option>\n        <option>娘娘</option>\n    </select>\n\n    请选择你心中的男神：\n    <select id=\"sel01\">\n        <option>--男神--</option>\n        <option>国哥</option>\n        <option>华仔</option>\n        <option>富城</option>\n    </select>\n\n\n</body>\n</html>\n```\n\n## 9.5 onsubmit 表单提交事件\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\" >\n        // 静态注册表单提交事务\n        function onsubmitFun(){\n            // 要验证所有表单项是否合法，如果，有一个不合法就阻止表单提交\n            alert(\"静态注册表单提交事件----发现不合法\");\n\n            return flase;\n        }\n\n        window.onload = function () {\n            //1 获取标签对象\n            var formObj = document.getElementById(\"form01\");\n            //2 通过标签对象.事件名 = function(){}\n            formObj.onsubmit = function () {\n                // 要验证所有表单项是否合法，如果，有一个不合法就阻止表单提交\n                alert(\"动态注册表单提交事件----发现不合法\");\n\n                return false;\n            }\n        }\n\n    </script>\n</head>\n<body>\n    <!--return false 可以阻止 表单提交 -->\n    <form action=\"http://localhost:8080\" method=\"get\" onsubmit=\"return onsubmitFun();\">\n        <input type=\"submit\" value=\"静态注册\"/>\n    </form>\n    <form action=\"http://localhost:8080\" id=\"form01\">\n        <input type=\"submit\" value=\"动态注册\"/>\n    </form>\n\n</body>\n</html>\n```\n\n# 10.DOM模型\n\n​\t\tDOM 全称是 Document Object Model 文档对象模型 \n\n大白话，就是把文档中的标签，属性，文本，转换成为对象来管理。 \n\n那么 它们是如何实现把标签，属性，文本转换成为对象来管理呢。这就是我们马上要学习的重点。 \n\n## 10.1Document 对象\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210505.png)\n\nDocument 对象的理解： \n\n​\t\t第一点：Document 它管理了所有的 HTML 文档内容。 \n\n​\t\t第二点：document 它是一种树结构的文档。有层级关系。\n\n​\t\t 第三点：它让我们把所有的标签 都 对象化 第四点：我们可以通过 document 访问所有的标签对象。\n\n那么 html 标签 要 对象化 怎么办？\n\n```html\n<body> \n    <div id=\"div01\">div01</div> \n</body> \n```\n\n模拟对象化，相当于：\n\n```java\nclass Dom{ \n    private String id; // id 属性 \n    private String tagName; //表示标签名 \n    private Dom parentNode; //父亲 \n    private List<Dom> children; // 孩子结点 \n    private String innerHTML; // 起始标签和结束标签中间的内容 \n}\n```\n\n## 10.2Document 对象中的方法介绍\n\ndocument.getElementById(elementId) \n\n​\t\t\t通过标签的 id 属性查找标签 dom 对象，elementId 是标签的 id 属性值 \n\ndocument.getElementsByName(elementName) \n\n​\t\t\t通过标签的 name 属性查找标签 dom 对象，elementName 标签的 name 属性值 \n\ndocument.getElementsByTagName(tagname) \n\n​\t\t\t通过标签名查找标签 dom 对象。tagname 是标签名 \n\ndocument.createElement( tagName) \n\n​\t\t\t通过给定的标签名，创建一个标签对象。tagName 是要创建的标签名\n\n<font color=\"red\">注：</font>\n\n​\t\tdocument 对象的三个查询方法，如果有 id 属性，优先使用 getElementById 方法来进行查询 如果没有 id 属性，则优先使用 getElementsByName 方法来进行查询 如果 id 属性和 name 属性都没有最后再按标签名查 getElementsByTagName \n\n​\t\t以上三个方法，一定要在页面加载完成之后执行，才能查询到标签对象。\n\n### 1.getElementById()代码示例\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\" >\n        /*\n        * 需求：当用户点击了较验按钮，要获取输出框中的内容。然后验证其是否合法。<br/>\n        * 验证的规则是：必须由字母，数字。下划线组成。并且长度是5到12位。\n        * */\n        function onclickFun() {\n            // 1 当我们要操作一个标签的时候，一定要先获取这个标签对象。\n            var usernameObj = document.getElementById(\"username\");\n            // [object HTMLInputElement] 它就是dom对象\n            var usernameText = usernameObj.value;\n            // 如何 验证 字符串，符合某个规则 ，需要使用正则表达式技术\n            var patt = /^\\w{5,12}$/;\n            /*\n            *  test()方法用于测试某个字符串，是不是匹配我的规则 ，\n            *  匹配就返回true。不匹配就返回false.\n            * */\n\n            var usernameSpanObj = document.getElementById(\"usernameSpan\");\n            // innerHTML 表示起始标签和结束标签中的内容\n            // innerHTML 这个属性可读，可写\n            usernameSpanObj.innerHTML = \"国哥真可爱！\";\n\n            if (patt.test(usernameText)) {\n                // alert(\"用户名合法！\");\n                // usernameSpanObj.innerHTML = \"用户名合法！\";\n                usernameSpanObj.innerHTML = \"<img src=\\\"right.png\\\" width=\\\"18\\\" height=\\\"18\\\">\";\n            } else {\n                // alert(\"用户名不合法！\");\n                // usernameSpanObj.innerHTML = \"用户名不合法！\";\n                usernameSpanObj.innerHTML = \"<img src=\\\"wrong.png\\\" width=\\\"18\\\" height=\\\"18\\\">\";\n            }\n        }\n    </script>\n</head>\n<body>\n    用户名：<input type=\"text\" id=\"username\" value=\"wzg\"/>\n    <span id=\"usernameSpan\" style=\"color:red;\">\n\n    </span>\n    <button onclick=\"onclickFun()\">较验</button>\n</body>\n</html>\n```\n\n### 2.getElementsByName()代码示例\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\">\n        // 全选\n        function checkAll() {\n            // 让所有复选框都选中\n            // document.getElementsByName();是根据 指定的name属性查询返回多个标签对象集合\n            // 这个集合的操作跟数组 一样\n            // 集合中每个元素都是dom对象\n            // 这个集合中的元素顺序是他们在html页面中从上到下的顺序\n            var hobbies = document.getElementsByName(\"hobby\");\n            // checked表示复选框的选中状态。如果选中是true，不选中是false\n            // checked 这个属性可读，可写\n            for (var i = 0; i < hobbies.length; i++){\n                hobbies[i].checked = true;\n            }\n        }\n        //全不选\n        function checkNo() {\n\n            var hobbies = document.getElementsByName(\"hobby\");\n            // checked表示复选框的选中状态。如果选中是true，不选中是false\n            // checked 这个属性可读，可写\n            for (var i = 0; i < hobbies.length; i++){\n                hobbies[i].checked = false;\n            }\n        }\n        // 反选\n        function checkReverse() {\n            var hobbies = document.getElementsByName(\"hobby\");\n\n            for (var i = 0; i < hobbies.length; i++) {\n                hobbies[i].checked = !hobbies[i].checked;\n\n                // if (hobbies[i].checked) {\n                //     hobbies[i].checked = false;\n                // }else {\n                //     hobbies[i].checked = true;\n                // }\n            }\n\n\n        }\n\n    </script>\n</head>\n<body>\n    兴趣爱好：\n    <input type=\"checkbox\" name=\"hobby\" value=\"cpp\" checked=\"checked\">C++\n    <input type=\"checkbox\" name=\"hobby\" value=\"java\">Java\n    <input type=\"checkbox\" name=\"hobby\" value=\"js\">JavaScript\n    <br/>\n    <button onclick=\"checkAll()\">全选</button>\n    <button onclick=\"checkNo()\">全不选</button>\n    <button onclick=\"checkReverse()\">反选</button>\n</body>\n</html>\n```\n\n### 3.getElementsByTagName()代码示例\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\">\n        window.onload = function(){\n            // alert( document.getElementById(\"btn01\") );\n        }\n\n\n        // 全选\n        function checkAll() {\n            alert( document.getElementById(\"btn01\") );\n            // document.getElementsByTagName(\"input\");\n            // 是按照指定标签名来进行查询并返回集合\n            // 这个集合的操作跟数组 一样\n            // 集合中都是dom对象\n            // 集合中元素顺序 是他们在html页面中从上到下的顺序。\n            var inputs = document.getElementsByTagName(\"input\");\n\n            for (var i = 0; i < inputs.length; i++){\n                inputs[i].checked = true;\n            }\n        }\n    </script>\n</head>\n<body>\n\n    <!--as -->\n    兴趣爱好：\n    <input type=\"checkbox\" value=\"cpp\" checked=\"checked\">C++\n    <input type=\"checkbox\" value=\"java\">Java\n    <input type=\"checkbox\" value=\"js\">JavaScript\n    <br/>\n    <button id=\"btn01\" onclick=\"checkAll()\">全选</button>\n\n</body>\n</html>\n```\n\n### 4.createElement()代码示例\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\">\n        window.onload = function () {\n            // 现在需要我们使用js代码来创建html标签，并显示在页面上\n            // 标签的内容就是：<div>国哥，我爱你</div>\n            var divObj = document.createElement(\"div\"); // 在内存中 <div></div>\n\n            var textNodeObj = document.createTextNode(\"国哥，我爱你\"); // 有一个文本节点对象 #国哥，我爱你\n\n            divObj.appendChild(textNodeObj); // <div>国哥，我爱你</div>\n\n            // divObj.innerHTML = \"国哥，我爱你\"; // <div>国哥，我爱你</div>,但，还只是在内存中\n            // 添加子元素\n            document.body.appendChild(divObj);\n        }\n    </script>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n## 10.3正则表达式补充\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\">\n        // 表示要求字符串中，是否包含字母e\n        // var patt = new RegExp(\"e\");\n        // var patt = /e/; // 也是正则表达式对象\n        // 表示要求字符串中，是否包含字母a或b或c\n        // var patt = /[abc]/;\n        // 表示要求字符串，是否包含小写字母\n        // var patt = /[a-z]/;\n        // 表示要求字符串，是否包含任意大写字母\n        // var patt = /[A-Z]/;\n        // 表示要求字符串，是否包含任意数字\n        // var patt = /[0-9]/;\n        // 表示要求字符串，是否包含字母，数字，下划线\n        // var patt = /\\w/;\n        // 表示要求 字符串中是否包含至少一个a\n        // var patt = /a+/;\n        // 表示要求 字符串中是否 *包含* 零个 或 多个a\n        // var patt = /a*/;\n        // 表示要求 字符串是否包含一个或零个a\n        // var patt = /a?/;\n        // 表示要求 字符串是否包含连续三个a\n        // var patt = /a{3}/;\n        // 表示要求 字符串是否包 至少3个连续的a，最多5个连续的a\n        // var patt = /a{3,5}/;\n        // 表示要求 字符串是否包 至少3个连续的a，\n        // var patt = /a{3,}/;\n        // 表示要求 字符串必须以a结尾\n        // var patt = /a$/;\n        // 表示要求 字符串必须以a打头\n        // var patt = /^a/;\n\n        // 要求字符串中是否*包含* 至少3个连续的a\n        // var patt = /a{3,5}/;\n        // 要求字符串，从头到尾都必须完全匹配\n        var patt = /^a{3,20}$/;\n\n        // var patt = /^\\w{5,12}$/;\n\n        var str = \"aaaaaaaaaaaaaaaa\";\n\n        alert( patt.test(str) );\n\n\n    </script>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n## 10.4节点的常用属性和方法\n\n​\t\t\t\t节点就是标签对象\n方法： 通过具体的元素节点调用 getElementsByTagName() 方法，获取当前节点的指定标签名孩子节点 \n\nappendChild( oChildNode ) 方法，可以添加一个子节点，oChildNode 是要添加的孩子节点\n\n| 属性            | 作用                                    |\n| --------------- | --------------------------------------- |\n| childNodes      | 获取当前节点的所有子节点                |\n| firstChild      | 获取当前节点的第一个子节点              |\n| lastChild       | 获取当前节点的最后一个子节点            |\n| parentNode      | 获取当前节点的父节点                    |\n| nextSibling     | 获取当前节点的下一个节点                |\n| previousSibling | 获取当前节点的上一个节点                |\n| className       | 用于获取或设置标签的 class 属性值       |\n| innerHTML       | 表示获取/设置起始标签和结束标签中的内容 |\n| innerText       | 表示获取/设置起始标签和结束标签中的文本 |\n\nHTML代码：\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>dom查询</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"css.css\"/>\n    <script type=\"text/javascript\" src=\"js.js\"></script>\n</head>\n<body>\n<div id=\"total\">\n    <div class=\"inner\">\n        <p>\n            你喜欢哪个城市?\n        </p>\n\n        <ul id=\"city\">\n            <li id=\"bj\">北京</li>\n            <li>上海</li>\n            <li>东京</li>\n            <li>首尔</li>\n        </ul>\n\n        <br>\n        <br>\n\n        <p>\n            你喜欢哪款单机游戏?\n        </p>\n\n        <ul id=\"game\">\n            <li id=\"rl\">红警</li>\n            <li>实况</li>\n            <li>极品飞车</li>\n            <li>魔兽</li>\n        </ul>\n\n        <br/>\n        <br/>\n\n        <p>\n            你手机的操作系统是?\n        </p>\n\n        <ul id=\"phone\">\n            <li>IOS</li>\n            <li id=\"android\">Android</li>\n            <li>Windows Phone</li>\n        </ul>\n    </div>\n\n    <div class=\"inner\">\n        gender:\n        <input type=\"radio\" name=\"gender\" value=\"male\"/>\n        Male\n        <input type=\"radio\" name=\"gender\" value=\"female\"/>\n        Female\n        <br>\n        <br>\n        name:\n        <input type=\"text\" name=\"name\" id=\"username\" value=\"abcde\"/>\n    </div>\n</div>\n<div id=\"btnList\">\n    <div>\n        <button id=\"btn01\">查找#bj节点</button>\n    </div>\n    <div>\n        <button id=\"btn02\">查找所有li节点</button>\n    </div>\n    <div>\n        <button id=\"btn03\">查找name=gender的所有节点</button>\n    </div>\n    <div>\n        <button id=\"btn04\">查找#city下所有li节点</button>\n    </div>\n    <div>\n        <button id=\"btn05\">返回#city的所有子节点</button>\n    </div>\n    <div>\n        <button id=\"btn06\">返回#phone的第一个子节点</button>\n    </div>\n    <div>\n        <button id=\"btn07\">返回#bj的父节点</button>\n    </div>\n    <div>\n        <button id=\"btn08\">返回#android的前一个兄弟节点</button>\n    </div>\n    <div>\n        <button id=\"btn09\">返回#username的value属性值</button>\n    </div>\n    <div>\n        <button id=\"btn10\">设置#username的value属性值</button>\n    </div>\n    <div>\n        <button id=\"btn11\">返回#bj的文本值</button>\n    </div>\n</div>\n</body>\n</html>\n```\n\nJavaScript代码：\n\n```javascript\nwindow.onload = function () {\n    //1.查找#bj节点\n    document.getElementById(\"btn01\").onclick = function () {\n        var bjObj = document.getElementById(\"bj\");\n        alert(bjObj.innerHTML);\n    }\n    //2.查找所有li节点\n    var btn02Ele = document.getElementById(\"btn02\");\n    btn02Ele.onclick = function () {\n        var lis = document.getElementsByTagName(\"li\");\n        alert(lis.length)\n    };\n    //3.查找name=gender的所有节点\n    var btn03Ele = document.getElementById(\"btn03\");\n    btn03Ele.onclick = function () {\n        var genders = document.getElementsByName(\"gender\");\n        alert(genders.length)\n    };\n    //4.查找#city下所有li节点\n    var btn04Ele = document.getElementById(\"btn04\");\n    btn04Ele.onclick = function () {\n        //1 获取id为city的节点\n        //2 通过city节点.getElementsByTagName按标签名查子节点\n        var lis = document.getElementById(\"city\").getElementsByTagName(\"li\");\n        alert(lis.length)\n    };\n    //5.返回#city的所有子节点\n    var btn05Ele = document.getElementById(\"btn05\");\n    btn05Ele.onclick = function () {\n        //1 获取id为city的节点\n        //2 通过city获取所有子节点\n        //输出9 ：子节点包括5个换行空格和4个子标签\n        alert(document.getElementById(\"city\").childNodes.length);\n    };\n    //6.返回#phone的第一个子节点\n    var btn06Ele = document.getElementById(\"btn06\");\n    btn06Ele.onclick = function () {\n        // 查询id为phone的节点\n        alert(document.getElementById(\"phone\").firstChild.innerHTML);\n    };\n    //7.返回#bj的父节点\n    var btn07Ele = document.getElementById(\"btn07\");\n    btn07Ele.onclick = function () {\n        //1 查询id为bj的节点\n        var bjObj = document.getElementById(\"bj\");\n        //2 bj节点获取父节点\n        alert(bjObj.parentNode.innerHTML);\n    };\n    //8.返回#android的前一个兄弟节点\n    var btn08Ele = document.getElementById(\"btn08\");\n    btn08Ele.onclick = function () {\n        // 获取id为android的节点\n        // 通过android节点获取前面兄弟节点\n        alert(document.getElementById(\"android\").previousSibling.innerHTML);\n    };\n    //9.读取#username的value属性值\n    var btn09Ele = document.getElementById(\"btn09\");\n    btn09Ele.onclick = function () {\n        alert(document.getElementById(\"username\").value);\n    };\n    //10.设置#username的value属性值\n    var btn10Ele = document.getElementById(\"btn10\");\n    btn10Ele.onclick = function () {\n        document.getElementById(\"username\").value = \"国哥你真牛逼\";\n    };\n    //11.返回#bj的文本值\n    var btn11Ele = document.getElementById(\"btn11\");\n    btn11Ele.onclick = function () {\n        alert(document.getElementById(\"city\").innerHTML);\n        // alert(document.getElementById(\"city\").innerText);\n    };\n};\n```\n\nCSS代码：\n\n```css\n@CHARSET \"UTF-8\";\n\nbody {\n\twidth: 800px;\n\tmargin-left: auto;\n\tmargin-right: auto;\n}\n\nbutton {\n\twidth: 300px;\n\tmargin-bottom: 10px;\n}\n\n#btnList {\n\tfloat:left;\n}\n\n#total{\n\twidth: 450px;\n\tfloat:left;\n}\n\nul{\n\tlist-style-type: none;\n\tmargin: 0px;\n\tpadding: 0px;\n}\n\n.inner li{\n\tborder-style: solid;\n\tborder-width: 1px;\n\tpadding: 5px;\n\tmargin: 5px;\n\tbackground-color: #99ff99;\n\tfloat:left;\n}\n\n.inner{\n\twidth:400px;\n\tborder-style: solid;\n\tborder-width: 1px;\n\tmargin-bottom: 10px;\n\tpadding: 10px;\n\tfloat: left;\n}\n```","categories":["Java学习","前端"]},{"title":"JavaJDBC学习","url":"/2021/01/09/尚硅谷说Java/数据库/JavaJDBC/","content":"JavaJDBC学习\n<!--more-->\n# 第一章：JDBC概述\n\n## 1.1 数据的持久化\n\n- 持久化(persistence)：**把数据保存到可掉电式存储设备中以供之后使用**。大多数情况下，特别是企业级应用，**数据持久化意味着将内存中的数据保存到硬盘**上加以”固化”**，而持久化的实现过程大多通过各种关系数据库来完成**。\n\n- 持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。\n\n  ![1566741430592](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411.png) \n\n## 1.2 Java中的数据存储技术\n\n- 在Java中，数据库存取技术可分为如下几类：\n  - **JDBC**直接访问数据库\n  - JDO (Java Data Object )技术\n\n  - **第三方O/R工具**，如Hibernate, Mybatis 等\n\n- JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。\n\n## 1.3 JDBC介绍\n\n- JDBC(Java Database Connectivity)是一个**独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口**（一组API），定义了用来访问数据库的标准Java类库，（**java.sql,javax.sql**）使用这些类库可以以一种**标准**的方法、方便地访问数据库资源。\n- JDBC为访问不同的数据库提供了一种**统一的途径**，为开发者屏蔽了一些细节问题。\n- JDBC的目标是使Java程序员使用JDBC可以连接任何**提供了JDBC驱动程序**的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。\n- 如果没有JDBC，那么Java程序访问数据库时是这样的：\n\n![1555575760234](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-1.png)\n\n***\n\n- 有了JDBC，Java程序访问数据库时是这样的：\n\n\n![1555575981203](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-2.png)\n\n***\n\n- 总结如下：\n\n![1566741692804](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-3.png)\n\n## 1.4 JDBC体系结构\n\n- JDBC接口（API）包括两个层次：\n  - **面向应用的API**：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。\n  -  **面向数据库的API**：Java Driver API，供开发商开发数据库驱动程序用。\n\n> **JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。**\n>\n> **不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t————面向接口编程**\n\n## 1.5 JDBC程序编写步骤\n\n![1565969323908](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-4.png)\n\n> 补充：ODBC(**Open Database Connectivity**，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。\n\n# 第二章：获取数据库连接\n\n## 2.1 要素一：Driver接口实现类\n\n### 2.1.1 Driver接口介绍\n\n- java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。\n\n- 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。\n  - Oracle的驱动：**oracle.jdbc.driver.OracleDriver**\n  - mySql的驱动： **com.mysql.jdbc.Driver**\n    - [jar包下载地址](https://plumriver.lanzous.com/iyI4gk75xoj)\n\n![1555576157618](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-5.png)\n\n![1555576170074](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-6.png)\n\n- 将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。\n\n ![1566134718955](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-7.png)\n\n在驱动jar上右键-->Build Path-->Add to Build Path\n\n ![1566134781682](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-8.png)\n\n注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可\n\n ![1566135290460](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-9.png)\n\n#### 2.1.2 加载与注册JDBC驱动\n\n- 加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名\n\n  - **Class.forName(“com.mysql.jdbc.Driver”);**\n\n- 注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序\n\n  - **使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动**\n\n  - 通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类**都**包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：\n\n    ![1566136831283](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-10.png)\n\n## 2.2 要素二：URL\n\n- JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。\n\n- JDBC URL的标准由三部分组成，各部分间用冒号分隔。 \n\n  - **jdbc:子协议:子名称**\n  - **协议**：JDBC URL中的协议总是jdbc \n  - **子协议**：子协议用于标识一个数据库驱动程序\n  - **子名称**：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了**定位数据库**提供足够的信息。包含**主机名**(对应服务端的ip地址)**，端口号，数据库名**\n\n- 举例：\n\n  ![1555576477107](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-11.png)\n\n- **几种常用数据库的 JDBC URL**\n\n  - MySQL的连接URL编写方式：\n\n    - jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&参数=值\n    - jdbc:mysql://localhost:3306/atguigu\n    - jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）\n    - jdbc:mysql://localhost:3306/atguigu?user=root&password=123456\n\n  - Oracle 9i的连接URL编写方式：\n\n    - jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称\n    - jdbc:oracle:thin:@localhost:1521:atguigu\n\n  - SQLServer的连接URL编写方式：\n\n    - jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称\n\n    - jdbc:sqlserver://localhost:1433:DatabaseName=atguigu\n\n## 2.3 要素三：用户名和密码\n\n- user,password可以用“属性名=属性值”方式告诉数据库\n- 可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接\n\n## 2.4 数据库连接方式举例\n\n### 2.4.1 连接方式一\n\n```java\n/**\n * 第一种连接方式\n * 缺点：代码中含有第三方的引用\n * @throws SQLException\n */\n@Test\npublic void connection1 () throws SQLException {\n    //1.加载mysql的驱动\n    Driver driver = new com.mysql.jdbc.Driver();\n    /** url：用于指定访问的路径\n     * jdbc:    数据库的父协议\n     * mysql:   数据库的子协议\n     * //localhost:3306     默认mysql的端口号\n     * /test    指明使用那个数据库，test表示数据库名\n     */\n    //2.提供连接的数据库\n    String url = \"jdbc:mysql://localhost:3306/test\";\n    //3.提供链接使用的用户名和密码\n    Properties info = new Properties();\n    info.setProperty(\"user\", \"root\");\n    info.setProperty(\"password\", \"root\");\n    //4.获取链接\n    Connection connect = driver.connect(url, info);\n    System.out.println(connect);\n    //5.关闭连接\n    connect.close();\n}\n```\n\n### 2.4.2 连接方式二\n\n```java\n/**\n * 第二种连接方式\n * 使用反射的方式使此代码不具有第三方jar包\n * @throws Exception\n */\n@Test\npublic void connection2() throws Exception {\n    //1.加载驱动：使用反射的方式\n    Class clazz = Class.forName(\"com.mysql.jdbc.Driver\");\n    Driver driver = (Driver) clazz.newInstance();\n    //2.提供连接的数据库\n    String url = \"jdbc:mysql://localhost:3306/test\";\n    //3.提供链接使用的用户名和密码\n    Properties info = new Properties();\n    info.setProperty(\"user\", \"root\");\n    info.setProperty(\"password\", \"root\");\n    //4.获取链接\n    Connection connect = driver.connect(url, info);\n    System.out.println(connect);\n    //5.关闭连接\n    connect.close();\n}\n```\n\n### 2.4.3 连接方式三\n\n```java\n/**\n * 第三种连接方式\n * 使用DriverManager替换Driver\n * @throws Exception\n */\n@Test\npublic void connection3() throws Exception{\n    //1.提供三个基本信息\n    String url = \"jdbc:mysql://localhost:3306/test\";\n    String user = \"root\";\n    String password = \"root\";\n    //2.获取驱动对象\n    Class clazz = Class.forName(\"com.mysql.jdbc.Driver\");\n    Driver driver = (Driver) clazz.newInstance();\n    //注册驱动\n    DriverManager.registerDriver(driver);\n    //3..获取连接\n    Connection connection = DriverManager.getConnection(url, user, password);\n    System.out.println(connection);\n    //4.关闭连接\n    connection.close();\n}\n```\n\n### 2.4.4 连接方式四\n\n```java\n/**\n * 第四种链接方式\n * 对第三种链接方式在驱动方面的优化\n * @throws Exception\n */\n@Test\npublic void connection4() throws Exception{\n    //1.提供三个基本信息\n    String url = \"jdbc:mysql://localhost:3306/test\";\n    String user = \"root\";\n    String password = \"root\";\n    //2.获取驱动对象\n    /**\n         * 在通过反射将类加载到内存中时，Driver类中有一个静态代码块\n         * static {\n         *         try {\n         *             DriverManager.registerDriver(new Driver());\n         *         } catch (SQLException var1) {\n         *             throw new RuntimeException(\"Can't register driver!\");\n         *         }\n         *     }\n         *自动的加载驱动并注册\n         * 注意：Class.forName这一行也不写时，仍能运行成功，\n         *  原因是：jar包在使用时会加载配置文件，配置文件中含有com.mysql.jdbc.Driver会自动注册驱动\n         *  但是不建议不写Class.forName\n         */\n    Class.forName(\"com.mysql.jdbc.Driver\");\n\n    //3..获取连接\n    Connection connection = DriverManager.getConnection(url, user, password);\n    System.out.println(connection);\n    //4.关闭连接\n    connection.close();\n}\n```\n\n### 2.4.5 连接方式五(最终版)\n\n* 文件位置\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-12.png)\n\n* 配置文件信息\n\n```properties\n# 注意等号两边不要有空格，每一行的后面也不要有空格\nuser=root\npassword=root\ndriverClass=com.mysql.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true\n```\n\n* 主要代码\n\n```java\n/**\n* 第五种连接方式(最终版):使用配置文件的方式连接数据库\n* 以上的方法都存在硬编码的方式，不适合切换数据库。\n* 好处：① 实现了代码与数据的分离(解耦)\n*      ② 如果需要可以以修改配置文件，避免程序重新打包\n*/\n@Test\npublic void connection5() throws Exception{\n    //1.加载配置文件,获取4个基本信息\n    InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(\"jdbc.properties\");\n    Properties properties = new Properties();\n    properties.load(is);\n    String user = properties.getProperty(\"user\");\n    String password = properties.getProperty(\"password\");\n    String driverClass = properties.getProperty(\"driverClass\");\n    String url = properties.getProperty(\"url\");\n\n    //2.加载驱动\n    Class.forName(driverClass);\n    //3.获取链接\n    Connection connection = DriverManager.getConnection(url, user, password);\n    System.out.println(connection);\n    //4.关闭连接\n    connection.close();\n}\n```\n\n# 第三章：实现CRUD\n\n## 3.1 操作和访问数据库\n\n- 数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。\n\n- 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：\n\n  - Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 \n  - PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。\n  - CallableStatement：用于执行 SQL 存储过程\n\n  ![1566573842140](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-13.png)\n\n## 3.2 使用Statement操作数据表的弊端\n\n- 通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。\n\n- Statement 接口中定义了下列方法用于执行 SQL 语句：\n\n  ```sql\n  int excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETE\n  ResultSet executeQuery(String sql)：执行查询操作SELECT\n  ```\n\n- 但是使用Statement操作数据表存在弊端：\n\n  - **问题一：存在拼串操作，繁琐**\n  - **问题二：存在SQL注入问题**\n\n- SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user='a' OR 1 = ' AND password = ' OR '1' = '1') ，从而利用系统的 SQL 引擎完成恶意行为的做法。\n\n- 对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。\n\n- 代码演示：\n\n```java\n/**\n *使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题\n */\n@Test\npublic void testLogin() {\n    Scanner scanner = new Scanner(System.in);\n    //正常使用\n    //\t\tString user = \"AA\";\n    //\t\tString password = \"123456\";\n    //sql注入的测试\n    String user = \"1' or\";\n    String password = \"= 1 or '1' = '1\";\n    String sql = \"select user,password from user_table WHERE user = '\"+user+\"' and password = '\"+password+\"'\";\n    User user1 = get(sql, User.class);\n    if (user1 == null){\n        System.out.println(\"登陆失败\");\n    }else{\n        System.out.println(\"登陆成功\");\n    }\n}\n// 使用Statement实现对数据表的查询操作\npublic <T> T get(String sql, Class<T> clazz) {\n    T t = null;\n    Connection conn = null;\n    Statement st = null;\n    ResultSet rs = null;\n    try {\n        // 1.加载配置文件\n        InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(\"jdbc.properties\");\n        Properties pros = new Properties();\n        pros.load(is);\n        // 2.读取配置信息\n        String user = pros.getProperty(\"user\");\n        String password = pros.getProperty(\"password\");\n        String url = pros.getProperty(\"url\");\n        String driverClass = pros.getProperty(\"driverClass\");\n        // 3.加载驱动\n        Class.forName(driverClass);\n        // 4.获取连接\n        conn = DriverManager.getConnection(url, user, password);\n        st = conn.createStatement();\n        rs = st.executeQuery(sql);\n        // 获取结果集的元数据\n        ResultSetMetaData rsmd = rs.getMetaData();\n        // 获取结果集的列数\n        int columnCount = rsmd.getColumnCount();\n        if (rs.next()) {\n            t = clazz.newInstance();\n            for (int i = 0; i < columnCount; i++) {\n                // //1. 获取列的名称\n                // String columnName = rsmd.getColumnName(i+1);\n                // 1. 获取列的别名\n                String columnName = rsmd.getColumnLabel(i + 1);\n                // 2. 根据列名获取对应数据表中的数据\n                Object columnVal = rs.getObject(columnName);\n                // 3. 将数据表中得到的数据，封装进对象\n                Field field = clazz.getDeclaredField(columnName);\n                field.setAccessible(true);\n                field.set(t, columnVal);\n            }\n            return t;\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        // 关闭资源\n        if (rs != null) {\n            try {\n                rs.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if (st != null) {\n            try {\n                st.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if (conn != null) {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}\n```\n\n综上：\n\n![1566569819744](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-14.png)\n\n## 3.3 PreparedStatement的使用\n\n### 3.3.1 PreparedStatement介绍\n\n- 可以通过调用 Connection 对象的 **preparedStatement(String sql)** 方法获取 PreparedStatement 对象\n\n- **PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句**\n\n- PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值\n\n### 3.3.2 PreparedStatement vs Statement\n\n- 代码的可读性和可维护性。\n\n- **PreparedStatement 能最大可能提高性能：**\n  - DBServer会对**预编译**语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u>\n  - 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u>\n  - (语法检查，语义检查，翻译成二进制命令，缓存)\n\n- PreparedStatement 可以防止 SQL 注入 \n\n### 3.3.3 Java与SQL对应数据类型转换表\n\n| Java类型           | SQL类型                  |\n| ------------------ | ------------------------ |\n| boolean            | BIT                      |\n| byte               | TINYINT                  |\n| short              | SMALLINT                 |\n| int                | INTEGER                  |\n| long               | BIGINT                   |\n| String             | CHAR,VARCHAR,LONGVARCHAR |\n| byte   array       | BINARY  ,    VAR BINARY  |\n| java.sql.Date      | DATE                     |\n| java.sql.Time      | TIME                     |\n| java.sql.Timestamp | TIMESTAMP                |\n\n### 3.3.4 使用PreparedStatement实现增、删、改操作\n\n```java\n/**\n * 使用PreparedStatement实现增删改的通用操作\n * @param sql 表示要执行的sql语句\n * @param args 表示参数\n */\npublic void updateJDBC(String sql, Object ...args){\n    Connection connection = null;\n    PreparedStatement preparedStatement = null;\n    try {\n        //1.获取数据库连接\n        connection = ConnectionUtil.getConnection();\n        //2.预编译sql语句\n        preparedStatement = connection.prepareStatement(sql);\n        //3.填充占位符\n        for (int i = 0; i < args.length; i++) {\n            preparedStatement.setObject(i+1,args[i]);\n        }\n        //4.执行\n        preparedStatement.execute();\n    } catch (SQLException throwables) {\n        throwables.printStackTrace();\n    } finally {\n        //5.关闭数据库\n        ConnectionUtil.close(connection,preparedStatement);\n    }\n}\n```\n\n### 3.3.5 使用PreparedStatement实现查询操作\n\n```java\n/**\n * 通用的查询操作。可以在不同表，不同限制下执行\n * @param clazz 数据库表对应的实体类的class\n * @param sql  查询语句\n * @param args 限制参数\n * @param <T>  泛型，表示数据库表对应的实体类\n * @return\n */\npublic <T> List<T> query(Class<T> clazz,String sql,Object ...args){\n    List<T> list = new ArrayList<>();\n    Connection connection = null;\n    PreparedStatement statement = null;\n    ResultSet resultSet = null;\n    try {\n        //获取链接。ConnectionUtil为自定义方法\n        connection = ConnectionUtil.getConnection();\n        statement = connection.prepareStatement(sql);\n        for (int i = 0; i < args.length; i++) {\n            statement.setObject(i+1,args[i]);\n        }\n        resultSet = statement.executeQuery();\n        //获取结果集的元数据：ResultSetMetaData\n        ResultSetMetaData metaData = resultSet.getMetaData();\n        //通过ResultSetMetaData获取结果集中的列数\n        int count = metaData.getColumnCount();\n        while (resultSet.next()){\n            T object = clazz.newInstance();\n            for (int i = 0; i < count; i++) {\n                //获取每个数据的列值\n                Object columnValue = resultSet.getObject(i+1);\n                //获取列的列名：getColumnName()  -- 不推荐使用\n                //获取列的别名：getColumnLabel()\n                String columnLabel = metaData.getColumnLabel(i + 1);\n                //给customer对象指定的columnName属性赋值为columnValue:通过反射的方式实现\n                Field field = clazz.getDeclaredField(columnLabel);\n                field.setAccessible(true);\n                field.set(object,columnValue);\n            }\n            list.add(object);\n        }\n        return list;\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        ConnectionUtil.close(connection,statement,resultSet);\n    }\n    return null;\n}\n```\n\n> 说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。\n\n## 3.4 ResultSet与ResultSetMetaData\n\n### 3.4.1 ResultSet\n\n- 查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象\n\n- ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现\n\n- ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。\n\n- ResultSet 对象维护了一个指向当前数据行的**游标**，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。\n\n- 当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。\n\n  - 例如: getInt(1), getString(\"name\")\n  - **注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。**\n\n- ResultSet 接口的常用方法：\n\n  - boolean next()\n\n  - getString()\n  - …\n\n  ![1555580152530](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-15.png)\n\n### 3.4.2 ResultSetMetaData\n\n- 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象\n\n- ResultSetMetaData meta = rs.getMetaData();\n  - **getColumnName**(int column)：获取指定列的名称\n  - **getColumnLabel**(int column)：获取指定列的别名\n  - **getColumnCount**()：返回当前 ResultSet 对象中的列数。 \n\n  - getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 \n  - getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 \n  - **isNullable**(int column)：指示指定列中的值是否可以为 null。 \n\n  - isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 \n\n![1555579494691](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-16.png)\n\n**问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？**\n\n​     需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData\n\n**问题2：关于ResultSetMetaData**\n\n1. **如何获取 ResultSetMetaData**： 调用 ResultSet 的 getMetaData() 方法即可\n2. **获取 ResultSet 中有多少列**：调用 ResultSetMetaData 的 getColumnCount() 方法\n3. **获取 ResultSet 每一列的列的别名是什么**：调用 ResultSetMetaData 的getColumnLabel() 方法\n\n![1555579816884](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-17.png)\n\n## 3.5 资源的释放\n\n- 释放ResultSet, Statement,Connection。\n- 数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是**尽量晚创建，尽量早的释放。**\n- 可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。\n\n## 3.6 JDBC API小结\n\n- 两种思想\n\n  - 面向接口编程的思想\n\n  - ORM思想(object relational mapping)\n    - 一个数据表对应一个java类\n    - 表中的一条记录对应java类的一个对象\n    - 表中的一个字段对应java类的一个属性\n\n  > sql是需要结合列名和表的属性名来写。注意起别名。\n\n- 两种技术\n\n  - JDBC结果集的元数据：ResultSetMetaData\n    - 获取列数：getColumnCount()\n    - 获取列的别名：getColumnLabel()\n  - 通过反射，创建指定类的对象，获取指定的属性并赋值\n\n# 第四章：操作BLOB类型字段\n\n## 4.1 MySQL BLOB类型\n\n- MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。\n- 插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。\n\n- MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)\n\n![1555581069798](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-18.png)\n\n- 实际使用中根据需要存入的数据大小定义不同的BLOB类型。\n- 需要注意的是：如果存储的文件过大，数据库的性能会下降。\n- 如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： **max_allowed_packet=16M**。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。\n\n## 4.2 向数据表中插入大数据类型\n\n```java\npublic void testInsert(){\n    Connection connection = null;\n    PreparedStatement preparedStatement = null;\n    try {\n        connection = ConnectionUtil.getConnection();\n        String sql = \"insert into customers(name, email, birth, photo) VALUES (?,?,?,?)\";\n        preparedStatement = connection.prepareStatement(sql);\n        preparedStatement.setObject(1, \"阿松大\");\n        preparedStatement.setObject(2, \"阿松大\");\n        preparedStatement.setObject(3, \"2021-1-1\");\n        FileInputStream inputStream = new FileInputStream(new File(\"C:\\\\Users\\\\wwwqq\\\\Pictures\\\\王.jpg\"));\n        //preparedStatement.setBlob(4, inputStream);\n        preparedStatement.setObject(4, inputStream);\n        preparedStatement.execute();\n    } catch (Exception throwables) {\n        throwables.printStackTrace();\n    }finally {\n        ConnectionUtil.close(connection,preparedStatement);\n    }\n}\n```\n\n## 4.3 修改数据表中的Blob类型字段\n\n```java\nConnection conn = JDBCUtils.getConnection();\nString sql = \"update customers set photo = ? where id = ?\";\nPreparedStatement ps = conn.prepareStatement(sql);\n// 填充占位符\n// 操作Blob类型的变量\nFileInputStream fis = new FileInputStream(\"coffee.png\");\nps.setBlob(1, fis);\nps.setInt(2, 25);\n\nps.execute();\nfis.close();\nJDBCUtils.closeResource(conn, ps);\n```\n\n## 4.4 从数据表中读取大数据类型\n\n```java\npublic void testQuery(){\n    Connection connection = null;\n    PreparedStatement preparedStatement = null;\n    ResultSet resultSet = null;\n    InputStream binaryStream = null;\n    FileOutputStream fileOutputStream = null;\n    try {\n        connection = ConnectionUtil.getConnection();\n        String sql = \"select id,name,email,birth,photo from customers where id = ?\";\n        preparedStatement = connection.prepareStatement(sql);\n        preparedStatement.setInt(1,24);\n        resultSet = preparedStatement.executeQuery();\n        if (resultSet.next()){\n            int id = resultSet.getInt(1);\n            String name = resultSet.getString(2);\n            String email = resultSet.getString(3);\n            Date birth = resultSet.getDate(4);\n            Customer customer = new Customer(id, name, email, birth);\n            System.out.println(customer);\n            //将Blob类型字段的数据下载下来，以文件的方式保存在本地\n            Blob blob = resultSet.getBlob(5);\n            binaryStream = blob.getBinaryStream();\n            fileOutputStream = new FileOutputStream(new File(\"1.jpg\"));\n            byte[] bytes = new byte[1024];\n            int len;\n            while ((len=binaryStream.read(bytes)) != -1){\n                fileOutputStream.write(bytes,0,len);\n            }\n        }\n    } catch (Exception throwables) {\n        throwables.printStackTrace();\n    }  finally {\n        try {\n            if (fileOutputStream != null) {\n                fileOutputStream.close();\n            }\n        } catch (Exception throwables) {\n            throwables.printStackTrace();\n        }\n        try {\n            if (binaryStream != null) {\n                binaryStream.close();\n            }\n        } catch (Exception throwables) {\n            throwables.printStackTrace();\n        }\n        ConnectionUtil.close(connection,preparedStatement,resultSet);\n    }\n}\n```\n\n# 第五章：批量插入\n\n## 5.1 批量执行SQL语句\n\n当需要成批插入或者更新记录时，可以采用Java的批量**更新**机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率\n\nJDBC的批量处理语句包括下面三个方法：\n\n- **addBatch(String)：添加需要批量处理的SQL语句或是参数；**\n- **executeBatch()：执行批量处理语句；**\n- **clearBatch():清空缓存的数据**\n\n通常我们会遇到两种批量执行SQL语句的情况：\n\n- 多条SQL语句的批量处理；\n- 一个SQL语句的批量传参；\n\n## 5.2 高效的批量插入\n\n举例：向数据表中插入20000条数据\n\n- 数据库中提供一个goods表。创建如下：\n\n```sql\nCREATE TABLE goods(\nid INT PRIMARY KEY AUTO_INCREMENT,\nNAME VARCHAR(20)\n);\n```\n\n### 5.2.1 实现层次一：使用Statement\n\n```java\n//方式一：使用Statement实现批量插入\nlong start1 = System.currentTimeMillis();\nConnection connection1 = null;\nStatement statement1 = null;\ntry {\n    connection1 = ConnectionUtil.getConnection();\n    statement1 = connection1.createStatement();\n    for (int i = 0; i < 20000; i++) {\n        String sql = \"insert into goods(name) values ('name_\"+ i +\"')\";\n        statement1.execute(sql);\n    }\n} catch (SQLException throwables) {\n    throwables.printStackTrace();\n} finally {\n    ConnectionUtil.close(connection1,statement1);\n}\nlong end1 = System.currentTimeMillis();\n//使用Statement的时间为：28338\nSystem.out.println(\"使用Statement的时间为：\"+(end1-start1));\n```\n\n### 5.2.2 实现层次二：使用PreparedStatement\n\n```java\n //方式二：使用PreparedStatement实现批量插入\nlong start2 = System.currentTimeMillis();\nConnection connection2 = null;\nPreparedStatement ps = null;\ntry {\n    connection2 = ConnectionUtil.getConnection();\n    String sql = \"insert into goods(name) values (?)\";\n    ps = connection2.prepareStatement(sql);\n    for (int i = 0; i < 20000; i++) {\n        ps.setObject(1,\"name_\" + i);\n        ps.execute();\n    }\n} catch (SQLException throwables) {\n    throwables.printStackTrace();\n} finally {\n    ConnectionUtil.close(connection2,ps);\n}\nlong end2 = System.currentTimeMillis();\n//使用PreparedStatement的时间为：27776\nSystem.out.println(\"使用PreparedStatement的时间为：\"+(end2-start2));\n```\n\n### 5.2.3 实现层次三\n\n```java\n/**\n * 使用PreparedStatement实现批量操作\n *  使用Batch进行优化。\n * 修改1： 使用 addBatch() / executeBatch() / clearBatch()\n * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。\n * \t\t ?rewriteBatchedStatements=true 写在配置文件的url后面\n * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar\n */\n@Test\npublic void testBatchThree(){\n    long start = System.currentTimeMillis();\n    Connection connection = null;\n    PreparedStatement ps = null;\n    try {\n        connection = ConnectionUtil.getConnection();\n        String sql = \"insert into goods(name) values (?)\";\n        ps = connection.prepareStatement(sql);\n        for (int i = 0; i < 1000000; i++) {\n            ps.setObject(1,\"name_\" + i);\n\n            //1.攒sql\n            ps.addBatch();\n            if(i%500==0){\n                //2.执行\n                ps.executeBatch();\n                //3.清空\n                ps.clearBatch();\n            }\n\n        }\n    } catch (SQLException throwables) {\n        throwables.printStackTrace();\n    } finally {\n        ConnectionUtil.close(connection,ps);\n    }\n    long end = System.currentTimeMillis();\n    //使用PreparedStatement插入20000条数据的时间为：460\n    //使用PreparedStatement插入1000000条数据的时间为：7945\n    System.out.println(\"使用PreparedStatement的时间为：\"+(end-start));\n}\n```\n\n### 5.2.4 实现层次四(最终版)\n\n```java\n/**\n * 使用Connection 的 setAutoCommit(false)  /  commit()\n * 使用 addBatch() / executeBatch() / clearBatch()\n * ?rewriteBatchedStatements=true 写在配置文件的url后面\n * 使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar\n */\n@Test\npublic void testBatchFour(){\n    long start = System.currentTimeMillis();\n    Connection connection = null;\n    PreparedStatement ps = null;\n    try {\n        connection = ConnectionUtil.getConnection();\n        //设置为不自动提交\n        connection.setAutoCommit(false);\n        String sql = \"insert into goods(name) values (?)\";\n        ps = connection.prepareStatement(sql);\n        for (int i = 0; i < 1000000; i++) {\n            ps.setObject(1,\"name_\" + i);\n\n            //1.攒sql\n            ps.addBatch();\n            if(i % 500==0){\n                //2.执行\n                ps.executeBatch();\n                //3.清空\n                ps.clearBatch();\n            }\n        }\n        //手动提交\n        connection.commit();\n    } catch (SQLException throwables) {\n        throwables.printStackTrace();\n    } finally {\n        ConnectionUtil.close(connection,ps);\n    }\n    long end = System.currentTimeMillis();\n    //使用PreparedStatement插入1000000条数据的时间为：4737\n    System.out.println(\"使用PreparedStatement的时间为：\"+(end-start));\n}\n```\n\n# 第六章：数据库事务\n\n## 6.1 数据库事务介绍\n\n- **事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。**\n\n- **事务处理（事务操作）：**保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都**被提交(commit)**，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务**回滚(rollback)**到最初状态。\n\n- 为确保数据库中数据的**一致性**，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 \n\n## 6.2 JDBC事务处理\n\n- 数据一旦提交，就不可回滚。\n\n- 数据什么时候意味着提交？\n\n  - **当一个连接对象被创建时，默认情况下是自动提交事务**：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。\n  - **关闭数据库连接，数据就会自动的提交。**如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。\n\n- **JDBC程序中为了让多个 SQL 语句作为一个事务执行：**\n\n  - 调用 Connection 对象的 **setAutoCommit(false);** 以取消自动提交事务\n  - 在所有的 SQL 语句都成功执行后，调用 **commit();** 方法提交事务\n  - 在出现异常时，调用 **rollback();** 方法回滚事务\n\n  > 若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。\n\n【案例：用户AA向用户BB转账100】\n\n```java\n@Test\npublic void testUpdate2(){\n    Connection connection = null;\n    try {\n        //获取链接\n        connection = ConnectionUtil.getConnection();\n        //1.设置不自动提交\n        connection.setAutoCommit(false);\n\n        String sql1 = \"update user_table set balance = balance-100 where user = ?\";\n        updateJDBC2(connection,sql1,\"AA\");\n\n        //模拟网络异常\n        System.out.println(10/0);\n\n        String sql2 = \"update user_table set balance = balance+100 where user = ?\";\n        updateJDBC2(connection,sql2,\"BB\");\n        //2.提交\n        connection.commit();\n    } catch (Exception e) {\n        e.printStackTrace();\n        //3.回滚\n        try {\n            connection.rollback();\n        } catch (SQLException throwables) {\n            throwables.printStackTrace();\n        }\n    } finally {\n        //在关闭连接前建议恢复连接的属性\n        //主要在数据库连接池方面的应用\n        try {\n            connection.setAutoCommit(true);\n        } catch (SQLException throwables) {\n            throwables.printStackTrace();\n        }\n        //关闭连接\n        ConnectionUtil.close(connection);\n    }\n}\n\n/**\n * 使用PreparedStatement实现增删改的通用操作 --2.0版本\n *      考虑数据库事务后的升级\n * @param sql 表示要执行的sql语句\n * @param args 表示参数\n */\npublic void updateJDBC2(Connection connection,String sql, Object ...args) throws SQLException {\n    PreparedStatement preparedStatement = null;\n    //2.预编译sql语句\n    preparedStatement = connection.prepareStatement(sql);\n    //3.填充占位符\n    for (int i = 0; i < args.length; i++) {\n        preparedStatement.setObject(i+1,args[i]);\n    }\n    //4.执行\n    preparedStatement.execute();\n    //关闭资源\n    preparedStatement.close();\n}\n```\n\n## 6.3 事务的ACID属性\n\n1. **原子性（Atomicity）**\n   原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 \n\n2. **一致性（Consistency）**\n   事务必须使数据库从一个一致性状态变换到另外一个一致性状态。\n\n3. **隔离性（Isolation）**\n   事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。\n\n4. **持久性（Durability）**\n   持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。\n\n### 6.3.1 数据库的并发问题\n\n- 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:\n  - **脏读**: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还**没有被提交**的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。\n  - **不可重复读**: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 **更新**了该字段。之后, T1再次读取同一个字段, 值就不同了。\n  - **幻读**: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中**插入**了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。\n\n- **数据库事务的隔离性**: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。\n\n- 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, **隔离级别越高, 数据一致性就越好, 但并发性越弱。**\n\n### 6.3.2 四种隔离级别\n\n- 数据库提供的4种事务隔离级别：\n\n  ![1555586275271](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-19.png)\n\n- Oracle 支持的 2 种事务隔离级别：**READ COMMITED**, SERIALIZABLE。 Oracle 默认的事务隔离级别为: **READ COMMITED** 。\n\n\n- Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: **REPEATABLE READ。**\n\n### 6.3.3 在MySql中设置隔离级别\n\n- 每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。\n\n- 查看当前的隔离级别: \n\n  ```mysql\n  SELECT @@tx_isolation;\n  ```\n\n- 设置当前 mySQL 连接的隔离级别:  \n\n  ```mysql\n  set  transaction isolation level read committed;\n  ```\n\n- 设置数据库系统的全局的隔离级别:\n\n  ```mysql\n  set global transaction isolation level read committed;\n  ```\n\n- 补充操作：\n\n  - 创建mysql数据库用户：\n\n    ```mysql\n    create user tom identified by 'abc123';\n    ```\n\n  - 授予权限\n\n    ```mysql\n    #授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.\n    grant all privileges on *.* to tom@'%'  identified by 'abc123'; \n    \n     #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。\n    grant select,insert,delete,update on atguigudb.* to tom@localhost identified by 'abc123'; \n    ```\n\n\n# 第七章：DAO及相关实现类\n\n- DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO\n- 作用：为了实现功能的模块化，更有利于代码的维护和升级。\n- 下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现：\n\n![1566726681515](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-20.png)\n\n- 层次结构：\n\n![1566745811244](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-21.png)\n\n### 【BaseDAO.java】\n\n```java\npackage com.atguigu.bookstore.dao;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\n\nimport org.apache.commons.dbutils.QueryRunner;\nimport org.apache.commons.dbutils.handlers.BeanHandler;\nimport org.apache.commons.dbutils.handlers.BeanListHandler;\nimport org.apache.commons.dbutils.handlers.ScalarHandler;\n\n\n/**\n * 定义一个用来被继承的对数据库进行基本操作的Dao\n * \n * @author HanYanBing\n *\n * @param <T>\n */\npublic abstract class BaseDao<T> {\n\tprivate QueryRunner queryRunner = new QueryRunner();\n\t// 定义一个变量来接收泛型的类型\n\tprivate Class<T> type;\n\n\t// 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定\n\tpublic BaseDao() {\n\t\t// 获取子类的类型\n\t\tClass clazz = this.getClass();\n\t\t// 获取父类的类型\n\t\t// getGenericSuperclass()用来获取当前类的父类的类型\n\t\t// ParameterizedType表示的是带泛型的类型\n\t\tParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass();\n\t\t// 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型\n\t\t// 这个方法会返回一个Type的数组\n\t\tType[] types = parameterizedType.getActualTypeArguments();\n\t\t// 获取具体的泛型的类型·\n\t\tthis.type = (Class<T>) types[0];\n\t}\n\n\t/**\n\t * 通用的增删改操作\n\t * \n\t * @param sql\n\t * @param params\n\t * @return\n\t */\n\tpublic int update(Connection conn,String sql, Object... params) {\n\t\tint count = 0;\n\t\ttry {\n\t\t\tcount = queryRunner.update(conn, sql, params);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t} \n\t\treturn count;\n\t}\n\n\t/**\n\t * 获取一个对象\n\t * \n\t * @param sql\n\t * @param params\n\t * @return\n\t */\n\tpublic T getBean(Connection conn,String sql, Object... params) {\n\t\tT t = null;\n\t\ttry {\n\t\t\tt = queryRunner.query(conn, sql, new BeanHandler<T>(type), params);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t} \n\t\treturn t;\n\t}\n\n\t/**\n\t * 获取所有对象\n\t * \n\t * @param sql\n\t * @param params\n\t * @return\n\t */\n\tpublic List<T> getBeanList(Connection conn,String sql, Object... params) {\n\t\tList<T> list = null;\n\t\ttry {\n\t\t\tlist = queryRunner.query(conn, sql, new BeanListHandler<T>(type), params);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t} \n\t\treturn list;\n\t}\n\n\t/**\n\t * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句\n\t * \n\t * @param sql\n\t * @param params\n\t * @return\n\t */\n\tpublic Object getValue(Connection conn,String sql, Object... params) {\n\t\tObject count = null;\n\t\ttry {\n\t\t\t// 调用queryRunner的query方法获取一个单一的值\n\t\t\tcount = queryRunner.query(conn, sql, new ScalarHandler<>(), params);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t} \n\t\treturn count;\n\t}\n}\n```\n\n### 【BookDAO.java】\n\n```java\npackage com.atguigu.bookstore.dao;\n\nimport java.sql.Connection;\nimport java.util.List;\n\nimport com.atguigu.bookstore.beans.Book;\nimport com.atguigu.bookstore.beans.Page;\n\npublic interface BookDao {\n\n\t/**\n\t * 从数据库中查询出所有的记录\n\t * \n\t * @return\n\t */\n\tList<Book> getBooks(Connection conn);\n\n\t/**\n\t * 向数据库中插入一条记录\n\t * \n\t * @param book\n\t */\n\tvoid saveBook(Connection conn,Book book);\n\n\t/**\n\t * 从数据库中根据图书的id删除一条记录\n\t * \n\t * @param bookId\n\t */\n\tvoid deleteBookById(Connection conn,String bookId);\n\n\t/**\n\t * 根据图书的id从数据库中查询出一条记录\n\t * \n\t * @param bookId\n\t * @return\n\t */\n\tBook getBookById(Connection conn,String bookId);\n\n\t/**\n\t * 根据图书的id从数据库中更新一条记录\n\t * \n\t * @param book\n\t */\n\tvoid updateBook(Connection conn,Book book);\n\n\t/**\n\t * 获取带分页的图书信息\n\t * \n\t * @param page：是只包含了用户输入的pageNo属性的page对象\n\t * @return 返回的Page对象是包含了所有属性的Page对象\n\t */\n\tPage<Book> getPageBooks(Connection conn,Page<Book> page);\n\n\t/**\n\t * 获取带分页和价格范围的图书信息\n\t * \n\t * @param page：是只包含了用户输入的pageNo属性的page对象\n\t * @return 返回的Page对象是包含了所有属性的Page对象\n\t */\n\tPage<Book> getPageBooksByPrice(Connection conn,Page<Book> page, double minPrice, double maxPrice);\n\n}\n```\n\n### 【UserDAO.java】\n\n```java\npackage com.atguigu.bookstore.dao;\n\nimport java.sql.Connection;\n\nimport com.atguigu.bookstore.beans.User;\n\npublic interface UserDao {\n\n\t/**\n\t * 根据User对象中的用户名和密码从数据库中获取一条记录\n\t * \n\t * @param user\n\t * @return User 数据库中有记录 null 数据库中无此记录\n\t */\n\tUser getUser(Connection conn,User user);\n\n\t/**\n\t * 根据User对象中的用户名从数据库中获取一条记录\n\t * \n\t * @param user\n\t * @return true 数据库中有记录 false 数据库中无此记录\n\t */\n\tboolean checkUsername(Connection conn,User user);\n\n\t/**\n\t * 向数据库中插入User对象\n\t * \n\t * @param user\n\t */\n\tvoid saveUser(Connection conn,User user);\n}\n```\n\n### 【BookDaoImpl.java】\n\n```java\npackage com.atguigu.bookstore.dao.impl;\n\nimport java.sql.Connection;\nimport java.util.List;\n\nimport com.atguigu.bookstore.beans.Book;\nimport com.atguigu.bookstore.beans.Page;\nimport com.atguigu.bookstore.dao.BaseDao;\nimport com.atguigu.bookstore.dao.BookDao;\n\npublic class BookDaoImpl extends BaseDao<Book> implements BookDao {\n\n\t@Override\n\tpublic List<Book> getBooks(Connection conn) {\n\t\t// 调用BaseDao中得到一个List的方法\n\t\tList<Book> beanList = null;\n\t\t// 写sql语句\n\t\tString sql = \"select id,title,author,price,sales,stock,img_path imgPath from books\";\n\t\tbeanList = getBeanList(conn,sql);\n\t\treturn beanList;\n\t}\n\n\t@Override\n\tpublic void saveBook(Connection conn,Book book) {\n\t\t// 写sql语句\n\t\tString sql = \"insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)\";\n\t\t// 调用BaseDao中通用的增删改的方法\n\t\tupdate(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath());\n\t}\n\n\t@Override\n\tpublic void deleteBookById(Connection conn,String bookId) {\n\t\t// 写sql语句\n\t\tString sql = \"DELETE FROM books WHERE id = ?\";\n\t\t// 调用BaseDao中通用增删改的方法\n\t\tupdate(conn,sql, bookId);\n\t\t\t\n\t}\n\n\t@Override\n\tpublic Book getBookById(Connection conn,String bookId) {\n\t\t// 调用BaseDao中获取一个对象的方法\n\t\tBook book = null;\n\t\t// 写sql语句\n\t\tString sql = \"select id,title,author,price,sales,stock,img_path imgPath from books where id = ?\";\n\t\tbook = getBean(conn,sql, bookId);\n\t\treturn book;\n\t}\n\n\t@Override\n\tpublic void updateBook(Connection conn,Book book) {\n\t\t// 写sql语句\n\t\tString sql = \"update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?\";\n\t\t// 调用BaseDao中通用的增删改的方法\n\t\tupdate(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId());\n\t}\n\n\t@Override\n\tpublic Page<Book> getPageBooks(Connection conn,Page<Book> page) {\n\t\t// 获取数据库中图书的总记录数\n\t\tString sql = \"select count(*) from books\";\n\t\t// 调用BaseDao中获取一个单一值的方法\n\t\tlong totalRecord = (long) getValue(conn,sql);\n\t\t// 将总记录数设置都page对象中\n\t\tpage.setTotalRecord((int) totalRecord);\n\n\t\t// 获取当前页中的记录存放的List\n\t\tString sql2 = \"select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?\";\n\t\t// 调用BaseDao中获取一个集合的方法\n\t\tList<Book> beanList = getBeanList(conn,sql2, (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE);\n\t\t// 将这个List设置到page对象中\n\t\tpage.setList(beanList);\n\t\treturn page;\n\t}\n\n\t@Override\n\tpublic Page<Book> getPageBooksByPrice(Connection conn,Page<Book> page, double minPrice, double maxPrice) {\n\t\t// 获取数据库中图书的总记录数\n\t\tString sql = \"select count(*) from books where price between ? and ?\";\n\t\t// 调用BaseDao中获取一个单一值的方法\n\t\tlong totalRecord = (long) getValue(conn,sql,minPrice,maxPrice);\n\t\t// 将总记录数设置都page对象中\n\t\tpage.setTotalRecord((int) totalRecord);\n\n\t\t// 获取当前页中的记录存放的List\n\t\tString sql2 = \"select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?\";\n\t\t// 调用BaseDao中获取一个集合的方法\n\t\tList<Book> beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE);\n\t\t// 将这个List设置到page对象中\n\t\tpage.setList(beanList);\n\t\t\n\t\treturn page;\n\t}\n\n}\n```\n\n### 【UserDaoImpl.java】\n\n```java\npackage com.atguigu.bookstore.dao.impl;\n\nimport java.sql.Connection;\n\nimport com.atguigu.bookstore.beans.User;\nimport com.atguigu.bookstore.dao.BaseDao;\nimport com.atguigu.bookstore.dao.UserDao;\n\npublic class UserDaoImpl extends BaseDao<User> implements UserDao {\n\n\t@Override\n\tpublic User getUser(Connection conn,User user) {\n\t\t// 调用BaseDao中获取一个对象的方法\n\t\tUser bean = null;\n\t\t// 写sql语句\n\t\tString sql = \"select id,username,password,email from users where username = ? and password = ?\";\n\t\tbean = getBean(conn,sql, user.getUsername(), user.getPassword());\n\t\treturn bean;\n\t}\n\n\t@Override\n\tpublic boolean checkUsername(Connection conn,User user) {\n\t\t// 调用BaseDao中获取一个对象的方法\n\t\tUser bean = null;\n\t\t// 写sql语句\n\t\tString sql = \"select id,username,password,email from users where username = ?\";\n\t\tbean = getBean(conn,sql, user.getUsername());\n\t\treturn bean != null;\n\t}\n\n\t@Override\n\tpublic void saveUser(Connection conn,User user) {\n\t\t//写sql语句\n\t\tString sql = \"insert into users(username,password,email) values(?,?,?)\";\n\t\t//调用BaseDao中通用的增删改的方法\n\t\tupdate(conn,sql, user.getUsername(),user.getPassword(),user.getEmail());\n\t}\n\n}\n```\n\n### 【Book.java】\n\n```java\npackage com.atguigu.bookstore.beans;\n/**\n * 图书类\n * @author songhongkang\n *\n */\npublic class Book {\n\n\tprivate Integer id;\n\tprivate String title; // 书名\n\tprivate String author; // 作者\n\tprivate double price; // 价格\n\tprivate Integer sales; // 销量\n\tprivate Integer stock; // 库存\n\tprivate String imgPath = \"static/img/default.jpg\"; // 封面图片的路径\n\t//构造器，get()，set()，toString()方法略\n}\n```\n\n### 【Page.java】\n\n```java\npackage com.atguigu.bookstore.beans;\n\nimport java.util.List;\n/**\n * 页码类\n * @author songhongkang\n *\n */\npublic class Page<T> {\n\n\tprivate List<T> list; // 每页查到的记录存放的集合\n\tpublic static final int PAGE_SIZE = 4; // 每页显示的记录数\n\tprivate int pageNo; // 当前页\n//\tprivate int totalPageNo; // 总页数，通过计算得到\n\tprivate int totalRecord; // 总记录数，通过查询数据库得到\n\n```\n\n### 【User.java】\n\n```java\npackage com.atguigu.bookstore.beans;\n/**\n * 用户类\n * @author songhongkang\n *\n */\npublic class User {\n\n\tprivate Integer id;\n\tprivate String username;\n\tprivate String password;\n\tprivate String email;\n\n```\n\n# 第八章：数据库连接池\n\n## 8.1 JDBC数据库连接池的必要性\n\n- 在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　　\n  - **在主程序（如servlet、beans）中建立数据库连接**\n  - **进行sql操作**\n  - **断开数据库连接**\n\n- 这种模式开发，存在的问题:\n  - 普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。**数据库的连接资源并没有得到很好的重复利用。**若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。\n  - **对于每一次数据库连接，使用完后都得断开。**否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？）\n  - **这种开发不能控制被创建的连接对象数**，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 \n\n## 8.2 数据库连接池技术\n\n- 为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。\n- **数据库连接池的基本思想**：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。\n\n- **数据库连接池**负责分配、管理和释放数据库连接，它**允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个**。\n- 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由**最小数据库连接数来设定**的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的**最大数据库连接数量**限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。\n\n![1555593464033](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-22.png)\n\n- **工作原理：**\n\n![1555593598606](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210109130411-23.png)\n\n- **数据库连接池技术的优点**\n\n  **1. 资源重用**\n\n  由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。\n\n  **2. 更快的系统反应速度**\n\n  数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间\n\n  **3. 新的资源分配手段**\n\n  对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源\n\n  **4. 统一的连接管理，避免数据库连接泄漏**\n\n  在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露\n\n## 8.3 多种开源的数据库连接池\n\n- JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：\n  - **DBCP** 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。**速度相对c3p0较快**，但因自身存在BUG，Hibernate3已不再提供支持。\n  - **C3P0** 是一个开源组织提供的一个数据库连接池，**速度相对较慢，稳定性还可以。**hibernate官方推荐使用\n  - **Proxool** 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，**稳定性较c3p0差一点**\n  - **BoneCP** 是一个开源组织提供的数据库连接池，速度快\n  - **Druid** 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快\n- DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池\n- **DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。**\n- 特别注意：\n  - 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此**整个应用只需要一个数据源即可。**\n  - 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。\n\n### 8.3.1 C3P0数据库连接池\n\n* [jar包下载地址](https://plumriver.lanzous.com/iyI4gk75xoj)\n\n- 获取连接方式一\n\n```java\n//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐\npublic static Connection getConnection1() throws Exception{\n\tComboPooledDataSource cpds = new ComboPooledDataSource();\n\tcpds.setDriverClass(\"com.mysql.jdbc.Driver\"); \n\tcpds.setJdbcUrl(\"jdbc:mysql://localhost:3306/test\");\n\tcpds.setUser(\"root\");\n\tcpds.setPassword(\"abc123\");\n\t\t\n//\tcpds.setMaxPoolSize(100);\n\t\n\tConnection conn = cpds.getConnection();\n\treturn conn;\n}\n```\n\n- 获取连接方式二\n\n```java\n//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐\nprivate static DataSource cpds = new ComboPooledDataSource(\"helloc3p0\");\npublic static Connection getConnection2() throws SQLException{\n\tConnection conn = cpds.getConnection();\n\treturn conn;\n}\n```\n\n其中，src下的配置文件为：【c3p0-config.xml】\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<c3p0-config>\n\t<named-config name=\"helloc3p0\">\n\t\t<!-- 获取连接的4个基本信息 -->\n\t\t<property name=\"user\">root</property>\n\t\t<property name=\"password\">abc123</property>\n\t\t<property name=\"jdbcUrl\">jdbc:mysql:///test</property>\n\t\t<property name=\"driverClass\">com.mysql.jdbc.Driver</property>\n\t\t\n\t\t<!-- 涉及到数据库连接池的管理的相关属性的设置 -->\n\t\t<!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 -->\n\t\t<property name=\"acquireIncrement\">5</property>\n\t\t<!-- 初始化数据库连接池时连接的数量 -->\n\t\t<property name=\"initialPoolSize\">5</property>\n\t\t<!-- 数据库连接池中的最小的数据库连接数 -->\n\t\t<property name=\"minPoolSize\">5</property>\n\t\t<!-- 数据库连接池中的最大的数据库连接数 -->\n\t\t<property name=\"maxPoolSize\">10</property>\n\t\t<!-- C3P0 数据库连接池可以维护的 Statement 的个数 -->\n\t\t<property name=\"maxStatements\">20</property>\n\t\t<!-- 每个连接同时可以使用的 Statement 对象的个数 -->\n\t\t<property name=\"maxStatementsPerConnection\">5</property>\n\n\t</named-config>\n</c3p0-config>\n```\n\n### 8.3.2 DBCP数据库连接池\n\n* [jar包下载地址1](https://plumriver.lanzous.com/iXuAZk7657a)\n* [jar包下载地址2](https://plumriver.lanzous.com/imN6Pk7658b)两个都要下\n\n- DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：\n  - Commons-dbcp.jar：连接池的实现\n  - Commons-pool.jar：连接池实现的依赖库\n- **Tomcat 的连接池正是采用该连接池来实现的。**该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。\n- 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。\n- 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。\n- 配置属性说明\n\n| 属性                       | 默认值 | 说明                                                         |\n| -------------------------- | ------ | ------------------------------------------------------------ |\n| initialSize                | 0      | 连接池启动时创建的初始化连接数量                             |\n| maxActive                  | 8      | 连接池中可同时连接的最大的连接数                             |\n| maxIdle                    | 8      | 连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制 |\n| minIdle                    | 0      | 连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。 |\n| maxWait                    | 无限制 | 最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待 |\n| poolPreparedStatements     | false  | 开启池的Statement是否prepared                                |\n| maxOpenPreparedStatements  | 无限制 | 开启池的prepared 后的同时最大连接数                          |\n| minEvictableIdleTimeMillis |        | 连接池中连接，在时间段内一直空闲， 被逐出连接池的时间        |\n| removeAbandonedTimeout     | 300    | 超过时间限制，回收没有用(废弃)的连接                         |\n| removeAbandoned            | false  | 超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收 |\n\n- 获取连接方式一：\n\n```java\npublic static Connection getConnection3() throws Exception {\n\tBasicDataSource source = new BasicDataSource();\n\t\t\n\tsource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n\tsource.setUrl(\"jdbc:mysql:///test\");\n\tsource.setUsername(\"root\");\n\tsource.setPassword(\"abc123\");\n\t\t\n\t//\n\tsource.setInitialSize(10);\n\t\t\n\tConnection conn = source.getConnection();\n\treturn conn;\n}\n```\n\n- 获取连接方式二：\n\n```java\n//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐\nprivate static DataSource source = null;\nstatic{\n\ttry {\n\t\tProperties pros = new Properties();\n\t\t\n\t\tInputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(\"dbcp.properties\");\n\t\t\t\n\t\tpros.load(is);\n\t\t//根据提供的BasicDataSourceFactory创建对应的DataSource对象\n\t\tsource = BasicDataSourceFactory.createDataSource(pros);\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n\t\t\n}\npublic static Connection getConnection4() throws Exception {\n\t\t\n\tConnection conn = source.getConnection();\n\t\n\treturn conn;\n}\n```\n\n其中，src下的配置文件为：【dbcp.properties】\n\n```properties\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&useServerPrepStmts=false\nusername=root\npassword=abc123\n\ninitialSize=10\n#...\n```\n\n### 8.3.3 Druid（德鲁伊）数据库连接池\n\n* [jar包下载地址](https://plumriver.lanzous.com/iADZuk765be)\n\nDruid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，**可以说是目前最好的连接池之一。**\n\n```java\npackage com.atguigu.druid;\n\nimport java.sql.Connection;\nimport java.util.Properties;\n\nimport javax.sql.DataSource;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\npublic class TestDruid {\n\tpublic static void main(String[] args) throws Exception {\n\t\tProperties pro = new Properties();\t\t pro.load(TestDruid.class.getClassLoader().getResourceAsStream(\"druid.properties\"));\n\t\tDataSource ds = DruidDataSourceFactory.createDataSource(pro);\n\t\tConnection conn = ds.getConnection();\n\t\tSystem.out.println(conn);\n\t}\n}\n\n```\n\n其中，src下的配置文件为：【druid.properties】\n\n```java\nurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true\nusername=root\npassword=123456\ndriverClassName=com.mysql.jdbc.Driver\n\ninitialSize=10\nmaxActive=20\nmaxWait=1000\nfilters=wall\n```\n\n- 详细配置参数：\n\n| **配置**                      | **缺省** | **说明**                                                     |\n| ----------------------------- | -------- | ------------------------------------------------------------ |\n| name                          |          | 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this) |\n| url                           |          | 连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto |\n| username                      |          | 连接数据库的用户名                                           |\n| password                      |          | 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter> |\n| driverClassName               |          | 根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) |\n| initialSize                   | 0        | 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 |\n| maxActive                     | 8        | 最大连接池数量                                               |\n| maxIdle                       | 8        | 已经不再使用，配置了也没效果                                 |\n| minIdle                       |          | 最小连接池数量                                               |\n| maxWait                       |          | 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 |\n| poolPreparedStatements        | false    | 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 |\n| maxOpenPreparedStatements     | -1       | 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 |\n| validationQuery               |          | 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 |\n| testOnBorrow                  | true     | 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 |\n| testOnReturn                  | false    | 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 |\n| testWhileIdle                 | false    | 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 |\n| timeBetweenEvictionRunsMillis |          | 有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明 |\n| numTestsPerEvictionRun        |          | 不再使用，一个DruidDataSource只支持一个EvictionRun           |\n| minEvictableIdleTimeMillis    |          |                                                              |\n| connectionInitSqls            |          | 物理连接初始化的时候执行的sql                                |\n| exceptionSorter               |          | 根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接 |\n| filters                       |          | 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall |\n| proxyFilters                  |          | 类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 |\n\n# 第九章：Apache-DBUtils工具包的使用\n\n## 9.1 Apache-DBUtils简介\n\n- commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。\n- API介绍：\n  - org.apache.commons.dbutils.QueryRunner\n  - org.apache.commons.dbutils.ResultSetHandler\n  - 工具类：org.apache.commons.dbutils.DbUtils   \n- API包说明：\n  - [jar包下载地址](https://plumriver.lanzous.com/iOPu7k765cf)\n\n## 9.2 主要API的使用\n\n### 9.2.1 DbUtils\n\n- DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：\n  - **public static void close(…) throws java.sql.SQLException**：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。\n  - public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。\n  - public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接\n  - public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 \n  - public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断\n  - public static void rollbackAndClose(Connection conn)throws SQLException\n  - rollbackAndCloseQuietly(Connection)\n  - public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。\n\n### 9.2.2 QueryRunner类\n\n- **该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。**\n\n- QueryRunner类提供了两个构造器：\n  - 默认的构造器\n  - 需要一个 javax.sql.DataSource 来作参数的构造器\n\n- QueryRunner类的主要方法：\n  - **更新**\n    - public int update(Connection conn, String sql, Object... params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。\n    - ......\n  - **插入**\n    - public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object... params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值\n    - ....\n  - **批处理**\n    - public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句\n    - public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：只支持INSERT语句\n    - .....\n  - **查询**\n    - public Object query(Connection conn, String sql, ResultSetHandler rsh,Object... params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。\n    - ...... \n\n- 测试\n\n```java\n// 测试添加\n@Test\npublic void testInsert() throws Exception {\n\tQueryRunner runner = new QueryRunner();\n\tConnection conn = JDBCUtils.getConnection3();\n\tString sql = \"insert into customers(name,email,birth)values(?,?,?)\";\n\tint count = runner.update(conn, sql, \"何成飞\", \"he@qq.com\", \"1992-09-08\");\n\n\tSystem.out.println(\"添加了\" + count + \"条记录\");\n\t\t\n\tJDBCUtils.closeResource(conn, null);\n\n}\n```\n\n```java\n// 测试删除\n@Test\npublic void testDelete() throws Exception {\n\tQueryRunner runner = new QueryRunner();\n\tConnection conn = JDBCUtils.getConnection3();\n\tString sql = \"delete from customers where id < ?\";\n\tint count = runner.update(conn, sql,3);\n\n\tSystem.out.println(\"删除了\" + count + \"条记录\");\n\t\t\n\tJDBCUtils.closeResource(conn, null);\n\n}\n```\n\n### 9.2.3 ResultSetHandler接口及实现类\n\n- 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。\n\n- ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。\n\n- 接口的主要实现类：\n\n  - ArrayHandler：把结果集中的第一行数据转成对象数组。\n\n  - ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。\n\n  - **BeanHandler：**将结果集中的第一行数据封装到一个对应的JavaBean实例中。\n\n  - **BeanListHandler：**将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。\n\n  - ColumnListHandler：将结果集中某一列的数据存放到List中。\n\n  - KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。\n\n  - **MapHandler：**将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。\n\n  - **MapListHandler：**将结果集中的每一行数据都封装到一个Map里，然后再存放到List\n\n  - **ScalarHandler：**查询单个值对象\n\n    \n\n- 测试\n\n```java\n/*\n * 测试查询:查询一条记录\n * \n * 使用ResultSetHandler的实现类：BeanHandler\n */\n@Test\npublic void testQueryInstance() throws Exception{\n\tQueryRunner runner = new QueryRunner();\n\n\tConnection conn = JDBCUtils.getConnection3();\n\t\t\n\tString sql = \"select id,name,email,birth from customers where id = ?\";\n\t\t\n\t//\n\tBeanHandler<Customer> handler = new BeanHandler<>(Customer.class);\n\tCustomer customer = runner.query(conn, sql, handler, 23);\n\tSystem.out.println(customer);\t\n\tJDBCUtils.closeResource(conn, null);\n}\n```\n\n```java\n/*\n * 测试查询:查询多条记录构成的集合\n * \n * 使用ResultSetHandler的实现类：BeanListHandler\n */\n@Test\npublic void testQueryList() throws Exception{\n\tQueryRunner runner = new QueryRunner();\n\n\tConnection conn = JDBCUtils.getConnection3();\n\t\t\n\tString sql = \"select id,name,email,birth from customers where id < ?\";\n\t\t\n\t//\n\tBeanListHandler<Customer> handler = new BeanListHandler<>(Customer.class);\n\tList<Customer> list = runner.query(conn, sql, handler, 23);\n\tlist.forEach(System.out::println);\n\t\t\n\tJDBCUtils.closeResource(conn, null);\n}\n```\n\n```java\n/*\n * 自定义ResultSetHandler的实现类\n */\n@Test\npublic void testQueryInstance1() throws Exception{\n\tQueryRunner runner = new QueryRunner();\n\n\tConnection conn = JDBCUtils.getConnection3();\n\t\t\n\tString sql = \"select id,name,email,birth from customers where id = ?\";\n\t\t\n\tResultSetHandler<Customer> handler = new ResultSetHandler<Customer>() {\n\n\t\t@Override\n\t\tpublic Customer handle(ResultSet rs) throws SQLException {\n\t\t\tSystem.out.println(\"handle\");\n//\t\t\treturn new Customer(1,\"Tom\",\"tom@126.com\",new Date(123323432L));\n\t\t\t\t\n\t\t\tif(rs.next()){\n\t\t\t\tint id = rs.getInt(\"id\");\n\t\t\t\tString name = rs.getString(\"name\");\n\t\t\t\tString email = rs.getString(\"email\");\n\t\t\t\tDate birth = rs.getDate(\"birth\");\n\t\t\t\t\t\n\t\t\t\treturn new Customer(id, name, email, birth);\n\t\t\t}\n\t\t\treturn null;\n\t\t\t\t\n\t\t}\n\t};\n\t\t\n\tCustomer customer = runner.query(conn, sql, handler, 23);\n\t\t\n\tSystem.out.println(customer);\n\t\t\n\tJDBCUtils.closeResource(conn, null);\n}\n```\n\n```java\n/*\n * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据，\n * 使用ScalarHandler\n * \n */\n@Test\npublic void testQueryValue() throws Exception{\n\tQueryRunner runner = new QueryRunner();\n\n\tConnection conn = JDBCUtils.getConnection3();\n\t\t\n\t//测试一：\n//\tString sql = \"select count(*) from customers where id < ?\";\n//\tScalarHandler handler = new ScalarHandler();\n//\tlong count = (long) runner.query(conn, sql, handler, 20);\n//\tSystem.out.println(count);\n\t\t\n\t//测试二：\n\tString sql = \"select max(birth) from customers\";\n\tScalarHandler handler = new ScalarHandler();\n\tDate birth = (Date) runner.query(conn, sql, handler);\n\tSystem.out.println(birth);\n\t\t\n\tJDBCUtils.closeResource(conn, null);\n}\n```\n\n# 总结：\n\n```java\npublic void testUpdateWithTx() {\n\t\t\n\tConnection conn = null;\n\ttry {\n\t\t//1.获取连接的操作（\n\t\t//① 手写的连接：JDBCUtils.getConnection();\n\t\t//② 使用数据库连接池：C3P0;DBCP;Druid\n\t\t//2.对数据表进行一系列CRUD操作\n\t\t//① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \\ version 2.0)\n//version2.0的增删改public void update(Connection conn,String sql,Object ... args){}\n//version2.0的查询 public <T> T getInstance(Connection conn,Class<T> clazz,String sql,Object ... args){}\n\t\t//② 使用dbutils提供的jar包中提供的QueryRunner类\n\t\t\t\n\t\t//提交数据\n\t\tconn.commit();\n\t\t\t\n\t\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t\t\t\n\t\t\t\n\t\ttry {\n\t\t\t//回滚数据\n\t\t\tconn.rollback();\n\t\t} catch (SQLException e1) {\n\t\t\te1.printStackTrace();\n\t\t}\n\t\t\t\n\t}finally{\n\t\t//3.关闭连接等操作\n\t\t//① JDBCUtils.closeResource();\n\t\t//② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作\n\t\t\t\n\t}\n}\n```\n\n","categories":["Java学习","数据库"]},{"title":"第一章-计算机系统概述","url":"/2020/12/30/计算机操作系统/第一章-计算机系统概述/","content":"\n计算机的概念，特征，运行机制，体系结构\n\n<!--more-->\n# 一，操作系统的概念\n\n操作系统是指<font color=\"red\">控制和管理整个计算机系统的硬件和软件资源</font>;<font color=\"blue\">并合理的组织调度计算机工作和资源的分配</font>；<font color=\"violet\"><以提供给用户和其他软件方便的接口和环境</font>；<font color=\"green\">它是计算机系统中最基本的系统软件</font>。\n\n计算机系统的层级结构：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201209192103.png)\n\n具有的功能：\n\n​\t\t①：操作系统是系统资源的管理者\n\n​\t\t②：向上层提供方便易用的服务\n\n​\t\t③：是最接近硬件的一层软件\n\n## 1.1 是系统资源的管理者\n\n**提供的功能**：处理机管理；存储器管理；文件管理；设备管理。\n\n补充：执行一个程序前需要将该程序放入到内存中。\n\n举例：使用QQ和朋友聊天时。\n\n第一步：打开QQ安装的文件位置。\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t------文件管理的功能\n\n第二步：双击打开QQ.exe。需要把该程序相关数据放入内存。\t\t\t\t\t  ------存储器管理\t\t\n\n第三步：QQ程序正常运行。对应的进程被处理机(CPU)处理。\t\t\t\t\t\t--------处理机管理\n\n第四步：需要将摄像头设备分配给进程。\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-------设备管理\n\n## 1.2向上层提供方便易用的服务\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201209193856.png)\n\n**GUI(图形用户界面)**\n\n​\t\t用户可以使用形象的图形界面进行操作，而不需要记忆复杂的命令，参数。\n\n**命令结构之联机命令接口**\n\n​\t\t联机命令接口=交互式命令接口。\n\n​\t\t特点：用户说一句，系统跟着做一句。\n\n**命令接口之脱机命令接口**\n\n​\t\t脱机命令接口=批处理命令接口。\n\n​\t\t特点：用户说一堆，系统跟着做一堆。\n\n**程序接口**\n\n​\t\t可以在程序中进行<font color=\"red\">系统调用</font>来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码<font color=\"red\">间接使用</font>。\n\n程序接口：由一系列系统调用组成。\n\n系统调用类似于函数调用，是应用程序请求操作系统服务的唯一方式。又被称为广义指令。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201209194621.png)\n\n## 1.3最接近硬件的一层软件\n\n目的：需要实现<font color=\"red\">对硬件机器的拓展</font>。\n\n没有任何软件支持的计算机称为<font color=\"red\">裸机</font>。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强，使用更方便的机器。\n\n通常把覆盖了软件的机器成为<font color=\"red\">扩充机器</font>，又称之为<font color=\"red\">虚拟机</font>。\n\n操作系统对硬件机器的扩展：将CPU，内存，磁盘，显示器，键盘等硬件合理的组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201209195451.png)\n\n# 二，操作系统的特征\n\n<font color=\"red\">并发性和共享性是操作系统最基本的特征，二者互为存在条件。</font>\n\n## 2.1并发\n\n并发：指两个或多个事件在同一时间间隔内发生。这些事件<font color=\"red\">宏观上是同时发生的</font>，但在<font color=\"red\">微观上是交替发生的</font>。\n\n并行：指两个或多个事件在同一时刻同时发生。\n\n举例：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201209202405.png)\n\n<font color=\"red\">操作系统的并发性</font>：指计算机系统中同时运行着多个程序，这些程序宏观上看是同时运行者的，但微观上看是交替运行的。\n\n操作系统就是伴随着“多道程序技术”而出现的。因此，<font color=\"red\">操作系统和程序并发是一起诞生的</font>。\n\n注意：\n\n​\t\t\t<font color=\"red\">单核CPU</font>同一时刻只能执行<font color=\"red\">一个程序</font>，各个程序只能<font color=\"red\">并发</font>地执行。\n\n​\t\t\t<font color=\"red\">多核CPU</font>同一时刻可以同时执行<font color=\"red\">多个程序</font>，多个程序可以<font color=\"red\">并行</font>地执行。\n\n## 2.2共享\n\n<font color=\"red\">共享</font>：即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。\n\n分类：互斥共享方式。同时共享方式。\n\n<font color=\"red\">互斥共享方式</font>：系统中的某些资源，虽然可以提供给多个进程使用，但<font color=\"red\">一个时间段内只允许一个进程访问该资源</font>。\n\n<font color=\"red\">同时共享方式</font>：系统中的某些资源，<font color=\"red\">允许一个时间段内由多个进程</font>“<font color=\"blue\">同时</font>”<font color=\"red\">对它们进行访问</font>。\n\n<font color=\"blue\">同时</font>指定是宏观上的，而在微观上，这些进程可能是在交替地对该资源进行访问的(即分时共享)。\n\n**举例：**![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201209202352.png)\n\n**共享与并发的关系：**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201209202348.png)\n\n## 2.3虚拟\n\n<font color=\"red\">虚拟</font>是指把一个物理上的实体变成若干个逻辑上的对应物。物理实体(前者)是实际存在的，而逻辑上对应物(后者)是用户感受到的。\n\n虚拟技术分为：空分复用技术(如虚拟存储器技术)，时分复用技术(如虚拟处理器)。\n\n**空分复用技术的体现：**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201209213815.png)\n\n**时分复用技术的体现：**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201209213816.png)\n\n显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就是去了实现虚拟性的意义。因此，<font color=\"red\">没有并发性，就谈不上虚拟性</font>。\n\n## 2.4异步\n\n<font color=\"red\">异步</font>：指在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。\n\n**举例：**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201209213817.png)\n\n显然，如果失去了异步性，则系统只能串行地处理各个进程，每个进程的执行会一贯到底。<font color=\"red\">只有系统拥有并发性，才有可能导致异步性。</font>\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201209213818.png)\n\n# 三，操作系统的发展历史和分类\n\n## 3.1手工操作阶段\n\n程序员通过纸带机读入纸带，输入的速度慢。计算速度很快。计算机通过纸带机将结果打印到纸带上，输出的速度慢。\n\n图示：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201209213819.png)\n\n**缺点**：用户独占全机，人机速度矛盾导致资源利用率极低。\n\n## 3.2批处理阶段\n\n引入脱机输入/输出技术(用外围机+磁带完成)，并由监督程序负责控制作业的输入，输出。\n\n**外围机**：可以把程序提前存到磁带中\n\n### 3.2.1单道批处理系统\n\n每次往计算机中只读取一个程序。操作系统的雏形。\n\n图示：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201209213820.png)\n\n**优点**：缓解了一定程度的人机速度矛盾，资源利用率有所提升。\n\n**缺点**：<font color=\"red\">内存中仅能有一道程序运行</font>，只有该程序运行结束后才能调入下一道程序。<font color=\"red\">CPU有大量的时间是在空闲等待I/O完成</font>。资源利用率依然很低。\n\n### 3.2.2多道批处理系统\n\n每次往内存中读入多道程序。操作系统正式诞生，用于支持多道批处理系统。\n\n图示：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201209213821.png)\n\n**优点**：多道程序<font color=\"red\">并发</font>执行，<font color=\"red\">共享</font>计算机资源，<font color=\"red\">资源利用率大幅提升</font>，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。\n\n**缺点**：用户响应时间长，<font color=\"red\">没有人机交互功能</font>(用户提交自己的作业后就只能等待计算机处理完成，中间不能控制自己的作业。例如无法调试程序/无法在程序运行过程中输入一些参数)。\n\n## 3.3分时操作系统\n\n分时操作系统：计算机以<font color=\"red\">时间片</font>为单位<font color=\"red\">轮流为各个用户/作业服务</font>，各个用户可通过终端与计算机进行交互。\n\n**优点**：用户请求可以立即被及时响应，<font color=\"red\">解决了人机交互问题</font>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。\n\n**缺点**：<font color=\"red\">不能优先处理一些紧急任务</font>。操作系统对各个用户/作业都是完全公平的，循环为每个用户/作业服务一个时间片，不区分任务的紧急性。\n\n## 3.4实时操作系统\n\n**优点**：能够优先响应一些紧急任务，某些紧急任务不需要时间片排队。\n\n在实时操作系统的控制下，计算机系统接受到外部信号后及时进行处理，<font color=\"red\">并且要求在严格的时限内处理完事件</font>。实时操作系统的主要特点是<font color=\"red\">及时性和可靠性</font>。\n\n分类：\n\n**硬实时系统**：并行在绝对严格的规定时间内完成处理。  例如：导弹控制系统，自动驾驶系统。\n\n**软实时系统**：能接受偶尔违反时间规定。\t例如：12306火车订票系统。\n\n## 3.5其他操作系统\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201209213822.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201209213823.png)\n\n# 四，操作系统的运行机制\n\n**小知识：**\n\n指令：指处理器能识别，执行的最基本的指令。一般为二进制机器指令。\n\nWindows中小黑框内使用的命令是“交互式命令接口”，不是指令。\n\n程序执行的过程其实就是CPU执行一条一条机器指令的过过程。\n\n## 4.1内核程序VS应用程序\n\n普通程序员编写的程序就是“<font color=\"red\">应用程序</font>”。\n\n微软，苹果有一部分人负责实现操作系统，他们编写的就是“<font color=\"red\">内核程序</font>”。\n\n由很多内核程序组成了“<font color=\"red\">操作系统内核</font>”，或简称为“<font color=\"red\">内核</font>”。\n\n<font color=\"red\">内核</font>是操作系统最重要最核心的部分，也是<font color=\"red\">最接近硬件的部分</font>。\n\n操作系统的功能未必都在内核中，如图形化界面GUI。\n\n## 4.2特权指令VS非特权指令\n\n操作系统内核作为“管理者”，有时会让CPU执行一些“特权指令”，如：内存清零指令。这些指令影响重大，只允许“管理者”来使用。\n\n在<font color=\"red\">CPU设计和生产的时候就划分了特权指令和非特权指令</font>，因此CPU执行一条指令前就能判断除其类型。\n\n## 4.3内核态VS用户态\n\nCPU有两种状态内核态和用户态。\n\n处于<font color=\"red\">内核态时</font>，说明此时正在<font color=\"red\">运行的是内核程序</font>，此时<font color=\"red\">可以执行特权指令</font>。\n\n处于<font color=\"red\">用户态时</font>，说明此时正在<font color=\"red\">运行的是应用程序</font>，此时<font color=\"red\">只能执行非特权指令</font>。\n\n扩展：CPU中有一个寄存器叫<font color=\"red\">程序状态字寄存器(PSW)</font>，其中有个二进制位，1表示内核态，0表示用户态。\n\n别名：内核态=核心态=<font color=\"red\">管态</font>。用户态=<font color=\"red\">目态</font>。\n\n## 4.4内核态和用户态的切换\n\n<font color=\"red\">内核态 --> 用户态</font>：执行一条<font color=\"red\">特权指令</font>---<font color=\"red\">修改PSW</font>的标志位为用户态，这个动作意味着操作系统将主动让出CPU使用权。\n\n<font color=\"red\">用户态 --> 内核态</font>：由“<font color=\"red\">中断</font>”引发，<font color=\"red\">硬件自动完成变态过程</font>，触发中断信号意味着操作系统将强行夺回CPU的使用权。\n\n​\t\tc除了非法使用特权指令外，还有很多时间会触发中断信号。一个共性是，<font color=\"red\">但凡需要操作系统接入的地方，都会触发中断信号</font>。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201209213824.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201209213825.png)\n\n# 五，中断和异常\n\n## 5.1中断 的作用\n\nCPU上会运行两种程序，一种是<font color=\"red\">操作系统内核程序</font>，一种是<font color=\"red\">应用程序</font>。\n\n操作系统内核程序是整个系统的管理者。\n\n在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序。\n\n中断是<font color=\"red\">让操作系统内核夺回CPU使用权的唯一途径</font>。\n\n如果没有中断机制，那么一旦应用程序在CPU运行，CPU就会一直运行这个程序，此时并发就不可能实现。\n\n<font color=\"red\">作用一</font>：中断会使CPU由用户态变成内核态。\n\n<font color=\"red\">作用二</font>：中断会使操作系统重新夺回对CPU的控制权。\n\n## 5.2中断的分类\n\n类型：内中断，外中断\n\n### 5.2.1内中断\n\n定义：与当前执行的指令有关，中断信号来源于CPU内部。\n\n举例：① 试图在用户态执行特权指令。\t \t\t\t\t\t\t---- 终止\n\n​\t\t\t② 执行除法指令时发现除数为0。\t\t\t\t\t\t\t---终止\n\n​\t\t\t③ 当应用程序想请求操作系统内核的服务，此时会执行<font color=\"red\">一条特殊的指令--陷入指令</font>，该指令会引发一个内部中断信号。\t\t\t\t\t\t\t\t\t\t\t\t\t---陷入\n\n​\t\t\t\t\t\t\t\t补充：执行“陷入指令”，意味着应用程序主动的将CPU控制权还给操作系统内核。“系统调用”就是通过陷入指令完成的。\n\n​\t\t\t\t\t\t\t\t<font color=\"red\">“陷入指令”不是特权指令，但是一种特殊的指令</font>。\n\n内中断的分类：陷入，故障，终止。\n\n陷入(陷阱)：有陷入指令引发，是应用程序故意引发的。\n\n故障：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把CPU使用权还给应用程序，让它继续执行下去。如：缺页故障。\n\n终止：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。如：整数除0，非法使用特权指令。\n\n注意：大多数教材中，内终端被称为异常  \n\n，例外。中断特指狭义的中断，即外中断。\n\n### 5.2.2外中断\n\n定义：与当前执行的指令无关，中断信号来源于CPU外部。\n\n举例：① 时钟中断。在CPU运行期间，时钟部件每隔一个时间片(如50ms)会给CPU发送一个时钟中断信号。\n\n​\t\t\t② I/O中断。由输入/输出设备发来的中断信号。\n\n每条指令执行结束时，CPU都会例行检查是否有外中断信号。\n\n分类：时钟中断，I/O中断请求。\n\n## 5.3中断机制的基本原理\n\n<font color=\"red\">不同的中断信号，需要使用不同的中断处理程序来处理</font>。当CPU检测到中断信号后，会根据中断信号的类型去查询“<font color=\"red\">中断向量表</font>”，以此找到相应的中断处理程序在内存中存放的位置。\n\n步骤：\n\n第一步：检查中断信号。内中断：CPU在执行指令时会检查是否有异常发生。外中断：每个指令周期末尾，CPU都会检查是否有外中断信号需要处理。\n\n第二步：找到相应的中断处理程序。通过中断向量表实现。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210070002.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210070003.png)\n\n# 六，系统调用\n\n系统调用是操作系统提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数。<font color=\"red\">应用程序可以通过系统调用来请求获得操作系统内核的服务。</font>\n\n## 6.1系统调用与库函数的区别\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210150315.png)\n\n**解决方法**:由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用” ，用户进程想要 使用打印机这种共享资源，只能通过系统系统调用” ，用户进程想要 使用打印机这种共享资源，只能通过系统。\n\n## 6.2系统调用的分类\n\n应用程序通过<font color=\"red\">系统调用</font>请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统- -掌管，因此<font color=\"red\">凡是与共享资源有关的操作(如存储分配、/O操作、文件管理等)，都必须通过系统调用的方式向操作系统内核提出服务请求</font>，由操作系统内核代为完成。这样<font color=\"red\">可以保证系统的稳定性和安全性</font>，防止用户进行非法操作。\n\n**设备管理**：完成设备的\t请求/释放/启动\t等功能。\n\n**文件管理**：完成文件的\t读/写/创建/删除\t等功能。\n\n**进程控制**：完成进程的\t创建/撤销/阻塞/唤醒\t等功能。\n\n**进程通信**：完成进程之间的\t消息传递/信号传递\t等功能。\n\n**内存管理**：完成内存的\t分配/回收\t等功能。\n\n## 6.3系统调用的过程\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210151031.png)\n\n**过程**：传递系统调用参数>执行陷入指令(用户态)→执行相应的内请求核程序处理系统调用(核心态) >返回应用程序。\n\n**注意**:\n\n 1. 陷入指令是在用户态执行的，执行陷入指令之后立即引发-一个内中断，使CPU进入核心态。\n\n2.发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行。\n\n**注意别名:**陷入指令=trap指令=访管指令\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210151308.png)\n\n# 七，操作系统的体系结构\n\n## 7.1操作系统的层次结构\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210194853.png)\n\n**时钟管理**：利用始终实现中断计时的功能。\n\n**原语**：原语是一种特殊的程序，具有原子性。也就是说，这段程序的运行必须一气呵成，<font color=\"red\">不可以被中断</font>。\n\n**内核**：是操作系统最基本，最核心的部分。\n\n实现操作系统内核功能的那些程序就是**内核程序**。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210195311.png)\n\n注意：操作系统<font color=\"red\">内核</font>需要运行在内核态。操作系统<font color=\"red\">非内核</font>需要运行在用户态。\n\n## 7.2大内核\n\n大内核：将操作系统的主要功能模块都作为系统内核，运行在核心态。\n\n体系结构：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210195521.png)\n\n\n\n## 7.3微内核\n\n微内核：只把最基本的功能保留在内核。\n\n体系结构：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210195530.png)\n\n\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210195737.png)","categories":["计算机操作系统"]},{"title":"第二章-内存管理","url":"/2020/12/30/计算机操作系统/第三章-内存管理/","content":"\n内存的基本知识，链接的三种方式，内存的扩充技术，分配与回收，动态分区分配算法 \n分页存储，分段存储，虚拟内存。\n\n<!--more-->\n# 第一节：内存的基本知识\n\n## 1.1 装入的三种方式\n\n* **绝对装入**：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。\n  * 绝对装入只适用于单道程序环境。\n* **静态重定位**：又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址(地址变换是在装入时一次完成的)。\n  * 静态重定位的特点是在--个作业装入内存时，必须分配其要求的全部内存空间，， 如果没有足够的内存，就不能装入该作业。\n  * 作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。.\n* **动态重定位**：又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要-一个重定位寄存器的支持。\n  * 重定位寄存器:存放装入模块存放的起始位置。\n  * 采用动态重定位时允许程序在内存中发生移动。\n  * 并且可将程序分配到不连续的存储区中;在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存;便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。\n\n## 1.2 程序的编写到运行的过程\n\n* **编译**：由编译程序将用户源代码编译成若干个目标模块(编译就是把高级语言翻译为机器语言)\n* **链接**：由链接程序将编译后形成的一-组目标模块，以及所需库函数链接在一起，形成-一个完整的装入模块\n* **装入(装载)** ：由装入程序将装入模块装入内存运行\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223212522.png)\n\n## 1.3 链接的三种方式\n\n* 1.**静态链接**:在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件(装入模块) ,之,后不再拆开。\n* 2.**装入时动态链接**:将各目标模块装入内存时，边装入边链接的链接方式。\n* 3.**运行时动态链接**:在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。\n\n## 1.4总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223211853.png)\n\n# 第二节 内存的管理功能\n\n* 1.操作系统负责内存空间的分配与回收。\n\n* 2.操作系统需要提供某种技术从逻辑上对内存空间进行扩充。\n\n* 3.操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。\n\n  * 为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换(这个过程称为地址重定位)应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223213245.png)\n\n* 4.操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。\n\n  * 方法一:在CPU中设置- -对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。\n  * 方法二:采用重定位寄存器(又称基址寄存器)和界地址寄存器(又称限长寄存器)进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。\n\n##  2.1 内存空间的扩充功能\n\n### 2.1.1覆盖技术\n\n* 覆盖技术的思想:将程序分为多个段(多个模块)。常用的段常驻内存，不常用的段在需要时调入内存。\n* 内存中分为- -个“固定区”和若千个“覆盖区”。\n* 需要常驻内存的段放在“固定区”中，调入后就不再调出( 除非运行结束)\n* 不常用的段放在“覆盖区”，需要用到时调入内存,用不到时调出内存\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224103423.png)\n\n* 必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点:对用户不透明，增加了用户编程负担。\n* 覆盖技术只用于早期的操作系统中，现在已成为历史。\n\n### 2.1.2交换技术\n\n* 交换(对换)技术的设计思想:内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)\n* 1.应该在外存(磁盘)的什么位置保存被换出的进程?\n  * 具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I/O速度比文件区的更快。\n* 2.什么时候应该交换?\n  * 交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。\n* 3.应该换出哪些进程?\n  * 可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间...\n  * (注意: PCB会常驻内存，不会被换出外存)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224103252.png)\n\n### 2.1.3虚拟存储技术\n\n## 2.2 内存空间的分配与回收\n\n### 连续分配管理\n\n* 连续分配:指为用户进程分配的必须是- -个连续的内存空间。\n\n#### 单一连续分配\n\n* 在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据;用户区用于存放用户进程相关数据。内存中只能有-道用户程序，用户程序独占整个用户区空间。\n* 优点:实现简单;无外部碎片;可以采用覆盖技术扩充内存;不一定需要采取内存保护(eg: 早期的PC操作系统MS-DOS)。\n* 缺点:只能用于单用户、单任务的操作系统中;有内部碎片;存储器利用率极低。\n\n#### 固定分区分配\n\n* 20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入-道作业，这样就形成了最早的、最简单的一-种可运行多道程序的内存管理方式。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224115017.png)\n\n* 分区大小相等:缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合(比如:钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序)。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224115050.png)\n\n* 分区大小不等:增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分(比如:划分多个小分区、适量中等分区、少量大分区)。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224115059.png)\n\n* 操作系统需要建立-一个数据结构--分区 说明表，来实现各个分区的分配与回收。每个表项对应-一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态(是否已分配)。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224115203.png)\n\n* 当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。\n\n* 优点:实现简单，无外部碎片。\n\n* 缺点: a.当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能; b. 会产生内部碎片，内存利用率低。\n\n#### 动态分区分配\n\n* 动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。(eg: 假设某计算机内存大小为64MB，系统区8MB,用户区共56 M...)\n\n* 1.系统要用什么样的数据结构记录内存的使用情况?\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224115319.png)\n\n* 2.当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?\n\n  * 把一个新作业装入内存时，须按照- -定的动态分区分配算法，从空闲分区表(或空闲分区链)中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。\n\n* 3.如何进行分区的分配与回收操作?\n\n  * 情况-一;回收区的后面有一个相邻的空闲分区，两个相邻的空闲分区合并为-一个\n  * 情况二:回收区的前面有一个相邻的空闲分区，两个相邻的空闲分区合并为-一个\n  * 情况三:回收区的前、后各有一个相邻的空闲分区，三个相邻的空闲分区合并为一个\n  * 情况四:回收区的前、后都没有相邻的空闲分区，新增一个表项\n    * 注:各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定。\n\n* 动态分区分配没有内部碎片，但是有外部碎片。\n\n  * 内部碎片：分配给某进程的内存区域中，如果有些部分没有用上。\n  * 外部碎片：是指内存中的某些空闲分区由于太小而难以利用。\n\n* 如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一- 整块连续的内存空间，因此这些“碎片”不能满足进程的需求。\n\n* 可以通过紧凑(拼凑，Compaction) 技术来解决外部碎片。\n\n#### 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224114627.png)\n\n### 非连续分配管理\n\n#### 分页存储管理\n\n#### 分段存储管理\n\n## 2.3 动态分区分配算法\n\n### 首次适应算法\n\n* 算法思想:每次都从低地址开始查找，找到第- -个能满足大小的空闲分区。\n* 如何实现:空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一 个空闲分区。\n\n### 最佳适应算法\n\n* 算法思想:由于动态分区分配是--种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。\n* 如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链( 或空闲分区表)，找到大小能满足要求的第一- 个空闲分区。\n* 缺点:每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。\n\n### 最坏适应算法\n\n* 又称最大适应算法( Largest Fit)\n* 算法思想:为了解决最佳适应算法的问题----即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。\n* 如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。\n* 缺点:每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。\n\n### 邻近适应算法\n\n* 算法思想:首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。\n* 如何实现:空闲分区以地址递增的顺序排列(可排成-一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。\n* 首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来(最佳适应算法的优点)。\n* 邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用( 最大适应算法的缺点)。\n\n### 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224120919.png)\n\n# 第三节：非连续分配管理\n\n## 3.1 分页存储管理\n\n* 将内存空间分为-一个个大小相等的分区(比如:每个分区4KB)，每个分区就是一个“页框”(页框=页 帧=内存块=物理块=物理页面)。每个页框有一一个编号，即“页框号”(页框号=页帧号=内存块号=物理块号=物理页号)，页框号从0开始。\n* 将进程的逻辑地址空间也分为与页框大小相等的一一个个部分，每个部分称为-一个“页”或“页面”。每个页面也有-一个编号，即“页号”，页号也是从0开始。\n* 操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入-一个页框中。也就是说，进程的页面与内存的页框有一- -对应的关系。\n* 各个页面不必连续存放，可以放到不相邻的各个页框中。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225090814.png)\n\n### 页表\n\n* 为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一-张页表。\n\n  * 注:页表通常存在PCB (进程控制块)中\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225090949.png)\n\n  * 1.一个进程对应- -张页表\n  * 2.进程的每个页面对应-一个页表项\n  * 3.每个页表项由“页号”和“块号”组成\n  * 4.页表记录进程页面和实际存放的内存块之间的映射关系\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225091029.png)\n\n### 页表的地址转换\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225091124.png)\n\n* 如果每个页面大小为2KB,用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分就是页号。\n\n* 分页存储管理的逻辑地址结构如下所示:\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225091804.png)\n\n* 地址结构包含两个部分:前- -部分为页号，后一部分为页内偏移量W。在上图所示的例子中，地址长度为32位，其中0~11位为“页内偏移量”，或称“页内地址”; 12~31 位为“页号”。\n\n* 如果有K位表示“页内偏移量”，则说明该系统中-一个页面的大小是2K个内存单元。\n\n* 如果有M位表示“页号”，则说明在该系统中，一个进程最多允许有2M个页面。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225090631.png)\n\n### 基本地址变换机构\n\n* 基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。\n\n* 通常会在系统中设置一一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。\n\n* 设页面大小为L，逻辑地址A到物理地址E的变换过程如下:\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225093227.png)\n\n  * ①计算页号P和页内偏移量W (如果用十进制数手算，则P=A/L, W=A%L; 但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量)\n  * ②比较页号P和页表长度M，若P2M，则产生越界中断，否则继续执行。(注意: 页号是从0开始的，而页表长度至少是1，因此P=M时也会越界)\n  * ③页表中页号P对应的页表项地址=页表起始地址F+页号P*页表项长度，取出该页表项内容b,即为内存块号。(注意区分页表项长度、 页表长度、页面大小的区别。页表长度指的是这个页表中总共有几个页表项，即总共有几个页;页表项长度指的是每个页表项占多大的存储空间;页面大小指的是一个页面占多大的存储空间)\n  * *④计算E=b*L+W，用得到的物理地址E去访存。 (如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了)\n\n* 例题：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225093556.png)\n\n* ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225093404.png)\n\n* 在分页存储管理(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225093227.png)\n\n### 具有快表的基本地址变换机构\n\n* 快表，又称联想寄存器(TLB，translation lookaside buffer )，是一-种访问速度比内存快很多的高速缓存(TLB不是内存! )，用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。\n\n* 快表的访问过程\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225100835.png)\n\n  * ①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。\n  * ②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。\n  * ③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换)\n\n* 由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，-般来说快表的命中率可以达到90%以上。\n\n* 快表的例题\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225100953.png)\n\n* 局部性原理\n\n  * **时间局部性**:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。( 因为程序中存在大量的循环)。\n  * **空间局部性**:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很 多数据在内存中都是连续存放的)。\n\n### 两级页表\n\n**单级页表存在的问题**\n\n* 问题一:页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。\n* 问题二:没有必要让整个页表常驻内存，因为进程在--段时间内可能只需要访问某几个特定的页面。\n\n**两级页表**\n\n* 为离散分配的页表再建立一张页表，称为页目录表，或称外层页表，或称顶层页表\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225102602.png)\n\n* 地址变换过程\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225102708.png)\n\n* 注意：\n\n* 1.若采用多级页表机制，则各级页表的大小不能超过一个页面\n\n* 2.两级页表的访存次数分析(假设没有快表机构)\n\n  * 第一次访存:访问内存中的页目录表\n  * 第二次访存:访问内存中的二级页表\n  * 第三次访存:访问目标内存单元\n\n**总结**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225102422.png)\n\n## 3.2 分段存储管理\n\n### 分段\n\n* 进程的地址空间:按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名(在低级语言中，程序员使用段名来编程)，每段从0开始编址\n\n* 内存分配规则:以段为单位进行分配，每个段在内存中占据连续空间，各段之间可以不相邻。\n\n* 分段系统的逻辑地址结构由段号(段名)和段内地址(段内偏移量)所组成。如:\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225105247.png)\n\n* 段号的位数决定了每个进程最多可以分几个段。\n\n* 段内地址位数决定了每个段的最大长度是多少。\n\n### 段表\n\n* 问题:程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立- -张段映射表，简称“段表“。\n* 1.每个段对应-一个段表项，其中记录了该段在内存中的起始位置(又称“基址”)和段的长度。\n* 2.各个段表项的长度是相同的。例如:某系统按字节寻址，采用分段存储管理，逻辑地址结构为(段号16位，段内地址16位)，因此用16位即可表示最大段长。物理内存大小为4GB (可用32位表示整个物理内存地址空间)。因此，可以让每个段表项占16+32=48位，即6B。由于段表项长度相同，因此段号可以是隐含的，不占存储空间。若段表存放的起始地址为M,则K号段对应的段表项存放的地址为M + K*6。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225105425.png)\n\n### 地址变换\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225105509.png)\n\n### 分段与分页的区别\n\n* 页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。\n* 段是信息的逻辑单位。分页的主要目的是更好地满足用户需求。一个段通常包含着一-组属于-一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。\n* 页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。\n  * 分页的用户进程地址空间是一-维的，程序员只需给出一个记忆符即可表示一一个地址。\n  * 分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。\n* 分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码(不属于临界资源)，这样的代码是可以共享的。可修改的代码是不能共享的\n* 访问一个逻辑地址需要几次访存?\n  * 分页(单级页表) :第一次访存--查内存中的页表，第二次访存一--访问目标内存单元。总共两次访存\n  * 分段:第一次访存- --查内存中的段表，第二次访存- - -访问目标内存单元。总共两次访存\n* 与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。\n\n### 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225105031.png)\n\n## 3.3 段页式存储管理方式\n\n### 分段和分页的优缺点\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225110659.png)\n\n### 段页式存储\n\n* 将进程按逻辑模块分段，再将各段分页(如每个页面4KB)再将内存空间分为大小相同的内存块/页框/页帧/物理块进程前将各页面分别装入各内存块中。\n\n* 段页式系统的逻辑地址结构由段号、页号、页内地址(页内偏移量)组成。如:\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225110820.png)\n\n  * 段号的位数决定了每个进程最多可以分几个段\n  * 页号位数决定了每个段最大有多少页\n  * 页内偏移量决定了页面大小、内存块大小是多少\n  * “分段”对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将各段“分页”对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此段页式管理的地址结构是二维的。\n\n* 每个段对应一一个段表项，每个段表项由段号、页表长度、页表存放块号(页表起始地址)组成。每个段表项长度相等，段号是隐含的。\n\n* 每个页面对应一一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。\n\n### 地址变换\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225111021.png)\n\n### 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225110631.png)\n\n# 第四节：虚拟内存\n\n","categories":["计算机操作系统"]},{"title":"第二章-进程管理","url":"/2020/12/30/计算机操作系统/第二章-进程管理/","content":"\n进程的概念，状态，进程控制，进程通信，线程，多线程，处理机调度，进程调度\n调度算法，先来先服务，进程的同步和互斥，信号量机制，生产者与消费者，管程，\n死锁，死锁的处理。\n\n<!--more-->\n# 一，进程的概念，组成，特征\n\n## 1.1进程的概念\n\n**程序**:是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。\n\n**进程(Process)** :是动态的，是程序的一次执行过程\n\n​\t\t\t\t\t\t\t同一个程序多次执行会对应多个进程。\n\n## 1.2进程的组成\n\n思考:操作系统是这些进程的管理者，它要怎么区分各个进程?\n\n答：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”--PID (Process ID，进程ID)。\n\n操作系统对进程做的操作：\n\n1.要记录PID、进程所属用户ID (UID)。\t\t\t--基本的进程描述信息，可以让操作系统区分各个进程\n\n2.要记录给进程分配了哪些资源(如:分配了多少内存、正在使用哪些1I/O设备、正在使用哪些文件)。 --可用于实现操作系统对资源的管理。\n\n3.要记录进程的运行情况(如: CPU使用时间、磁盘使用情况、网络流量使用情况等)。\t--可用于实现操作系统对进程的控制、调度。\n\n**进程控制块PCB**：PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。\n\n操作系统对进程进行<font color=\"red\">管理工作所需的信息</font>都存在PCB中。\n\nPCB的组成：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210201659.png)\n\n一个<font color=\"red\">进程实体(进程映像)</font>由<font color=\"red\">PCB、 程序段、数据段</font>组成。\n\n<font color=\"red\">进程</font>是<font color=\"red\">动态</font>的， <font color=\"red\">进程实体(进程映像)</font>是<font color=\"red\">静态</font>的。\n\n​\t进程实体反映了进程在<font color=\"red\">某一时刻</font>的状态。\n\n进程实体的组成：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210202032.png)\n\nPCB是给操作系统用的。\n\n程序段、数据段是给进程自己用的，与进程自身的运行逻辑有关。\n\n <font color=\"red\">程序段、数据段、PCB</font>三部分组成了 <font color=\"red\">进程实体(进程映像)</font>。\n\n引入进程实体的概念后，可把进程定义为: <font color=\"red\">进程</font>是进程实体的 <font color=\"red\">运行过程</font>，是系统进行 <font color=\"red\">资源分配</font>和 <font color=\"red\">调度</font>的一个独立单位。\n\n​\t\t\t\t一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行。\n\n**举例**：同时挂三个QQ号，会对应三个QQ进程，它们 的PCB、数据段各不相同，但程序段的内容都是相同的(都是运行着相同的QQ程序)。\n\n## 1.3进程的特征\n\n程序是静态的，进程是动态的，相比于程序，进程拥有以下特征:\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210202428.png)\n\n动态性是进程的<font color=\"red\">最基本的特征</font>。\n\n异步性会导致并发程序执行结果的不确定性。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210202759.png)\n\n# 二，进程的状态与转换\n\n## 2.1进程的状态\n\n​\t\t进程正在被创建时，它的状态是“<font color=\"red\">创建态</font>”，在这个阶段操作系统会为进程分配资源、初始化PCB。\n\n​\t\t当进程创建完成后，便进入‘‘ <font color=\"red\">就绪态</font>”处于就绪态的进程已经具备运行条件,但由于没有空闲CPU，就暂时不能运行。\n\n如果一个进程此时在CPU上运行，那么这个进程处于“ <font color=\"red\">运行态</font>’。CPU会执行该进程对应的程序(执行指令序列)。\n\n在进程运行的过程中，可能会请求等待某个事件的发生(如等待某种系统资源的分配，或者等待其他进程的响应)。在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入\" <font color=\"red\">阻塞态</font>”。当CPU空闲时，又会选择另-一个“就绪态”进程上CPU运行。\n\n一个进程可以执行exit系统调用，请求操作系统终止该进程。此时该进程会进入“ <font color=\"red\">终止态</font>”，操作系统会让该进程下CPU,并回收内存空间等资源，最后还要回收该进程的PCB。当终止进程的工作完成之后，这个进程就彻底消失了。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210204658.png)\n\n进程的整个生命周期中，大部分时间都处于<font color=\"red\">三种基本状态:运行态，就绪态，阻塞态</font>。\n\n单CPU情况下，同一时刻只会有一个进程处于运行态，多核CPU情况下，可能有多个进程处于运行态。\n\n<font color=\"red\">进程PCB中，会有-一个变量state来表示进程的当前状态</font>。如: 1表示创建态、2表示就绪态、3表示运行态....\n\n为了对同一个状态下的各个进程进行统一一的管理，操作系统会将各个进程的PCB组织起来。\n\n## 2.2状态之间的转换\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210204615.png)\n\n注意：运行态→阻塞态是一种进程自身做出的<font color=\"red\">主动行为</font>。\n\n​\t\t\t阻塞态>就绪态是不是 进程自身能控制的，是一种<font color=\"red\">被动行为</font>。\n\n**注意:**不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态(因为进入阻塞状态是进程主动请求的，必然需要进程在运行时才能发出这种请求).\n\n## 2.3进程的组织方式\n\n**链接方式**：按照进程状态将PCB分为多个队列。操作系统持有指向各个队列的指针。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210205035.png)\n\n\n\n**索引方式**：根据进程状态的不同，建立几张索引表。操作系统持有指向各个索引表的指针![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210205108.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210205248.png)\n\n# 三，进程控制\n\n## 3.1基本概念\n\n**进程控制**：主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销己有进程、实现进程状态转换等功能。总之：进程控制就是要<font color=\"red\">实现进程状态转换</font>。\n\n**进程控制的实现：**用”原语“实现。原语的执行具有“原子性”，一气呵成。\n\n**思考**:为何进程控制(状态转换)的过程要‘一气呵成”?\n\n​\t\t如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作。\n\n<font color=\"red\">原语</font>的执行具有<font color=\"red\">原子性</font>，即执行过程只能- -气呵成，期间<font color=\"red\">不允许被中断</font>。\n\n可以用“<font color=\"red\">关中断指令</font>”和“<font color=\"red\">开中断指令</font>”这两个<font color=\"red\">特权指令</font>实现原子性。\n\n关/开中断的作用：CPU执行了<font color=\"red\">关中断指令<</font>之后，就不再例行检查中断信号，直到执行<font color=\"red\">开中断指令</font>之后才会恢复检查。\n\n## 3.2相关原语\n\n**创建原语**：\n\n​\t\t作用：创建态 ---> 就绪态\n\n​\t\t功能：①申请空白PCB。②为新进程分配所需资源。③初始化PCB。④将PCB插入就绪队列。\n\n​\t\t引起进程创建的事件：\n\n​\t\t\t\t①用户登录：分时系统中，用户登录成功，系统会建立为其建立-一个新的进程。\n\n​\t\t\t\t②作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立-个新的进程。\n\n​\t\t\t\t③提供服务：用户向操作系统提出某些请求时，会新建一个进程 处理该请求。\n\n​\t\t\t\t④应用请求：由用户进程主动请求创建一个子进程。\n\n**撤销原语**：\n\n​\t\t作用：就绪态/阻塞态/运行态 ---> 终止态 ---> 无\n\n​\t\t功能：①从PCB集合中找到终止进程的PCB。\n\n​\t\t\t\t\t②若进程正在运行，立即剥夺CPU,将CPU分配给其他进程。\n\n​\t\t\t\t\t③终止其所有子进程。（进程间的关系是树形结构）\n\n​\t\t\t\t\t④将该进程拥有的所有资源归还给父进程或操作系统。\n\n​\t\t\t\t\t⑤删除PCB。\n\n​\t\t引起进程撤销的事件：①正常结束。(进程自已请求终止(exit系统调用))。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t②异常结束。(整数除以0、非法使用特权指令，然后被操作系统强行杀掉)。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t③外界干预。(Ctrl+Alt+delete，用户选择杀掉进程)。\n\n**阻塞原语**：\n\n​\t\t作用：运行态 ---> 阻塞态\n\n​\t\t功能：①找到要阻塞的进程对应的PCB。\n\n​\t\t\t\t\t②保护进程运行现场，将PCB状态信息设置为“阻塞态\"，暂时停止进程运行。\n\n​\t\t\t\t\t③将PCB插入相应事件的等待队列。\n\n​\t\t引起进程阻塞的事件：①需要等待系统分配某种资源。\n\n​\t\t\t\t\t\t\t\t\t\t\t   ②需要等待相互合作的其他进程完成工作。\n\n**唤醒原语**：\n\n​\t\t作用：阻塞态 ---> 运行态\n\n​\t\t功能：①在事件等待队列中找到PCB。\n\n​\t\t\t\t\t②将PCB从等待队列移除，设置进程为就绪态。\n\n​\t\t\t\t\t③将PCB插入就绪队列，等待被调度。\n\n​\t\t引起进程唤醒的事件：①等待的事件发生一因何事阻塞， 就应由何事唤醒。\n\n<font color=\"red\" size=\"5px\">阻塞原语和唤醒原语必须成对使用。</font>\n\n**切换原语**：\n\n​\t\t作用：运行态 ---> 就绪态。就绪态 ---> 运行态\n\n​\t\t功能：①将运行环境信息(进程上下文)存入PCB。\n\n​\t\t\t\t\t②PCB移入相应队列。\n\n​\t\t\t\t\t③选择另一个进程执行，并更新其PCB。\n\n​\t\t\t\t\t④根据PCB恢复新进程所需的运行环境。\n\n​\t\t引起进程切换的事件：①当前进程时间片到。\n\n​\t\t\t\t\t\t\t\t\t\t\t  ②有更高优先级的进程到达。\n\n​\t\t\t\t\t\t\t\t\t\t\t  ③当前进程主动阻塞。\n\n​\t\t\t\t\t\t\t\t\t\t\t  ④当前进程终止。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210212742.png)\n\n# 四，进程通信\n\n顾名思义，进程通信就是指进程之间的信息交换。\n\n进程是分配系统资源的单位(包括内存地址空间)，因此<font color=\"red\">各进程</font>拥有的<font color=\"red\">内存地址空间相互独立</font>。\n\n为了保证安全，<font color=\"red\">一个进程不能直接访问另一个进程的地址空间</font>。\n\n但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。\n\n进程通信的方式：共享存储，消息传递，管道通信。\n\n## 4.1共享存储\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211062820.png)\n\n两个进程对共享空间的访问必须是<font color=\"red\">互斥</font>的(互斥访问通过操作系统提供的工具实现)。\n\n操作系统只负责提供共享空间和同步互斥工具(如P、V操作)。\n\ngnn共享存储又分为：基于数据结构的共享；基于存储区的共享。\n\n**基于数据结构的共享:**比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种<font color=\"red\">低级通信</font>方式。\n\n**基于存储区的共享**:在内存中画出一-块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种<font color=\"red\">高级通信</font>方式。\n\n## 4.2管道通信\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211063138.png)\n\n“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。\n\n**特点：**\n\n1. 管道只能采用<font color=\"red\">半双工通信</font>，某一时间段内只能实现单向的传输。如果要实现<font color=\"red\">双向同时通信</font>，则<font color=\"red\">需要设置两个管道</font>。 \n\t\n2. 各进程要<font color=\"red\">互斥</font>地访问管道。\n\t\n3. 数据以字符流的形式写入管道，当<font color=\"red\">管道写满</font>时，<font color=\"red\">写进程</font>的write()系统调用将被<font color=\"red\">阻塞</font>，等待读进程将数据取走。当读进程将数据全部取走后，<font color=\"red\">管道变空</font>，此时<font color=\"red\">读进程</font>的read()系统调用将被<font color=\"red\">阻塞</font>。\n\t\n4. 如果<font color=\"red\">没写满</font>，就不允许读。如果<font color=\"red\">没读空</font>，就不允许写。\n\t\n5. 数据一且被读出，就从管道中被拋弃，这就意味着<font color=\"red\">读进程最多只能有一个</font>，否则可能会有读错数据的情况。\n\n## 4.3消息传递\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211063603.png)\n\n进程间的数据交换以<font color=\"red\">格式化的消息(Message) </font>为单位。进程通过操作系统提供的“<font color=\"red\">发送消息/接收消息</font>”两个原语进行数据交换。\n\n消息头包括:发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息(计算机网络中发送的“报文”其实就是一种格式化的消息)。\n\n消息传递分为：直接通信方式；间接通信方式。\n\n**直接通信方式**：消息直接挂到接收进程的消息缓冲队列上。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211063809.png)\n\n**间接通信方式：**消息要先发送到中间实体(信箱)中，因此也称为”信箱通信方式“。例如：计算机网络中的电子邮件系统。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211064008.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211064111.png)\n\n# 五，线程概念\n\n## 5.1线程的基本概念\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211064902.png)\n\n可以把线程理解为“轻量级进程”。\n\n<font color=\"red\">线程</font>是一个<font color=\"red\">基本的CPU执行单元</font>，也是<font color=\"red\">程序执行流的最小单位</font>。\n\n引入线程之后，不仅是进程之间可以并发，进程内的<font color=\"red\">各线程之间也可以并发</font>，从而进一步<font color=\"red\">提升了系统的并发度</font>，使得-一个进程内也可以并发处理各种任务( 如QQ视频、文字聊天、传文件)。\n\n引入线程后，<font color=\"red\">进程</font>只作为<font color=\"red\">除CPU之外的系统资源的分配单元</font>(如打印机、内存地址空间等都是分配给进程的)\n\n## 5.2引入线程后的变化\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211065340.png)\n\n## 5.3线程的属性\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211065610.png)\n\n# 六，线程的实现方式\n\n## 6.1线程的实现方式\n\n**用户级线程：**\n\n​\t历史背景:早期的操作系统(如:早期Unix) 只支持进程，不支持线程。当时的“线程”是由线程库实现的\n\n​\t示意：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211114714.png)\n\n​\t问题：\n\n1.线程的管理工作由谁来完成?\n\n​\t答：用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责(包括线程切换)。\n\n2.线程切换是否需要CPU变态?\n\n​\t答：用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。\n\n3.操作系统是否能意识到用户级线程的存在?\n\n​\t答：在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程”。\n\n4.这种线程的实现方式有什么优点和缺点?\n\n​\t答：优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。\n\n​\t\t\t缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。\n\n**内核级线程：**\n\n内核级线程( Kernel-Level Thread, KLT,又称“内核支持的线程:“由操作系统支持的线程个件。\n\n示意：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211115156.png)\n\n1.线程的管理工作由谁来完成?\n\n​\t答：1.内核级线程的管理工作由操作系统内核完成。\n\n2.线程切换是否需要CPU变态?\n\n​\t答：2.线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。\n\n3.操作系统是否能意识到内核级线程的存在?\n\n​\t答：3.操作系统会为每个内核级线程建立相应的TCB (Thread Control Block,线程控制块) , 通过TCB对线程进行管理。“内核级线程” 就是“从操作系统内核视角看能看到的线程。\n\n4.这种线程的实现方式有什么优点和缺点?\n\n​\t答：优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机.上并行执行。\n\n​\t\t\t缺点: - 一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。\n\n## 6.2多线程模型\n\n**一对一模型**：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219171331.png)\n\n优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机_上并行执行。\n\n缺点:一个用户进程会占用多个内核级线程,线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。\n\n**多对一模型**：多个用户级线程映射到一个内核级线程。且一一个进程只被分配-一个内核级线程。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211143409.png)\n\n优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。\n\n缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。\n\n<font color=\"blue\">重点重点重点</font>:操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。\n\n**多对多模型**： n用户及线程映射到m个内核级线程(n>=m)。每个用户进程对应m个内核级线程。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211143632.png)\n\n克服了多对一-模型并发度不高的缺点(一个阻塞全体阻塞)，又克服了一对- -模型中一个用户进程占用太多内核级线程，开销太大的缺点。\n\n可以这么理解:用户级线程是“代码逻辑”的载体。\n\n​\t\t\t\t\t\t内核级线程是“运行机会”的载体。\n\n<font color=\"red\">内核级线程才是处理机分配的单位</font>。例如:多核CPU环境下，左边这个进程最多能被分配两个核。\n\n一段“代码逻辑”只有获得了“运行机会”才能被CPU执行。\n\n内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211114525.png)\n\n# 七，处理机调度\n\n## 7.1基本概念\n\n当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定<font color=\"red\">某种规则</font>来决定处理这些任务的<font color=\"red\">顺序</font>，这就是<font color=\"red\">“调度”</font>研究的问题。\n\n**作业:**一个具体的任务\n\n用户向系统提交一个作业≈用户让操作系统启动-一个程序(来处理一个具体的任务)\n\n## 7.2高级调度\n\n**高级调度(作业调度)**：按一定的原则从<font color=\"red\">外存</font>的作业后备队列中挑选-一个<font color=\"red\">作业</font>调入<font color=\"red\">内存</font>，并创建进程。，每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212084518.png)\n\n## 7.3中级调度\n\n内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。\n\n暂时调到外存等待的进程状态为<font color=\"red\">挂起状态</font>。被挂起的进程PCB会被组织成<font color=\"red\">挂起队列</font>。\n\n**中级调度(内存调度)**：按照某种策略决定将哪个处于挂起状态的<font color=\"red\">进程</font>重新调入<font color=\"red\">内存</font>。\n\n一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要<font color=\"red\">比高级调度更高</font>。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212084842.png)\n\n## 7.4低级调度\n\n**低级调度(进程调度/处理机调度)**：按照某种策略从就绪队列中选取-一个<font color=\"red\">进程</font>，将<font color=\"red\">处理机</font>分配给它。\n\n进程调度是操作系统中<font color=\"red\">最基本的一种调度</font>，在--般的操作系统中都必须配置进程调度。\n\n进程调度的<font color=\"red\">频率很高</font>，一般几十毫秒-一次。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212084849.png)\n\n## 7.5三层调度的区别\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212085335.png)\n\n## 7.6七状态模型\n\n暂时调到外存等待的进程状态为<font color=\"red\">挂起状态(挂起态，suspend)</font>。\n\n挂起态又可以进一-步细分为<font color=\"red\">就绪挂起、阻塞挂起</font>两种状态。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212085054.png)\n\n注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是<font color=\"red\">将进程映像调到外存</font>去了，而阻塞态下进程<font color=\"red\">映像还在内存中</font>。\n\n有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212085413.png)\n\n# 八，进程调度\n\n## 8.1进程调度的时机\n\n进程调度(低级调度)：就是按照某种算法从就绪队列中选择一个进程为其分配处理机。\n\n需要进程调度与切换的时机：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212090439.png)\n\n禁止进程调度与切换的时机：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212090501.png)\n\n<font color=\"red\">注意：</font>\n\n​\t\t\t进程在<font color=\"red\">操作系统内核程序临界区</font>中<font color=\"red\">不能</font>进行调度与切换。  √\n\n​\t\t\t进程处于<font color=\"red\">临界区</font>时<font color=\"red\">不能</font>进行处理机调度。   ×\n\n**临界资源:**一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。\n\n**临界区**:访问临界资源的那段代码。\n\n<font color=\"red\">内核程序临界区</font>一般是用来访问<font color=\"red\">某种内核数据结构</font>的，比如进程的就绪队列(由各就绪进程的PCB组成)\n\n例如：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212091136.png)\n\n内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界期间不能进行调度 与切换。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212091237.png)\n\n普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。\n\n## 8.2进程调度的切换与过程\n\n“狭义的进程调度”与“进程切换”的区别:\n\n**狭义的进程调度**：指的是从就绪队列中<font color=\"red\">选中一个要运行的进程</font>。(这个进程可以是刚刚被暂停执行的进程，也可能是<font color=\"red\">另一个进程</font>，后-种情况就需要<font color=\"red\">进程切换</font>)。\n\n**进程切换**：是指一个进程让出处理机，由另一个进程占用处理机的过程。\n\n**广义的进程调度**：包含了选择-一个进程和进程切换两个步骤。\n\n进程切换的过程主要完成了：\n\n​\t\t1.对原来运行进程各种数据的保存。\n\n​\t\t2.对新的进程各种数据的恢复(如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)。\n\n注意:<font color=\"red\">进程切换是有代价的</font>，因此如果<font color=\"red\">过于频繁</font>的进行进程<font color=\"red\">调度、切换</font>，必然会使整个<font color=\"red\">系统的效率降低</font>,使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。\n\n## 8.3进程调度的方式\n\n**非剥夺调度方式**，又称**非抢占方式**。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。\n\n​\t\t实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。\n\n**剥夺调度方式**，又称**抢占方式**。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。\n\n​\t\t可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能(通过时钟中断)。适合于分时操作系统、实时操作系统。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212094214.png)\n\n# 九，调度算法的评价指标\n\n## 9.1CPU利用率\n\n由于早期的CPU造价极其昂贵，因此人们会希望让CPU尽可能多地工作\n\n**CPU利用率**:指CPU“忙碌”的时间占总时间的比例。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212095308.png)\n\n## 9.2系统吞吐量\n\n对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业。\n\n**系统吞吐量**:单位时间内完成作业的数量。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212095425.png)\n\n## 9.3周转时间\n\n对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。\n\n**周转时间**：是指从<font color=\"red\">作业被提交给系统开始</font>，到<font color=\"red\">作业完成为止</font>的这段时间间隔。\n\n它包括四个部分:作业在外存后备队列上等待作业调度(高级调度)的时间、进程在就绪队列上等待进程调度(低级调度)的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212095620.png)\n\n**带权周转时间：**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212095731.png)\n\n## 9.4等待时间\n\n计算机的用户希望自己的作业尽可能少的等待处理机。\n\n**等待时间**:指进程/作业<font color=\"red\">处于等待处理机状态时间之和</font>，等待时间越长，用户满意度越低。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212095931.png)\n\n对于<font color=\"red\">进程</font>来说，等待时间就是指进程建立后<font color=\"red\">等待被服务的时间之和</font>，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。\n\n对于<font color=\"red\">作业</font>来说，不仅要考虑<font color=\"red\">建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</font>。\n\n一个作业总共需要被CPU服务多久，被I/0设备服务多久一-般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“<font color=\"red\">平均等待时间</font>”来评价整体性能。\n\n## 9.5响应时间\n\n对于计算机用户来说，会希望自己的提交的请求(比如通过键盘输入了一个调试命令)尽早地开始被系统服务、回应。\n\n**响应时间**:指从用户提交请求到首次产生响应所用的时间。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212100106.png)\n\n# 十，调度算法\n\n## 10.1 先来先服务(FCFS)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212105645.png)\n\n**举例：**![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212105648.png)\n\n## 10.2 短作业优先(SJF)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212105654.png)\n\n**非抢占式的举例：**![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212105658.png)\n\n**抢占式的举例：**![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212105703.png)\n\n**细节问题：**\n\n1.如果题目中<font color=\"red\">未特别说明</font>，所提到的“短作业/进程优先算法\"<font color=\"red\">默认是非抢占式的</font>。\n\n2.很多书上都会说“SJF调度算法的平均等待时间、平均周转时间最少”。\n\n严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少\n\n应该加上一一个条件“在<font color=\"red\">所有进程同时可运行</font>时，采用SJF调度算法的平均等待时间、平均周转时间最少”;\n\n或者说“在<font color=\"red\">所有进程都几乎同时到达</font>时，采用SJF调度算法的平均等待时间、平均周转时间最少”;\n\n如果不加。上述前提条件，则应该说“<font color=\"red\">抢占式</font>的短作业/进程优先调度算法(<font color=\"red\">最短剩余时间优先, SRNT</font>算法)的平均等待时间、平均周转时间最少”。\n\n3.虽然严格来说， SJF的平均等待时间、平均周转时间并不- - 定最少，但相比于其他算法(如FCFS)，SJF依然可以获得较少的平均等待时间、平均周转时间\n\n4.如果选择题中遇到“SJIF算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项。\n\n## 10.4 高响应比优先(HRRN)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212110033.png)\n\n**举例：**![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212110046.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212110148.png)\n\n注：这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于<font color=\"red\">早期的批处理系统</font>，当然， FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。\n\n## 10.4 时间片轮转(RR)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212140802.png)\n\n**例题：**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212140944.png)\n\n**补充：**\n\n​\t\t如果时间片太大，使得每个进程都可以在-一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。\n\n​\t\t另一-方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。\n\n​\t\t一般来说时间片时要让切换进程的开销占比不超过1%。\n\n## 10.5 优先级调度()\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212141322.png)\n\n**非抢占式的例题：**![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212141243.png)\n\n**抢占式的例题：**![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212141248.png)\n\n**补充：**\n\n就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置。\n\n根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。\n\n​\t\t**静态优先级:**创建进程时确定，之后一直不变 。\n\n​\t\t**动态优先级:**创建进程时有一个初始值，之后会根据情况动态地调整优先级。\n\n如何合理地设置各类进程的优先级?\n\n​\t通常：系统进程优先级高于用户进程。前台进程优先级高于后台进程。操作系统更偏好I/O型进程(或称/0繁忙型进程)。\n\n​\t注:与I/0型进 程相对的是计算型进程( 或称CPU繁忙型进程)。\n\n如果采用的是动态优先级，什么时候应该调整?\n\n​\t\t可以从追求公平、提升资源利用率等角度考虑。\n\n​\t\t如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级。\n\n​\t\t如果某进程占用处理机运行了很长时间，则可适当降低其优先级。\n\n​\t\t如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级\n\n## 10.6 多级反馈队列调度()\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212141733.png)\n\n**例题：**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212141904.png)\n\n设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。\n\n新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下- -级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾。\n\n只有第k级队列为空时，，才会为k+1级队头的进程分配时间片。\n\n被抢占处理机的进程重新放回原队列队尾。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212142133.png)\n\n注:比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统(包括分时操作系统、实时操作系统等)更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。(比如UNIX使用的就是多级反馈队列调度算法)。\n\n# 十一，进程的同步和互斥\n\n## 11.1进程同步\n\n知识点回顾:进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212143056.png)\n\n读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据>读数据”的顺序来执行的。\n\n如何解决这种异步问题，就是“ 进程同步”所讨论的内容。\n\n<font color=\"red\">同步</font>亦称<font color=\"red\">直接制约关系</font>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上<font color=\"red\">协调</font>它们的<font color=\"red\">工作次序</font>而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。\n\n## 11.2进程互斥\n\n进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源(比如内存，又比如打印机、摄像头这样的/0设备)。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212143338.png)\n\n我们把<font color=\"red\">一个时间段内只允许一个进程使用</font>的资源称为<font color=\"red\">临界资源</font>。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。\n\n对临界资源的访问，必须<font color=\"red\">互斥</font>地进行。互斥，亦称<font color=\"red\">间接制约关系</font>。<font color=\"red\">进程互斥</font>指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。\n\n对临界资源的互斥访问，可以在**逻辑上分为如下四个部分:**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212143541.png)\n\n注意:临界区是进程中访问临界资源的代码段。\n\n​\t\t进入区和退出区是负责实现互斥的代码段。\n\n​\t\t临界区也可称为“临界段”\n\n为了实现对临界资源的互斥访问，同时保证系统整体性能，**需要遵循以下原则:**\n\n​\t\t1.**<font color=\"red\">空闲让进</font>**。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区;\n\n​\t\t2.**<font color=\"red\">忙则等待</font>**。当已有进程进入临界区时，其他试图进入临界区的进程必须等待; .\n\n​\t\t3.**<font color=\"red\">有限等待</font>**。对请求访问的进程，应保证能在有限时间内进入临界区( 保证不会饥饿) ;\n\n​\t\t4.**<font color=\"red\">让权等待</font>**。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212142914.png)\n\n# 十二，进程互斥的软件实现方法\n\n## 12.1 单标志法\n\n**算法思想**：两个进程在<font color=\"red\">访问完临界区后</font>会把使用临界区的权限转交给另-一个进程。也就是说<font color=\"red\">每个进程进入临界区的权限只能被另一个进程赋予</font>。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212145904.png)\n\nturn的初值为0,即刚开始只允许0号进程进入临界区。\n\n若P1先上处理机运行，则会一直卡在⑤。直到P1的时间片用完，发生调度，切换PO.上处理机运行。\n\n代码①不会卡住PO, PO可以正常访问临界区，在PO访问临界区期间即时切换回P1, P1依然会卡在⑤。\n\n只有PO在退出区将turn改为1后，P1才能进入临界区。\n\n因此，该算法可以实现“<font color=\"red\">同一时刻最多只允许一个进程访问临界区</font>”。\n\n​\t\t\t<font color=\"red\">单标志法</font>存在的主要问题是：<font color=\"red\">违背”空闲让进“原则</font>。\n\n## 12.2 双标志先检查\n\n**算法思想**：设置一个布尔型数组flag[]，数组中各个元素用来<font color=\"red\">标记各进程想进入临界区的意愿</font>，比如“flag[0] = ture”意味着0号进程PO现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true,之后开始访问临界区。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212150337.png)\n\n若按照①⑤②⑥3...的顺序执行，PO 和P1将会同时访问临界区。\n\n因此，双标志先检查法的<font color=\"red\">主要问题</font>是：<font color=\"red\">违反“忙则等待”原则</font>。\n\n原因在于，<font color=\"red\">进入区</font>的“检查”和“上锁”<font color=\"red\">两个处理不是一气呵成的</font>。“检查” 后，“上锁”前可能发生进程切换。\n\n## 12.3 双标志后检查\n\n**算法思想**：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212150631.png)\n\n若按照①⑤②⑥...的顺序执行，PO和P1将都无法进入临界区。\n\n因此，双标志后检查法虽然<font color=\"red\">解决了“忙则等待”</font>的问题，但是<font color=\"red\">又违背了“空闲让进”和“有限等待”原则</font>，会因各进程都长期无法访问临界资源而<font color=\"red\">产生“饥饿”</font>现象。\n\n## 12.4 Peterson算法\n\n算法思想:结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”(谦让)。, 做一个有礼貌的进程。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212150840.png)\n\nPeterson算法用软件方法解决了进程互斥问题，<font color=\"red\">遵循了空闲让进、忙则等待、有限等待三个原则</font>，但是依然<font color=\"red\">未遵循让权等待</font>的原则。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212151023.png)\n\n# 十三，进程互斥的硬件实现方法\n\n## 13.1 中断屏蔽方法\n\n利用“开/关中断指令”实现(与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况)。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212155414.png)\n\n**优点**：简单、高效。\n\n**缺点**：不适用于多处理机;只适用于操作系统内核进程，不适用于用户进程(因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)。\n\n## 13.2 TestAndSet（TS指令/TSL指令）\n\n简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令。\n\nTSL指令是用硬件实现的，执行的过程不允许被中断，只能- -气呵成。以下是用C语言描述的逻辑。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212155635.png)\n\n若刚开始lock是false，则TSL返回的old 值为false, while 循环条件不满足，直接跳过循环，进入临界区。若刚开始lock是true，则执行TLS后old返回的值为true, while 循环条件满足，会-直循环，直到当前访问临界区的进程在退出区进行“解锁”。\n\n相比软件实现方法，TSL 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。\n\n**优点**：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞;适用于多处理机环境。\n\n**缺点**：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致”忙等“。\n\n## 13.3 Swap指令(XCHG指令)\n\n有的地方也叫Exchange指令，或简称XCHG指令。.\n\nSwap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212155841.png)\n\n逻辑.上来看Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁(记录在old变量上)，再将.上锁标记lock设置为true，最后检查old，如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。\n\n**优点**:实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞;适用于多处理机环境。\n\n**缺点**:不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行Swap指令，从而导致“忙等”\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212155910.png)\n\n# 十四，信号量机制\n\n用户进程可以通过使用操作系统提供的<font color=\"red\">一对原语</font>来对<font color=\"red\">信号量</font>进行操作，从而很方便的实现了进程互斥、进程同步。\n\n<font color=\"red\">**信号量**</font>：其实就是一个变量(<font color=\"blue\">可以是一个整数，也可以是更复杂的记录型变量</font>)，可以用一个信号量来<font color=\"red\">表示系统中某种资源的数量</font>，比如:系统中只有一-台打印机，就可以设置一个初值为1的信号量。\n\n**<font color=\"red\">原语</font>**：是一种特殊的程序段，其<font color=\"red\">执行只能一气呵成，不可被中断</font>。原语是由<font color=\"red\">关中断/开中断指令</font>实现的。软件解决方案的主要问题是由“进入区的各种操作无法- -气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。\n\n**一对原语**：<font color=\"red\">wait(S)</font>原语和<font color=\"red\">signal(S)</font>原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal,括号里的<font color=\"red\">信号量S</font>其实就是函数调用时传入的一一个参数。\n\nwait、signal原语常<font color=\"red\">简称为P、V操作</font>(来自荷兰语proberen和verhogen)。因此，做题的时候常把wait(S)、sigal(S) 两个操作分别写为<font color=\"red\">P(S)、V(S)</font>。\n\n## 14.1 整形信号量\n\n**整形信号量**：用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。\n\n与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作。\n\nEg:某计算机系统中有一台打印机...\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212161122.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212161254.png)\n\n**作用**：检查”和“上锁”一气呵成，避免了并发、异步导致的问题。\n\n**存在的问题**:不满足“让权等待”原则，会发生“忙等”。\n\n## 14.2 记录型信号量\n\n**记录型信号量**：即用记录型数据结构表示的信号量。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212161503.png)\n\n在考研题目中wait(S)、sinal(S) 也可以记为P(S)、V(S),这对原语可用于<font color=\"red\">实现系统资源的“申请”和“释放”</font>。\n\n<font color=\"red\">S.value的初值</font>表示系统中<font color=\"red\">某种资源的数目</font>。\n\n对信号量S的<font color=\"red\">一次P操作</font>意味着进程<font color=\"red\">请求一个单位的该类资源</font>，因此需要执行S.value--， 表示资源数减1，当S.value<0时表示该类资源已分配完毕，因此进程应<font color=\"red\">调用block原语进行自我阻塞</font>(当前运行的进程从<font color=\"red\">运行态→阻塞态</font>)，主动放弃处理机，并插入该类资源的等待队列S.L中。可见，该机制<font color=\"red\">遵循了“让权等待”原则</font>，不会出现“忙等”现象。\n\n对信号量S的<font color=\"red\">一次V操作</font>意味着进程<font color=\"red\">释放一个单位的该类资源</font>，因此需要执行S.value++，表示资源数加1,若加1后仍是S.value <= 0，表示依然有进程在等待该类资源，因此应<font color=\"red\">调用wakeup原语唤醒等待队列中的第一个进程</font>(被唤醒进程从<font color=\"red\">阻塞态>就绪态</font>)。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212162133.png)\n\n# 十五，信号量机制的使用\n\n## 15.1 实现进程互斥\n\n理解:信号量mutex表示“进入临界区的名额”。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212173644.png)\n\n## 15.2 实现进程同步\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212173824.png)\n\n## 15.3 实现进程前驱关系\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212173828.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212173907.png)\n\n# 十六，生产者消费者问题\n\n**题目分析：**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212174117.png)\n\n**实现：**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212174234.png)\n\n**修改：**  \n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212174326.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212174402.png)\n\n# 十七，多生产者和多消费者\n\n## 问题描述\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223164347.png)\n\n## 问题分析\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223164427.png)\n\n## 代码实现\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223164525.png)\n\n## 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223164628.png)\n\n# 十八，管程\n\n## 18.1 管程的定义和基本特征\n\n* 管程是一种特殊的软件模块，有这些部分组成: .\n  * 1.局部于管程的共享数据结构说明;\n  * 2.对该数据结构进行操作的--组过程;\n  * 3.对局部于管程的共享数据设置初始值的语句;.\n  * 4.管程有一个名字。\n* 管程的基本特征:\n  * 1.局部于管程的数据只能被局部于管程的过程所访问;\n  * 2.一个进程只有通过调用管程内的过程才能进入管程访问共享数据;\n  * 3.每次仅允许一个进程在管程内执行某个内部过程。\n* 引入管程的目的无非就是要更方便地实现进程互斥和同步。\n  * 1.需要在管程中定义共享数据(如生产者消费者问题的缓冲区)\n  * 2.需要在管程中定义用于访问这些共享数据的“入口”--其实就是- -些函数(如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品)\n  * 3.只有通过这些特定的“入口”才能访问共享数据\n  * 4.管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或线程进入(如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意:这种互斥特性是由编译器负责实现的，程序员不用关心)\n  * 5.可在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让-一个进程或线程在条件变量上等待(此时，该进程应先释放管程的使用权，也就是让出“入口”) ;可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。\n\n## 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223181258.png)\n\n# 第十九节：死锁\n\n## 19.1 死锁的概念\n\n* 在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”发生死锁后若无外力干涉，这些进程都将无法向前推进。\n* 死锁:各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。\n* 饥饿:由于长期得不到想要的资源，某进程无法向前推进的现象。比如:在短进程优先(SPF) 算法中，若有源源不断的短进程到来，则长进程将一直 得不到处理机，从而发生长进程“饥饿”\n* 死循环:某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223182852.png)\n\n## 19.2 死锁产生的必要条件\n\n* 产生死锁必须同时满足一下四个条件， 只要其中任一条件不成立， 死锁就不会发生。\n  * **互斥条件**:只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源)。\n  * **不剥夺条件**:进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。\n  * **请求和保持条件**:进程已经保持了至少-一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。\n  * **循环等待条件**:存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。\n* 注意!发生死锁时一.定有循环等待，但是发生循环等待时未必死锁(循环等待是死锁的必要不充分条件)\n\n## 19.3 死锁的发生\n\n* 1.对系统资源的竞争。各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的。\n* 2.进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又 申请资源R1,两者会因为申请的资源被对方占有而阻塞，从而发生死锁。\n* 3.信号量的使用不当也会造成死锁。如生产者~消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。(可 以把互斥信号量、同步信号量也看做是一种抽象的系统资源。\n* 总之，对不可剥夺资源的不合理分配，可能导致死锁。\n\n## 19.4 死锁的处理策略\n\n* 1.预防死锁。破坏死锁产生的四个必要条件中的一个或几个。\n* 2.避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁(银行家算法)\n* 3.死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。\n\n## 19.5 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223183648.png)\n\n# 第二十节：死锁的处理策略\n\n## 20.1 预防死锁\n\n### 破坏互斥条件\n\n* 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。\n* 如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: SPOOLing技术。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技 术将打印机改造为共享设备....\n* 该策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还不行保护这种互斥性，因此，很多时候都无法破坏互斥条件。\n\n### 破坏不可剥夺条件\n\n* 不剥夺条件:进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。\n* 破坏不剥夺条件:\n  * 方案一:当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。\n  * 方案二:当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级(比如:剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)\n* 该策略的缺点:\n  * 1.实现起来比较复杂。\n  * 2.释放己获得的资源可能造成前一阶段工作的失效。因此这种方法- -般只适用于易保存和恢复状态的资源，如CPU。\n  * 3.反复地申请和释放资源会增加系统开销，降低系统吞吐量。\n  * 4.若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。\n\n### 破坏请求和保持条件\n\n* 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。\n* 可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一.旦投入运行后，这些资源就一直归它所有， 该进程就不会再请求别的任何资源了。\n* 该策略实现起来简单，但也有明显的缺点：有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一-直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。\n\n### 破坏循环等待条件\n\n* 循环等待条件:存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。\n* 可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源(即编号相同的资源)一次申请完。\n* 原理分析: - 一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。\n* 该策略的缺点:\n  * 1.不方便增加新的设备，因为可能需要重新分配所有的编号;\n  * 2.进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费;\n  * 3.必须按规定次序申请资源，用户编程麻烦。\n\n### 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223185245.png)\n\n## 20.2 避免死锁\n\n* 所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。\n* 如果分配了资源之后，系统中找不出任何一一个安全序列，系统就进入了不安全状态。这就意味着之后.可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。\n* 如果系统处于安全状态，就一定不 会发生死锁。如果系统进入不安全状态，就可能发生死锁(处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)\n* 因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源\n  分配请求。这也是“银行家算法”的核心思想。\n* 银行家算法是荷兰学者Dijkstra为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于避免死锁。\n* 核心思想:在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223203438.png)\n\n### 银行家算法\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223203536.png)\n\n### 总结\n\n* 数据结构: .\n  * 长度为m的一-维数组Available表示还有多少可用资源\n  * n*m矩阵Max表示各进程对资源的最大需求数\n  * n\\*m矩阵Allocation表示已经给各进程分配了多少资源\n  * Max-Allocation=Need矩阵表示各进程最多还需要多少资源\n  * 用长度为m的一位数组Request表示进程此次申请的各种资源数\n* 银行家算法步骤:\n  * ①检查此次申请是否超过了之前声明的最大需求数\n  * ②检查此时系统剩余的可用资源是否还能满足这次请求\n  * ③试探着分配，更改各数据结构\n  * ④用安全性算法检查此次分配是否会导致系统进入不安全状态\n* 安全性算法步骤:\n  * 检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。\n  * 不断重复上述过程，看最终是否能让所有进程都加入安全序列。\n* 系统处于不安全状态未必死锁，但死锁时-定处于不安全状态。系统处于安全状态一定 不会死锁。\n\n## 20.3 死锁的检测和解除\n\n* 如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法:\n  * ①死锁检测算法:用于检测系统状态，以确定系统中是否发生了死锁。\n  * ②死锁解除算法:当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。\n\n### 死锁的检测\n\n* 为了能对系统是否己发生了死锁进行检测，必须:\n  * ①用某种数据结构来保存资源的请求和分配信息;\n  * ②提供一种算法， 利用上述信息来检测系统是否已进入死锁状态。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223204639.png)\n\n* 死锁的检测\n  * 如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。\n  * 如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。\n  * 相应的，这些被激活的进程执行完了之后又会归还一-些资源，这样可能又会激活另外- -些阻塞的进程...\n  * 如果按，上述过程分析，最终能消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁 (相当于能找到一个安全序列)。\n  * 如果最终不能消除所有边，那么此时就是发生了死锁。\n  * 最终还连着边的那些进程就是处于死锁状态的进程。\n* 检测死锁的算法:\n  * 1)在资源分配图中，找出既不阻塞又不是孤点的进程Pi(即找出一-条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如下图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源)。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中,P1是满足这-条件的进程结点，于是将P1的所有边消去。\n  * 2)进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，P2就满足这样的条件。根据1)中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的。\n* **死锁定理**：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁\n\n### 死锁的解除\n\n* 一旦检测出死锁的发生，就应该立即解除死锁。\n* 补充:并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程\n* 解除死锁的主要方法有:\n  * 1.资源剥夺法。挂起(暂时放到外存上)某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。\n  * 2.撤销进程法(或称终止进程法)。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。\n  * 3.进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程\n    的历史信息，设置还原点。\n* 如何决定“对谁动手”\n  * 1.进程优先级\n  * 2.已执行多长时间\n  * 3.还要多久能完成\n  * 4.进程已经使用了多少资源\n  * 5.进程是交互式的还是批处理式的\n\n### 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223204500.png)","categories":["计算机操作系统"]},{"title":"第五章-中央处理器","url":"/2020/12/23/计算机组成原理/第五章-中央处理器/","content":"\nCPU的功能和结构，指令周期，数据通路的功能，控制器的功能，指令流水线。\n<!--more-->\n# 第一节：CPU的功能和结构\n\n## 1.1 CPU的功能\n\n* **指令控制**：完成取指令、分析指令和执行指令的操作，即程序的顺序控制。\n* **操作控制**：一条指令的功能往往是由若干操作信号的组合来实现的。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部化从而控制这些部件按指令的要求进行动作。\n* **时间控制**：对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。\n* **数据加工**：对数据进行算术和逻辑运算。\n* **中断处理**：对计算机运行过程中出现的异常情况和特殊请求进行处理。\n* 运算器：对数据进行加工。\n* 控制器：协调并控制计算机各部件执行程序的指令序列，基本功能包括取指令、分析指令、执行指令。\n  * 取指令:自动形成指令地址;自动发出取指令的命令。\n  * 分析指令:操作码译码(分析本条指令要完成什么操作);产生操作数的有效地址。\n  * 执行指令:根据分析指令得到的“操作命令”和“操作数地址”，形成操作信号控制序列，控制运算器、存储器以及I/O设备完成相应的操作。\n  * 中断处理:管理总线及输入输出;处理异常情况(如掉电)和特殊请求(如打印机请求打印一-行字符)。\n\n## 1.2 运算器的基本结构\n\n* **算术逻辑单元**：主要功能是进行算术/逻辑运算。\n\n* **通用寄存器组**：如AX、BX、CX、DX、SP等，用于存放操作数(包括源操作数、目的操作数及中间结果)和各种地址信息等。SP是堆栈指针，用于指示栈顶的地址。\n\n* **暂存寄存器**：用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容。\n\n* **累加寄存器**：它是一一个通用寄存器，用于暂时存放ALU运算的结果信息，用于实现加法运算。\n\n* **程序状态字寄存器**：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志(OP)、符号标志(SF)、零标志(ZF)、进位标志(CF)等。PSW中的这些位参与并决定微操作的形成。\n\n* **移位器**：对运算结果进行移位运算。\n\n* **计数器**：控制乘除运算的操作步数。\n\n* **专用数据通路方式**：根据指令执行过程中的数据和地址的流动方向安排连接线路。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223091844.png)\n\n  * 如果直接用导线连接，相当于多个寄存器同时并且- - 直向ALU传输数据。\n\n  * 解决方法1.使用多路选择器根据控制信号选择一路输出。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223092741.png)\n\n  * 解决方法2.使用三态门可以控制每一-路是否输出。如: ROout为1时 Ro中的数据输出到A端，ROout为0时R。中的数据无法输出到B端。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223092832.png)\n\n* CPU内部单总线方式:将所有寄存器的输入端和输出端都连接到一条公共的通路上。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223093008.png)\n\n## 1.3 控制器的基本机构\n\n* **程序计数器**：用于指出下一条指令在主存中的存放地址。CPU就是根据PC的内容去主存中取指令的。因程序中指令(通常)是顺序执行的，所以PC有自增功能。\n* **指令寄存器**：用于保存当前正在执行的那条指令。\n* **指令译码器**：仅对操作码字段进行译码，向控制器提供特定的操作信号。\n* **微操作信号发生器**：根据IR的内容(指令)、PSW的内容(状态信息)及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。\n* **时序系统**：用于产生各种时序信号，它们都是由统-时钟(CLOCK) 分频得到。\n* **存储器地址寄存器**：用于存放所要访问的主存单元的地址。\n* **存储器数据寄存器**：用于存放向主存写入的信息或从主存中读出的信息。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223093410.png)\n\n## 1.4 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223093510.png)\n\n# 第二节：指令执行过程\n\n## 2.1 指令周期\n\n* **指令周期**：CPU从主存中每取出并执行一-条指令所需的全部时间。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223105529.png)\n\n* 指令周期常常用若干机器周期来表示，机器周期又叫CPU周期。\n\n* 一个机器周期又包含若干时钟周期(也称为节拍、T周期或CPU时钟周期，它是CPU操作的最基本单位)。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223105628.png)\n\n  * 每个指令周期内机器周期数可以不等，每个机器周期内的节拍数也可以不等。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223105740.png)\n\n* 指令周期流程\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223105904.png)\n\n## 2.2 数据流\n\n###  取指周期\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223110041.png)\n\n* 1.当前指令地址送至存储器地址寄存器，记做: (PC) →MAR。\n* 2.CU发出控制信号，经控制总线传到主存，这里是读信号，记做: 1>R。\n* 3.将MAR所指主存中的内容经数据总线送入MDR，记做: M(MAR) > MDR。\n* 4.将MDR中的内容(此时是指令)送入IR，记做:(MDR)→IR。\n* 5.CU发出控制信号，形成下一- 条指令地址，记做: (PC)+1 > PC。\n\n###  间址周期\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223110140.png)\n\n* 1.将指令的地址码送入MAR,记做: Ad(IR) →MAR或Ad(MDR)→MAR\n* 2.CU发出控制信号，启动主存做读操作，记做: 1> R\n* 3.将MAR所指主存中的内容经数据总线送入MDR，记做: M(MAR) →MDR\n* 4.将有效地址送至指令的地址码字段，记做: (MDR)→ Ad(IR)\n\n###  执行周期\n\n* 执行周期的任务是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果。\n* 不同指令的执行周期操作不同，因此没有统-的数据流向。\n\n###  中断周期\n\n**中断**：暂停当前任务去完成其他任务。为了能够恢复当前任务，需要保存断点一般使用堆栈来保存断点z0这里用SP表示栈顶地址，假设SP指向栈顶元素，进栈操作是先修改指针，后存入数据。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223110403.png)\n\n* 1.CU控制将SP减1，修改后的地址送入MAR记做: (SP)-1 →SP，(SP) →MAR本质上是将断点存入某个存储单元，假设其地址为a，故可记做: a > MAR\n* 2.C发出控制信号，启动主存做写操作，记做: 1> W\n* 3.将断点(PC内容)送入MDR,记做: (PC) →MDR\n* 4.CU控制将中断服务程序的入口地址(由向量地址形成部件产生)送入记做:向量地址> PC\n\n## 2.3 执行方案\n\n### 方案1.单指令周期\n\n对所有指令都选用相同的执行时间来完成。指令之间串行执行;指令周期取决于执行时间最长的指令的执行时间。对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度。\n\n### 方案2.多指令周期\n\n对不同类型的指令选用不同的执行步骤来完成。指令之间串行执行;可选用不同个数的时钟周期来完成不同指令的执行过程。需要更复杂的硬件设计。\n\n### 方案3.流水线方案\n\n在每-一个时钟周期启动--条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中指令之间并行执行。 \n\n## 2.4 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223105430.png)\n\n# 第三节：数据通路的功能和基本结构\n\n* 数据通路:数据在功能部件之间传送的路径。\n* 数据通路的基本结构:\n  * CPU内部单总线方式。\n  * CPU内部多总线方式。\n  * 专用数据通路方式。\n\n## 3.1 CPU内部单总线方式。\n\n* 内部总线是指同一-部件，如CPU内部连接各寄存器及运算部件之间的总线;\n* 系统总线是指同一台计算机系统的各部件，如CPU、内存、通道和各类l/O接口间互相连接的总线。\n\n### 寄存器之间数据传送\n\n* 比如把PC内容送至MAR，实现传送操作的流程及控制信号为:\n  * (PC)→Bus         PCout有效，PC内容送总线\n  * Bus→MAR       MARin有效，总线内容送MAR\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223132603.png)\n\n### 主存与CPU之间的数据传送\n\n* 比如CPU从主存读取指令，实现传送操作的流程及控制信号为:\n  * (PC)→Bus→MAR         PCout和MARin有效，现行指令地址>MAR\n  * 1→R                               CU发读命令(通过控制总线发出，图中未画出)\n  * MEM(MAR)→MDR       MDRin有效\n  * MDR-→Bus→IR           MDRout和IRin有效，现行指令>IR \n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223132813.png)\n\n### 执行算术或逻辑运算\n\n* 比如一条加法指令，微操作序列及控制信号为:\n  * Ad(IR)-→Bus >MAR                   MDRout和MARin有效\n  * 1→R                                             CU发读命令\n  * MEM(MAR)>数据线→MDR       MDRin有 效\n  * MDR→Bus→Y                              MDRout和Yin有效，操作数→Y\n  * (ACC)+(Y)→Z                                ACCout和ALUin有效，CU向ALU发送加操作控制\n  * Z- >ACC                                          Zout和ACCin有效，结果→ACC\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223133107.png)\n\n### 例题\n\n* 设有如图所示的单总线结构，分析指令ADD (RO), R1的指令流程和控制信号。\n\n  * 1.分析指令功能和指令周期\n\n    * 功能: ((RO))+(R1)->(RO)\n    * 取指周期、间址周期、执行周期\n\n  * 2.写出各阶段的指令流程\n\n    * 取指周期:公共操作\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223133419.png)\n\n    * 间址周期:完成取数操作，被加数在主存中，加数已经放在寄存器R1中。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223133357.png)\n\n    * 执行周期:完成取数操作，被加数在主存中，加数已经放在寄存器R1中。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223133329.png)\n\n## 3.2 专用数据通路方式。\n\n\n\n# 第四节：控制器的功能和工作原理\n\n\n\n# 第五节：指令流水线\n\n","categories":["计算机组成系统"]},{"title":"第四章-指令系统","url":"/2020/12/22/计算机组成原理/第四章-指令系统/","content":"\n指令，指令的分类，扩展操作码指令，指令寻址，数据寻址，复杂指令集，精简指令集。\n<!--more-->\n# 第一节：指令格式\n\n## 1.1 指令的基本概念\n\n指令(又称机器指令) :是指示计算机执行某种操作的命令；是计算机运行的最小功能单位。\n\n一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。\n\n注:一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。\n\n一条指令就是机器语言的-一个语句，它是一组有意义的二进制代码。\n\n一条指令通常要包括操作码字段和地址码字段两部分:\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222191802.png)\n\n## 1.2 指令的分类—按地址码数目分类\n\n根据地址码数目不同，可以将指令分为零地址指令、一地址指令、 二地址指令...\n\n### 零地址指令\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222191956.png)\n\n1.不需要操作数，如空操作、停机、关中断等指令。\n\n2.堆栈计算机，两个操作数隐含存放在栈项和次栈顶，计算结果压回栈顶。\n\n### 一地址指令\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222192015.png)\n\n1.只需要单操作数，如加1、减1、取反、求补等\n\n​\t\t指令含义: OP(A1)- →A1, 完成一条指令需要3次访存:取指≥读A1 >写A1。\n\n2.需要两个操作数，但其中一个操作数隐含在某个寄存器(如隐含在ACC)\n\n​\t\t指令含义: (ACC)OP(A)- →ACG，完成一条指令需要2次访存:取指→读A1。\n\n注: A1 指某个主存地址，(A1)表示 A1所指向的地址中的内容。\n\n### 二地址指令\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222192157.png)\n\n常用于需要两个操作数的算术运算、逻辑运算相关指令\n\n指令含义: (A1)OP(A2)- →A1，完成一-条指令需要访存4次，取指>读A1 >读A2 >写A1。\n\n### 三地址指令\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222192200.png)\n\n常用于需要两个操作数的算术运算、逻辑运算相关指令\n\n指令含义: (A1)OP(A2)- →A3，完成一条指令需要访存4次，取指>读A1→读A2 >写A3。\n\n### 四地址指令\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222192256.png)\n\n指令含义: (A1)OP(A2)>A3， A4=下 - -条将要执行指令的地址\n\n完成- -条指令需要访存4次，取指>读A1 >读A2 >写A3。\n\n正常情况下:取指令之后PC+1,指向下一条指令。\n\n四地址指令:执行指令后，将PC的值修改位A4所指地址。\n\n## 1.3 指令的分类—按指令长度分类\n\n**指令字长**:一条指令的总长度(可能会变)。\n\n**机器字长**:CPU进行--次整数运算所能处理的二进制数据的位数(通常和ALU直接相关)。\n\n**存储字长**:  一个存储单元中的二进制代码位数(通常和MDR位数相同)。\n\n**半字长指令、单字长指令、双字长指令**。——指令长度是机器字长的多少倍。\n\n指令字长会影响取指令所需时间。如:机器字长=存储字长=16bit,则取一条双字长指令需要两次访存。\n\n**定长指令字结构**:指令系统中所有指令的长度都相等。\n\n**变长指令字结构**:指令系统中各种指令的长度不等\n\n## 1.4 指令的分类—按操作码长度分类\n\n* 定长操作码**:指令系统中所有指令的操作码长度都相同\n  * n位→2^n条指令\n  * 控制器的译码电路设计简单，但灵活性较低。\n* 可变长操作码:指令系统中各指令的操作码长度可变\n  * 控制器的译码电路设计复杂，但灵活性较高。\n\n定长指令字结构+可变长操作码   ——>扩展操作码指令格式。\n\n不同地址数的指令使用不同长度的操作码。\n\n## 1.5 指令的分类—按操作类型分类\n\n* 1.数据传送\n  * LOAD   作用:把存储器中的数据放到寄存器中\n  * STORE   作用:把寄存器中的数据放到存储器中\n* 2.算术逻辑操作\n  * 算术:加、减、乘、除、增1、减1、求补、浮点运算、十进制运算\n  * 逻辑:与、或、非、异或、位操作、位测试、位清除、位求反\n* 3.移位操作\n  * 算术移位、逻辑移位、循环移位(带进位和不带进位)\n* 4.转移操作\n  * 无条件转移JMP\n  * 条件转移JZ: 结果为0; JO:结果溢出; JC:结果有进位\n  * 调用和返回CALL和RETURN\n  * 陷阱(Trap)与陷阱指令\n* 5.输入输出操作\n  * CPU寄存器与I0端口之间的数据传送(端口即|0接口中的寄存器)\n\n数据传送类：进行主存与CPU之间的数据传送。\n\n运算类。\n\n程序控制类：改变程序执行的顺序。\n\n输入输出类(I/0) ：进行CPU和I/0设备之间的数据传送\n\n## 1.6 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222191538.png)\n\n# 第二节：扩展操作码指令格式\n\n## 2.1 举例\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222194259.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222194606.png)\n\n## 2.2 扩展操作码指令设计\n\n* 在设计扩展操作码指令格式时，必须注意以下两点:\n  * 1)不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同。\n  * 2)各指令的操作码一定不能重复。\n* 通常情况下，对使用频率较高的指令，分配较短的操作码;对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。\n* 设地址长度为n，上一层留出m种状态，下一 层可扩展出m*2^n种状态。\n\n## 2.3 扩展操作码和定长操作码的对比\n\n* 定长操作码:在指令字的最高位部分分配固定的若干位(定长)表示操作码。\n  * 一般n位操作码字段的指令系统最大能够表示2”条指令。\n  * 优:定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利;\n  * 缺:指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限。\n* 扩展操作码(不定长操作码) ;全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上。\n  * 最常见的变长操作码方法是扩展操作码，使操作码的长度随地址码的减少而增加，不同地址数的\n    指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。\n  * 优:在指令字长有限的前提下仍保持比较丰富的指令种类;\n  * 缺:增加了指令译码和分析的难度，使控制器的设计复杂化。\n\n# 第三节：寻址方式\n\n## 3.1 指令寻址\n\n* 定义：下一条欲执行执行的指令地址。始终由程序计数器给出。\n\n### 分类\n\n* 顺序寻址：PC自动加一，执行下一条指令。\n* 跳跃寻址：转移指令的操作码提出转移，地址码上的是其他指令的地址。当执行转移指令时，会直接跳转到转移指令给出的指令地址。这种方式叫做跳跃寻址。\n\n### 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222195631.png)\n\n## 3.2 数据寻址\n\n* 数据寻址：确定本条指令的地址码指明的真实地址。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222200130.png)\n\n### 分类\n\n假设指令字长=机器字长=存储字长，操作数为3；\n\n* 直接寻址：指令字中的形式地址A就是操作数的真实地址EA，即EA=A 。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222200852.png)\n\n* 间接寻址：指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址,0也就是操作数地址的地址，即EA=(A)。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222200948.png)\n\n* 寄存器寻址：在指令字中直接给出操作数所在的寄存器编号，即EA =R，其操作数在由R,所指的寄存器内。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222201120.png)\n\n* 寄存器间接寻址：寄存器R中给出的不是-一个操作数，而是操作数所在主存单元的地址，即EA=(R)。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222201210.png)\n\n* 隐含寻址：不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222201259.png)\n\n* 立即寻址：形式地址A就是操作数本身，又称为立即数，-般采用补码形式。#表示立即寻址特征。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222201340.png)\n\n* 基址寻址：将CPU中基址寄存器(BR)的内容加上指令格式中的形式地址A,而形成操作数的有效地址，即EA=(BR)+A。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222202237.png)\n\n* 变址寻址：有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和，即EA= (IX)+A,其中IX可为变址寄存器(专用), 也可用通用寄存器作为变址寄存器。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222202235.png)\n\n* 相对寻址：把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA=(PC)+A， 其中A是相对于PC所指地址的位移量，可正可负，补码表示。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222202557.png)\n\n* 堆栈寻址：操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数地址。\n\n  * 堆栈是存储器(或专用寄存器组)中-块特定的按“后进先出(LIFO) ”；原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针(SP) 。\n  * 硬堆栈不访存，软堆栈访存\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222210342.png)\n\n## 3.3 总结\n\n|    寻址方式    | 有效的地址  | 访存次数(指令执行期间) |\n| :------------: | :---------: | :--------------------: |\n|    隐含寻址    |  程序指定   |           0            |\n|    立即寻址    | A既是操作数 |           0            |\n|    直接寻址    |    EA=A     |           1            |\n|  一次间接寻址  |   EA=(A)    |           2            |\n|   寄存器寻址   |    EA=Ri    |           0            |\n| 寄存器间接寻址 |   EA=(Ri)   |           1            |\n|    相对寻址    |  EA=(PC)+A  |           1            |\n|    基址寻址    |  EA=(BP)+A  |           1            |\n|    变址寻址    |  EA=(IX)+A  |           1            |\n\n# 第四节：CISC和RISC设计方式\n\n## CISC：复杂指令集设计\n\n* 设计思路：一条指令完成一个复杂的基本功能\n* 代表：x86架构，主要用于笔记本，台式机等\n* 80-20规律：典型程序中80%的语句仅仅使用处理机中20%的指令。\n\n## RISC：精简指令集设计\n\n* 设计思路：一条指令完成一个基本动作；多条指令组合成一个复杂的基本功能。\n* 代表：ARM架构，主要用于手机，平板等。\n\n|                  |                 SISC                 |                 RISC                 |\n| :--------------: | :----------------------------------: | :----------------------------------: |\n|     指令系统     |              复杂，庞大              |              简单，精简              |\n|     指令数目     |            一般大于200条             |            一般小于100条             |\n|     指令字长     |                不固定                |                 定长                 |\n|    可访存指令    |               不加限制               |          只有Load/Store指令          |\n| 各种指令执行时间 |               相差较大               |       绝大多数在一个周期内完成       |\n| 各种指令使用频率 |               相差很大               |              都比较常用              |\n|  通用寄存器数量  |                 较少                 |                  多                  |\n|     目标代码     | 难以用优化编译生成高效的目标代码程序 | 采用优化的编译程序，生成代码较为高效 |\n|     控制方式     |         绝大多数为微程序控制         |        绝大多数为组合逻辑控制        |\n|    指令流水线    |         可以通过一定方式实现         |               必须实现               |\n\n","categories":["计算机组成系统"]},{"title":"第三章-存储系统","url":"/2020/12/22/计算机组成原理/第三章-存储系统/","content":"存储器，主存储器，半导体存储器，双端口RAM，缓存Cache,缓存-主存映射，缓存替换方式\n缓存写策略。\n<!--more-->\n# 第一节：存储器基本概念\n\n## 1.1 存储器的层次结构\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222144954.png)\n\n* 主存一辅存:实现虚拟存储系统，解决了主存容量不够的问题\n* Cache-主存:解决了主存与CPU速度不匹配的问题\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222145815.png)\n\n## 1.2 存储器的分类\n\n* 按层次分\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222145902.png)\n\n* 按存储介质分类\n  * 半导体存储器(主存、Cache)：以半导体器件存储信息。\n  * 磁表面存储器:磁盘、磁带：以磁性材料存储信息。\n  * 光存储器：以光介质存储信息。\n* 按存取方式分类\n  * 随机存取存储器(RandomAccess Memory, RAM) :读写任何一个存储单元所需时间都相同，与存储单元所在的物理位置无关。\n  * 顺序存取存储器(SequentialAccess Memory ,SAM) :读写一个存储单元所需时间取决于存储单元所在的物理位置。\n  * 直接存取存储器( Direct AccessMemory, DAM) :既有随机存取特性，也有顺序存取特性。先直接选取信息所在区域，然后按顺序方式存取。\n  * 相联存储器(Associative Memory) ,即可以按内容访问的存储器( ContentAddressed Memory, CAM)可以按照内容检索到存储位置进行读写，“快表”就是一-种相联存储器。\n* 按信息的可更改性分类\n  * 读写存储器(Read/Write Memory) --即可读、也可写(如:磁盘、内存、Cache)\n  * 只读存储器(Read Only Memory) --只能读，不能写(如:实体音乐专辑通常采用CD-ROM, 实体电影采用蓝光光碟，BIOS通 常写在ROM中)。\n* 按信息的可保存性分类\n  * 断电后，存储信息消失的存储器--易失性存储器 (主存、Cache)\n  * 断电后，存储信息依然保持的存储器--非 易失性存储器(磁盘、光盘)\n\n  * 信息读出后，原存储信息被破坏- -- -破坏性读出( 如DRAM芯片，读出数据后要进行重写)\n  * 信息读出后，原存储信息不被破坏-- -非破坏性读出(如SRAM芯片、磁盘、光盘)\n\n## 1.3 存储器的性能指标\n\n* 存储容量：存储字长 * 字长(如1M * 8位)\n\n* 单位成本：每位价格 = 总成本/总容量\n\n* 存储速度：数据传输率(主存带宽) = 数据宽度/存储周期\n  \n  * 主存带宽(Bm)：又称为数据传输率，表示每秒从主存进出信息的最大数量，单位为：字/秒，字节/秒，位/秒。\n  \n* 存储周期 = 存取时间+恢复时间\n  \n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222150812.png)\n  \n  * 存取时间(Ta)：指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。\n  * 存取周期(Tm)：又称为读写周期或访问周期。指存储器进行一次完整的读写操作所需的全部时间，及连续两次单独访问存储器操作之间所需的最小时间间隔。\n\n## 1.4 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222150907.png)\n\n# 第二节：主存储器的基本组成\n\n* 总容量 = 存储单元的个数 * 存储字长。\n  * 例如：一个3位地址8位字长的存储器，存储单元个数 = 2^3 = 8,存储字长 = 8 \n  * 1B = 8bit 。B：字节。bit：位。\n  * 8K * 8位。总容量 = 2^13  * 8bit = 8KB\n  * 64K * 16位。总容量 = 2^64 * 16bit = 128KB\n* 地址线：数值上等于MAR的位数。n位地址线 --> 2^n个存储单元\n* 数据线：数值上等价于存储字长\n* 寻址：一个字长为4B，总容量为1KB。\n  * 按字节寻址：1K个单元，每个单元1B，地址线10根。 \n    * 字节：1字节  = 1B。地址线：1K = 2^10\n  * 按字寻址：256个单元，每个单元4B，地址线8根。\n    * 字：题意知1字 = 4B。地址线：256 = 2^8\n  * 按半字寻址：512个单元，每个单元2B，地址线9根\n    * 半字：题意知，半字 = 2B。地址线：512= 2^9\n  * 按双字寻址：128个单元，每个单元8B，地址线7根\n    * 双字：题意知，双字 = 8B。地址线：128= 2^7\n\n# 第三节：半导体存储器\n\n* 存储器的基本结构及概念\n\n  * 存储矩阵：由大量相同的位存储单元阵列构成。\n* 译码驱动：将来自地址总线的地址信号翻译成对应存储单元的选通信号，该信号在读写电路的配合下完成对被选中单元的读写操作\n  * 读写电路：包括读出放大器和写入电路，用来完成读写操作\n  * 读写控制线：决定芯片进行读/写操作\n  * 片选线：确定哪个存储芯片被选中。可用于容量扩充。符号：CS\n  * 数据线：单向输入，其位数与存储字的个数有关。\n  * 地址线：是双向的，其位数与读出或写入的数据位数有关\n  * 数据线数和地址线数共同反应存储芯片容量的大小\n    * 如：地址线10根，数据线8根，则芯片容量=2^10*8 = 8Kbit\n\n## RAM：随机存取存储器\n\n* 适用于用户程序区\n\n* SRAM和DRAM的区别\n\n  |            |  SRAM  |             DRAM              |\n  | :--------: | :----: | :---------------------------: |\n  |  存储信息  | 触发器 |             电容              |\n  | 破坏性读出 |   非   |              是               |\n  |  需要刷新  |  不要  |             需要              |\n  | 送行列地址 | 同时送 |           分两次送            |\n  |  运行速度  |   快   |              慢               |\n  |   集成度   |   低   |              高               |\n  |   发热量   |   大   |              小               |\n  |  存储成本  |   高   |              低               |\n  |   常用来   | Cache  | 主存（现代的主存通常是SDRAM） |\n\n* 存取周期： = 存取时间 + 恢复时间\n\n### SRAM：静态随机存取存储器\n\n* 基本属性\n  * 存储信息：用触发器作基本元件，通过触发器的状态存放信息的0/1\n  * 读/写：读：查看触发器的状态。写：改变触发器的状态。\n  * 需要刷新：不需要刷新，因为触发器能保持两种稳定的状态\n  * 送行列地址：可以一次性的将地址送到容器中。\n  * 运行速度：因为较稳定，所以运行速度快\n  * 集成度：由于触发器的性质，存储一个0/1需要6个逻辑元件构成，因此及横渡很低。\n\n### DRAM：动态随机存取存储器\n\n* 基本属性\n\n  * 存储信息：用电容作基本元件；通过充放电的形式存储0/1；断电就丢失信息。又被称为易失性存储器。\n  * 读/写：读：连接电容，检测电流变化，读出后需要重新充电。写：给电容充/放电。\n  * 需要刷新：由于电容上的电荷只能维持2ms,因此需要刷新\n  * 送行列地址：DRAM会将地址对半分成行地址和列地址，一次只送一个；因此地址会被分两次送入。注意，求DRAM的地址线数时要注意结果<font color = \"red\">除以2</font>。\n  * 运行速度：由于时刻要刷新，因此运行速度较低\n  * 集成度：电容存放一个0/1只需要1个或3个逻辑元件，因此集成度高。\n\n* 刷新\n\n  * 多久刷新一次：刷新周期：一般位2ms。<font color = \"red\">（当前主流的DRAM的刷新周期为64ms）</font>\n  * 每次刷新多少存储单元：以行为单位，每次刷新一行存储单元。\n    * 为什么要用行列地址：为了减少选通线的数量。\n      * 选通线：译码驱动连接存储单元的线\n  * 如何刷新：有硬件支持，读出一行的信息后重新写入，<font color = \"red\">占用一个读/写周期</font>\n  * 在什么时刻刷新：有分散刷新，集中刷新，异步刷新三种方式。\n\n* 刷新的举例：假设DRAM内部结构排成128*128的形式，读/写周期0.5us。刷新周期为2ms。\n\n  * 分散刷新：每次读写完都刷新一行，\n\n    * 系统的存取周期为1us:前0.5us用于正常的读写，后0.5us用于刷新某行。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222151812.png)\n\n  * 集中刷新：2ms内集中安排时间刷新全部的DRAM。\n\n    * 系统的存取周期还是0.5us。有一段时间换门用于刷新，无法访问存储器，称为访存死区。\n    * 2ms:前1936us内用于读写，后64us内用于对128行进行刷新，这64us被称为死区。\n    * 64us = 0.5us * 128 。1936us = 2ms-64us\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222151907.png)\n\n  * 异步刷新：2ms内每行刷新一次即可\n\n    * 2ms内需要产生128次刷新请求，因此每隔2ms/128=15.6us发出一次刷新请求，即每15.6us内有0.5us的死区。\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222151923.png)\n\n## ROM：只读存储器\n\n* 特点：结构简单，位密度比RAM高；非易失性，可靠性高。\n* 适用于系统程序区\n* 分类：\n  * 掩膜式只读存储器(MROM)\n    * 存储内容由半导体制造厂按用户提出的要求在芯片的生产过程中直接写入，无法修改。\n  * 一次可编程只读存储器(PROM)\n    * 存储内容由用户用专门的设备一次性写入，之后无法修改\n  * 可擦除可编程只读存储器(EPROM)\n    * 修改次数有限，写入时间很长\n    * 又分为紫外线擦除(UVEPROM)，电擦除(EEPROM)两种\n  * 闪速存储器(Flash Memory)\n    * 如U盘，写入速度很快\n  * 固态硬盘(Solid State Drives)\n    * 控制单元+FLASH芯片\n\n# 第四节：主存与CPU的连接\n\n* 位扩展：例如将8个8K * 1位的存储器通过位扩展变成1个8K * 8位的存储器\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222152241.png)\n\n* 字扩展：例如将4个4K * 8位的存储器通过位扩展变成1个32K * 8位的存储器\n\n  * 线选法：一个地址线对应一个存储器。n条线对应n个片选信号\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222152500.png)\n\n  * 译码片选法：将多个地址线连在译码器上，译码器因此生出多个控制线，控制多个存储器。n条线对应2^n个片选信号\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222152523.png)\n\n* 译码编译器：可以接受n条线，然后输出2^n条线，来控制存储器。\n\n  * 有高电平和低电平两种。\n  * 译码器有一个总开关，只有输入特定的值来打开开关译码器才会工作。这个开关可以被称为访存控制信号\n\n* 字位扩展：例如将8个16K * 4位的存储器通过字位扩展成一个64K * 8位的存储器\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222152643.png)\n\n* 例题：\n\n  ![]()\n\n  ![]()\n\n  * 说明\n    * 图右下方位74LS138译码器的图示。74LS138译码器又称为38译码器。左边有3个连接地址总线，右边有8个为片选信号。左上角的三个G为总开关\n    * 对于地址线的分析(以系统程序区为例)：首先由地址范围得地址总线为11根，因此CPU的后11为应与ROM的地址线相连；\n    * 然后又因为译码器采用38译码器，因此地址译码需要3个，对照系统程序区和用户程序区的地址，由地址线多的系统程序区，再向前选三位(100)，因此100作为ROM的片选信号Y4，101作为用户程序区的片选信号Y5。\n    * 最后还剩下前两位，由于前两位都是01，因此他们可以作为地址译码器的总开关的标识，又因为访存控制信号是低电平有效的，因此这个信号只能选G2A或G2B。\n\n  ![]()\n\n  * 说明\n    * 对于用户程序区：它的A10和Y5可以作为一个标识符来界定地址是在用户程序区的。图中 的小圆圈表示非运算和低电平有效。\n    * A10=0 & Y5 =0  --> !0 & !0 = 1 & 1 = 1 \n\n# 第五节：双端口RAM和多端口存储器\n\n## 5.1双端口RAM\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222154537.png)\n\n* 需要有两组完全独立的数据线、地址线、控制线。CPU、RAM中也要有更复.杂的控制电路。\n* 作用:优化多核CPU访问一根内存条的速度。\n* 两个端口对同- -主存操作有以下4种情况:\n  * 1.两个端口同时对不同的地址单元存取数据。√\n  * 2.两个端口同时对同一地址单元读出数据。√\n  * 3.两个端口同时对同-地址单元写入数据。×\n  * 4.两个端口同时对同- -地址单元，一个写入数据，另-一个读出数据。×\n* 解决方法:置“忙”信号为0,由判断逻辑决定暂时关闭-一个端口(即被延时)，未被关闭的端口正常访问，被关闭的端口延长一个很短的时间段后再访问。\n\n## 5.2 多端口存储器\n\n### 多体并行存储器\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222155111.png)\n\n* 宏观上，一个存储周期内，m体交叉存储器可以提供的数据量为单个模块的m倍。\n* 存取周期为T，存取时间为r，为了使流水线不间断，应保证模块数m≥T/r\n\n### 单体多字存储器\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222155304.png)\n\n## 5.3 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222155328.png)\n\n# 第六节：Cache\n\n## 6.1 局部性原理\n\n* 空间局部性:在最近的未来要用到的信息(指令和数据)，很可能与现在正在使用的信息在存储空间上是邻近的。\n* 时间局部性:在最近的未来要用到的信息，很可能是现在正在使用的信息。\n\n## 6.2 性能分析\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222155930.png)\n\n设tc为访问一次Cache所需时间，tm为访问--次主存所需时间。\n\n* 命中率H：CPU欲访问的信息已在Cache中的比率。\n* 缺失(未命中)率：M=1-H。\n* Cache-主存 系统的平均访问时间t为：\n  * t =Htc +(1- H)(tc + tm)   --->  先访问Cache,若Cache未命中再访问主存。\n  * 或  t = Htc+(1一H)tm  --->  同时访问Cache和主存，若Cache命中则立即停止访问主存。\n\n**例题**：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222160331.png)\n\n## 6.3 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222161103.png)\n\n# 第七节：Cache-主存映射方式\n\n## 7.1 全相联映射\n\n* 主存块可以放在Cache的任意位置。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222162914.png)\n\n* 例题：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222163120.png)\n\n## 7.2 直接映射\n\n* 每个主存块只能放到一个特定的位置：Cache块号=主存块号% Cache总块数\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222163024.png)\n\n* 例题：\n  * 缺点:其他地方有空闲Cache块,但是8号主存块不能使用\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222163256.png)\n\n## 7.3 组相联映射\n\n* Cache块分为若干组，每个主存块可放到特定分组中的任意一个位置：组号=主存块号%分组数\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222163027.png)\n\n* 例题：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222163344.png)\n\n## 7.4 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222163425.png)\n\n# 第八节：Cache替换算法\n\n## 8.1 随机算法(RAND)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222171617.png)\n\n随机算法： 实现简单，但完全没考虑局部性原理，命中率低，实际效果很不稳定\n\n## 8.2 先进先出算法(FIFO)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222171658.png)\n\n先进先出算法- --实现简单，最开始按#0#1#2#3放入Cache, 之后轮流替换#0#1#2#3。\n\nFIFO依然没考虑局部性原理，最先被调入Cache的块也有可能是被频繁访问的。\n\n抖动现象：频繁的换入换出现象(刚被替换的块很快又被调入)。\n\n## 8.3 近期最少使用(LRU)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222171915.png)\n\n①命中时，所命中的行的计数器清零，比其低的计数器加1，其余不变。\n\n②未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1。\n\n③未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1。\n\nCache块的总数=2\"，则计数器只需n位。且Cache装满后所有计数器的值-定不重复。\n\nLRU算法- -基于“局部性原理”，近期被访问过的主存块，在不久的将来也很有可能被再次访问，此淘汰最久没被访问过的块是合理的。LRU算法的实际运行效果优秀，Cache命中率高。\n\n若被频繁访问的主存块数量>Cache行的数量，则有可能发生“抖动”，如: {1,2,3,4,5,1,2,3,4,5,1,2}。\n\n## 8.4 最不经常使用(LFU)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222172316.png)\n\n新调入的块计数器=0，之后每被访问- -次计数器+1。需要替换时。选择体数器最小的一行，\n\n若有多个计数器最小的行，可按行号递增或FIFO策略进行选择。\n\nLFU算法---曾经被经常访问的主存块在未来不一定会用到；并没有很好地遵循局部性原理，因此实际运行效果不如LRU。\n\n## 8.5 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222171511.png)\n\n\n\n# 第九节：Cache写策略\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222173028.png)\n\n \n\n","categories":["计算机组成系统"]},{"title":"第二章-数据的表示和运算","url":"/2020/12/21/计算机组成原理/第二章-数据的表示和运算/","content":"\n进制数，BCD码，校验码，定点数的表示和运算，浮点数的表示和运算。\n<!--more-->\n# 第一节 进位计数制\n\n## 1.1 r进制计数法\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217174958.png)\n\n* 基数：每个数码位所用到的不同符号的个数，r进制的基数为r\n* 常见进制的基数\n  * 二进制：0，1\n  * 八进制：0，1，2，3，4， 5，6，7\n  * 十进制：0，1，2，3，4，5，6，7，8，9\n  * 十六进制：0，1，2，3，4，5，6，7，8，9，A，B，C，D，E，F\n  ```java\n  二进制：101.1 -> 1*2^2 + 0*2^1 + 1*2^0 + 1*2^(-1) = 5.5\n  八进制：5.4 -> 5*8^0 + 4*8^(-1) = 5.5\n  十进制：5.5 -> 5*10^0 + 5*10^(-1) = 5.5\n  十六进制： 5.8 -> 5*16^0 + 8*16^(-1) = 5.5\n  ```\n* 计算机采用二进制的原因\n  * ① 可以使用两个稳定状态的物理器件表示\n  * ② 0，1正好对应逻辑值假，真。方便实现逻辑运算\n  * ③ 可很方便的使用逻辑门电路实现算术运算\n## 1.2 r进制 --> 十进制\n\n* 利用公式一步步展开。\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217174927.png)\n* r进制的数值 = 各数码位与位权的乘积之和\n```java\n二进制：10010010.110   1*2^7 + 1*2^4 + 1*2^1 + 1*2^(-1) + 1*2^(-2) = 146.752 \n八进制：251.5          2*8^2 + 5*8^1 + 1*8^0 + 5*8^(-1) = 168.625\n十六进制：AE86.1       10*16^3 + 14*16^2 + 8*16^1 + 6*16^0 + 1*16^(-1) = 44678.0625\n```\n## 1.3 二进制 <--> 八进制\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219165910.png)\n\n## 1.4 二进制 <--> 十六进制\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219165916.png)\n\n## 1.5 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219175851.png)\n\n# 第二节 BCD码\n\n* BCD码：用二进制编码的十进制。即为将十进制的每一个位上的数用四个二进制位表示。\n* BCD码有三种方式：8421码，余3码，2421码。\n\n## 2.1 8421码\n\n* 四个二进制数的权重依次位8，4，2，1。可以表示2^4种数字，但有6种是冗余的。如下表\n  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |\n  | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n  | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 |\n* 例如\n  | 十进制编码 |  8421码   |\n  | :--------: | :-------: |\n  |     5      |   0101    |\n  |     15     | 0001 0101 |\n  |     99     | 1001 1001 |\n\n* 加法运算：和十进制加法一样，每四位按位置相加，但要满足下面的情况\n  * ① 当四位加四位的结果在十进制10~19时，结果的后四位数字要加上二进制0110(也就是十进制6)\n  * ② 如果有进位，则进位做任何处理，直接进位\n  ```   java\n  例如：5 + 8 = 13\n     5 --> 0101\n   + 8 --> 1000\n         = 1101  结果在10~19范围内，因此后四位要再加0110\n         + 0110\n       = 1 0011  结果为5位，需要补位，因此在前面加三个0\n   13 -->0001 0011\n  例如：9 + 9 = 18\n     9 --> 1001\n   + 9 --> 1001\n       = 1 0010  结果在10~19范围内，因此后四位要再加0110\n         + 0110\n       = 1 1000  结果为5位，需要补位，因此在前面加三个0\n   18 -->0001 1000\n  例如：99 + 99 = 198\n     99 --> 1001 1001\n   + 99 --> 1001 1001   个位先相加\n        =      1 0010   个位相加结果在10~19范围内，因此后四位要再加0110\n        +\t\t   0110\n        =\t     1 1000   个位处理完，十位再相加。注意个位相加结果的进位\n        = 1 0011        十位相加结果在10~19范围内，因此后四位要再加0110\n        +   0110\n        = 1 1001 1000   结果为9位，需要补位，因此在前面加三个0\n   198 -->0001 1001 1000\n  ```\n\n## 2.2 余3码\n\n* 8421码+(0011)。即8421码的二进制编码后再加上0011，即为余3码的编码。如下表\n|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |\n| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n| 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 |\n## 2.3 2421码\n\n* 和8421码类似，四个二进制数的权重依次位2，4，2，1。且表示0~4时二进制的最高位为0，表示5~9时二进制的最高位为1。\n\n| 0                             | 1                             | 2                             | 3                             | 4                             | 5                             | 6                             | 7                             | 8                             | 9                             |\n| ----------------------------- | ----------------------------- | ----------------------------- | ----------------------------- | ----------------------------- | ----------------------------- | ----------------------------- | ----------------------------- | ----------------------------- | ----------------------------- |\n| <font color=\"red\">0</font>000 | <font color=\"red\">0</font>001 | <font color=\"red\">0</font>010 | <font color=\"red\">0</font>011 | <font color=\"red\">0</font>100 | <font color=\"red\">1</font>011 | <font color=\"red\">1</font>100 | <font color=\"red\">1</font>101 | <font color=\"red\">1</font>110 | <font color=\"red\">1</font>111 |\n# 第三节 字符与字符串\n\n## 3.1 ASCII码\n\n* 可印刷字符：32~126，其余为控制，通信字符\n* 数字：48(0011 0000) ~ 57(0011 1001)     前四位一样：0011\n* 大写字母：65(0100 0001) ~ 90(0101 1010)    前三位一样：010\n* 小写字母：97(0110 0001) ~ 122(0111 1010)     前三位一样：011\n## 3.2 汉字的表示与编码\n\n* GB 2312-80：汉字+各种符号共7445个\n  * 区位码：94个区，每区94个位置，例如：啊  1601 表示16区01位\n* 国标码：区位码+20H 20H     (H表示16进制数，转换成十进制为32)\n* 汉字内码：国标码+80H 80H     (H表示16进制数，转换成十进制为128)\n## 3.3 字符串\n\n* 从低地址祷告地址逐个字符存储，常采用'\\0'作为结尾标志\n* 对于多字节的数据(如汉字)，可采取大/小端存储模式\n  * 大端模式：将数据的最高有效字节存放在低地址单元中\n  * 小端模式：将数据的最高有效字节存放在高地址单元中\n\n## 3.4 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201220091112.png)\n\n# 第四节 校验码\n\n* 引入：当数据在传输过程中发生了0变成1，1变成0的情况时，计算机如何检查出来并纠错？为此设计了校验码\n* ① 2bit映射到4个合法状态\n| 信息 |  A   |  B   |  C   |  D   |\n| :--: | :--: | :--: | :--: | :--: |\n| 编码 |  00  |  01  |  10  |  11  |\n* ② 3bit映射到4个合法状态(有4个冗余的非法状态)\n| 信息 |  A   |  B   |  C   |  D   |\n| :--: | :--: | :--: | :--: | :--: |\n| 编码 | 100  | 001  | 010  | 111  |\n* 有若干个代码组成的一个字叫做<font color=\"red\">码字</font>。例如：上表中 00就是一个码字，100也是一个码字\n* 将两个码字逐位进行对比，具有不同的位的个数称为<font color=\"red\">两个码字间的距离</font>。比如①中的A和B的码字间的距离是1，②中A和B的码字间的距离是2.\n* 一种编码方案可能有若干个合法码字，各合法码字间的最小距离称为<font color=\"red\">码距</font>。例如①的码距是1，②的码距是2。\n* 当码距=1时，无检错能力；当码距=2时，有检错能力；当码距>2时，若设计合理，可能具有检错，纠错能力。\n## 4.1 奇偶校验码\n\n* 只有一个校验位，即码距=2的校验码。\n* 奇校验码：整个校验码(包含有效信息位和校验位)中“1”的个数为奇数。\n* 偶校验码：整个校验码(包含有效信息位和校验位)中“1”的个数为偶数。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201220091613.png)\n\n**例题**： \n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201220091651.png)\n\n* 偶校验的硬件实现：各信息位进行异或(模2加)运算，得到的结果应为偶校验位的值。\n  * 异或(模2加)运算：相同为0，不同为1。\n* 奇校验的硬件实现：各信息位进行异或(模2加)运算，得到的结果应为奇校验位值的相反数。\n* 优点：能识别奇位数出错，即有一个数出错了或3个数出错了可以识别。\n* 缺点：不能识别偶位数出错，而且没有纠错能力。\n### 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201220093426.png)\n\n## 4.2 海明校验码\n\n* 设计思路：将信息位分组进行偶校验 -->多个校验位\n* 需要多少个校验位？\n  ```java\n  信息位  校验位  -->信息位+校验位，共k+n位\n    n      k    -->由于校验位位k,因此码字最多有有2^k种状态\n  因此：码字的数量应满足  2^k >= n+k+1         1表示正确状态\n  ```\n* 常见的n和k的分配表如下\n|  n   |  1   | 2-4  | 5-11 | 12-26 | 27-57 | 58-120 |\n| :--: | :--: | :--: | :--: | :---: | :---: | :----: |\n|  k   |  2   |  3   |  4   |   5   |   6   |   7    |\n* 解题步骤  ：例如 信息位为1010\n  * ①确定海明码的位数：2^k >= n+k+1 \n  ```java\n  n = 4  --> k = 3\n  设信息位为D4,D3,D2,D1(1010),共4位，校验位P3,P2,P1,共3位，对应的海明码为H7,H6,H5,H4,H3,H2,H1。  \n  ```\n  * ②确定校验位的分布\n    * 校验位Pi应放在海明位号位2^(i-1)的位置上，因此，海明码的值如下表\n  |  H7  |  H6  |  H5  |             H4             |  H3  |             H2             |             H1             |\n  | :--: | :--: | :--: | :------------------------: | :--: | :------------------------: | :------------------------: |\n  |  D4  |  D3  |  D2  |             P3             |  D1  |             P2             |             P1             |\n  |  1   |  0   |  1   | <font color=\"red\">0</font> |  0   | <font color=\"red\">1</font> | <font color=\"red\">0</font> |\n  * ③求校验位的值\n  ```java\n  先将信息位所处的位置用二进制表示\n      H3 ：3  --> 0  1  1\n      H5 ：5  --> 1  0  1\n      H6 ：6  --> 1  1  0\n      H7 ：7  --> 1  1  1\n                  p3 p2 p1\n  校验位Pi与位置序号第i位为1的信息为归为一组，\n      Pi的值为它分组内的信息位的异或的结果。异或符号：^\n      因此 P1 = H3⊕H5⊕H7 = D1⊕D2⊕D4 = 0⊕1⊕1 = 0\n          P2 = H3⊕H6⊕H7 = D1⊕D3⊕D4 = 0⊕0⊕1 = 1\n          P3 = H5⊕H6⊕H7 = D2⊕D3⊕D4 = 1⊕0⊕1 = 0\n  三个分组分别进行偶校验\n  ```\n  * ④纠错\n  ```java\n  纠错方程：\n   S1 = P1⊕D1⊕D2⊕D4\n   S2 = P2⊕D1⊕D3⊕D4 \n   S3 = P3⊕D2⊕D3⊕D4\n   当接收到：1010010\n   S1 = P1⊕D1⊕D2⊕D4 = 0⊕0⊕1⊕1 = 0\n   S2 = P2⊕D1⊕D3⊕D4 = 1⊕0⊕0⊕1 = 0 \n   S3 = P3⊕D2⊕D3⊕D4 = 0⊕1⊕0⊕1 = 0    无错误\n    当接收到：10100‘0’0\n   S1 = P1⊕D1⊕D2⊕D4 = 0⊕0⊕1⊕1 = 0\n   S2 = P2⊕D1⊕D3⊕D4 = 0⊕0⊕0⊕1 = 1\n   S3 = P3⊕D2⊕D3⊕D4 = 0⊕1⊕0⊕1 = 0   有错误，出错位为S3S2S1 = 010 = 2出错， \t\t即H2位出错\n  ```\n  * ⑤ 全校验位的添加\n    | H8   | H7   | H6   | H5   | H4   | H3   | H2   | H1   |\n    | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n    | P全  | D4   | D3   | D2   | P3   | D1   | P2   | P1   |\n    | 1    | 1    | 0    | 1    | 0    | 0    | 1    | 0    |\n```java\n  由于海明校验码的检错能力是2位，纠错能力只有1位。因此在此基础上有添加了一个全校验位\n      全校验位对整体进行偶校验\n  使用：S3S2S1 = 000   且全体偶校验成功 --> 无错误\n       S3S2S1 != 000  且全体偶校验失败 --> 有1位错，纠正即可\n       S3S2S1 != 000  且全体偶校验成功 --> 有2位错，需要重传\n```\n### 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201220093343.png)\n\n## 4.3 循环冗余校验码(CRC码)\n\n* 思想：数据发送，接受约定一个“除数”。k个信息位+R个校验位作为“被除数”，添加校验位后需保证除法的余数为0。接收到数据后，进行除法检查余数是否为0.若余数非0说明出错，则进行重传或纠错。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201220093911.png)\n\n* 模2除运算：假设除数有4位，先取被除数的高四位，高四位的最高位为1则商1，然后对除最高位意外的三位数进行模2减运算，然后循环执行\n* 模2减运算：对相减的两个二进制数进行异或运算\n* 解题步骤 \n```java\n举例：设生成多项式为G(x) = x^3 + x^2 + 1,信息码为101001，求对应的CRC码。\n    1.确定K,R以及生成多项式对应的二进制码\n    \tK = 信息码的长度 = 6，\n    \tR = 生成多项式最高次幂 = 3\n    \t校验码位数 N = K + R =9\n    \t生成多项式G(x) = 1*x^3 + 1*x^2 + 0*x^1 + 1*x^0,对应二进制码1101\n    2.移位\n    \t信息码左移R位，低位补0。信息码：101001000\n    3.相除\n    \t对移位后的信息码，用生成多项式的二进制码进行模2除运算，产生余数001。计算步骤如下图\n      \t因此CRC码应为：101001 001\n    4.检错和纠错\n    \t发送：101001001 \n    \t接受：101001001 --> 用1101进行模2除 --> 余数为000，代表没有出错\n    \t发送：101001011 --> 用1101进行模2除 --> 余数为010，代表出错\n```\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201220094119.png)\n\n* 余数的值不能确定出错位，但对于确定的生成多项式，出错位与余数是相对应的\n* K个信息位，R个校验位，若生成多项式选择得当，且2^R >= K+R+1，则CRC码可纠正1位错\n* 实际应用中一般CRC码只用来检错\n* 理论上可以证明循环冗余校验码的检错能力有以下特点\n  * 可检测出所有奇数个错误\n  * 可检测出所有双比特的错误\n  * 可检测出所有小于等于校验位长度的连续错误\n# 第五节 定点数的表示\n\n定点数:小数点的位置固定。\n\n浮点数:小数点的位置不固定。\n\n## 5.1 无符号数\n\n* 整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。\n  * 例如：1001 1100转换成十进制数就是156\n* 表示范围：n位的无符号二进制数表示范围为0~(2^n) -1 \n  * 8位二进制数有2^8(256)个不同状态，可以表示0000 0000 ~ 1111 1111 的无符号二进制数。\n* 通常只有无符号整数，没有无符号小数。\n## 5.2 有符号数\n\n* 整个机器字长的第一位是符号位，其余为表示数值。\n  * 符号位表示正负，0表示整数，1表示负数\n* 原码：用位数表示真值的绝对值，符号位“0/1”对应“正/负”\n* 反码：对于正数，反码和原码相同。对于负数，反码是原码的符号位不变，数值位全部取反。\n* 补码：对于正数，补码和原码相同。对于负数，补码是反码加1（要考虑进位）。\n* 移码：在补码的基础上，将补码的符号位取反即是移码。\n  * <font color = \"red\" >移码只能表示整数</font>，不能表示小数\n  * 移码在计算机中常用来比大小\n  * 移码=真值+偏置值。偏置值一般取2^(n-1)；比如8位字长的偏置值为1000 0000。\n### 定点整数\n\n* 小数点在个位的后面隐藏，表示形式如下\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201220100147.png)\n* 原码形式\n  * 表示方式：[-19]原 = 1 001 0011 \n  ```java\n             符 6 5 4 3 2 1 0   假设机器字长为8位，\n  [+19]原 --> 0 0 0 1 0 0 1 1\n  [-19]原 --> 1 0 0 1 0 0 1 1\n  [+0]原  --> 0 0 0 0 0 0 0 0 \n  [-0]原  --> 1 0 0 0 0 0 0 0         \n  ```\n  * 表示范围：假设机字字长n+1位，-（2^n -1）<= x <= 2^n -1\n  * 真值0有+0和-0两种形式\n* 反码\n  ```java\n             符 6 5 4 3 2 1 0   假设机器字长为8位，\n  [+19]反 --> 0 0 0 1 0 0 1 1\n  [-19]反 --> 1 1 1 0 1 1 0 0\n  [+0]反  --> 0 0 0 0 0 0 0 0 \n  [-0]反  --> 1 1 1 1 1 1 1 1        \n  ```\n  * 表示范围：假设机字字长n+1位，-（2^n -1）<= x <= 2^n -1\n  * 真值0有+0和-0两种形式\n* 补码\n  ```java\n             符 6 5 4 3 2 1 0   假设机器字长为8位，\n  [+19]补 --> 0 0 0 1 0 0 1 1\n  [-19]补 --> 1 1 1 0 1 1 0 1\n  [+0]补 = [-0]补 --> 0000 0000\n  ```\n  * 表示范围：假设机字字长n+1位，-2^n <= x <= 2^n -1 （比原码多表示一个）\n  * 真值0只有一种表示形式\n  * 定点整数的补码[x]补=1000 000表示x=-2^7=-128\n* 移码\n  ```java\n             符 6 5 4 3 2 1 0   假设机器字长为8位，\n  [+19]移 --> 1 0 0 1 0 0 1 1\n  [-19]移 --> 0 1 1 0 1 1 0 1\n  [+0]移 = [-0]移 --> 1000 0000\n  ```\n  * 表示范围：假设机字字长n+1位，-2^n <= x <= 2^n -1 （比原码多表示一个）\n  * 真值0只有一种表示形式\n  * 定点整数的移码[x]移=0000 000表示x=-2^7=-128\n* 用几种码表示定点整数\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201220121818.png)\n### 定点小数\n\n* 小数点在符号位的后面隐藏，表示形式如下\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201220100240.png)\n* 原码\n    * 表示方式：[-0.75]原 = 1 110 0000\n    ```java\n                  符 -1 -2 -3 -4 -5 -6 -7   假设机器字长为8位，\n    [+0.75]原 -->  0  1  1  0  0  0  0  0 \n    [-0.75]原 -->  1  1  1  0  0  0  0  0 \n      [+0]原  -->  0  0  0  0  0  0  0  0 \n      [-0]原  -->  1  0  0  0  0  0  0  0               \n    ```\n    * 表示范围：假设机字字长n+1位，-(1-2^-n )<= x <= 1-2^-n \n    * 真值0有+0和-0两种形式\n* 反码\n    ```java\n                  符 -1 -2 -3 -4 -5 -6 -7   假设机器字长为8位，\n    [+0.75]反 -->  0  1  1  0  0  0  0  0 \n    [-0.75]反 -->  1  0  0  1  1  1  1  1 \n      [+0]反  -->  0  0  0  0  0  0  0  0 \n      [-0]反  -->  1吧  1  1  1  1  1  1  1   \n    ```\n    * 表示范围：假设机字字长n+1位，-（1-2^-n ）<= x <= 1-2^-n \n    * 真值0有+0和-0两种形式\n* 补码\n    ```java\n                  符 -1 -2 -3 -4 -5 -6 -7   假设机器字长为8位，\n    [+0.75]补 -->  0  1  1  0  0  0  0  0 \n    [-0.75]补 -->  1  0  1  0  0  0  0  0 \n    [+0]补 = [-0]补 --> 0000 0000\n    ```\n    * 表示范围：假设机字字长n+1位，-1<= x <= 1-2^-n （比原码多表示一个）\n    * 真值0只有一种表示形式\n    * 定点小数的补码[x]补=1000 000表示x=-1\n\n## 5.3 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201220122238.png)\n\n# 第六节 定点数的运算\n\n## 6.1 移位运算\n\n* 移位：通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用移位算法实现乘法，除法\n  * 二进制数x左移n位x后的值 = x*2^n\n  * 二进制数x右移n位x后的值 = x*2^-n\n  \n* 算术移位\n  * 算术移位：符号位保持不变，仅对数值位进行移位\n  * 原码\n    * 左移：低位补0，高位舍弃。若舍弃的一位 = 0，则相当于 除2；若舍弃的一位 != 0，则会丢失精度。\n    * 右移：高位补0，低位舍弃。若舍弃的一位 = 0，则相当于 乘2；若舍弃的一位 != 0，则会出现严重误差。\n  * 反码\n    * 正数的反码算术移位和原码的算术移位相同\n      * 左移：低位补0，高位舍弃。右移：高位补0，低位舍弃。\n    * 负数的反码算术移位和原码的算术移位相反\n      * 左移：低位补1，高位舍弃。右移：高位补1，低位舍弃。\n  * 补码\n    * 正数的补码算术移位和原码的算术移位相同\n      * 左移：低位补0，高位舍弃。右移：高位补0，低位舍弃。\n    * 负数的补码的算术移位则不一样\n      * 规律：负数补码中，以最右边的1为界限，其右边的和原码相同，其左边的和反码相同\n      * 左移：低位补0，高位舍弃。右移：高位补1，低位舍弃。\n\n  ### 总结\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201220144822.png)\n\n* 逻辑移位\n  * 与算术移位的区别：符号位也移位。可以看作是对无符号数的移位\n  * 逻辑右移：高位补0，低位舍弃\n  * 逻辑左移：低位补0，高位舍弃\n  \n* 循环移位\n  * 循环左移：将高位的数补在低位数上。循环右移：将低位的数补在高位上。\n  * 带进位位的循环左移：将进位位上的数补在低位上，然后将高位的数放在进位位上。右移类似\n  \n  总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201220150609.png)\n\n## 6.2 加减运算和溢出判断\n\n* 原码用于加减运算时，硬件实现太难，因此常常用补码来实现加减运算。\n* 加法运算\n  * 和十进制加法类似，有进位。要注意溢出。\n* 减法运算\n  * 先将减号右边的数由正转换成负，由负转换成正，以此来消除减号。这样可以将减法运算转换成加法运算。要注意溢出。\n  * 形如：x-y =[x]补+[y]补 \n```java\n设机器字长为8位(含一位符号位)，A=15,B=-24,求[A+B]补和[A-B]补。\n        原码           补码\n A = 0 000 1111 --> 0 000 1111\n B = 1 001 1000 --> 1 110 1000\n-B = 0 001 1000 --> 0 001 1000\n[A+B]补 = [A]补 + [B]补 = 0 000 1111 + 1 110 1000 = 1 111 0111 = -9  A+8=-9\n[A-B]补 = [A]补 - [B]补 = [A]补 + [-B]补 = 0 000 1111 + 0 001 1000 = 0 010 0111 = +39   A-B=+39 \n```\n* 溢出判断 \n  * 溢出：指两各二进制数相加后，结果超出二进制数所能表示的范围。\n  * 上溢：指结果大于范围的最大值。只有\"正数+正数\"才会上溢 -->  \"正+正 = 负\"\n  * 下溢：指结果小于范围的最小值。只有\"负数+负数\"才会下溢 -->  \"=负+负 = 正\"\n  ```java\n  设机器字长为8位(含一位符号位)，A=15,B=-24,C=124,求[A+C]补和[B-C]补。\n  [A+C]补 = 0 000 1111 + 0 111 1100 = 1 000 1011  =-117  而A+C=138，因此发生了上溢 \n  [B-C]补 = 1 110 1000 + 1 000 0100 = 0 110 1100  =+108  而B-C=-148，因此发生了下溢\n  ```\n  * 判断方法一：采用一位符号位\n    * 设A的符号位时Sa，B 的符号位是Sb，结果的符号位是Ss,\n    * 则溢出逻辑表达式为： V = ( SaSb(!Ss) ) + ( (!Sa)(!Sb)Ss )。( (Sa & Sb & !Ss )|| (!Sa & !Sb & Ss) ) \n      * &表示都是为真才为真。||表示有一个为真即为真。!表示取反，即0变为1，1变为0。\n    * 若V=0，表示无溢出。若V=1，表示溢出。\n    ```java\n    上述的[A+C]补的操作的溢出判断：V = (0 & 0 & !1) ||(!0 & !0 & 1) = (0 & 0 & 0)||(1 & 1 & 1) = 0 || 1 = 1\n    上述的[B-C]补的操作的溢出判断：V = (1 & 1 & !0) ||(!1 & !1 & 0) = (1 & 1 & 1)||(0 & 0 & 0) = 1 || 0 = 1\n    ```\n  * 判断方法二：采用一位符号位，根据数据进位情况判断溢出\n    * 设计算时符号位的进位为S1，数值位的最高位的进位情况为S2。\n    * 溢出逻辑表达式为：V = S1 ⊕ S2。V=1时表示溢出。\n    * 则当S1=0,S2=1时为上溢。当S1=1,S2=0时为下溢。\n    ```java\n    上述的[A+C]补的操作的溢出判断： 符号位的进位为0，数值位的最高位的进位为1，因此为上溢\n    上述的[B-C]补的操作的溢出判断： 符号位的进位为1，数值位的最高位的进位为0，因此为下溢\n    ```\n  * 判断方法三：采用双符号位，正数符号位为00，负数符号位为11。\n    * 设结果的两个符号位分别为S1,S2。则溢出判断：V = S1 ⊕ S2。V=1时表示溢出。\n    * 结果的符号位为 01 时表示上溢。结果的符号位为 10 时表示下溢。\n\n    ```java\n    [A+C]补 = 00 000 1111 + 00 111 1100 = 01 000 1011  符号位为01，表示上溢\n    [B-C]补 = 11 110 1000 + 11 000 0100 = 10 110 1100  符号位为10，表示下溢\n    ```\n* 小知识\n  * 双符号位补码又称：模4补码。单符号位补码又称：模2补码。\n  * 双符号位虽然有两个符号位，但实际存储时只存储一个符号位，运算时会复制一个符号位。\n* 符号扩展：比如8位二进制数扩展成16位二进制数\n  * 定点整数的符号扩展：在原符号位和数值位<font color=\"red\">中间</font>添加新位。正数都添0；负数原码添0，负数反，补码添1。\n  * 定点小数的符号扩展：在数值位的<font color=\"red\">后面</font>添加新位。正数都添0；负数原，补 添0，负数反码添1。\n### 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201220160802.png)\n\n## 6.3 乘法运算\n\n### 原码的乘法运算\n\n* 设机器字长为n+1=5位(含一位符号位)，[x]原=1 1101，[y]原=0 1011,采用原码一位乘法求x*y。\n* 手算方式\n```java\n 符号位分别位1，0,则结果的符号位为1⊕0 = 1。数值位取绝对值进行乘法运算\n \t\t1101\n      * 1011\n     --------\n        1101\n       1101\n      0000\n     1101\n  -----------   \n    10001111\n   加上符号位结果为1 1000 1111\n```\n* 运算规则： \n  * 符号位单独运算，结果为两个加数的符号位的异或值。符号位不参与下面运算。\n  * 数值位进行n轮加法，移位。\n  * 每次加法可能是+0，+[x]原。根据当前MQ中的最低位来确定加什么。\n    * MQ中最低位=1时，(ACC)+[x]原。\n    * MQ中最低位=0时，(ACC)+0。\n  * 每次移位是原码数值位 的逻辑右移。\n  * 将数值位的运算结果加上符号位的运算结果\n* 计算机运算方式\n  * 运算器的组成部分：ACC:存放乘积高位。MQ：存放乘数，乘积的低位。X：存放被乘数。\n  ```java\n  1.情况:ACC：00000。MQ：01011。X：01101。\n      判断MQ最后一位为1，ACC加一次X，然后ACC和MQ整体逻辑右移一位,将ACC高位补0，右移出的一位数补在MQ的高位上\n  2.情况:ACC：00110。MQ：10101。X：01101。\n      判断MQ最后一位为1，ACC加一次X，然后ACC和MQ整体逻辑右移一位,将ACC高位补0，右移出的一位数补在MQ的高位上\n  3.情况:ACC：01001。MQ：11010。X：01101。\n      判断MQ最后一位为0，ACC加0，然后ACC和MQ整体逻辑右移一位,将ACC高位补0，右移出的一位数补在MQ的高位上\n  4.情况:ACC：00100。MQ：11101。X：01101。\n      判断MQ最后一位为1，ACC加一次X，然后ACC和MQ整体逻辑右移一位,将ACC高位补0，右移出的一位数补在MQ的高位上\n  5.情况:ACC：01000。MQ：11110。X：01101。\n      判断MQ最后一位为符号位时，结束运算\n  最终：根据ACC和MQ的数据得出结果位0 1000 1111。其中第一个0是符号位。\n      由符号位单独计算得出符号位为1。因此最终结果为1 1000 1111。和手算结果相同\n  ```\n  * 手写的步骤样式为：\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201220162209.png)\n  * 总结：符号位通过异或确定；数值部分通过被乘数和乘数绝对值的n轮加法，移法完成根据当前乘法中参与运算的位确定ACC加什么。若当前运算位=1，则ACC+[x]原；若运算位=0，则ACC+0。每轮加法后ACC，MQ的内容统一逻辑右移。\n\n### 补码的乘法运算\n\n* 设机器字长为n+1=5位(含一位符号位)，[x]原=-1101，[y]原=+1011,采用原码一位乘法求x*y。\n* 运算规则：与原码的运算规则类似，但有一定的区别。\n  * 进行n轮加法，移位。最后再多来一次加法\n  * 每次加法可能是+0，+[x]补，+[-x]补。根据当前MQ中的最低位和辅助位来确定加什么。\n    * 辅助位-MQ中最低位=1时，(ACC)+[x]补。\n    * 辅助位-MQ中最低位=0时，(ACC)+0。\n    * 辅助位-MQ中最低位=-1时，(ACC)+[-x]补。\n  * 每次移位是补码的<font color=\"red\">算术右移</font>\n    * 算术右移时，ACC和MQ当成一个整体，ACC的前两位符号位不移动，然后ACC的后n位和MQ的所有位都右移一位。ACC会补一位数。正数补1，负数补0。\n  * 符号位不单独运算，而是参与运算。\n  * 运算结果为ACC的数拼接上MQ中存放的前n位数\n* 计算机运算方式\n  * 运算器的组成部分：ACC:存放乘积高位。MQ：存放乘数，乘积的低位。X：存放被乘数。\n  * 特别的，ACC,X,MQ的位数都是n+2位。其中ACC,X中存放的是双符号位；MQ存放的是单符号位，但MQ的最后一位是辅助位，辅助位默认位0 。MQ中辅助位前面的那一位是MQ中的最低位。\n  ```java\n  [x]补=11 0011，[-x]补=00 1101，[y]补=00 1011\n  1.情况:ACC：00 0000。MQ：0 1011 0。X：11 0011。\n      判断MQ的辅助位-最低位 = 0-1=-1，ACC+[-x]补，然后将ACC和MQ整体算术右移一位，MQ 的最低位移到MQ中的辅助位上。\n  2.情况:ACC：00 0110。MQ：1 0101 1。X：11 0011。\n      判断MQ的辅助位-最低位 = 1-1=0，ACC+0，然后将ACC和MQ整体算术右移一位，MQ 的最低位移到MQ中的辅助位上。\n  3.情况:ACC：00 0011。MQ：0 1010 1。X：11 0011。\n      判断MQ的辅助位-最低位 = 1-0=1，ACC+[x]补，然后将ACC和MQ整体算术右移一位，MQ 的最低位移到MQ中的辅助位上。\n  4.情况:ACC：11 1011。MQ：0 0101 0。X：11 0011。\n      判断MQ的辅助位-最低位 = 0-1=-1，ACC+[-x]补，然后将ACC和MQ整体算术右移一位，MQ 的最低位移到MQ中的辅助位上。    \n  5.情况:ACC：00 0100。MQ：0 0010 1。X：11 0011。\n     最后在额外加执行一次加法。判断MQ的辅助位-最低位 = 1-0=1，ACC+[x]补。不移位\n  6.情况:ACC：11 0111。MQ：0 0010 1。X：11 0011。  \n     结果位ACC的数拼接上MQ的前n位,即[x*y]补 = 11 0111 0001 = -0111 0001\n  ```\n  * 手写的步骤样式为：\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201220163015.png)\n\n## 6.4 除法运算\n\n### 原码的除法运算\n\n*  设机器字长为n+1=5位(含一位符号位)，[x]原=0.1011，[y]原=0.1101,采用原码除法求x/y。\n* 运算器的组成部分：ACC:存放被除数和余数。MQ：存放乘数，乘积的低位。X：存放被乘数。\n* 恢复余数法运算规则：\n  * 符号位单独运算，结果为两个加数的符号位的异或值。符号位不参与下面运算。\n  * 数值位进行上商判断\n    * 先让商为1时，然后执行被除数 - 除数，判断求得的值是正是负。\n    * 当值是正时，则确定商1；\n    * 当值是负时，先让 值+ 除数，得到被除数，然后商0，在执行被除数-0。\n  * 然后进行逻辑左移。\n  * 总共得到n+1位商即可结束判断和移位。\n  * 运算结果：将符号位和商像拼接得结果。\n* 恢复余数法计算机运算过程\n  * 运算器的组成部分：ACC:存放被除数和余数。MQ：存放商。X：存放除数。\n  * MQ 的最后一位是每次商的位置\n  ```java\n  符号位单独运算：0⊕0=0\n  [|x|]=01011，[|y|]=01101，[|y|]补=01101,[-|y|]补=10011\n  1.情况:ACC：01011。MQ：0000 0。X：01101。\n      先尝试商1，然后执行ACC-X。得ACC：11110。MQ：0000 1。\n     \t\t由于ACC的符号位为1，是负数，因此先恢复数据，让ACC+X，得ACC：01011。MQ：0000 0。\n      然后商0，执行ACC-0。得ACC：01011。MQ：0000 0。\n      \t结果ACC值大于0，因此确定商为0。\n      在执行逻辑左移，将ACC和MQ整体左移，ACC的高位丢弃，MQ的低位补0，MQ的高位补上ACC的低位。\n  2.情况:ACC：10110。MQ：0000 0。X：01101。\n      先尝试商1，然后执行ACC-X。得ACC：01001。MQ：0000 1。\n      \t结果ACC值大于0，因此确定商为1。\n      在执行逻辑左移，将ACC和MQ整体左移，ACC的高位丢弃，MQ的低位补0，MQ的高位补上ACC的低位。    \n  3.情况:ACC：10010。MQ：0001 0。X：01101。\n      先尝试商1，然后执行ACC-X。得ACC：00101。MQ：0001 1。\n      \t结果ACC值大于0，因此确定商为1。\n      在执行逻辑左移，将ACC和MQ整体左移，ACC的高位丢弃，MQ的低位补0，MQ的高位补上ACC的低位。\n  4.情况:ACC：01010。MQ：0011 0。X：01101。\n      先尝试商1，然后执行ACC-X。得ACC：11101。MQ：0011 1。\n      由于ACC的符号位为1，是负数，因此先恢复数据，让ACC+X，得ACC：01010。MQ：0011 0\n      然后商0，执行ACC-0。得ACC：01010。MQ：0011 0。\n      结果ACC值大于0，因此确定商为0。\n      在执行逻辑左移，将ACC和MQ整体左移，ACC的高位丢弃，MQ的低位补0，MQ的高位补上ACC的低位。\n  5.情况:ACC：10100。MQ：0110 0。X：01101。\n      先尝试商1，然后执行ACC-X。得ACC：00111。MQ：0110 1。\n      \t结果ACC值大于0，因此确定商为1。\n      最后一次不移位。\n  6.情况:ACC：00111。MQ：0110 1。X：01101。 \n      最终结果的商为MQ的值，01101，由于符号位运算结果为0，\n      则最终[x/y] = 0.1101,余数的值为ACC的值，为0.0111\n  ```\n* 恢复余数法的手写图示\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201221150247.png)\n* 加减交替法运算规则\n  * 符号位单独运算，结果为两个加数的符号位的异或值。符号位不参与下面运算。\n  * 数值位执行以下操作\n    * 先将被除数-除数，得余数，然后对余数执行下面的循环判断\n      * 若余数为负，则直接商0，再让余数左移一位，然后 + 除数，得到下一个余数。\n      * 若余数为正，则直接商1，再让余数左移一位，然后 - 除数，得到下一个余数。\n  * 当得到n+1为位的商时结束操作，将商和符号位的结合即是结果。\n  * 对于最后一次得到的余数：\n    * 若余数的符号位和商的符号位相同，则不做处理。\n    * 若余数的符号位和商的符号位不同：\n      * 若余数为负，则余数 + 除数 = 真正的余数。\n      * 若余数为正，则余数 - 除数 = 真正的余数。\n* 加减交替法的手写图示\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201221150333.png)\n### 补码的除法运算\n\n* 加减交替法运算法则：和原码的加减交替法类似\n  * 符号位参与运算，被除数，余数，除数都采用双符号位\n  * 第一步：被除数和除数同号，则被除数 - 除数；异号则被除数 + 除数。求得一个余数。\n  * 然后循环判断：重复n次\n    * 若余数和除数同号，则商1，余数左移一位，然后余数 - 除数\n    * 若余数和除数异号，则商0，余数左移一位，然后余数 + 除数\n  * 对于第n+1位商，我们都强制让它置为1。\n* 加减交替法的手写图示\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201221150827.png) \n\n### 除法总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201221150753.png)\n\n# 第七节 浮点数的表示\n\n* 科学计数法：形如 M *10^E。其中M一般是1.几，E表示数的阶位。\n* 计算机中浮点数的表示方法和科学计数法类似：M * 2^E。例如 \n* 阶码(E)：常用补码 或移码表示的定点整数。尾数(M)：常用原码或补码表示的定点小数。\n  * 对于一个8位字长的存储空间，用前三位表示阶码，后五位表示尾数，其中前三位的第一位表示阶码的符号位，后五位的第一位表示尾数的符号位。 \n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222094123.png)\n  * 阶码E反映浮点数的表示范围及小数点的实际位置；尾数M的数值部分的位数n反映浮点数的精度。\n* 规格化浮点数 ：规定浮点数的尾数的最高位数值位必须是一个有效数值(二进制数的有效数是1)。\n  * 左规：当浮点数运算的结果位<font color=\"red\">非规格化</font>时，要进行规格化处理，将尾数算术左移一位，阶码减1。\n    * 例如 2^2*0.01001 左规为 2^1 * 0.1001。\n  * 右规：当浮点数运算的结果尾数<font color=\"red\">出现溢出(双符号位为01或10)时</font>，将尾数算术右移一位，阶码加1。\n    * 例如2^2 * 01.0100 右规为 2^3 * 00.1010。\n* 规格化浮点数的特点\n  * 用原码表示的尾数进行规格化\n    * 正数为0.1xxx的形式，其最大值表示为0.11..1；最小值为0.10..0。尾数的表示范围为：1/2<=M<=(1-2^(-n))。\n    * 负数为<font color=\"red\">1.1xxx</font>的形式，其最大值表示为1.10..0；最小值为1.11..1。尾数的表示范围为：-(1-2^(-n))<=M<=-1/2。\n  * 用补码表示的尾数进行规格化\n    * 正数为0.1xxx的形式，其最大值表示为0.11..1；最小值为0.10..0。尾数的表示范围为：1/2<=M<=(1-2^(-n))。\n    * 负数为<font color=\"red\">1.0xxx</font>的形式，其最大值表示为1.01..1；最小值为1.00..0。尾数的表示范围为：-1<=M<=-(1/2+2^-n)。\n    * 补码算术左移，低位补0，补码算术右移，高位补1。\n* **总结**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222095416.png)\n\n## 7.1 IEEE 754标准\n\n* 对移码的定义：移码 = 真值+偏置值。偏置值设定为2^(n-1)-1。 n为阶码的位数\n* 对于8位字长的数据，偏置值=127=0111 1111。\n  * 例如：真值 -128 = -1000 0000。移码 = -1000 0000 + 0111 1111 = 1111 1111。\n  * 例如：真值 -127 = -0111 1111。移码 = -0111 1111 + 0111 1111 = 0000 0000。\n* 标准规定的存储形式如下\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222095943.png)\n  \n  | 类型                    | 数符 | 阶码 | 尾数数值 | 总位数 | 偏置值 |\n  | ----------------------- | ---- | ---- | -------- | ------ | ------ |\n  | 短浮点数(float)         | 1    | 8    | 23       | 32     | 127    |\n  | 长浮点数(double)        | 1    | 11   | 52       | 64     | 1023   |\n  | 临时浮点数(long double) | 1    | 15   | 64       | 80     | 16383  |\n  * 说明：\n    * 由于原码尾数的规格化，实际尾数位隐藏了一个最高位表示1；尾数的实际值是1.M\n    * 对于8位阶码，移码的全1和全0 用于特殊用途，因此阶码的真值的取值范围是-126~127\n    * 对于短浮点数的真值是：(-1)^s * 1.M * 2^(E-127)\n  * 单精度浮点数的最小绝对值为：1.0B * 2^-126；最大绝对值为：1.11..1B * 2^127。\n  * 特殊情况：\n    * 当阶码E全为0，尾数M不全为0时，表示非规格化小数 ：+-（0.xxx..x）B * 2^-126。\n      * 注意：隐含高位是0，不再是1；阶码固定为-126。\n    * 当阶码E全为0，尾数M全为0时，表示真值+0或-0。\n    * 当阶码E全为1，尾数M全为0时，表示无穷大：正无穷或负无穷。\n    * 当阶码E全为1，尾数M不全为0时，表示非数值“NaN”。\n      * 当计算0/0等非法运算的结果就是NaN。\n* 例题\n  ```java\n  将十进制数-0.75转换成IEEE 754的单精度浮点数格式。\n   (-0.75)D = (-0.11)B = (-1.1)B*2^-1\n     数符 = 1\n     尾数部分 = .10000..（隐含最高位1）\n     阶码真值 = -1\n     单精度浮点型偏置值 = 127\n     移码 = 阶码真值 + 偏置值 = -1 + 0111 1111 = 0111 1110B\n     -->1 01111110 100 0000 0000 0000 0000 0000B\n  IEEE754的单精度浮点数C0 A0 00 00H的值是多少？\n     C0 A0 00 00H --> 1100 0000 1010 0000 0000 0000 0000 0000B\n     数符 = 1 -->是个负数\n     尾数部分 = .0100..(隐含最高位1) -->尾数真值 = 1.01B\n     移码 = 1000 0001\n     单精度浮点型偏置值 = 127D\n     阶码真值 = 移码 - 偏置值 = 1000 0001 - 0111 1111 = 0000 0010B = 2D\n     -->浮点数真值 = (-1.011)B * 2^2 = -1.25*2^2 = -5.0\n  ```\n# 第八节 浮点数的运算\n\n## 8.1  加减运算\n\n* 运算步骤\n  * (这步有时可以省略)转换格式：将十进制数转换成二进制补码形式\n  * 对阶：要求运算的两个数的阶码相同。不同时，小阶像大阶看起，尾数右移一位，阶码加1。\n    * 求阶差：通过x,y的阶码相减，根据差值判断哪个大。\n    * 对阶：将小阶像大阶对其。\n  * 尾数加减：正常的对尾数进行加减。\n  * 规格化：对加减后的尾数按照规格化的定义进行左规或右规。\n  * 舍入：按照不同的规则取舍有效位数。\n  * 判溢出：对阶码进行判断，然后通过左移或右移将阶码符合规定。\n* 浮点数运算，十进制版\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222102702.png)\n* 浮点数运算，二进制版 \n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222103510.png)\n* 浮点数的舍入\n  * “0”舍“1’入法:类似于十进制数运算中的“四舍五入”法，即在尾数右移时，被移去的最高数值位为0，则舍去;被移去的最高数值位为1，则在尾数的末位加1。这样做可能会使尾数又溢出，此时需再做一次右规。\n  * 恒置“1”法:尾数右移时，不论丢掉的最高数值位是‘1’ 还是‘0'都使右移后的尾数末位恒置“1”。这种方法同样有使尾数变大和变小的两种可能。\n\n### 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222104220.png)\n\n## 8.2 算术逻辑单元(ALU)\n\n### 一位全加器\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222105330.png)\n\n### 串行加法器\n\n* 串行加法器:只有-一个全加器，数据逐位串行送入加法器中进行运算。进位触发器用来寄存进位信号，以便参与下一次运算。\n* 如果操作数长n位，加法就要分n次进行，每次产生一位和，并且串行逐位地送回寄存器。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222105436.png)\n\n### 并行加法器\n\n* 串行进位的并行加法器:把n个全加器串接起来，就可进行两个n位数的相加。\n* 串行进位又称为行波进位，每一级进位直接依赖于前一-级的进位，即进位信号是逐级形成的。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222105534.png)\n\n### 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201222105226.png)\n\n## 8.3 算术逻辑单元的改进\n\n","categories":["计算机组成系统"]},{"title":"第一章-计算机系统概述","url":"/2020/12/19/计算机组成原理/第一章-计算机系统概述/","content":"\n计算机的概念，硬件部分，层次结构。性能指标\n<!--more-->\n\n# 第一节：计算机概述\n\n## 冯.诺伊曼计算机的特点\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219140232.png)\n\n​\t1.计算机由五 大部件组成\n\n​\t2.指令和数据以同等地位存于存储器，可按地址寻访\n\n​\t3.指令和数据用二进制表示\n\n​\t4.指令由操作码和地址码组成\n\n5. 存储程序\n6. 以运算 器为中心（输入/输出设备与存储器之间的数据传送通过运算器完成）\n\n## 现代计算机结构\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219140555.png)\n\n## 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219140620.png)\n\n# 第二节：硬件部件\n\n## 2.1主存储器的基本组成\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219150542.png)\n\nMemory Address Register(存储地址寄存器)：MAR位数反映存储单元的个数\n\nMemory Data Register(存储数据寄存器)：MDR位数=存储字长\n\n数据在存储体内按地址存储。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219150702.png)\n\n**存储单元**:  每个存储单元存放一-串二进制代码。\n\n**存储字(word)**:  存储单元中二进制代码的组合。\n\n**存储字长**:  存储单元中二进制代码的位数。\n\n**存储元：**即存储二进制的电子元件，每个存储元可存1bit。\n\n## 2.2 运算器的基本组成\n\n![运算器](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219151933.png)\n\n**运算器**:  用于实现算术运算(如:加减乘除)、逻辑运算(如:与或非)\n\n**ACC**:  累加器，用于存放操作数，或运算结果。\n\n**MQ**:  乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。\n\n**X**:  通用的操作数寄存器，用于存放操作数\n\n**ALU**:  算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219152051.png)\n\n## 2.3 控制器的基本组成\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219152143.png)\n\n**CU**:  控制单元，分析指令，给出控制信号\n\n**IR**:  指令寄存器，存放当前执行的指令\n\n**PC**:  程序计数器，存放下- -条指令地址，有自动加1功能\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219152248.png)\n\n## 2.4 计算机的工作过程\n\n题目：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219152401.png)\n\n第一步：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219152525.png)\n\n第二步：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219152919.png)\n\n第三步：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219152923.png)\n\n第四步：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219152928.png)\n\n第五步：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219152933.png)\n\n## 2.5 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219153044.png)\n\n# 第三节 计算机系统的层次结构\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219153930.png)\n\n## 3.1 三种级别的语言\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219154137.png)\n\n**编译程序**:将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序( 只需翻译一次)。\n\n**解释程序**:将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一-句(每次执行都要翻译)。\n\n## 3.2 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219154251.png)\n\n# 第四节 性能指标\n\n## 4.1 存储器的性能指标\n\n**总容量**=存储单元个数\\*存储字长bit =存储单元个数*存储字长/8 Byte\n\nEg: MAR为32位，MDR为8位 ：总容量= 232*8bit = 4GB。\n\n## 4.2 CPU的性能指标\n\n**CPU主频**: CPU内 数字脉冲信号振荡的频率。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219160119.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219160046.png)\n\n**CPI**(ClockcyclePerInstruction):执行一条指令所需的时钟周期数。\n\n不同的指令，CPI不同。甚至相同的指令，CPI也可能有变化。\n\n**执行一条指令的耗时**=CPI*CPU时钟周期。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219160239.png)\n\n**CPU执行时间( 整个程序的耗时)** =CPU时钟周期数/主频= (指令条数*CPI) /主频。\n\n**IPS** ( Instructions Per Second )：每秒执行多少条指令。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219160415.png)\n\n**FLOPS** ( Floating-point Operations Per Second )：每秒执行多少次浮点运算。\n\n## 4.3 系统整体的性能指标\n\n**数据通路带宽**:数据总线一-次所能并行传送信息的位数(各硬件部件通过数据总线传输数据)。\n\n**吞吐量**:指系统在单位时间内处理请求的数量。\n\n它取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。\n\n**响应时间**:指从用户向计算机发送一一个请求， 到系统对该请求做出响应并获得它所需要的结果的等待时间。\n\n通常包括CPU时间(运行-一个程序所花费的时间)与等待时间(用于磁盘访问、存储器访问、/O操作、操作系统开销等时间)。\n\n## 4.4 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219155811.png)","categories":["计算机组成系统"]},{"title":"第七章-输入输出系统","url":"/2020/12/19/计算机组成原理/第七章-输入输出系统/","content":"\nIO的概念，外部设备，IO接口，程序查询方式，中断，中断的 处理，DMA控制器，\nDMA方式与中断\n<!--more-->\n# 第一节：I.O系统基本概念\n\n## 1.1 基本概念\n\n**I/0接口**:又称I/0控制器(I/O Controller)、设备控制器，负责协调主机与外部设备之间的数据传输\n\n一般来说，I/0系统由I/0软件和I/O硬件两部分构成。\n\n​\t1. I/O硬件包括外部设备、I/O接口、I/O总 线等。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218131255.png)\n\n2. I/O软件包括驱动程序、用户程序、管理程序、升级补丁等。通常采用I/O指令和通道指令实现主机和I/O设备的信息交换。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218131346.png)\n\n注: I/0 指令与普通指令格式略有不同，操作码指明了CPU要对I0接口做什么，命令码指明了I0接口要对设备做什么.\n\n## 1.2 I/O控制方式\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218130410.png)\n\nCPU如何控制键盘I/O的完成?\n\n​\t\t1)程序查询方式: CPU不断轮 询检查I/O控制器中的“状态寄存器”，检测到状态为“已完成”之后，再从数据寄存器取出输入数据。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218130736.png)\n\n​\t\t2)程序中断方式:等待键盘I/O时CPU可以先去执行其他程序，键盘I/0完成后I/O控制器向CPU发出中断请求，CPU响应中断请求，并取走输入数据\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218130739.png)\n\n​\t\t3)DMA控制方式:主存与高速I/O设备之间有- - 条直接数据通路(DMA总线)。CPU向DMA接口发出“读/写”命令，并指明主存地址、磁盘地址、读写数据量等参数。\n\nDMA控制器自动控制磁盘与主存的数据读写，每完成- - 整块数据读写(如1KB为一整块)，才向CPU发出一次中断请求。\n\n注: DMA接口，即DMA控制器p也是-种特殊的I/O控制器\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218130743.png)\n\n​\t\t4)通道:可以理解为是“弱鸡版的CPU”。 通道可以识别并执行- -系列通道指令，通道指令种类、功能通常比较单--。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218131053.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218131619.png)\n\n# 第二节：外部设备\n\n外部设备也称外围设备，是除了主机以外的、能直接或间接与计算机交换信息的装置。\n\n输入设备：用于向计算机系统输入命令和文本、数据等信息的部件。键盘和鼠标是最基本的输入设备。\n\n输出设备：用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。显示器和打印机是最基本的输出设备。\n\n外存设备：是指除计算机内存及CPU缓存等以外的存储器。硬磁盘、光盘等是最基本的外存设备。\n\n## 2.1输入设备\n\n**键盘**\n\n![键盘](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218133449.png)\n\n**鼠标**\n\n![鼠标](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218133516.png)\n\n## 2.2输出设备\n\n**显示器**\n\n按显示设备所用的显示器件分类:阴极射线管(CRT)显示器；液晶显示器(LCD)；LED显示器等等。\n\n按所显示的信息内容分类:字符显示器；图形显示器；图像显示器。\n\n屏幕大小：以对角线长度表示，常用的有12~29英寸等。\n\n分辨率：所能表示的像素个数，屏幕上的每一一个光点就是一个像素，以宽、高的像素的乘积表示，例如，800x600、1024x 768和1280x1024等。\n\n灰度级：灰度级是指黑白显示器中所显示的像素点的亮暗差别，在彩色显示器中则表现为颜色的不同，灰度级越多，图像层次越清楚逼真，典型的有8位(256级)、16位等。n位可以表示2\"种不同的亮度或颜色。\n\n刷新：光点只能保持极短的时间便会消失，为此必须在光点消失之前再重新扫描显示一遍，这个过程称为刷新。刷新频率:单位时间内扫描整个屏幕内容的次数，按照人的视觉生理，刷新频率大于30Hz时才不会感到闪烁，通常显示器刷新频率在60~ 120Hz。\n\n显示存储器( VRAM)：也称刷新存储器，为了不断提高刷新图像的信号，必须把- -帧图像信息存储在刷新存储器中。其存储容量由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量越大。\n\n​\t\t<font color=\"red\">VRAM容量=分辨率X灰度级位数</font>\n\n​\t\t<font color=\"red\">VRAM带宽=分辨率X灰度级位数X帧频</font>\n\n例如：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218134036.png)\n\n阴极射线管(CRT)：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218134243.png)\n\n液晶显示器(LCD)：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218134335.png)\n\nLED显示器：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218134340.png)\n\n阴极射线管显示器按显示内容不同可分为：\n\n字符显示器：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218134550.png)\n\n图形显示器：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218134554.png)\n\n图像显示器：\n\n**打印机**\n\n打印机是计算机的输出设备之一一，用于将计算机处理结果打印在相关介质上。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218134656.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218134758.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218134802.png)\n\n## 2.3外存设备\n\n计算机的外存储器又称为辅助存储器，目前主要使用磁表面存储器。\n\n所谓“磁表面存储”，是指把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218173028.png)\n\n一次只能读取1字节的数据。\n\n磁表面存储器的优点:\n\n​\t\t①存储容量大，位价格低;\n\n​\t\t②记录介质可以重复使用;\n\n​\t\t③记录信息可以长期保存而不丢失，甚至可以脱机存档;\n\n​\t\t④非破坏性读出，读出时不需要再生。\n\n磁表面存储器的缺点: \n\n​\t\t①存取速度慢;\n\n​\t\t②机械结构复杂;\n\n​\t\t③对工作环境要求较高。\n\n外存储器既可以作为输入设备，也可以作为输出设备。(既可以存数据，也可以读数据)\n\n### 磁盘设备的组成\n\n**存储区域**\n\n一块硬盘含有若干个记录面，每个记录面划分为若干条磁道，而每条磁道又划分为若干个扇区，扇区( 也称块)是磁盘读写的最小单位，也就是说磁盘按块存取。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218173436.png)\n\n**硬盘存储器**\n\n硬盘存储器由磁盘驱动器、磁盘控制器和盘片组成。\n\n磁盘驱动器: 核心部件是磁头组件和盘片组件，温彻斯特盘是-种可移动头固定盘片的硬盘存储器。\n\n磁盘控制器: 是硬盘存储器和主机的接口，主流的标准有IDE、SCSI、 SATA等。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218173659.png)\n\n### 磁盘的性能指标\n\n**磁盘的容量**\n\n一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。\n\n​\t\t非格式化容量：是指磁记录表面可以利用的磁化单元总数。\n\n​\t\t\t格式化容量：是指按照某种特定的记录格式所能存储信息的总量。\n\n**记录密度**\n\n记录密度：是指盘片单位面积上记录的二进制的信息量，通常以道密度、位密度和面密度表示。\n\n​\t\t道密度是沿磁盘半径方向单位长度上的磁道数;\n\n​\t\t位密度是磁道单位长度上能记录的二进制代码位数;\n\n​\t\t面密度是位密度和道密度的乘积。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218174015.png)\n\n注意:磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故每个磁道的位密度都不同。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218174017.png)\n\n**平均存取时间**\n\n平均存取时间=寻道时间(磁头移动到目的磁道) +旋转延迟时间(磁头定位到所在扇区) +传输时间(传输数据所花费的时间)。\n\n旋转延迟时间：当题目中不给出时采用旋转半圈的时间当旋转延迟时间。\n\n有的题目会加上磁盘控制器延迟。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218174124.png)\n\n**数据传输率**\n\n磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。\n\n假设磁盘转数为r (转/秒)，每条磁道容量为N个字节，则数据传输率为D,=rN。\n\n### 磁盘地址\n\n主机向磁盘控制器发送寻址信息，磁盘的地址一般如图所示:\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218174634.png)\n\n若系统中有4个驱动器，每个驱动器带-一个磁盘， 每个磁盘256个磁道、16个盘面，每个盘面划分为16个扇区，则每个扇区地址要18位二进制代码;\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218174650.png)\n\n### 硬盘的工作过程\n\n硬盘的主要操作是寻址、读盘、写盘。每个操作都对应-一个控制字，硬盘工作时，第-一步是取控制字，第二步是执行控制字。\n\n硬盘属于机械式部件，其读写操作是串行的，不可能在同一-时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。\n\n### 磁盘阵列\n\nRAID ( Redundant Array of Inexpensive Disks,廉价冗余磁盘阵列)是将多个独立的物理磁盘组成-一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。\n\nRAID的分级如下所示。在RAID1 ~ RAID5的几种方案中，无论何时有磁盘损坏，都可以随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏。\n\nRAIDO:无冗余和无校验的磁盘阵列。\n\n​\t\t\t逻辑上相邻的两个扇区在物理.上存到两个磁盘，类比第三章“低位交叉编址的多体存储器”\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218174931.png)\n\nRAID1:镜像磁盘阵列。存两份数据\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218175023.png)\n\nRAID2:采用纠错的海明码的磁盘阵列。\n\n​\t\t\t逻辑上连续的几个bit物理上分散存储在各个盘中4bit信息位+3bit海明校验位一可纠正一位错\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218175119.png)\n\nRAID3:位交叉奇偶校验的磁盘阵列。\n\nRAID4:块交叉奇偶校验的磁盘阵列。\n\nRAID5:无独立校验的奇偶校验磁盘阵列。\n\n特点：\n\nRAIDO把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但RAID0没有容错能力。\n\nRAID1是为了提高可靠性，使两个磁盘同时进行读写，互为备份，如果一个磁盘出现故障，可从另一磁盘中读出数据。两个磁盘当一个磁盘使用，意味着容量减少-一半。\n\nRAID通过同时使用多个磁盘，提高了传输率;通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量;通过镜像功能，可以提高安全可靠性;通过数据校验，可以提供容错能力。\n\n### 光盘存储器\n\n光盘存储器是利用光学原理读/写信息的存储装置，它采用聚焦激光束对盘式介质以非接触的方式记录信息。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218175312.png)\n\n特点:存储密度高；携带方便；成本低；容量大；存储期限长；容易保存；等...\n\n光盘的类型如下:\nCD-ROM:  只读型光盘，只能读出其中内容，不能写入或修改。\nCD-R:  只可写入-一次信息，之后不可修改。\nCD-RW:  可读可写光盘，可以重复读写。\nDVD-ROM:  高容量的CD-ROM，DVD表示通用数字化多功能光盘。\n\n### 固定硬盘\n\n在微小型高档笔记本电脑中，采用高性能Flash Memory作为硬盘来记录数据，这种“硬盘”称固态硬盘。\n\n固态硬盘除了需要FlashMemory外，还需要其他硬件和软件的支持。\n\n注:闪存(Flash Memory)是在E2PROM的基础上发展起来的，本质上是只读存储器。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218175738.png)\n\n# 第三节：I/O接口\n\n## 3.1 结构和作用\n\n### 作用\n\n数据缓冲:  通过数据缓冲寄存器(DBR) 达到主机和外设工作速度的匹配\n错误或状态监测:  通过状态寄存器反馈设备的各种错误、状态信息，供CPU查用\n控制和定时:  接收从控制总线发来的控制信号、时钟信号\n数据格式转换:  串-并、并-串等格式转换\n与主机和设备通信:  实现主机- -I/0接口- -I/O设备之间的通信\n\n### 结构\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218181325.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218181350.png)\n\n### 工作原理\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218181505.png)\n\n①发命令:发送命令字到I/O控制寄存器，向设备发送命令(需要驱动程序的协助)\n②读状态:从状态寄存器读取状态字，获得设备或I/O控制器的状态信息\n③读/写数据:从数据缓冲寄存器发送或读取数据，完成主机与外设的数据交换\n\n控制寄存器、状态寄存器在使用时间上是错开的，因此有的I/O接口中可将二者合二为一。\nI/0控制器中的各种寄存器称为I/0端口。\n\n数据线：读写数据、状态字、控制字、中断类型号\n\n地址线：指明I/0端口\n\n控制线：读/写I/0端口的信号、中断请求信号\n\n## 3.2 I/O端口\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218181650.png)\n\nI/O端口是指接口电路中可以被CPU直接访问的寄存器。\n\n### 统一编制\n\n把I/O端口当做存储器的单元进行地址分配，用统一的访存指令就可以访问I/0端口，又称存储器映射方式。\n靠不同的地址码区分内存和I/O设备，1/0地址要求相对固定在地址的某部分。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218182035.png)\n\n如系统总线中地址线共10根，则可以访问的存储单元个数为210= 1024个，假设要给10个/O端口编址:\n\n1. 0~9表示I/0地址，10~ 1023为主存单元地址\n2. 2.0~ 1013表示主存单元地址，1014~ 1023为I0地址\n\n优点:\n不需要专门的输入/输出指令，所有访存指令都可直接\n访问端口，程序设计灵活性高\n端口有较大的编址空间\n读写控制逻辑电路简单\n缺点:\n端口占用了主存地址空间，使主存地址空间变小\n外设寻址时间长(地址位数多，地址译码速度慢\n\n### 独立编址\n\nI/O端口地址与存储器地址无关，独立编址CPU需要设置专门的输入/输出指令访问端口，又称I/0映射方式。\n靠不同的指令区分内存和I/O设备。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218182032.png)优点: \n使用专用I/0指令，程序编制清晰\nI/O端口地址位数少，地址译码速度快\n1/0端口的地址不占用主存地址空间\n缺点:\nI/0指令类型少，-般只能对端口进行传送操作,\n程序设计灵活性差\n需要CPU提供存储器读/写、I/0设备读/写两组控制\n信号，增加了控制逻辑电路的复杂性\n\n## 3.3 分类\n\n按数据传送方式可分为\n\t\t并行接口: -一个字节或一个字所有位同时传送。\n\t\t串行接口:一位--位地传送。\n注:这里所说的数据传送方式指的是外设和接口一侧的传送方式，而在主机和接口一侧，数据总是并行传送的。接口要完成数据格式转换。\n按主机访问I/O设备的控制方式可分为：程序查询接口；中断接口；DMA接口。\n按功能选择的灵活性可分为：可编程接口；不可编程接口。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201218182400.png)\n\n# 第四节  程序查询方式\n\n## 4.1 流程图\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219092911.png)\n\n## 4.2 例题\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219093013.png)\n\n## 4.3 回顾\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219093155.png)\n\nCPU一旦启动I/O，必须停止现行程序的运行，并在现行程序中插入一段程序。\n\t\t主要特点: CPU有“踏步”等待现象，CPU与I/O串行工作。\n\t\t优点:接口设计简单、设备量少。\n\t\t缺点: CPU在信息传送过程中要花费很多时间用于查询和等待，而且如果采用独占查询，则在一段时间内只能和一台外设交换信息，效率大大降低。\n**独占查询:** CPU 100%的时间都在查询I/0状态，完全串行\n**定时查询:**在保证数据不丢失的情况下，每隔一-段时间CPU就查询--次I/0状态。查询的\n间隔内CPU可以执行其他程序\n\n# 第五节 程序中断方式\n\n**总览**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219101215.png)\n\n## 5.1 中断的基本概念\n\n程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂\n时中止现行程序，而转去对这些异常情况或特殊请求进行处理，在处理完毕后CPU又自动返回到现\n行程序的断点处，继续执行原程序。\n\n**工作流程：**\n\n1.中断请求\n\t\t中断源向CPU发送中断请求信号。\n2.中断响应\n\t\t响应中断的条件。\n\t\t中断判优:多个中断源同时提出请求时通过中断判优逻辑响应一一个中断源。\n3.中断处理\n\t\t中断隐指令。\n\t\t中断服务程序。\n\n## 5.2 中断请求的分类\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219101429.png)\n\n## 5.3 中断请求标记\n\n每个中断源向CPU发出中断请求的时间是随机的。\n为了记录中断事件并区分不同的中断源，中断系统需对每个中断源设置中断请求标记触发器INTR,当其状态为“1”时，表示中断源有请求。\n这些触发器可组成中断请求标记寄存器，该寄存器可集中在CPU中，也可分散在各个中断源中。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219101537.png)\n\n对于外中断，CPU是在统一-的时刻即每条指令执行阶段结束前向接口发出中断查询信号，以获取I/0的中断请求，也就是说，CPU响应中断的时间是在每条指令执行阶段的结束时刻。\nCPU响应中断必须满足以下3个条件:\n\t\t①中断源有中断请求。\n\t\t②CPU允许中断即开中断。\n\t\t③一条指令执行完毕，且没有更紧迫的任务。\n\n## 5.4 中断判优\n\n中断判优既可以用硬件实现，也可用软件实现:\n硬件实现是通过硬件排队器实现的，它既可以设置在CPU中，也可以分散在各个中断源中;软件实现是通过查询程序实现的。\n\n**硬件实现：**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219101845.png)\n\n**软件实现：**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219101849.png)\n\n### **优先级设置**\n\n1. 硬件故障中断属于最高级，其次是软件中断;\n2. 非屏蔽中断优于可屏蔽中断;\n3. DMA请求优于I/O设备传送的中断请求\n4. 高速设备优于低速设备;\n5. 输入设备优于输出设备;\n6. 实时设备优于普通设备。\n\n## 5.5 中断处理过程\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219103634.png)\n\n### 中断隐指令\n\n中断隐指令的主要任务:\n\t\t①关中断。在中断服务程序中，为了保护中断现场(即CPU主要寄存器中的内容)期间不被新的中断所打断，必须关中断，从而保证被中断的程序在中断服务程序执行完毕之后能接着正确地执行下去。\n\t\t②保存断点。为了保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来程序的断点(即程序计数器(PC)的内容)保存起来。可以存入堆栈，也可以存入指定单元。\n\t\t③引出中断服务程序。引出中断服务程序的实质就是取出中断服务程序的入口地址并传送给程序计数器(PC)。\n\n分为：软件查询法；硬件向量法。\n\n硬件向量法：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219103921.png)\n\n### 中断服务程序\n\n中断服务程序的主要任务:\n\t\t①保护现场\n\t\t保存通用寄存器和状态寄存器的内容(eg: 保存ACC寄存器的值)，以便返回原程序后可以恢复CPU环境。可使用堆栈，也可以使用特定存储单元。\n\t\t②中断服务(设备服务)\n\t\t主体部分，如通过程序控制需打印的字符代码送入打印机的缓冲存储器中(eg: 中断服务的过程中有可能修改ACC寄存器的值)\n\t\t③恢复现场\n\t\t通过出栈指令或取数指令把之前保存的信息送回寄存器中(eg: 把原程序算到一-般的ACC值恢复原样)\n\t\t④中断返回\n\t\t通过中断返回指令回到原程序断点处。\n\n### 总结\n\n单重中断，执行史断服务程序时不响应新的中断请求。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219104152.png)\n\n## 5.6 多重中断\n\n多重中断：又称中断嵌套，执行中断服务程序时可响应新的中断请求。\n\n### 单重中断与多重中断\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219105524.png)\n\n### 中断屏蔽技术\n\n中断屏蔽技术主要用于多重中断，CPU要具备多重中断的功能，须满足下列条件。\n\t\t①在中断服务程序中提前设置开中断指令。\n\t\t②优先级别高的中断源有权中断优先级别低的中断源。\n\t每个中断源都有-一个屏蔽触发器，1表示屏蔽该中断源的请求，0表示可以正常申请，所有屏蔽触发器组合在一起，便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219105737.png)\n\n屏蔽字设置的规律:\n\t\t1.一般用'1'表示屏蔽，'0'表示正常申请。\n\t\t2.每个中断源对应-一个屏蔽字(在处理该中断源的中断服务程序时，屏蔽寄存器中的内容为该中断源对应的屏蔽字)。\n\t\t3.屏蔽字中'1'越多，优先级越高。每个屏蔽字中至少有一个'1'(至少要能屏蔽自身的中断)。\n\n**例题：**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219105839.png)\n\n### 小结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219105919.png)\n\n## 5.7 例题\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219110732.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219110807.png)\n\n# 第六节 DMA方式\n\n## 6.1DMA 控制器\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219113946.png)\n\nCPU向DMA控制器指明要输入还是输出;要传送多少个数据;数据在主存、外设中的地址。\n\n传送前：\n\n​\t\t( 1)接受外设发出的DMA请求(外设传送-一个字的请求)，并向CPU发出总线请求。\n​\t\t(2) CPU响应此总线请求，发出总线响应信号，接管总线控制权，进入DMA操作周期。\n\n传送时:\n\n​\t\t(3)确定传送数据的主存单元地址及长度，并能自动修改主存地址计数和传送长度计数。\n​\t\t(4)规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作。\n\n（5）向CPU报告DMA操作的结束\n\n## 6.2 各部件的功能\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219114241.png)\n\n**控制/状态逻辑：**由控制和时序电路及状态标志组成，用于指定传送方向，修改传送参数，并对DMA请求信号和CPU响应信号进行协调和同步。\n\n**DMA请求触发器：**每当I/0设备准备好数据后给出一个控制信号，使DMA请求触发器置位。\n\n**数据缓冲寄存器：**用于暂存每次传送的数据。\n\n**传送长度计数器：**简称WC，用来记录传送数据的长度，计数溢出时，数据即传送完毕，自动发中断请求信号。\n\n**主存地址计数器：**简称AR，存放要交换数据的主存地址。\n\n**中断机构：**当一个数据块传送完毕后触发中断机构，向CPU提出中断请求。\n\n**注:** 在DMA传送过程中，DMA控制器将接管CPU的地址总线、数据总线和控制总线，CPU的主存控制信号被禁止使用。而当DMA传送结束后，将恢复CPU的一切权利并开始执行其操作。\n\n## 6.3 DMA传送过程\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219114622.png)\n\n## 6.4 DMA方式的特点\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219114707.png)\n\n主存和DMA接口之间有一条直接数据通路。\n由于DMA方式传送数据不需要经过CPU，因此不必中断现行程序，1/0与主机并行工作，程序和传送并行工作。\nDMA方式具有下列特点:\n\t\t①它使主存与CPU的固定联系脱钩，主存既可被CPU访问，又可被外设访问。\n\t\t②在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。\n\t\t③主存中要开辟专用缓冲区，及时供给和接收外设的数据。\n\t\t④DMA传送速度快，CPU和外设并行工作，提高了系统效率。\n\t\t⑤DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。\n\n## 6.5 DMA传送方式\n\n主存和DMA控制器之间有-条数据通路，因此主存和/0设备之间交换信息时，不通过CPU。但当I/0设备和CPU同时访问主存时，可能发生冲突，为了有效地使用主存，DMA控制器与CPU通常采用以下3种方法使用主存。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219114856.png)\n\n## 6.6 DMA方式与中断方式\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219114955.png)\n\n## 6.7 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219115027.png)","categories":["计算机组成系统"]},{"title":"第六章-总线","url":"/2020/12/18/计算机组成原理/第六章-总线/","content":"\n总线的概念和性能指标，集中仲裁方式，分布仲裁方式，总线传输，总线标准\n<!--more-->\n# 第一节：总线概念与分类\n\n## 1.1 定义\n\n### 总线的物理实现\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217084901.png)\n\n如上图，4根信号线组成“一根”总线，所有硬件部件都可以通过这根总线传递数据。\n\n可并行发送4bit数据。同一时刻<font color=\"red\">只能有一个部件发送数据</font>，但是<font color=\"red\">可有多个部件接受数据</font>。\n\n### 总线的定义\n\n**总线**是一组能为多个部件<font color=\"red\">分时</font><font color=\"blue\">共享</font>的公共信息传送线路。\n\n<font color=\"red\">**共享**是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可以通过这组线路分时共享。</font>\n\n<font color=\"blue\">**分时**是指同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时地向总线发送信息。</font>\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217085133.png)\n\n为什么要用总线?\n\n​\t\t早期计算机外部设备少时大多采用分散连接方式，不易实现随时增减外部设备。\n\n​\t\t为了更好地解决I/O设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展成总线连接。\n\n## 1.2 特性\n\n1.机械特性:尺寸、形状、管脚数、排列顺序\n\n2.电气特性:传输方向和有效的电平范围\n\n3.功能特性:每根传输线的功能(地址、数据、控制)\n\n4.时间特性:信号的时序关系\n\n## 1.3 分类\n\n### 按数据传输格式\n\n**串行总线：**每次只能发送1个bit的信息。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217085733.png)\n\n优点:只需要一条传输线，成本低廉，广泛应用于长距离传输;应用于计算机内部时，可以节省布线空间。\n\n缺点:在数据发送和接收的时候要进行拆卸和装配，要考虑串行-并行转换的问题。\n\n**并行总线：**每次发送可以发送多个bit的信息。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217085741.png)\n\n优点:总线的逻辑时序比较简单，电路实现起来比较容易。\n\n缺点:信号线数量多，占用更多的布线空间;远距离传输成本高昂;由于工作频率较高时，并行的信号线之间会产生严重干扰，对每条线等长的要求也越高，所以无法持续提升工作频率。\n\n###  按功能\n\n**片内总线：**\n\n片内总线是芯片内部的总线。\n\n它是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线。\n\n**系统总线：**\n\n按系统总线传输信息内容的不同，又可分为3类:<font color=\"red\">数据总线</font>、<font color=\"blue\">地址总线</font>和<font color=\"greenr\">控制总线</font>。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217085133.png)\n\n1)<font color=\"red\">**数据总线**</font>用来传输各功能部件之间的数据信息，它是<font color=\"red\">双向</font>传输总线，其位数<font color=\"red\">与机器字长、存储字长有关</font>。\n\n2)<font color=\"blue\">**地址总线**</font>用来指出数据总线上的源数据或目的数据所在的主存单元或I/O端口的地址，它是<font color=\"blue\">单向</font>传输总线，地址总线的位数<font color=\"blue\">与主存地址空间的大小有关</font>。\n\n3)<font color=\"green\">**控制总线**</font>传输的是控制信息，包括<font color=\"green\">CPU送出的控制命令</font>和<font color=\"green\">主存(或外设)返回CPU的反馈信号</font>。\n\n<font color=\"red\">注意：</font>\n\n​\t\t数据通路表示的是数据流经的路经。\n\n​\t\t数据总线是承载的媒介\n\n**通信总线：**\n\n通信总线是用于计算机系统之间或计算机系统与其他系统(如远程通信设备、测试设备)之间信息传送的总线，通信总线也称为外部总线。\n\n可以理解为网线。\n\n###  按时序控制方式\n\n**同步总线：**\n\n**异步总线：**\n\n## 1.4 总线结构\n\n### 单总线结构\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217090731.png)\n\n**结构**: CPU、主存、I/O设备(通过I/O接口)都连接在一组总线上，允许I/O设备之间、I/O设备和CPU之间或I/O设备与主存之间直接交换信息。\n\n注:单总线并不是指只有一根信号线，系统总线按传送信息的不同可以细分为地址总线、数据总线和控制总线。\n\n**优点**:结构简单，成本低，易于接入新的设备。\n\n**缺点**:带宽低、负载重，多个部件只能争用唯一 的总线，且不支持并发传送操作。\n\n###  双总线结构\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217091153.png)\n\n<font color=\"blue\">通道是具有特殊功能的处理器，能对I/O设备进行统-管理。通道程序放在主存中。</font>\n\n结构:双总线结构有两条总线，一条 是主存总线，用于CPU、 主存和通道之间进行数据传送;另一条是/0总线，用于多个外部设备与通道之间进行数据传送。\n\n优点:将较低速的I/O设备从单总线上分离出来，实现存储器总线和I/O总线分离。\n\n缺点:需要增加通道等硬件设备。\n\n双总线结构支持突发(猝发)传送：送出一个地址，收到多个地址连续的数据。例如CPU给主存发送一条控制信息，主存会把很多条数据发给CPU。\n\n###  三总线结构\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217091335.png)\n\nDMA:Direct Memory Access,直接内存访问。\n\n结构:三总线结构是在计算机系统各部件之间采用3条各自独立的总线来构成信息通路，这3条总线分别为主存总线、/0总线和直接内存访问DMA总线。\n\n优点:提高了I/O设备的性能，使其更快地响应命令，提高系统吞吐量。\n\n缺点:系统工作效率较低。\n\n###  四总线结构(不考)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217091425.png)\n\n1.桥接器:用于连接不同的总线，具有数据缓冲、转换和控制功能。\n\n2.靠近CPU的总线速度较快。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217091528.png)\n\n# 第二节：总线的性能指标\n\n## 2.1 总线的传输周期\n\n-一次总线操作所需的时间(包括申请阶段、寻址阶段、传输阶段和结束阶段)，通常由若干个总线时钟周期构成。\n\n## 2.2 总线的时钟周期\n\n即机器的时钟周期。计算机有-一个统一- 的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。\n\n现在的计算机中，总线时钟周期也有可能由桥接器提供。\n\n总线周期与总线时钟周期的关系比较魔幻，\n\n大多数情况下，-个总线周期包含多个总线时钟周期\n\n有的时候，-一个总线周期就是一一个总线时钟周期\n\n有的时候，-一个总线时钟周期可包含多个总线周期\n\n## 2.3 总线的工作频率\n\n总线上各种操作的频率，为总线周期的倒数。若总线周期=N个时钟周期，则总线的工作频率=时钟频率/N。实际上指一秒内传送几次数据。\n\n## 2.4 总线的时钟频率\n\n即机器的时钟频率，为时钟周期的倒数。若时钟周期为T，则时钟频率为1/T。实际上指一秒内有多少个时钟周期。\n\n## 2.5 总线宽度\n\n又称为总线位宽，它是总线上同时能够传输的数据位数，通常是指数据总线的根数，如32根称为32位(bit) 总线。\n\n## 2.6 总线带宽\n\n可理解为总线的数据传输率，即单位时间内总线上可传输数据的位数，通常用每秒钟传送信息的字节数来衡量，单位可用字节/秒(B/s) 表示。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217110643.png)\n\n**例题：**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217110739.png)\n\n## 2.7 总线复用\n\n总线复用是指一种信号线在不同的时间传输不同的信息。可以使用较少的线传输更多的信息，从而节省了空间和成本。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217111157.png)\n\n## 2.8 信号线数\n\n地址总线、数据总线和控制总线3种总线数的总和称为信号线数。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217111322.png)\n\n# 第三节-总线仲裁\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217152035.png)\n\n同一时刻只能有-一个设备控制总线传输操作，可以有一一个或多个设备从总线接收数据。\n将总线上所连接的各类设备按其对总线有无控制功能分为:\n\t\t主设备:获得总线控制权的设备。\n\t\t从设备:被主设备访问的设备，只能响应从主设备发来的各种总线命令。\n为什么要仲裁?\n\t\t总线作为--种共享设备，不可避免地会出现同--时刻有多个主设备竞争总线控制权的问题。\n总线仲裁的定义:\n\t\t多个主设备同时竞争主线控制权时，以某种方式选择--个主设备优先获得总线控制权称为总线仲裁。\n总线仲裁分类:\n\t\t集中仲裁方式：链式查询方式、 计数器定时查询方式、独立请求方式\n\t\t分布仲裁方式\n\n## 3.1 集中仲裁方式\n\n工作流程:\n\n1.主设备发出请求信号;\n\n2.若多个主设备同时要使用总线，则由总线控制器的判优、仲裁逻辑按-定的优先等级顺序确定哪个主设备能使用总线;\n\n3.获得总线使用权的主设备开始传送数据。\n\n### 链式查询方式\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217152322.png)\n\n过程：\n\n​\t1， 当设备接口1想要使用总线时，通过BR对控制部件发送请求。\n\n​\t2， 控制部件接收到请求，且BS部位不为忙的时候，通过BG发送允许信号。\n\n​\t3, \tBG经过设备接口0时，由于设备接口1不需要使用总线，因此信号会被传送到设备接口1.\n\n​\t4， 设备接口1要使用总线，会截断BG信号，并将BS设为忙，然后使用总线。\n\n​\t5， 控制部件在感受到BS为忙时，便不会再BG上发送允许的信号。\n\n“总线忙”信号的建立者是获得总线控制权的设备。\n\n优先级:  离总线控制器越近的部件，其优先级越高;离总线控制器越远的部件，其优先级越低。\n\n优点:链式查询方式优先级固定。只需很少几根控制线就能按一定优先次序实现总线控制，结构简单，扩充容易。\n\n缺点:对硬件电路的故障敏感，并且优先级不能改变。当优先级高的部件频繁请求使用总线时，会使优先级较低的部件长期不能使用总线。\n\n### 计数器定时查询方式\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217153305.png)\n\n过程：\n\n​\t1， 当接口1想要使用总线时，会通过BR发送请求信号。\n\n​\t2，控制部件在接收到BR的请求信号，并且BS不忙时，计数器就会开始工作。\n\n​\t3， 计数器会从一个数开始计数，通过设备地址开始依次访问是哪个设备需要占用总线。\n\n​\t4， 当接口1收到计数器的访问时，会将BS设为忙，然后开始使用总线。\n\n​\t5,\t控制部件再检查到BS为忙时，会停止计数器的计数和访问。\n\n计数器的作用：当总线控制器收到总线请求信号，判断总线空闲时，计数器开始计数，计数值通过设备地址线发向各个部件。当地址线上的计数值与请求使用总线设备的地址一一致时，该设备获得总线控制权。同时，中止计数器的计数及查询。\n\n结构特点:用一个计数器控制总线使用权，相对链式查询方式多了一组设 备地址线，少了一一根总线响应线BG;它仍共用- -根总线请求线。\n\n优点: 计数初始值可以改变优先次序-计数每次从“0”开始， 设备的优先级就按顺序排列，固定不变;\n\n计数从上-一次的终点开始，此时设备使用总线的优先级相等;-计数器的初值还可以由程序设置。\n\n缺点: 增加了控制线数，若设备有n个，则需[ log2n 1+2条控制线；控制相对 比链式查询相对复杂。\n\n### 独立请求方式\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217154031.png)\n\n当总线控制器按一一定的优先次序决定批准某个部件的请求时，则给该部件发送总线响应信号。\n\n当总线上的部件需要使用总线时，经各自的总线请求线发送总线请求信号，在总线控制器中排队。\n\n结构特点:每一个设备均有一对总线请求线BR:和总线允许线BGi。\n\n优点:1.响应速度快，总线允许信号BG直接从控制器发送到有关设备,不必在设备间传递或者查询。2.对优先次序的控制相当灵活。\n\n缺点:1.控制线数量多-若设备有n个，则需要2n+1 条控制线。其中+1为BS线，用于设备向总线控制部件反馈已经是否正在使用总线。2.总线的控制逻辑更加复杂\n\n## 3.2 分布仲裁方式\n\n特点:不需要中央仲裁器，每个潜在的主模块都有自己的仲裁器和仲裁号，多个仲裁器竞争使用总线。\n\n过程：\n\n​\t当设备有总线请求时，它们就把各自唯-的仲裁号发送到共享的仲裁总线上;\n\n​\t每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较;\n\n​\t如果仲裁总线上的号优先级高，则它的总线请求不予响应，并撤销它的仲裁号;\n\n​\t最后，获胜者的仲裁号保留在仲裁总线上。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217154457.png)\n\n# 第四节：总线操作和定时\n\n## 4.1总线传输的四个阶段\n\n1)申请分配阶段:由需要使用总线的主模块(或主设备)提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某- - 申请者。也可将此阶段细分为传输请求和总线仲裁两个阶段。\n\n2)寻址阶段:获得使用权的主模块通过总线发出本次要访问的从模块的地址及有关命令，启动参与本次传输的从模块。\n\n3)传输阶段:主模块和从模块进行数据交换，可单向或双向进行数据传送。\n\n4)结束阶段:主模块的有关信息均从系统总线上撤除，让出总线使用权。\n\n**总线定时**是指总线在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为总线定时，它的实质是一种协议或规则。\n\n## 4.2 定时\n\n### 同步定时方式(同步通信)\n\n总线控制器采用一一个统的时钟信号来 协调发送和接收双方的传送定时关系。\n\n假设: CPU作为主设备，某个输入设备作为丛设备\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217170928.png)\n\n​\t1) CPU在T1时刻的上升沿给出地址信息。\n\n​\t2)在T2的上升沿给出读命令(低电平有效)，与地址信息相符合的输入设备按命令进行一系列的内部操作，且必须在T3的上升沿来之前将CPU所需的数据送到数据总线上。\n\n​\t3) CPU在T3时钟周期内，将数据线上的信息传送到其内部寄存器中。\n\n​\t4) CPU在T4的上升沿撤销读命令，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动。\n\n**同步定时方式**是指系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。\n\n若千个时钟产生相等的时间间隔，每个间隔构成-一个总线周期。\n\n在一个总线周期中，发送方和接收方可进行一-次数据传送。\n\n因为采用统--的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一 一个总线传送周期开始。\n\n<font color=\"blue\">优点:传送速度快，具有较高的传输速率;总线控制逻辑简单。</font>\n\n<font color=\"red\">缺点:主从设备属于强制性同步;不能及时进行数据通信的有效性检验，可靠性较差。</font>\n\n同步通信适用于<font color=\"yellow\">总线长度较短</font>及总线<font color=\"yellow\">所接部件的存取时间比较接近</font>的系统。\n\n### 异步定时方式(异步通信)\n\n在异步定时方式中，没有统--的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。\n\n主设备提出交换信息的“请求”信号，经接口传送到从设备;从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。\n\n根据“请求”和“回答”信号的撤销是否互锁，分为以下3种类型。\n\n​\t\t1)不互锁方式\n\n​\t\t2)半互锁方式\n\n​\t\t3)全互锁方式\n\n<font color=\"blue\">优点:总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。</font>\n\n<font color=\"red\">缺点:比同步控制方式稍复杂-一些，速度比同步定时方式慢。</font>\n\n#### 不互锁：速度最快，可靠性最差\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217171503.png)\n\n主设备发出“<font color=\"red\">请求</font>”信号后，不必等到接到从设备的“<font color=\"blue\">回答</font>”信号，而是经过-段时间，便撤销“<font color=\"red\">请求</font>”信号。\n\n而从设备在接到“<font color=\"red\">请求</font>”信号后，发出“<font color=\"blue\">回答</font>”信号，并经过一段时间，自动撤销“<font color=\"blue\">回答</font>”信号。双方不存在互锁关系。\n\n#### 半互锁\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217171506.png)\n\n主设备发出“<font color=\"red\">请求</font>”信号后，必须待接到从设备的“<font color=\"blue\">回答</font>”信号后，才撤销“<font color=\"red\">请求</font>”信号，有互锁的关系。\n\n而从设备在接到“<font color=\"red\">请求</font>”信号后，发出“<font color=\"blue\">回答</font>”信号，但不必等待获知主设备的“<font color=\"red\">请求</font>”信号已经撤销，而是隔一段时间后自动撤销“<font color=\"blue\">回答</font>”信号，不存在互锁关系。\n\n#### 全互锁：最可靠，速度最慢\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217171510.png)\n\n主设备发出“<font color=\"red\">请求</font>”信号后，必须待从设备“<font color=\"blue\">回答</font>”后，才撤销\"<font color=\"red\">请求</font>”信号;\n\n从设备发出“<font color=\"blue\">回答</font>”信号，必须待获知主设备“<font color=\"red\">请求</font>”信号已撤销后，再撤销其“<font color=\"blue\">回答</font>”信号。双方存在互锁关系。\n\n### 半同步通信\n\n同步：发送方用系统时钟前沿发信号；接收方用系统时钟后沿判断、识别。\n\n异步：允许不同速度的模块和谐工作。\n\n**半同步通信**:统一时钟的基础上，增加一个“等待”响应信号WAIT\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217171945.png)\n\n### 分离式通信\n\n上述三种通信的共同点\n\n一个总线传输周期(以输入数据为例)\n\n* 主模块发地址、命令\t\t\t\t\t使用总线\n* 从模块准备数据                            不使用总线              总线空闲\n* 从模块向主模块发数据:              使用总线\n\n分离式通信的一个总线传输周期：\n\n​\t\t\t子周期1：主模块申请占用总线，使用完后放弃总线的使用权。\n\n​\t\t\t子周期2：从模块申请占用总线，将各种信息送至总线上。\n\n特点:\n\n​\t\t1.各模块均有权申请占用总线\n\n​\t\t2.采用同步方式通信，不等对方回答\n\n​\t\t3.各模块准备数据时，不占用总线\n\n​\t\t4.总线利用率提高\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**<font size=\"15px\">小结：</font>**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217172356.png)\n\n# 第五节-总线标准\n\n## 5.1 总线的基本概念\n\n总线标准是国际上公布或推荐的互连各个模块的标准，它是把各种不同的模块组成计算机系统时必须遵守的规范。按总线标准设计的接口可视为通用接口，在接口的两端，任何一-方只需根据总线标准的要求完成自身方面的功能要求，而无须了解对方接口的要求。\n\n根据总线在计算机系统中的位置，可分为：\n\n​\t\t**系统总线**:通常与CPU直接相连，用于连接CPU与北桥芯片、或CPU与主存等。\n\n​\t\t**局部总线**:没有直接与CPU连接，通常是连接高速的北桥芯片，用于连接了很多重要的硬件部件(如显卡、声卡等)。\n\n​\t\t**设备总线、通信总线**:通常由南桥芯片控制，用于连接计算机与计算机，或连接计算机与外部I/0设备\n\n## 5.2 系统总线的标准\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217172958.png)\n\n## 5.3 局部总线的标准\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217173251.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217173323.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217173400.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217173435.png)\n\n## 5.4 设备总线标准\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217173700.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217173703.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217173816.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217173840.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217173949.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217174024.png)\n\n## 5.5 速度对比\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217174125.png)\n\n## 5.6 总线标准的发展\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201217174302.png)\n\n## 5.7 为何串行总线取代并行总线\n\n**并行总线:**用m根线每次传送m个比特，用<font color=\"red\">高/低电平表示1/0</font>，通常采用同步定时方式，由于线间信号干扰，因此总线<font color=\"red\">工作频率不能太高</font>。另外，各条线不能有长度差，长距离并行传输时工艺难度大。\n\n**串行总线**:用两根线每次传送一个比特，采用<font color=\"red\">“差模信号”表示1/0</font>，通常采用异步定时方式，总线<font color=\"red\">工作频率可以很高</font>。现在的串行总线通常基于包传输，如80bit为- 一个数据包，包与包之间有先后关系，因此可以用多个数据通路分别串行传输多个数据包。因此某种程度上现在的串行总线也有“并行”的特点\n\n\n\n","categories":["计算机组成系统"]},{"title":"异常","url":"/2020/12/16/尚硅谷说Java/Java基础语法/10-异常/","content":"\nJava中异常的处理机制\n\n<!--more-->\n# 异常概述于异常体系结构\n\n* 异常：在Java语言中，将程序执行中发生的不正常情况称为“异常”。 (开发过程中的语法错误和逻辑错误不是异常)\n* Java程序在执行过程中所发生的异常事件可分为两类：\n  * Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。\n  * Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：\n    * 空指针访问\n    * 试图读取不存在的文件\n    * 网络连接中断\n    * 数组角标越界\n* 对于这些错误，一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法是由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理。\n* 捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生。比如：除数为0，数组下标越界等\n  * 分类：编译时异常和运行时异常\n* 运行时异常(非受检异常)\n  * 是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。\n  * 对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。\n* 编译时异常(受检异常)\n  * 是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。\n  * 对于这类异常，如果程序不处理，可能会带来意想不到的结果\n\n# 常见异常\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184159.png)\n\n* java.lang.RuntimeException ：运行时异常\n  * ClassCastException：类强制转化异常\n  * ArrayIndexOutOfBoundsException：数组索引越界异常\n  * NullPointerException：空指针异常\n  * ArithmeticException：算术异常\n  * NumberFormatException：数字格式异常\n  * InputMismatchException：输入不匹配异常\n* java.io.IOException：IO异常\n  *  FileNotFoundException：找不到文件异常\n  * EOFException：EOF异常\n* java.lang.ClassNotFoundException：类找不到异常\n* java.lang.InterruptedException：中断的异常\n* java.io.FileNotFoundException：文件找不到异常\n* java.sql.SQLException：数据库异常\n\n# 异常处理机制一：try-catch-finally\n\n* Java异常处理：Java采用的异常处理机制，是将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁、优雅，并易于维护。\n\n* Java异常处理的方式：\n\n  * 方式一：try-catch-finally\t\n  * 方式二：throws + 异常类型\n\n* Java提供的是异常处理的抓抛模型。\n\n* Java程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常。\n\n* 异常对象的生成\n\n  * 由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出——自动抛出\n  * 由开发人员手动创建：Exception exception = new ClassCastException();——创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样\n\n* 如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。这一过程称为捕获(catch)异常。\n\n* 如果一个异常回到main()方法，并且main()也不处理，则程序运行终止。\n\n* 程序员通常只能处理Exception，而对Error无能为力\n\n* 异常处理是通过try-catch-finally语句实现的。\n\n  ```java\n  try{\n      ...... //可能产生异常的代码\n  }\n  catch( ExceptionName1 e ){\n      ...... //当产生ExceptionName1型异常时的处置措施\n  }\n  catch( ExceptionName2 e ){\n      ...... //当产生ExceptionName2型异常时的处置措施\n  } finally{\n      ...... //无论是否发生异常，都无条件执行的语句\n  } \n  ```\n\n* try：捕获异常的第一步是用try{…}语句块选定捕获异常的范围，将可能出现异常的代码放在try语句块中。\n\n* catch (Exceptiontype e)：在catch语句块中是对异常对象进行处理的代码。每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。\n\n* 如果明确知道产生的是何种异常，可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。\n\n* 捕获异常的有关信息：与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法。\n\n  * getMessage() 获取异常信息，返回字符串\n  * printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184200.png)\n\n* finally：\n\n  * 捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。\n  * 不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，finally块中的语句都会被执行。\n  * finally语句和catch语句是任选的\n\n* 不捕获异常时的情况\n\n  * 前面使用的异常都是RuntimeException类或是它的子类，这些类的异常的特点是：即使没有使用try和catch捕获，Java自己也能捕获，并且编译通过( 但运行时会发生异常使得程序运行终止 )。\n  * 如果抛出的异常是IOException等类型的非运行时异常，则必须捕获，否则编译错误。也就是说，我们必须处理编译时异常，将异常进行捕捉，转化为运行时异常。\n\n# 异常处理机制二：throws\n\n* 声明抛出异常是Java中处理异常的第二种方式\n\n  * 如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。\n  * 在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。\n\n* 声明抛出异常举例：\n\n  ```java\n  public void readFile(String file) throws FileNotFoundException {\n      ……\n          // 读文件的操作可能产生FileNotFoundException类型的异常\n          FileInputStream fis = new FileInputStream(file);\n      ..……\n  }\t\n  ```\n\n* 重写方法不能抛出比被重写方法范围更大的异常类型。在多态的情况下， 对methodA()方法的调用-异常的捕获按父类声明的异常处理。\n\n# 手动抛出异常：throw\n\n* Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要使用人工创建并抛出。\n\n  * 首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运行环境)。\n\n    ```java\n    IOException e = new IOException();\n    throw e;\n    ```\n\n  * 可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将会产生语法错误：\n\n    ```java\n    throw new String(\"want to throw\");\n    ```\n\n* throw 与 throws的区别\n\n  * 含义不同：throws是异常的处理机制，throw只是抛出了一个异常\n  * 抛出的内容不同：throws抛出的是一个个异常类型。throw抛出的是异常类的对象\n  * 抛给的对象不同：throws抛给了调用这个方法的方法。throw抛给了Java处理机。\n  * 声明的位置不同：throws是声明在方法名的后面。throw是声明在方法体内\n\n# 用户自定义异常\n\n* 一般地，用户自定义异常类都是RuntimeException的子类。\n* 自定义异常类通常需要编写几个重载的构造器。 \n* 自定义异常需要提供serialVersionUID\n* 自定义的异常通过throw抛出。 \n* 自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。\n\n# 总结\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207180611.png)\n\n\n\n```java\n * Error:Java虚拟机无法解决的严重问题。\n * \t\t如JVM系统内部错误，资源耗尽等情况。\n * \t\t一般不针对性的编写代码进行处理\n * 一，异常体系结构\n * \tjava.lang.Throwable\n * \t\tjava.lang.Error:一般不针对性的编写代码进行处理\n * \t\tjava.lang.Exception:可以进行异常处理\n * \t\t\t编译时异常：IOException,ClassNotFoundException\n * \t\t\t运行时异常：RuntimeException\n * 二，异常的处理：抓抛模型\n * \t\t过程一：抛：程序正在执行的过程中，一旦出现异常，就会在异常代码处生成一个对应\n * \t\t\t\t异常类的对象，并将此异常抛出。一旦抛出异常对象后，其后面的代码就不执行了\n * \t\t过程二：抓：可以理解为异常的处理方式：① try-catch-finally。② throws\n * \t1：try-catch-finally的使用\n * \t\ttry{\n * \t\t\t//可能出现异常的代码\n * \t\t}catch(异常类型1  变量名1){\n * \t\t\t//处理异常1的方式\n * \t\t}catch(异常类型2  变量名2){\n * \t\t\t//处理异常2的方式\n * \t\t}...\n * \t\tfinally{\n * \t\t\t//一定会执行的代码\n * \t\t}\n * \t\t① finally是可逆的\n * \t\t② 使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成\n * \t\t一个对应异常类的对象，根据此对象的类型，区catch中进行匹配\n * \t\t③ 一旦try中的异常对象匹配到其中一个catch时，就进入catch中进行异常的处理。\n * \t\t一旦处理完成就跳出当前的try-catch结构(在没有写finally时)，继续执行其后的代码\n * \t\t④ catch中的异常类型如果没有父子关系，则谁声明在上，谁声明在下无所谓\n * \t\t\t如果满足父子关系。则要求子类一定声明在父类的上面。否则会出错\n * \t\t⑤ 常用的异常处理方式： String getMessage() printStackTrace()\n * \t\t⑥ 在try结构中声明的变量，再出了try结构以后，就不能在被调用\n *    结论1：使用try-catch-finally处理编译时异常，是让程序在编译时不报错，但是运行时仍可能报错。\n *    \t相当于我们使用try-catch-finally将一个编译时可能出现的异常延迟到运行时出现。\n *    结论2：开发中，有运行时异常比较常见，使用我们通常不针对性的编写try-catch-finally。\n *    \t针对编译时的异常，则一定要考虑异常的处理\n *  2：finally的使用\n * \t\t① finally是可选的\n * \t\t② finally中声明的是一定会被执行的代码。即使catch中又出现了，try中有return 语句，catch中有return语句\n * \t\t 时，finally中的语句也一定会执行\n * \t\t③ 像数据库连接，输入输出流，网络编程等资源，JVM是不能自动回收的，我们需要自己手动的进行资源的回收和释放。\n * \t\t 因此，此时的资源的释放声明在finally中\n * \t3：throws + 异常类型\n * \t\t① throws + 异常类型 写在方法的声明处，方法名的后面。指明在方法执行时可能会抛出的异常类型。\n * \t\t 一旦方法执行时，出现异常，仍会在异常出现的代码处生成一个异常对象，此对象满足throws的异常类型，\n * \t\t 就会被抛出。异常后面的代码将不会执行。\n * \t\t② 重写的方法抛出的异常不能大于原方法抛出的异常 \n * \t\t③ try-catch-finally:真正的将异常给处理了。\n * \t\t  throws的方式只是将异常给抛给了方法的调用者。并没有将异常给真正处理掉。  \t\t\n * \t 使用：开发中如果选择使用try-catch-fianlly，还是使用throws\n * \t\t①：如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws,只能使用try-catch-finally\n *       来处理异常\n * \t\t②：如果一个方法A有调用另一个方法B，另一个方法B有调用其他的方法C，而且这几个方法都有可能会出现异常。我们建议这几\n *       个方法都是用throws方式来抛出异常，并且在方法A中来使用try-catch-finally来处理异常\n * \t4：手动抛出异常:throw\n * \t\t>异常对象的产生：①系统自动生成的异常对象 ②手动的生成一个异常对象并抛出throw  \n * \t\t>throw 一般写在方法内，在要抛出异常的地方编写\n * \t\t>格式：throw new 异常类型的构造方法\n *  5：自定义异常类\n *   >自定义步骤：\n *  \t①继承于现有的异常结构：RuntimeException , Exception\n *  \t②提供全局常量：serialVersionUID\n *  \t③提供重载的构造器\n * \n```\n\n","categories":["Java学习","Java基础语法"]},{"title":"面向对象(下)","url":"/2020/12/15/尚硅谷说Java/Java基础语法/9-面向对象下/","content":"\nJava中抽象类和接口，多态性\n\n<!--more-->\n# static关键字\n\n* 引入：当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会产生出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，某些特定的数据在内存空间里只有一份，例如所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。\n\n* 类属性作为该类各个对象之间共享的变量。在设计类时,分析哪些属性不因对象的不同而改变，将这些属性设置为类属性。相应的方法设置为类方法。\n\n* 如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。\n\n* 使用范围：\n\n  * 在Java类中，可用static修饰属性、方法、代码块、内部类\n  * 只能在静态类型类或顶级类型类中才能声明静态方法\n\n* 被修饰后的成员具备以下特点：\n\n  * 随着类的加载而加载\n  * 优先于对象存在\n  * 修饰的成员，被所有对象所共享\n  * 访问权限允许时，可不创建对象，直接被类调用\n\n* static修饰属性：静态属性(类属性)\n\n  * 类变量（类属性）由该类的所有实例共享\n  * 静态属性随着类的加载而加载，可以通过“类.静态属性”的方式进行调用\n  * 可以通过类名调用静态属性而不能调用非静态属性，可以通过对象调用静态属性和非静态属性\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184329.png)\n\n* static修饰方法：静态方法(类方法)\n\n  * 没有对象的实例时，可以用类名.方法名()的形式访问由static修饰的类方法。在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。\n  * 因为不需要实例就可以访问static方法，因此static方法内部不能有this和super。\n  * static修饰的方法不能被重写\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184330.png)\n\n  * main()方法的说明：\n\n    * 由于Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public，又因为Java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数。 \n    * 又因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184331.png)\n\n# 类的成员之四：代码块\n\n* 代码块(或初始化块)的作用：  对Java类或对象进行初始化\n\n* 代码块(或初始化块)的分类：\n\n  * 一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块\n  * 没有使用static修饰的，为非静态代码块。\n\n* static代码块通常用于初始化static的属性\n\n* 静态代码块：用static 修饰的代码块\n\n  1. 可以有输出语句。\n  2. 可以对类的属性、类的声明进行初始化操作。\n  3. 不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。\n  4. 若有多个静态的代码块，那么按照从上到下的顺序依次执行。\n  5. 静态代码块的执行要先于非静态代码块。\n  6. 静态代码块随着类的加载而加载，且只执行一次。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184332.png)\n\n* 非静态代码块：没有static修饰的代码块\n\n  1. 可以有输出语句。 \n  2. 可以对类的属性、类的声明进行初始化操作。 \n  3. 除了调用非静态的结构外，还可以调用静态的变量或方法。 \n  4. 若有多个非静态的代码块，那么按照从上到下的顺序依次执行。 \n  5. 每次创建对象的时候，都会执行一次。且先于构造器执行。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184333.png)\n\n* 程序中成员变量赋值的执行顺序\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184334.png)\n\n# final关键字\n\n* 在Java中声明类、变量和方法时，可使用关键字final来修饰,表示“最终的”。\n\n* final标记的类不能被继承。提高安全性，提高程序的可读性。\n\n  * 比如：String类、System类、StringBuffer类\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184335.png)\n\n* final标记的方法不能被子类重写。\n\n  * 比如：Object类中的getClass()。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184330.png)\n\n* final标记的变量(成员变量或局部变量)即称为常量。名称大写，且只能被赋值一次。\n\n  * final标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋值，然后才能使用。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184336.png)\n\n* static final：全局常量\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184337.png)\n\n# 抽象类和抽象方法\n\n* 随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。\n\n* 用abstract关键字来修饰一个类，这个类叫做抽象类。\n\n  ```java\n  abstract class Person{\n  }\n  ```\n\n* 用abstract来修饰一个方法，该方法叫做抽象方法。\n\n  * 抽象方法：只有方法的声明，没有方法的实现。以分号结束：\n\n  ```java\n  public abstract void eat();\n  ```\n\n* 含有抽象方法的类必须被声明为抽象类。\n\n* 抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类\n\n* 不能用abstract修饰变量、代码块、构造器；\n\n* 不能用abstract修饰私有方法、静态方法、final的方法、final的类。\n\n* 抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类。\n\n* 多态的应用：模板方法设计模式(TemplateMethod)\n\n  * 抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。\n  * 解决的问题：\n    * 当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。\n    * 换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式\n  * 模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：\n    * 数据库访问的封装\n    * Junit单元测试\n    *  JavaWeb的Servlet中关于doGet/doPost方法调用\n    * Hibernate中模板程序\n    *  Spring中JDBCTemlate、HibernateTemplate等\n\n* 匿名对象的使用\n\n  ```java\n  public class AbstraceTest {\n  \tpublic static void main(String[] args) {\n  \t\t//非匿名的类(Student)匿名对象\n  \t\tmethod2(new Student());//吃饭\n  \t\t\n  \t\t//非匿名的类(Student)非匿名的对象(s)\n  \t\tStudent s = new Student();\n  \t\tmethod1(s);//吃饭\n  \t\t\n  \t\t//创建了一个匿名子类的对象p\n  \t\tPerson p = new Person() {\n  \t\t\t@Override\n  \t\t\tpublic void eat() {\n  \t\t\t\tSystem.out.println(\"匿名吃饭\");\t\n  \t\t\t}\n  \t\t};\n  \t\tmethod1(p);//匿名吃饭\n  \t\t\n  \t\t//创建匿名子类的匿名对象\n  \t\tmethod1(new Person() {\n  \t\t\t@Override\n  \t\t\tpublic void eat() {\n  \t\t\t\tSystem.out.println(\"匿名子类吃饭\");\n  \t\t\t}\n  \t\t});//匿名子类吃饭\n  \t}\n  \tpublic static void method1(Person person) {\n  \t\tperson.eat();\n  \t}\n  \tpublic static void method2(Student student) {\n  \t\tstudent.eat();\n  \t}\n  }\n  abstract class Person{\n  \tpublic abstract void eat();\n  }\n  class Student extends Person{\n  \t@Override\n  \tpublic void eat() {\n  \t\tSystem.out.println(\"吃饭\");\n  \t}\n  }\n  \n  ```\n\n# 接口(interface)\n\n* 一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。\n\n* 另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。\n\n* 接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要...则必须能...”的思想。继承是一个\"是不是\"的关系，而接口实现则是 \"能不能\"的关系。\n\n* 接口的本质是契约，标准，规范，就像我们的法律一样。制定好后大家都要遵守。\n\n* 接口(interface)是抽象方法和常量值定义的集合。 \n\n* 接口的特点：\n\n  * 用interface来定义。 \n  * 接口中的所有成员变量都默认是由public static final修饰的。（JDK7及以前） \n  * 接口中的所有抽象方法都默认是由public abstract修饰的。 （JDK7及以前） \n  * 接口中还支持静态方法和默认方法。(JDK8及以后)\n  * 接口中没有构造器。 \n  * 接口采用多继承机制。\n\n  ```java\n  //接口的定义\n  public interface Person{\n  \t//常量\n  \tpublic static final int MAX_NUM = 1;\n  \t//抽象方法\n  \tpublic abstract void show();\n  \t//默认方法\n  \tpublic default void eat() {\n  \t\tSystem.out.println(\"eat\");\n  \t}\n  \t//静态方法\n  \tpublic static void work() {\n  \t\tSystem.out.println(\"work\");\n  \t}\n  }\n  ```\n\n* 定义Java类的语法格式：先写extends，后写implements\n\n  ```java\n  例如：class A extends B implements C{ }\n  ```\n\n* 一个类可以实现多个接口，接口也可以继承其它接口。\n\n* 实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类。\n\n* 接口的主要用途就是被实现类实现。（面向接口编程）\n\n* 与继承关系类似，接口与实现类之间存在多态性\n\n* 接口和类是并列关系，或者可以理解为一种特殊的类。\n\n* 接口的应用：\n\n  * 代理模式：代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问\n    * 应用场景：\n      * 安全代理：屏蔽对真实角色的直接访问。 \n      * 远程代理：通过代理类处理远程方法调用（RMI） \n      * 延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象\n    * 分类\n      * 静态代理（静态定义代理类） \n      * 动态代理（动态生成代理类） \n  * 工厂模式：实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。\n\n* 接口与抽象类之间的对比\n| No. | 区别点 | 抽象类 | 接口|\n| ---- | ---- | ---- | ----|\n| 1 |定义 | 包含抽象方法的类 | 主要是抽象方法和全局常量的集合|\n| 2 |组成 |构造方法、抽象方法、普通方法、常量、变量 | 常量、抽象方法、(jdk8.0:默认方法、静态方法) |\n| 3 |使用 |子类继承抽象类(extends)| 子类实现接口(implements)|\n|4 |关系 |抽象类可以实现多个接口 |接口不能继承抽象类，但允许继承多个接口|\n| 5 |常见设计模式 |模板方法 |简单工厂、工厂方法、代理模式|\n| 6 |对象 |都通过对象的多态性产生实例化对象||\n| 7 |局限| 抽象类有单继承的局限 |接口没有此局限|\n| 8 |实际| 作为一个模板|是作为一个标准或是表示一种能力|\n| 9 | 选择| 如果抽象类和接口都可以使用的话，优先使用接口， |因为避免单继承的局限|\n\n* 在开发中，常看到一个类不是去继承一个已经实现好的类，而是要么继承抽象类，要么实现接口。\n\n### JDK 8关于接口的改进\n\n* Java 8中，你可以为接口添加静态方法和默认方法。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。\n* 静态方法：使用 static 关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像Collection/Collections或者Path/Paths这样成对的接口和类。\n* 默认方法：默认方法使用 default 关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。\n  * 比如：java 8 API中对Collection、List、Comparator等接口提供了丰富的默认方法\n* 若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同参数的方法（不管此方法是否是默认方法），在实现类同时实现了这两个接口时，会出现：<font color = \"red\">接口冲突。</font>\n  * 解决办法：实现类必须覆盖接口中同名同参数的方法，来解决冲突。\n* 若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，则不会出现冲突问题。因为此时遵守：类优先原则。接口中具有相同名称和参数的默认方法会被忽略。\n\n# 类的成员之五：内部类\n\n* 当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。\n\n* 在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。\n\n* 内部类一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。\n\n  * 内部类的名字不能与包含它的外部类类名相同；\n\n* 分类： \n\n  * 成员内部类（static成员内部类和非static成员内部类）\n  * 局部内部类（不谈修饰符）、匿名内部类\n\n* 成员内部类作为类的成员的角色：\n\n  * 和外部类不同，内部类还可以声明为private或protected。\n  * 可以调用外部类的结构\n  * 内部类可以声明为static的，但此时就不能再使用外层类的非static的成员变量。\n\n* 成员内部类作为类的角色：\n\n  * 可以在内部定义属性、方法、构造器等结构\n  * 可以声明为abstract类 ，因此可以被其它的内部类继承\n  * 可以声明为final的\n  * 编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）\n\n* 注意\n\n  * 非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员内部类中才可声明static成员。\n  * 外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式\n  * 成员内部类可以直接使用外部类的所有成员，包括私有的数据\n  * 当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的\n\n* 如何声明局部内部类\n\n  ```java\n  class 外部类{\n  \t方法(){\n  \t\tclass 局部内部类{ } \n      }\n      {\n  \t\tclass 局部内部类{ } \n      } \n  }\n  ```\n\n* 如何使用局部内部类\n\n  * 只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类\n  * 内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号，以及数字编号。\n  * 只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类。\n  * 局部内部类可以使用外部类的成员，包括私有的。  局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内部类和局部变量的声明周期不同所致。\n  * 局部内部类和局部变量地位类似，不能使用public,protected,缺省,private\n  * 局部内部类不能使用static修饰，因此也不能包含静态成员\n\n* 匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。\n\n* 格式：\n\n  ```java\n  new 父类构造器（实参列表）|实现接口(){\n  \t\t//匿名内部类的类体部分\n  } \n  ```\n\n*  匿名内部类的特点\n\n  * 匿名内部类必须继承父类或实现接口\n  * 匿名内部类只能有一个对象\n  * 匿名内部类对象只能使用多态形式引用\n\n```java\npublic class AbstraceTest {\n\tpublic String name;\n\tpublic int age = 10;\n\tpublic void eat() {\n\t}\n\t//静态成员内部类\n\tstatic class Person{\n\t\tpublic String name;\n\t\tpublic int age;\n\t\t\n\t\tpublic void eat() {\t\n\t\t}\n\t}\n\t//非静态成员内部类\n\tpublic class Student{\n\t\tpublic String name;\n\t\tpublic int age;\n\t\tpublic void eat() {\n\t\t\tAbstraceTest.this.age = 11;\n\t\t}\n\t\tpublic void show() {\n\t\t\t//调用内部类的属性\n\t\t\tSystem.out.println(this.name);\n\t\t\t//调用外部类的属性\n\t\t\tSystem.out.println(AbstraceTest.this.name);\n\t\t\t//调用内部类的方法\n\t\t\tthis.eat();\n\t\t\t//调用外部类的方法\n\t\t\tAbstraceTest.this.eat();\n\t\t}\n\t}\n\t//开发中的使用\n\tpublic Comparable getComparable() {\n\t\tint num ;\n\t\tclass MyComparable implements Comparable{\n\t\t\t@Override\n\t\t\tpublic int compareTo(Object o) {\n\t\t\t\t// TODO 自动生成的方法存根\n\t\t\t\t\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn new MyComparable(); \n\t}\n}\n```\n\n# 总结\n\n```java\n\t/**\n\t * static关键字的使用\n\t * \t1.static：静态的 \n\t *  2.static可以用来修饰：属性，方法，代码块，内部类\n\t * \t3.使用static修饰属性：静态变量(类变量) \n\t * \t\t3.1属性，按是否使用static修饰，属性分为静态属性vs非静态属性(实例变量)\n\t * \t\t\t实例属性：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。\n\t * \t\t\t\t当修改其中的一个对象中的 非静态属性时，不会导致其他对象中同样的属性值的修改\n\t * \t\t\t静态属性：我们创建了类的多个对象，多个对象共享同一个静态属性。\n\t * \t\t\t\t当通过类或某个对象修改静态属性时， 会导致其他对象调用此静态属性时，值是修改过的。\n\t * \t\t3.2补充说明： \n\t * \t\t\t①：静态属性随着类的加载而加载，可以通过“类.静态属性”的方式进行调用 \n\t * \t\t\t②：静态属性的加载要早于对象的创建 \n\t * \t\t\t③：由于类只会加载一次，则静态属性在内存中也只会存在一份(存放在方法区的静态域中) \n\t * \t\t\t④：可以通过 类名 调用静态属性而不能调用非静态属性\n\t * \t\t\t \t可以通过 对象 调用静态属性和非静态属性 \n\t * \t\t3.3举例：System.out Math.PI \n\t * \t4.使用static修饰方法：静态方法\n\t * \t\t4.1随着类的加载而加载，可以通过“类.静态方法”的方式进行调用 \n\t * \t\t4.2静态方法中只能调用静态的方法和属性\n\t * \t\t4.3非静态方法中可以调用非静态的属性和方法，也可以调用静态的属性和方法\n\t *  \t4.4可以通过 类名 调用静态方法而不能调用非静态方法\n\t * \t\t\t可以通过 对象 调用静态方法和非静态方法 \n\t * \t5.static注意点： \n\t * \t\t5.1在静态的方法内，不能使用this关键字，super关键字\n\t * \t\t5.2关于静态属性和静态方法的使用，都会从生命周期的角度去理解\n\t *  6.开发中如何确定一个属性是否要声明为static的？\n\t * \t\t>属性是可以被多个对象所共享的，不会随着对象的不同而不同 >类中的常量也经常被设置为static的 \n\t * \t    开发中如何确定一个方法是否要声明为static的？\n\t * \t\t\t>操作静态属性的方法，通常设置为static的 \n\t * \t\t\t>工具类中的方法，习惯上声明为static的。比如：Math，Arrays,Collections\n\t * \t7.main()方法的使用说明： \n\t * \t\t>main()方法作为程序的入口 \n\t *\t\t>main()方法也是一个普通的静态方法 \n\t * \t\t>mian()方法可以作为我们与控制台交互的方法\n\t *\n\t * 类的成员之四：代码块 \n\t *  1.代码块的作用：初始化类，对象 \n\t *  2.代码块的修饰符只能是static \n\t *  3.分类：静态代码块vs非静态代码块 \n\t *  4.静态代码块\n\t *    >内部可以有输出语句 \n\t *    >随着类的加载而执行，而且只执行一次 \n\t *    >作用：初始化类的信息 \n\t *    >如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行\n\t *    >静态代码块的执行要有优先于非静态代码块的执行 \n\t *    >静态代码块内只能调用静态属性，静态的方法。不能调用非静态的属性和方法 5.非静态代码块\n\t *    >内部可以有输出语句 \n\t *    >随着对象的创建而执行 \n\t *    >每次创建一个对象，就执行一次非静态代码块 \n\t *    >作用：可以在创建对象时，对对象的属性等进行初始化\n\t *    >如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行 \n\t *    >非静态代码块内可以调用静态属性，静态的方法。也能调用非静态的属性和方法\n\t * \n\t * 对属性赋值的位置： \n\t * \t①默认初始化\n\t *  ②显式初始化 \n\t *  ③构造器中初始化\n\t *  ④通过“对象.属性”或“对象.方法”的方式进行复制 \n\t *  ⑤在代码块中进行初始化 \n\t *  顺序：① - ②/⑤ - ③ - ④ \n\t * \t\t补从与说明：对于只有非静态代码块和非静态属性来说②和⑤谁在类的前面先执行谁。\n\t * \t\t\t对于静态代码块和静态属性来说来说②和⑤谁在类的前面先执行谁。 \n\t * \t\t\t对于静态代码块和非静态代码块和静态属性来说。非静态代码块在最后执行且不受位置的影响\n\t * 关于代码块与构造器的执行顺序： 举例：爷，父，儿三者之间的关系。主函数中调用子类的构造器 。\n\t * \t\t输出顺序：爷的静态代码块 - 父的静态代码块 - 儿的静态代码块\n\t * \t\t\t\t- 爷的非静态代码块 - 爷的无参构造器 - 父的非静态代码块 \n\t * \t\t\t\t- 父的无参构造器 - 儿的非静态代码块 - 儿的构造器\n\t *\n\t * final关键字 \n\t * \t1.final可以用来修饰的结构：类，方法，变量 \n\t * \t2.final用来修饰一个类：此类不能被其他类继承。\n\t * \t\t比如：String类，System类 \n\t * \t3.final用来修饰方法：表明此方法不可以被重写 比如：Object类中getClass();\n\t * \t4.final用来修饰变量：此时的变量就称为是一个常量\n\t * \t\t4.1 final修饰属性：可以考虑赋值的位置有：显式初始化，代码块中初始化，构造器中初始化(属性不能是静态的)\n\t * \t\t4.2 final修饰变量：final可以修饰形参和实参，但是一旦被赋值后这个变量可以被使用但不能改变值 \n\t *  static和final在一起通常修饰和全局变量\n\t *\n\t * abstract关键字\n\t *  1.abstract：抽象的\n\t *  2.abstract可以用来修饰的结构：类，方法\n\t *  3.abstract修饰类：抽象类\n\t * \t\t>此类不能被实例化\n\t * \t\t>抽象类中一定有构造器，便于子类实例化时调用\n\t *\t\t>开发中都会提供抽象类的子类，让子类对象实例化，完成对抽象类的使用\n\t *  4.abstract修饰方法：抽象方法\n\t *\t\t>抽象方法只有方法的声明，没有方法体\n\t *\t\t>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象的方法\n\t *\t\t>若子类重写了父类中的所有的抽象的方法后，此子类方可实例化\n\t *\t\t 若子类没有重写父类中的所有抽象方法，则此子类也是一个抽象类，需使用abstract修饰 \n\t *  5.注意点\n\t *\t\t>abstract不能修饰：属性，构造器等结构\n\t *\t\t>abstract不能修饰私有方法，静态方法，final的方法，final的类\n\t *\n\t * 接口的使用\n\t *  1.接口使用interface定义\n\t *  2.Java中，接口和类是并列的两个结构\n\t *  3.如何定义接口：定义接口中的成员\n\t *  \t3.1 JDK7及以前：只能定义全局常量和抽象方法\n\t *  \t\t>全局常量：public static final修饰的。书写时可以将修饰符省略不写\n\t *  \t\t>抽象方法：public abstract修饰的。书写时可以将修饰符省略不写\n\t *  \t3.2 JDK8及以后：除了定义全局常量和抽象方法，还可以定义静态方法，默认方法\n\t *  \t\t>接口中定义的静态方法，只能通过此接口来调用\n\t *  \t\t>通过接口的实现类的对象，可以调用接口中的默认方法。如果实现类重写了默认方法，则调用的重写以后的方法\n\t *  \t\t>如果子类(实现类)继承的父类和实现的接口中声明了同名同参的方法\n\t *  \t\t 那么子类在没有重写此方法的情况下，默认调用的时父类中同名同参的方法。--->体现了类优先原则\n\t *  \t\t>如果实现类实现的多个接口中声明了同名同参的方法。\n\t *  \t\t 实现类在没有重写此方法的情况下会报错(接口冲突)。此时实现类编写重写此方法\n\t *  \t\t>在实现类中调用接口中的默认方法 的格式：接口名.super.方法名\n\t *  \t\t>在实现类中调用接口中的静态方法 的格式：接口名.方法名  \t\t\n\t *  4.接口中不能定义构造器的！意味着接口不可以实例化\n\t *  5.Java开发中，接口通过让类去实现(implements)的方式来使用\n\t *  \t若实现类覆盖了接口中的所有的抽象方法，则此实现类就可以实例化\n\t *  \t若实现类没有覆盖接口中的所有的抽象方法，则此实现类只能是一个抽象类\n\t *  6.Java类可以实现多个接口 -->弥补了Java单继承性的局限性\n\t *  \t格式：class A extends b implements c,d,e{}\t\n\t *  7.接口的使用：\n\t *  \t>接口与接口之间可以继承，而且可以多继承\n\t *  \t>接口的具体使用，体现多态性\n\t *  \t>接口，实际上可以看做是一种规范\n\t *  \t>接口像多态性一样有着匿名的使用\n\t *  8.接口的应用：代理模式，工厂模式\n\t *\n \t * 类的内部成员之五：内部类\n \t *\t1.Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B被成为外部类\n \t *\t2.内部类的分类： 成员内部类(静态的，非静态的)  vs 局部内部类(方法内，代码内，构造器内的类)\n \t *\t3.成员内部类：\n \t *\t\t作为外部类的成员：\n \t *\t\t\t>调用外部类的结构\n     *\t\t\t>可以被static修饰\n     *\t\t\t>可以被4种不同的权限符修饰\n     *\t\t作为一个类：\n     *\t\t\t>类内可以定义属性，方法名，构造器等\n     *\t\t\t>可以被final修饰，表示此类不可以被继承\n     *\t\t\t>可以被abstract修饰\n     * 4.内部类的使用\n     * \t4.1  如何实例化成员内部类的对象\n     * \t\t①对于非静态内部类：父类名.内部类名  对象名 = new 父类名.内部类的构造方法;\n     * \t\t②对于静态内部类：先创建父类的对象：父类名 父对象名 = new 父类的构造方法();\n     * \t\t\t\t\t\t然后创建内部类的对象：父类名.内部类名  对象名 = 父对象名.new 内部类的构造方法;\n     * \t4.2  如何在成员内部类种区分调用外部类的结构\n     * \t\t① 当内部类的属姓名和方法名和外部类的相同时。调用格式如下\n     * \t\t\t调用外部类的属性和方法：外部类名.this.方法名/属性\n     * \t\t\t调用内部类的属性和方法：this.方法名/属性\n     * \t\t② 当内部类的属姓名和方法名和外部类的不相同时，直接调用即可，不用加前缀\n     *  4.3 开发中局部内部类的使用\n     * 5.注意点：当在一个方法A中定义一个内部类时，在这个内部类中再定义一个方法B。\n     * \t\t\t如果方法A中有一个变量。当方法B中想要使用这个变量时，这个变量不能被修改\n     * \t\t\t相当于一个常量。\n     * \t\tJDK 7及以前需要再这个变量前加final才能被方法B使用\n     * \t\tJDK 8及以后则不需要加final\n     * \t\t原因：内部类的字节码文件是会和外部类平级的，在内部类中调用的外部类的方法中的变量是一个副本，副本不能被改变\n     *\n```\n\n\n\n","categories":["Java学习","Java基础语法"]},{"title":"mysql学习","url":"/2020/12/14/尚硅谷说Java/数据库/mysql/","content":"mysql学习\n<!--more-->\n# 一、为什么要学习数据库\n\n**数据库的好处**\n\t1.持久化数据到本地\n\t2.可以实现结构化查询，方便管理\n\n# 二、数据库的相关概念\n\n​\t1、DB：数据库，保存一组有组织的数据的容器\n​\t2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据\n​\t3、SQL:结构化查询语言，用于和DBMS通信的语言\n\n#  三、数据库存储数据的特点\n\n​\t1、将数据放到表中，表再放到库中\n​\t2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。\n​\t3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。\n​\t4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”\n​\t5、表中的数据是按行存储的，每一行类似于java中的“对象”。\n\n# 四、初始MySQL\n\n## 4.1MySQL产品的介绍\n\n**SQL语言分类**\n\n​\t\t1、DML（Data Manipulation Language):数据操纵语句，用于添加、删除、修改、查询数据库记录，并检查数据完整性\n\n​\t\t2、DDL（Data Definition Language):数据定义语句，用于库和表的创建、修改、删除。\n\n​\t\t3、DCL（Data Control Language):数据控制语句，用于定义用户的访问权限和安全级别。\n\n**DML**\n\n​\t\tDML用于查询与修改数据记录，包括如下SQL语句：\n\n​\t\t\t\tINSERT：添加数据到数据库中\n\n​\t\t\t\tUPDATE：修改数据库中的数据\n\n​\t\t\t\tDELETE：删除数据库中的数据\n\n​\t\t\t\tSELECT：选择（查询）数据\n\n​\t\t\t\t\t\tSELECT是SQL语言的基础，最为重要\n\n**DDL**\n\n​\t\tDDL用于定义数据库的结构，比如创建、修改或删除数据库对象，包括如下SQL语句：\n\n​\t\t\t\tCREATE TABLE：创建数据库表\n\n​\t\t\t\tALTER TABLE：更改表结构、添加、删除、修改列长度\n\n​\t\t\t\tDROP TABLE：删除表\n\n​\t\t\t\tCREATE INDEX：在表上建立索引\n\n​\t\t\t\tDROP INDEX：删除索引\n\n**DCL**\n\n​\t\tDCL用来控制数据库的访问，包括如下SQL语句：\n\n​\t\t\t\tGRANT：授予访问权限\n\n​\t\t\t\tREVOKE：撤销访问权限\n\n​\t\t\t\tCOMMIT：提交事务处理\n\n​\t\t\t\tROLLBACK：事务处理回退\n\n​\t\t\t\tSAVEPOINT：设置保存点\n\n​\t\t\t\tLOCK：对数据库的特定部分进行锁定\n\n## 4.2MySQL产品的安装\n\nWindows平台下下载：http://dev.mysql.com/downloads/mysql \n\n下载社区版5版本的较为稳定\n\n## 4.3MySQL服务的启动和停止\n\n​\t方式一：计算机——右击管理——服务\n​\t方式二：通过管理员身份运行\n​\t\t\tnet start 服务名（启动服务）\n​\t\t\tnet stop 服务名（停止服务）\n\n## 4.4MySQL服务的登录和退出\n\n​\t方式一：通过mysql自带的客户端\t\t\t-->只限于root用户\n\n​\t方式二：通过windows自带的客户端\n​\t\t\t登录：\n​\t\t\t\t\tmysql 【-h主机名 -P端口号 】-u用户名 -p密码\t\t\n\n​\t\t\t\t\t例如：mysql -uroot -proot\n\n​\t\t\t退出：\n\n​\t\t\t\t\texit或ctrl+C\n\n## 4.5MySQL的常见命令和语法规范\n\n**常见命令**\n\n1.查看当前所有的数据库\n\n​\t\tshow databases;\n\n2.打开指定的库\n\n​\t\tuse 库名\n\n3.查看当前库的所有表\n\n​\t\tshow tables;\n\n4.查看其它库的所有表\n\n​\t\tshow tables from 库名\n\n5.创建表\n\t\tcreate table 表名(\n\n​\t\t\t\t列名 列类型,\n\n​\t\t\t\t列名 列类型，\n\n​\t\t\t\t。。。\n\n​\t\t);\n6.查看表结构\n\n​\t\tdesc 表名;\n\n7.查看服务器的版本\n\t\t方式一：登录到mysql服务端\n\t\t\t\t\tselect version();\n\t\t方式二：没有登录到mysql服务端\n\t\t\t\t\tmysql --version或mysql --V\n\n**语法规范**\n\n1.不区分大小写,但建议关键字大写，表名、列名小写\n2.每条命令最好用分号结尾\n3.每条命令根据需要，可以进行缩进 或换行\n4.注释\n\t单行注释：#注释文字\n\t单行注释：-- 注释文字\n\t多行注释：/* 注释文字  */\n\n## 4.6MYSQL的语言分类\n\nDQL（Data Query Language）：数据查询语言\n\tselect \nDML(Data Manipulate Language):数据操作语言\n\tinsert 、update、delete\nDDL（Data Define Languge）：数据定义语言\n\tcreate、drop、alter\nTCL（Transaction Control Language）：事务控制语言\n\tcommit、rollback\n\n## 4.7MYSQL的常见命令\n\n```MYS\nshow databases； 查看所有的数据库\nuse 库名； 打开指定 的库\nshow tables ; 显示库中的所有表\nshow tables from 库名;显示指定库中的所有表\ncreate table 表名(\n\t字段名 字段类型,\t\n\t字段名 字段类型\n); 创建表\n\ndesc 表名; 查看指定表的结构\nselect * from 表名;显示表中的所有数据\n```\n\n# 五、DQL语言的学习\n\n## 5.1基础查询\n\n一，语法：\n\tSELECT  要查询的东西  FROM  表名 ;\n\n​\t\t类似于Java中 :System.out.println(要打印的东西);\n二，特点：\n​\t①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在\n​\t② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数\n\n建议：<font color = \"red\">在执行SQL语句前先打开要执行的数据库</font>\n\n三，示例\n\n 1、查询单个字段\n   \t select 字段名 from 表名;\n\n```mysql\nUSE myemployees;\n# 查询工作表的工作名称\nSELECT\n\tjob_title \nFROM\n\tjobs;\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095615.png)\n\n2、查询多个字段\n    select 字段名，字段名 from 表名;\n\n```mysql\nUSE myemployees;\n#查询工作表的工作名称,最低工资，最高工资\nSELECT\n\tjob_title,\n\tmin_salary,\n\tmax_salary \nFROM\n\tjobs;\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095616.png)\n\n 3、查询所有字段\n        select * from 表名\n\n```mysql\nUSE myemployees;\n# 查询工作表的所有信息\n# 方式一\nSELECT\n\tjob_title,\n\tmin_salary,\n\tmax_salary,\n\tjob_id \nFROM\n\tjobs;\n# 方式二 用*号表示。缺点是查询后的顺序和原表的列的顺序相同，不够灵活\nSELECT\n\t* \nFROM\n\tjobs;\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095617.png)\n\n4、查询常量\n\t\tselect 常量值;\n\t\t注意：字符型和日期型的常量值必须用单引号引起来，数值型不需要\n\n```mysql\nUSE myemployees;\n    #\t查询100\nSELECT 100;\n    # 查询字符的常量值\nSELECT 'asd';\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095618.png)\n\n5、查询函数\n    select 函数名(实参列表);\n\n```mysql\nUSE myemployees;\n# 查询mysql的版本\nSELECT VERSION();\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095619.png)\n\n6、查询表达式\n\n```mysql\nUSE myemployees;\n# 查询100对99的余数\nselect 100%99;\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095620.png)\n\n7、起别名\n        ①as\n        ②空格\n\n​\t建议：<font color=\"red\">在别名上加双引号，以防止别名中有关键字等信息</font>\n\n```mysql\nUSE myemployees;\nSELECT min_salary as \"最低工资\",max_salary as \"最高工资\" from jobs;\n# 等价于\nSELECT min_salary \"最低工资\",max_salary \"最高工资\" from jobs;\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095621.png)\n\n 8、去重：distinct 关键字\n    \t格式：select distinct 字段名 from 表名;\n\n```mysql\nUSE myemployees;\n# 去重前\nselect department_id from employees;\n# 去重后\nselect DISTINCT department_id from employees;\n```\n\n​\t\t去重前：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095622.png)\n\n​\t\t去重后：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095623.png)\n\n 9、+\n    作用：做加法运算\n    select 数值+数值; 直接运算\n    select 字符+数值;先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成0，再做运算\n    select null+值;结果都为null\n\n```mysql\nUSE myemployees;\nSELECT 100+90;\nSELECT '123'+20;\nSELECT 'abd'+20;\nSELECT null + 20;\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095624.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095625.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095626.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095627.png)\n\n10、【补充】concat函数\n    功能：拼接字符\n    格式：select concat(字符1，字符2，字符3,...);\n\n```mysql\nUSE myemployees;\n# 查询员工名和性连接成一个字段，并显示为姓名\nSELECT CONCAT(last_name, first_name) AS \"姓名\" FROM employees;\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095628.png)\n\n11、【补充】ifnull函数\n    功能：判断某字段或表达式是否为null，如果为null 返回指定的值，否则返回原本的值\n\n```mysql\nUSE myemployees;\nSELECT\n\tIFNULL( commission_pct, 0 ) AS 奖金率,\n\tcommission_pct \nFROM\n\temployees;\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095629.png)\n\n 12、【补充】isnull函数\n    功能：判断某字段或表达式是否为null，如果是，则返回1，否则返回0\n\n```mysql\nUSE myemployees;\nSELECT\n\tISNULL(commission_pct)AS 奖金率,\n\tcommission_pct \nFROM\n\temployees;\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095630.png)\n\n## 5.2条件查询\n\n​\t\t条件查询：根据条件过滤原始表的数据，查询到想要的数据\n一，语法：\n​\t\tselect \n​\t\t\t\t要查询的字段|表达式|常量值|函数\n​\t\tfrom \n​\t\t\t\t表\n​\t\twhere \n​\t\t\t\t条件 ;\n\n​\t<font color = \"red\">执行的顺序：先找表，然后筛选条件，最后查询</font>\n\n二、筛选条件的分类\n\n1、简单条件运算符\n\n​\t<       大于\n\n​\t\\>       小于\n\n​\t=       等于 (不可以判断null)\n\n​\t<>    不等于 （相比!=，建议使用这个）\n\n​\t !=     不等于\n\n​\t \\>=    大于等于\n\n​\t<=    小于等于\n\n​\t<=>   安全等于 (可以判断null值)\n\n```mysql\n# 查询工资>12000的员工信息\nSELECT * FROM employees WHERE salary > 12000;\n# 查询部门编号补等于90的员工名和部门编号\nSELECT last_name, department_id FROM employees WHERE department_id <> 90;\n# 查询没有奖金的员工名和奖金率\nSELECT last_name,commission_pct FROM employees WHERE commission_pct <=> null;\n```\n\n2、逻辑运算符\n\tand（&&）:两个条件如果同时成立，结果为true，否则为false\n\tor(||)：\t两个条件只要有一个成立，结果为true，否则为false\n\tnot(!)：\t如果条件成立，则not后为false，否则为true\n\n推荐使用and,or,not\n\n```mysql\n# 查询部门编号不是在90到110之间，或者工资高于15000的员工信息\nSELECT * from employees \nWHERE not(department_id>=90 AND department_id<=110) OR salary>15000;\n```\n\n3、模糊查询\n\tlike:\t\t\t一般搭配通配符使用，可以判断字符型或数值型 (支持转义字符\\\\)(5版本以后支持查询数值型)\n\t\t\t\t通配符：%任意多个字符(包含0个字符)，_任意单个字符 \n\n​\tbetween  a  and\tb\t 表示匹配在a到b之间的(包含a,b)\t\n\n​\tin（...）\t\t\t\t\t\t判断某字段的值是否等于in列表中的某一项(匹配的依据是=)\t\t\t\t\t\t\t\n\n​\tis null  \t\t\t\t\t\t为空        因为=不能判断null，因此延申出这两个\n\n​\tis not null\t\t\t\t   不为空\n\n```mysql\n# 查询所有员工名字中含有字符a的员工信息\nSELECT * from employees WHERE last_name like \"%a%\";\n# 查询部门编号为1开头三位数字的员工信息\nSELECT * FROM employees WHERE department_id LIKE \"1__\";\n# 查询员工名中第三个字母为n，第五个字符为l的员工信息\nSELECT * FROM employees WHERE last_name LIKE \"__n_l%\";\n# 查询员工名中第二个字符是下划线的员工信息\n# ESCAPE \"$\" 表示赋予$字符具有转义的作用\nSELECT * FROM employees WHERE last_name LIKE \"_$_%\" ESCAPE \"$\";\n# 查询员工编号在100到120之间的员工信息\nSELECT * FROM employees WHERE employee_id BETWEEN 100 AND 120;\n# 查询某员工部编号为AD_PRES,AD_VP,IT_PROG中的某一项的员工信息\nSELECT * FROM employees WHERE job_id in(\"AD_PRES\",\"AD_VP\",\"IT_PROG\"); \n# 查询没有奖金的员工名和奖金率\nSELECT last_name,commission_pct FROM employees WHERE commission_pct is NULL;\n# 查询有奖金的员工名和奖金率\nSELECT last_name,commission_pct FROM employees WHERE commission_pct is not NULL;\n```\n\nis null 与<=>的区别\n\nis null \t\t仅可以判断null值，可读性较高，建议使用\n\n<=>         既可以判断null值，也可以判断普通的值，可读性低\n\n\n\n#### 转移关键字ESCAPE\n\n```mysql\n# 查询员工名中第二个字符是下划线的员工信息\n# ESCAPE \"$\" 表示赋予$字符具有转义的作用\nSELECT * FROM employees WHERE last_name LIKE \"_$_%\" ESCAPE \"$\";\n```\n\n## 5.3排序查询\n\n一，语法：\n\tselect\n\t\t要查询的东西\n\tfrom\n\t\t表名\n\twhere \n\t\t条件\n\n​\torder by 排序的字段|表达式|函数|别名 【asc|desc】\n\n二，特点\n\n​\t1、asc ：升序，如果不写默认升序\n \t\t  desc：降序\n\n​\t2、排序列表 支持 单个字段、多个字段、函数、表达式、别名\n\n​\t3、order by的位置一般放在查询语句的最后（除limit语句之外）\n\n三，示例\n\n```mysql\n# 查询员工信息，要求工资从高到低排序\nselect * from employees ORDER BY salary DESC;\n# 查询员工信息，要求工资从高到低排序\nselect * from employees ORDER BY salary ASC;\n# 按年薪的高低显示员工名和年薪 【按表达式排序】\nSELECT last_name, salary * 12 * (1+IFNULL(commission_pct,0)) as \"年薪\"\nfrom employees\nORDER BY salary * 12 * (1+IFNULL(commission_pct,0));\n# 按年薪的高低显示员工名和年薪 【按别名排序】\nSELECT last_name, salary * 12 * (1+IFNULL(commission_pct,0)) as 年薪\nfrom employees\nORDER BY 年薪;\n# 按员工名的长度升序排列\nselect length(last_name) ,last_name from employees\nORDER BY LENGTH(last_name);\n# 先按员工的部门编号升序排序，再工资进行降序排序\nselect * from employees\nORDER BY department_id ASC , salary DESC;\n```\n\n## 5.4常见函数\n\n**一、概述**\n\t\t功能：类似于java中的方法\n\t\t好处：提高重用性和隐藏实现细节\n\t\t调用：select 函数名(实参列表);\n\n**二，分类：**\n\n​\t\t1、单行函数\n\n​\t\t\t\t如 concat、length、ifnull等\n\n​\t\t2、分组函数\n\n​\t\t\t\t功能：做统计使用，又称为统计函数、聚合函数、组函数\n\n**三、单行函数**\n\t1、字符函数\n\n​\t\t\tlength(str)：获取字节个数(utf-8一个汉字代表3个字节,gbk为2个字节)\n\n​\t\t\tconcat(str1,str2,...)：连接字符串\n\n​\t\t\tsubstr(str,pos,len)：截取子串，从下标为pos开始，长度为len。len不写时默认到最后\n\n​\t\t\tupper(str)：变大写\n\n​\t\t\tlower(str)：变小写\n\n​\t\t\treplace(str,from_str,to_str)：将str中的from_str替换成to_str\n\n​\t\t\ttrim([remstr FROM] str)：去除str前面和后面的remstr字符串。remstr默认为 空格\n\n​\t\t\tlpad(str,len,padstr)：对str左填充padstr字符使其字符数量为len\n\n​\t\t\trpad(str,len,padstr)：对str右填充padstr字符使其字符数量为len\n\n​\t\t\tinstr(str,substr)：获取子串第一次出现的索引\n\n```mysql\n#1.length 获取参数值的字节个数\nSELECT LENGTH('john');-- 4\nSELECT LENGTH('张三丰hahaha');-- 15\n# 查看字符编码\nSHOW VARIABLES LIKE '%char%';\n\n#2.concat 拼接字符串\n# 将员工名的第一个字母大写并与剩下的字符用-拼接\nSELECT CONCAT(last_name,'_',first_name) 姓名 FROM employees;\n\n#3.upper、lower\nSELECT UPPER('john');-- JOHN\nSELECT LOWER('joHn');-- john\n#示例：将姓变大写，名变小写，然后拼接\nSELECT CONCAT(UPPER(last_name),LOWER(first_name))  姓名 FROM employees;\n\n#4.substr、substring\n# 注意：索引从1开始\n#截取从指定索引处后面所有字符\nSELECT SUBSTR('李莫愁爱上了陆展元',7)  out_put; -- 陆展元\n#截取从指定索引处指定字符长度的字符\nSELECT SUBSTR('李莫愁爱上了陆展元',1,3) out_put;-- 李莫愁\n#案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来\nSELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),'_',LOWER(SUBSTR(last_name,2)))  out_put\nFROM employees;\n\n#5.instr 返回子串第一次出现的索引，如果找不到返回0\nSELECT INSTR('杨不殷六侠悔爱上了殷六侠','殷八侠') AS out_put;-- 0\n\n#6.trim\nSELECT LENGTH(TRIM('    张翠山    ')) AS out_put;-- 9\n# 输出 a张aaaaaaaaaaaa翠山a\nSELECT TRIM('aa' FROM 'aaaaaaaaa张aaaaaaaaaaaa翠山aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')  AS out_put;\n\n#7.lpad 用指定的字符实现左填充指定长度\nSELECT LPAD('殷素素',2,'*') AS out_put;-- 殷素\n\n#8.rpad 用指定的字符实现右填充指定长度\nSELECT RPAD('殷素素',12,'ab') AS out_put;-- 殷素素ababababa\n\n#9.replace 替换\n# 赵敏赵敏赵敏赵敏张无忌爱上了赵敏\nSELECT REPLACE('周芷若周芷若周芷若周芷若张无忌爱上了周芷若','周芷若','赵敏') AS out_put;\n```\n\n​\t2、数学函数\n​\t\t\tround(X,D)：四舍五入 ，D表示小数点后几位\n\n​\t\t\tmod(N,M)：取模\n\n​\t\t\tceil(X)：向上取整，返回>=该参数的最小整数\t\t\n\n​\t\t\tfloor(X)：向下取整，返回<=该参数的最大整数\n\n​\t\t\ttruncate(X,D)：截断，D是保留小数的位数。\n\n​\t\t\trand()：获取随机数，返回0-1之间的小数\n\n```mysql\n#round 四舍五入\nSELECT ROUND(-1.55);-- -2\nSELECT ROUND(1.567,2);-- 1.57\n\n#ceil 向上取整,返回>=该参数的最小整数\nSELECT CEIL(-1.02);-- -1\n\n#floor 向下取整，返回<=该参数的最大整数\nSELECT FLOOR(-9.99);-- -10\n\n#truncate 截断\nSELECT TRUNCATE(1.69999,1);-- 1.6\n\n#mod取余\n/*\nmod(a,b) ：  a-a/b*b\n\nmod(-10,-3):-10- (-10)/(-3)*（-3）=-1\n*/\nSELECT MOD(10,-3);-- 1\nSELECT 10%3;-- 1\n```\n\n​\t3、日期函数\n\n​\t\t\tnow：返回当前日期+时间\n\n​\t\t\tyear:返回年\n\n​\t\t\tmonth：返回月\n\n​\t\t\tday:返回日\n\n​\t\t\thour:小时\n\n​\t\t\tminute:分钟\n\n​\t\t\tsecond：秒\n\n​\t\t\tdate_format(date,format)：将日期转换成字符\n\n​\t\t\tcurdate：返回当前日期\n\n​\t\t\tstr_to_date(str,format)：将字符转换成日期\n\n​\t\t\tcurtime：返回当前时间\n\n​\t\t\tdatediff(expr1,expr2)：返回两个日期相差的天数\n\n​\t\t\tmonthname(date)：以英文形式返回月\n\n```mysql\n#now 返回当前系统日期+时间\nSELECT NOW();\n\n#curdate 返回当前系统日期，不包含时间\nSELECT CURDATE();\n\n#curtime 返回当前时间，不包含日期\nSELECT CURTIME();\n\n#可以获取指定的部分，年、月、日、小时、分钟、秒\nSELECT YEAR(NOW()) 年;\nSELECT YEAR('1998-1-1') 年;\nSELECT  YEAR(hiredate) 年 FROM employees;\nSELECT MONTH(NOW()) 月;\nSELECT MONTHNAME(NOW()) 月;\n\n#str_to_date 将字符通过指定的格式转换成日期\nSELECT STR_TO_DATE('1998-3-2','%Y-%c-%d') AS out_put;\n\n#查询入职日期为1992--4-3的员工信息\nSELECT * FROM employees WHERE hiredate = '1992-4-3';\n# 另一种写法\nSELECT * FROM employees WHERE hiredate = STR_TO_DATE('4-3 1992','%c-%d %Y');\n\n#date_format 将日期转换成字符\nSELECT DATE_FORMAT(NOW(),'%y年%m月%d日') AS out_put;\n\n#查询有奖金的员工名和入职日期(xx月/xx日 xx年)\nSELECT last_name,DATE_FORMAT(hiredate,'%m月/%d日 %y年') 入职日期\nFROM employees\nWHERE commission_pct IS NOT NULL;\n```\n\n​\t4、其他函数\n​\t\t\tversion ：当前数据库服务器的版本\n​\t\t\tdatabase： 当前打开的数据库\n​\t\t\tuser：当前用户\n​\t\t\tpassword('字符')：返回该字符的密码形式\n​\t\t\tmd5('字符'):返回该字符的md5加密形式\n\n```mysql\nSELECT VERSION();\nSELECT DATABASE();\nSELECT USER();\nselect password(\"123456\");-- *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9\nselect md5(\"123456\");-- e10adc3949ba59abbe56e057f20f883e\n```\n\n​\t5、流程控制函数\n\n​\t\t\t①if(条件表达式，表达式1，表达式2)：如果条件表达式成立，返回表达式1，否则返回表达式2\n​\t\t\t②case情况1:类似Java的switch case\n​\t\t\t\tcase 变量或表达式或字段\n​\t\t\t\twhen 常量1 then 值1\n​\t\t\t\twhen 常量2 then 值2\n​\t\t\t\t...\n​\t\t\t\telse 值n\n​\t\t\t\tend\n\n​\t\t\t③case情况2:类似Java的多重if else\n​\t\t\t\tcase \n​\t\t\t\twhen 条件1 then 值1\n​\t\t\t\twhen 条件2 then 值2\n​\t\t\t\t...\n​\t\t\t\telse 值n\n​\t\t\t\tend\n\n```mysql\n#五、流程控制函数\n#1.if函数： if else 的效果\nSELECT IF(10<5,'大','小');\n# 查询员工名，员工奖金，备注，备注中如果员工有奖金则输出有奖金，嘻嘻，否则输出没奖金，呵呵\nSELECT last_name,commission_pct,IF(commission_pct IS NULL,'没奖金，呵呵','有奖金，嘻嘻') 备注\nFROM employees;\n\n#2.case函数的使用一： switch case 的效果\n/*\n    java中\n        switch(变量或表达式){\n            case 常量1：语句1;break;\n            ...\n            default:语句n;break;\n\n\n        }\n    mysql中\n        case 要判断的字段或表达式\n        when 常量1 then 要显示的值1或语句1;\n        when 常量2 then 要显示的值2或语句2;\n        ...\n        else 要显示的值n或语句n;\n        end\n*/\n\n/*案例：查询员工的工资，要求\n    部门号=30，显示的工资为1.1倍\n    部门号=40，显示的工资为1.2倍\n    部门号=50，显示的工资为1.3倍\n    其他部门，显示的工资为原工资\n*/\nSELECT salary 原始工资,department_id,\nCASE department_id\nWHEN 30 THEN salary*1.1\nWHEN 40 THEN salary*1.2\nWHEN 50 THEN salary*1.3\nELSE salary\nEND AS 新工资\nFROM employees;\n\n#3.case 函数的使用二：类似于 多重if\n/*\n    java中：\n        if(条件1){\n            语句1；\n        }else if(条件2){\n            语句2；\n        }\n        ...\n        else{\n            语句n;\n        }\n    mysql中：\n        case \n        when 条件1 then 要显示的值1或语句1\n        when 条件2 then 要显示的值2或语句2\n        。。。\n        else 要显示的值n或语句n\n        end\n*/\n\n/*案例：查询员工的工资的情况\n\t如果工资>20000,显示A级别\n\t如果工资>15000,显示B级别\n\t如果工资>10000，显示C级别\n\t否则，显示D级别\n*/\nSELECT salary,\nCASE \nWHEN salary>20000 THEN 'A'\nWHEN salary>15000 THEN 'B'\nWHEN salary>10000 THEN 'C'\nELSE 'D'\nEND AS 工资级别\nFROM employees;\n```\n\n**四、分组函数**\n\t1、分类\n\t\t\tmax 最大值\n\t\t\tmin 最小值\n\t\t\tsum 和\n\t\t\tavg 平均值\n\t\t\tcount 计算个数\n\n​\t2、特点\n\n​\t\t①语法\n​\t\t\tselect max(字段) from 表名;\n\n​\t\t②支持的类型\n​\t\t\tsum和avg一般用于处理数值型\n​\t\t\tmax、min、count可以处理任何数据类型\n\n​\t\t③以上分组函数都忽略null\n​\t\t④都可以搭配distinct使用，实现去重的统计\n​\t\t\tselect sum(distinct 字段) from 表;\n​\t\t⑤count函数\n​\t\t\tcount(字段)：统计该字段非空值的个数\n​\t\t\tcount(*)：统计结果集的行数\n\n效率上：\n\t\t5版本前 MyISAM存储引擎，count(*)最高\n\t\t5版本后 InnoDB存储引擎，count(*)和count(1)效率>count(字段)\n\n​\t\t⑥ 和分组函数一同查询的字段，要求是group by后出现的字段\n\n```mysql\n/*\n\t功能：用作统计使用，又称为聚合函数或统计函数或组函数\n\n    分类：\n    sum 求和、avg 平均值、max 最大值 、min 最小值 、count 计算个数\n\n    特点：\n    1、sum、avg一般用于处理数值型\n       max、min、count可以处理任何类型\n    2、以上分组函数都忽略null值\n    3、可以和distinct搭配实现去重的运算\n    4、count函数的单独介绍\n    \t一般使用count(*)用作统计行数\n    5、和分组函数一同查询的字段要求是group by后的字段\n*/\n# 1、简单 的使用\nSELECT SUM(salary) FROM employees;\nSELECT AVG(salary) FROM employees;\nSELECT MIN(salary) FROM employees;\nSELECT MAX(salary) FROM employees;\nSELECT COUNT(salary) FROM employees;\n\nSELECT SUM(salary) 和,AVG(salary) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数\nFROM employees;\n\nSELECT SUM(salary) 和,ROUND(AVG(salary),2) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数\nFROM employees;\n\n# 2、参数支持哪些类型\nSELECT SUM(last_name) ,AVG(last_name) FROM employees;-- 查询无结果\nSELECT SUM(hiredate) ,AVG(hiredate) FROM employees;\nSELECT MAX(last_name),MIN(last_name) FROM employees;\n\nSELECT MAX(hiredate),MIN(hiredate) FROM employees;\n\nSELECT COUNT(commission_pct) FROM employees;\nSELECT COUNT(last_name) FROM employees;\n\n# 3、是否忽略null\nSELECT SUM(commission_pct) ,AVG(commission_pct),SUM(commission_pct)/35,SUM(commission_pct)/107 FROM employees;\n\nSELECT MAX(commission_pct) ,MIN(commission_pct) FROM employees;\n\nSELECT COUNT(commission_pct) FROM employees;-- 35\nSELECT commission_pct FROM employees;-- 107条数据\n\n# 4、和distinct搭配\nSELECT SUM(DISTINCT salary),SUM(salary) FROM employees;\n\nSELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees;\n\n# 5、count函数的详细介绍\nSELECT COUNT(salary) FROM employees;\n\nSELECT COUNT(*) FROM employees;\n\nSELECT COUNT(1) FROM employees;\n/*效率：\n\tMYISAM存储引擎下  ，COUNT(*)的效率高\n\tINNODB存储引擎下，COUNT(*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些\n*/\n\n#6、和分组函数一同查询的字段有限制\nSELECT AVG(salary),employee_id  FROM employees;-- 无法运行\n```\n\n## 5.5分组查询\n\n**一、语法**\n\t\tselect 分组函数，分组后的字段\n\t\tfrom 表\n\t\t【where 筛选条件】\n\t\tgroup by 分组的字段\n\t\t【having 分组后的筛选】\n\t\t【order by 排序列表】\n\n**二、特点**\n\n1、和分组函数一同查询的字段必须是group by后出现的字段\n2、筛选分为两类：分组前筛选和分组后筛选\n\n​\t\t\t\t\t\t使用关键字\t\t筛选的表\t\t\t\t\t位置\n\n分组前筛选\twhere\t\t\t\t原始表\t\t\t\t\t\tgroup by的前面\n分组后筛选\thaving\t\t\t\t分组后的结果\t\t\tgroup by 的后面\n\n3、分组可以按单个字段也可以按多个字段\n\n4、可以搭配着排序使用\n\n​\t问题1：分组函数做筛选能不能放在where后面\n​\t\t\t\t答：不能\n\n​\t问题2：where——group by——having\n\n​\t\t\t\t一般来讲，能用分组前筛选的，尽量使用分组前筛选，提高效率\n\n```mysql\n#引入：查询每个部门的员工个数\nSELECT COUNT(*) FROM employees WHERE department_id=90;-- 3\n\n#1.简单的分组\n#案例1：查询每个工种的员工平均工资\nSELECT AVG(salary),job_id\nFROM employees\nGROUP BY job_id;\n#案例2：查询每个位置的部门个数\nSELECT COUNT(*),location_id\nFROM departments\nGROUP BY location_id;\n\n#2、可以实现分组前的筛选\n#案例1：查询邮箱中包含a字符的 每个部门的最高工资\nSELECT MAX(salary),department_id\nFROM employees\nWHERE email LIKE '%a%'\nGROUP BY department_id;\n#案例2：查询有奖金的每个领导手下员工的平均工资\nSELECT AVG(salary),manager_id\nFROM employees\nWHERE commission_pct IS NOT NULL\nGROUP BY manager_id;\n\n#3、分组后筛选\n#案例：查询哪个部门的员工个数>5\n\t#①查询每个部门的员工个数\n\tSELECT COUNT(*),department_id\n\tFROM employees\n\tGROUP BY department_id;\n\t#② 筛选刚才①结果\n\tSELECT COUNT(*),department_id\n\tFROM employees\n\tGROUP BY department_id\n\tHAVING COUNT(*)>5;\n#案例2：每个工种有奖金的员工的最高工资>12000的工种编号和最高工资\nSELECT job_id,MAX(salary)\nFROM employees\nWHERE commission_pct IS NOT NULL\nGROUP BY job_id\nHAVING MAX(salary)>12000;\n#案例3：领导编号>102的每个领导手下的最低工资大于5000的领导编号和最低工资\nSELECT manager_id,MIN(salary)\nFROM employees\nwhere manager_id > 102\nGROUP BY manager_id\nHAVING MIN(salary)>5000;\n\n#4.添加排序\n#案例：每个工种有奖金的员工的最高工资>6000的工种编号和最高工资,按最高工资升序\nSELECT job_id,MAX(salary) m\nFROM employees\nWHERE commission_pct IS NOT NULL\nGROUP BY job_id\nHAVING m>6000\nORDER BY m ;\n\n#5.按多个字段分组\n#案例：查询每个工种每个部门的最低工资,并按最低工资降序\nSELECT MIN(salary),job_id,department_id\nFROM employees\nGROUP BY department_id,job_id\nORDER BY MIN(salary) DESC;\n```\n\n## 5.6连接查询\n\n**一、含义**\n\n当查询中涉及到了多个表的字段，需要使用多表连接\n\n​\t\tselect 字段1，字段2\n\n​\t\tfrom 表1，表2,...; 但是此语句会使显示的语句具有笛卡尔乘积现象\n\n笛卡尔乘积：当查询多个表时，没有添加有效的连接条件，导致多个表所有行实现完全连接\n\n​\t\t即：表1 有m行，表2有n行，结果=m*n行\n\n发生原因：没有有效的连接条件\n\n如何解决：添加有效的连接条件\n\n**二、分类**\n\n按年代分类：\n\n​\tsql92：等值，非等值，自连接，也支持一部分外连接（用于oracle、sqlserver，mysql不支持）\n\n​\tsql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接\n\n按功能分类：\n\n​\t\t\t内连接：等值连接，非等值连接，自连接\n\n​\t\t\t外连接：左外连接，右外连接，全外连接（mysql不支持）\n\n​\t\t\t交叉连接\n\n**三、SQL92语法**\n\n​\t\t1、等值连接\n\n​\t\t\t\t语法：\n\n​\t\t\t\t\t\tselect 查询列表\n\n​\t\t\t\t\t\tfrom 表1 别名,表2 别名\n\n​\t\t\t\t\t\twhere 表1.key=表2.key\n\n​\t\t\t\t\t\t【and 筛选条件】\n\n​\t\t\t\t\t\t【group by 分组字段】\n\n​\t\t\t\t\t\t【having 分组后的筛选】\n\n​\t\t\t\t\t\t【order by 排序字段】\n\n​\t\t\t\t特点：\n\n​\t\t\t\t\t\t① 一般为表起别名\n\n​\t\t\t\t\t\t②多表的顺序可以调换\n\n​\t\t\t\t\t\t③n表连接至少需要n-1个连接条件\n\n​\t\t\t\t\t\t④等值连接的结果是多表的交集部分\n\n​\t\t\t\t\t\t⑤ 可以搭配前面介绍的所有子句使用，比如排序、分组、筛选\n\n```mysql\n#1、等值连接\n#案例1：查询女神名和对应的男神名\nSELECT NAME,boyName \nFROM boys,beauty\nWHERE beauty.boyfriend_id= boys.id;\n#案例2：查询员工名和对应的部门名\nSELECT last_name,department_name\nFROM employees,departments\nWHERE employees.`department_id`=departments.`department_id`;\n\n#2、为表起别名\n/*\n\t①提高语句的简洁度\n\t②区分多个重名的字段\n\t注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定\n*/\n#查询员工名、工种号、工种名\nSELECT e.last_name,e.job_id,j.job_title\nFROM employees  e,jobs j\nWHERE e.`job_id`=j.`job_id`;\n\n#3、两个表的顺序是否可以调换\n#查询员工名、工种号、工种名\nSELECT e.last_name,e.job_id,j.job_title\nFROM jobs j,employees e\nWHERE e.`job_id`=j.`job_id`;\n\n#4、可以加筛选\n#案例：查询有奖金的员工名、部门名\nSELECT last_name,department_name,commission_pct\nFROM employees e,departments d\nWHERE e.`department_id`=d.`department_id`\nAND e.`commission_pct` IS NOT NULL;\n#案例2：查询城市名中第二个字符为o的部门名和城市名\nSELECT department_name,city\nFROM departments d,locations l\nWHERE d.`location_id` = l.`location_id`\nAND city LIKE '_o%';\n\n#5、可以加分组\n#案例1：查询每个城市的部门个数\nSELECT COUNT(*) 个数,city\nFROM departments d,locations l\nWHERE d.`location_id`=l.`location_id`\nGROUP BY city;\n#案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资\nSELECT department_name,d.`manager_id`,MIN(salary)\nFROM departments d,employees e\nWHERE d.`department_id`=e.`department_id`\nAND commission_pct IS NOT NULL\nGROUP BY department_name,d.`manager_id`;\n#6、可以加排序\n#案例：查询每个工种的工种名和员工的个数，并且按员工个数降序\nSELECT job_title,COUNT(*)\nFROM employees e,jobs j\nWHERE e.`job_id`=j.`job_id`\nGROUP BY job_title\nORDER BY COUNT(*) DESC;\n\n#7、可以实现三表连接？\n#案例：查询员工名、部门名和所在的城市\nSELECT last_name,department_name,city\nFROM employees e,departments d,locations l\nWHERE e.`department_id`=d.`department_id`\nAND d.`location_id`=l.`location_id`\nAND city LIKE 's%'\nORDER BY department_name DESC;\n```\n\n​\t\t2、非等值连接\n\n​\t\t\t\t语法：\n\n​\t\t\t\t\t\tselect 查询列表\n\n​\t\t\t\t\t\tfrom 表1 别名,表2 别名\n\n​\t\t\t\t\t\twhere 非等值的连接条件\n\n​\t\t\t\t\t\t【and 筛选条件】\n\n​\t\t\t\t\t\t【group by 分组字段】\n\n​\t\t\t\t\t\t【having 分组后的筛选】\n\n​\t\t\t\t\t\t【order by 排序字段】\n\n```mysql\n#案例1：查询员工的工资和工资级别\nSELECT salary,grade_level\nFROM employees e,job_grades g\nWHERE salary BETWEEN g.`lowest_sal` AND g.`highest_sal`\nAND g.`grade_level`='A';\n```\n\n​\t\t3、自连接\n\n​\t\t\t\t语法：\n\n​\t\t\t\t\t\tselect 查询列表\n\n​\t\t\t\t\t\tfrom 表 别名1,表 别名2\n\n​\t\t\t\t\t\twhere 等值的连接条件\n\n​\t\t\t\t\t\t【and 筛选条件】\n\n​\t\t\t\t\t\t【group by 分组字段】\n\n​\t\t\t\t\t\t【having 分组后的筛选】\n\n​\t\t\t\t\t\t【order by 排序字段】\n\n```mysql\n#案例：查询 员工名和上级的名称.\nSELECT e.employee_id,e.last_name,m.employee_id,m.last_name\nFROM employees e,employees m\nWHERE e.`manager_id`=m.`employee_id`;\n```\n\n**四、SQL99语法**\n\n​\t\t\t\t\tselect 查询列表\n\n​\t\t\t\t\tfrom 表1 别名\n\n​\t\t\t\t\t【<font color=\"red\">连接类型</font>】 join 表2 别名 on 连接条件\n\n​\t\t\t\t\t【where 筛选条件】\n\n​\t\t\t\t\t【group by 分组列表】\n\n​\t\t\t\t\t【having 分组后的筛选】\n\n​\t\t\t\t\t【order by 排序列表】\n\n​\t\t1、内连接：inner\n\n​\t\t\t\t语法：\n\n​\t\t\t\t\tselect 查询列表\n\n​\t\t\t\t\tfrom 表1 别名\n\n​\t\t\t\t\t【<font color=\"red\">inner</font>】 join 表2 别名 on 连接条件\n\n​\t\t\t\t\t【where 筛选条件】\n\n​\t\t\t\t\t【group by 分组列表】\n\n​\t\t\t\t\t【having 分组后的筛选】\n\n​\t\t\t\t\t【order by 排序列表】\n\n​\t\t\t\t\t【limit 子句】;\n\n​\t\t\t\t特点：\n\n​\t\t\t\t\t① 添加排序、分组、筛选\n\n​\t\t\t\t\t② inner可以省略\n\n​\t\t\t\t\t③ 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读\n\n​\t\t\t\t\t④ inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集\n\n​\t\t\t\t\t⑤ 表的顺序可以调换\n\n​\t\t\t\t\t⑥ n表连接至少需要n-1个连接条件\n\n​\t\t\t\t分类：等值连接；非等值连接；自连接；\n\n效果图：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095631.png)\n\n```mysql\n#1、等值连接\n\t#案例1.查询员工名、部门名\n\t\tSELECT last_name,department_name\n\t\tFROM departments d\n\t\t JOIN  employees e\n\t\tON e.`department_id` = d.`department_id`;\n\t#案例2.查询名字中包含e的员工名和工种名（添加筛选）\n\t\tSELECT last_name,job_title\n\t\tFROM employees e\n\t\tINNER JOIN jobs j\n\t\tON e.`job_id`=  j.`job_id`\n\t\tWHERE e.`last_name` LIKE '%e%';\n\t#3. 查询部门个数>3的城市名和部门个数，（添加分组+筛选）\n\t\t#①查询每个城市的部门个数\n\t\t#②在①结果上筛选满足条件的\n\t\tSELECT city,COUNT(*) 部门个数\n\t\tFROM departments d\n\t\tINNER JOIN locations l\n\t\tON d.`location_id`=l.`location_id`\n\t\tGROUP BY city\n\t\tHAVING COUNT(*)>3;\n\t#案例4.查询哪个部门的员工个数>3的部门名和员工个数，并按个数降序（添加排序）\n\t\t#①查询每个部门的员工个数\n\t\tSELECT COUNT(*),department_name\n\t\tFROM employees e\n\t\tINNER JOIN departments d\n\t\tON e.`department_id`=d.`department_id`\n\t\tGROUP BY department_name\n\t\t#② 在①结果上筛选员工个数>3的记录，并排序\n\t\tSELECT COUNT(*) 个数,department_name\n\t\tFROM employees e\n\t\tINNER JOIN departments d\n\t\tON e.`department_id`=d.`department_id`\n\t\tGROUP BY department_name\n\t\tHAVING COUNT(*)>3\n\t\tORDER BY COUNT(*) DESC;\n\t#5.查询员工名、部门名、工种名，并按部门名降序（添加三表连接）\n\t\tSELECT last_name,department_name,job_title\n\t\tFROM employees e\n\t\tINNER JOIN departments d ON e.`department_id`=d.`department_id`\n\t\tINNER JOIN jobs j ON e.`job_id` = j.`job_id`\n\t\tORDER BY department_name DESC;\n\n#二）非等值连接\n\t#查询员工的工资级别\n\t\tSELECT salary,grade_level\n\t\tFROM employees e\n\t\tJOIN job_grades g\n\t\tON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`;\n\t#查询工资级别的个数>20的个数，并且按工资级别降序\n\t\tSELECT COUNT(*),grade_level\n\t\tFROM employees e\n\t\tJOIN job_grades g\n\t\tON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`\n\t\tGROUP BY grade_level\n\t\tHAVING COUNT(*)>20\n\t\tORDER BY grade_level DESC;\n \n#三）自连接\n\t#查询员工的名字、上级的名字\n\t\tSELECT e.last_name,m.last_name\n\t\tFROM employees e\n\t\tJOIN employees m\n\t\tON e.`manager_id`= m.`employee_id`;\n\t#查询姓名中包含字符k的员工的名字、上级的名字\n\t\tSELECT e.last_name,m.last_name\n\t\tFROM employees e\n\t\tJOIN employees m\n\t\tON e.`manager_id`= m.`employee_id`\n\t\tWHERE e.`last_name` LIKE '%k%';\n```\n\n​\t\t2、外连接\n\n​\t\t\t\t应用场景：用于查询一个表中有，另一个表没有的记录\n\n​\t\t\t\t语法：\n\n​\t\t\t\t\tselect 查询列表\n\n​\t\t\t\t\tfrom 表1 别名\n\n​\t\t\t\t\t<font color=\"red\">left|right|full【outer】</font> join 表2 别名 on 连接条件\n\n​\t\t\t\t\t【where 筛选条件】\n\n​\t\t\t\t\t【group by 分组列表】\n\n​\t\t\t\t\t【having 分组后的筛选】\n\n​\t\t\t\t\t【order by 排序列表】\n\n​\t\t\t\t\t【limit 子句】;\n\n​\t\t\t\t特点：\n\n​\t\t\t\t\t① 外连接的查询结果为主表中的所有记录\n\n​\t\t\t\t\t\t\t如果从表和它匹配的将显示匹配行，\n\n​\t\t\t\t\t\t\t如果从表没有匹配的则显示null\n\n​\t\t\t\t\t② left join 左边的就是主表，right join 右边的就是主表，full join 两边都是主表\n\n​\t\t\t\t\t③ 一般用于查询除了交集部分的剩余的不匹配的行\n\n​\t\t\t\t\t④ 左外和右外交换两个表的顺序，可以实现同样的效果 \n\n​\t\t\t\t\t⑤ 全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的\n\n效果图：\n\n​\t左外连接：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095632.png)\n\n​\t右外连接：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095633.png)\n\n​\t全连接：![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095634.png)\n\n```mysql\n#左外连接\n\tSELECT b.*,bo.*\n\tFROM boys bo\n\tLEFT OUTER JOIN beauty b\n\tON b.`boyfriend_id` = bo.`id`\n\tWHERE b.`id` IS NULL;\n#案例1：查询哪个部门没有员工\n\t#左外\n\tSELECT d.*,e.employee_id\n\tFROM departments d\n\tLEFT OUTER JOIN employees e\n\tON d.`department_id` = e.`department_id`\n\tWHERE e.`employee_id` IS NULL;\n\t#右外\n\tSELECT d.*,e.employee_id\n\tFROM employees e\n\tRIGHT OUTER JOIN departments d\n\tON d.`department_id` = e.`department_id`\n\tWHERE e.`employee_id` IS NULL;\n#全外\nUSE girls;\nSELECT b.*,bo.*\nFROM beauty b\nFULL OUTER JOIN boys bo\nON b.`boyfriend_id` = bo.id;\n```\n\n​\t\t3、交叉连接\n\n​\t\t\t\t语法：\n\n​\t\t\t\t\tselect 查询列表\n\n​\t\t\t\t\tfrom 表1 别名\n\n​\t\t\t\t\t<font color=\"red\">cross</font> join 表2 别名;\n\n​\t\t\t\t特点：\n​\t\t\t\t\t类似于笛卡尔乘积\n\n```mysql\nSELECT b.*,bo.*\nFROM beauty b\nCROSS JOIN boys bo;\n```\n\n**比较**\n\n​\t\t功能：sql99支持的较多\n​\t\t可读性：sql99实现连接条件和筛选条件的分离，可读性较高\n\n## 5.7子查询\n\n**一，含义：**\n\n​\t\t出现在其他语句中的select语句，称为子查询或内查询。\n​\t\t外部的查询语句，称为主查询或外查询。\n\n**二，分类**\n\n按子查询出现的位置：\n\n​\tselect后面：\n\n​\t\t\t仅仅支持标量子查询\n\n​\tfrom后面：\n\n​\t\t\t支持表子查询\n\n​\twhere或having后面：★\n\n​\t\t\t标量子查询（单行） √\n\n​\t\t\t列子查询  （多行） √\n\n​\t\t\t行子查询\n\nexists后面（相关子查询）\n\n​\t表子查询\n\n按结果集的行列数不同：\n\n​\t标量子查询（结果集只有一行一列）\n\n​\t列子查询（结果集只有一列多行）\n\n​\t行子查询（结果集有一行多列或多行多列）\n\n​\t表子查询（结果集一般为多行多列）\n\n**三，语法**\n\n1、where或having后面\n\n​\t1、标量子查询（单行子查询）\n​\t2、列子查询（多行子查询）\n​\t3、行子查询（多列多行）\n​\t特点：\n​\t\t①子查询放在小括号内\n​\t\t②子查询一般放在条件的右侧\n​\t\t③标量子查询，一般搭配着单行操作符使用\n​\t\t\t\t> < >= <= = <>\n​\t\t\t列子查询，一般搭配着多行操作符使用\n​\t\t\t\tin、any/some、all\n​\t\t④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果\n\n```mysql\n#1.标量子查询★\n#案例1：谁的工资比 Abel 高?\n#①查询Abel的工资\n\tSELECT salary FROM employees WHERE last_name = 'Abel'\n#②查询员工的信息，满足 salary>①结果\n\tSELECT * FROM employees\n\tWHERE salary>(\n\t\tSELECT salary FROM employees WHERE last_name = 'Abel'\n\t);\n# 案例2：返回job_id与141号员工相同，salary比143号员工多的员工 \n# 姓名，job_id 和工资\n#①查询141号员工的job_id\n\tSELECT job_id FROM employees WHERE employee_id = 141\n#②查询143号员工的salary\n\tSELECT salary FROM employees WHERE employee_id = 143\n#③查询员工的姓名，job_id 和工资，要求job_id=①并且salary>②\n\tSELECT last_name,job_id,salary FROM employees\n\tWHERE job_id = (\n\t\tSELECT job_id FROM employees WHERE employee_id = 141\n\t) AND salary>(\n\t\tSELECT salary FROM employees WHERE employee_id = 143\n\t);\n#案例3：返回公司工资最少的员工的last_name,job_id和salary\n#①查询公司的 最低工资\n\tSELECT MIN(salary) FROM employees\n#②查询last_name,job_id和salary，要求salary=①\n\tSELECT last_name,job_id,salary FROM employees\n\tWHERE salary=(\n\t\tSELECT MIN(salary) FROM employees\n\t);\n#案例4：查询最低工资大于50号部门最低工资的部门id和其最低工资\n#①查询50号部门的最低工资\n\tSELECT  MIN(salary)FROM employees WHERE department_id = 50\n#②查询每个部门的最低工资\n\tSELECT MIN(salary),department_id FROM employees GROUP BY department_id\n#③ 在②基础上筛选，满足min(salary)>①\n\tSELECT MIN(salary),department_id FROM employees GROUP BY department_id\n\tHAVING MIN(salary)>(\n\t\tSELECT  MIN(salary) FROM employees WHERE department_id = 50\n\t);\n#非法使用标量子查询\n\tSELECT MIN(salary),department_id FROM employees GROUP BY department_id\n\tHAVING MIN(salary)>(\n\t\tSELECT  salary FROM employees WHERE department_id = 250\n\t);\n#2.列子查询（多行子查询）★\n#案例1：返回location_id是1400或1700的部门中的所有员工姓名\n#①查询location_id是1400或1700的部门编号\n\tSELECT DISTINCT department_id FROM departments WHERE location_id IN(1400,1700)\n#②查询员工姓名，要求部门号是①列表中的某一个\n\tSELECT last_name FROM employees\n\tWHERE department_id  <>ALL(\n\t\tSELECT DISTINCT department_id FROM departments \n\t\tWHERE location_id IN(1400,1700)\n\t);\n# 案例2：返回其它工种中比job_id为‘IT_PROG’工种任一工资低\n# 的员工的员工号、姓名、job_id 以及salary\n# ①查询job_id为‘IT_PROG’部门任一工资\n\tSELECT DISTINCT salary FROM employees WHERE job_id = 'IT_PROG'\n#②查询员工号、姓名、job_id 以及salary，salary<(①)的任意一个\n\tSELECT last_name,employee_id,job_id,salary FROM employees\n\tWHERE salary<ANY(\n\t\tSELECT DISTINCT salary FROM employees WHERE job_id = 'IT_PROG'\n\t) AND job_id<>'IT_PROG';\n#或\n\tSELECT last_name,employee_id,job_id,salary FROM employees\n\tWHERE salary<(\n\t\tSELECT MAX(salary) FROM employees WHERE job_id = 'IT_PROG'\n\t) AND job_id<>'IT_PROG';\n#案例3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工   \n# 的员工号、姓名、job_id 以及salary\n\tSELECT last_name,employee_id,job_id,salary FROM employees\n\tWHERE salary<ALL(\n\t\tSELECT DISTINCT salary FROM employees WHERE job_id = 'IT_PROG'\n\t) AND job_id<>'IT_PROG';\n#或\n\tSELECT last_name,employee_id,job_id,salary FROM employees\n\tWHERE salary<(\n\t\tSELECT MIN( salary) FROM employees WHERE job_id = 'IT_PROG'\n\t) AND job_id<>'IT_PROG';\n\n#3、行子查询（结果集一行多列或多行多列）\n#案例：查询员工编号最小并且工资最高的员工信息\n\tSELECT * FROM employees\n\tWHERE (employee_id,salary)=(\n\t\tSELECT MIN(employee_id),MAX(salary)FROM employees\n\t);\n#①查询最小的员工编号\n\tSELECT MIN(employee_id)FROM employees\n#②查询最高工资\n\tSELECT MAX(salary)FROM employees\n#③查询员工信息\n\tSELECT *FROM employees\n\tWHERE employee_id=(\n\t\tSELECT MIN(employee_id)FROM employees\n\t)AND salary=(\n\t\tSELECT MAX(salary)FROM employees\n\t);\n```\n\n2，select后面\n\n​\t\t仅仅支持标量子查询\n\n```mysql\n#案例：查询每个部门的员工个数\n\tSELECT d.*,(\n\t\tSELECT COUNT(*)FROM employees e\n\t\tWHERE e.department_id = d.`department_id`\n\t) 个数 FROM departments d;\n#案例2：查询员工号=102的部门名\n\tSELECT (\n\t\tSELECT department_name,e.department_id FROM departments d\n\t\tINNER JOIN employees e ON d.department_id=e.department_id\n\t\tWHERE e.employee_id=102\n\t) 部门名;\n```\n\n3，from后面\n\n​\t\t将子查询结果充当一张表，要求必须起别名\n\n```mysql\n#案例：查询每个部门的平均工资的工资等级\n#①查询每个部门的平均工资\n\tSELECT AVG(salary),department_id\n\tFROM employees\n\tGROUP BY department_id\n#②连接①的结果集和job_grades表，\n#筛选条件平均工资 between lowest_sal and highest_sal\n\tSELECT  ag_dep.*,g.`grade_level`\n\tFROM (\n\t\tSELECT AVG(salary) ag,department_id FROM employees\n\t\tGROUP BY department_id\n\t) ag_dep INNER JOIN job_grades g\n\tON ag_dep.ag BETWEEN lowest_sal AND highest_sal;\n```\n\n4，exists后面(相关子查询)\n\n​\t语法：exists(完整的查询语句)\n​\t结果：1或0\n\n```mysql\nSELECT EXISTS(SELECT employee_id FROM employees WHERE salary=300000);\n#案例1：查询有员工的部门名\n-- in\nSELECT department_name FROM departments d\nWHERE d.`department_id` IN(\n\tSELECT department_id FROM employees\n)\n-- exists\nSELECT department_name FROM departments d\nWHERE EXISTS(\n\tSELECT * FROM employees e\n\tWHERE d.`department_id`=e.`department_id`\n);\n#案例2：查询没有女朋友的男神信息\n-- in\nSELECT bo.* FROM boys bo\nWHERE bo.id NOT IN(\n\tSELECT boyfriend_id FROM beauty\n)\n-- exists\nSELECT bo.* FROM boys bo\nWHERE NOT EXISTS(\n\tSELECT boyfriend_id FROM beauty b\n\tWHERE bo.`id`=b.`boyfriend_id`\n);\n```\n\n## 5.8分页查询\n\n**一、应用场景**\n\n​\t\t当要查询的条目数太多，一页显示不全\n\n**二、语法**\n\n​\t\tselect 查询列表 from 表  limit 【offset,】size;\n\n**三，特点**\n\n​\t\t\toffset代表的是起始的条目索引，默认从0卡死\n\n​\t\t\tsize代表的是显示的条目数\n\n​\t\t\tlimit子句放在查询语句的最后\n\n​\t公式：\n\n​\t\t\t假如要显示的页数为page，每一页条目数为size\n\n​\t\t\tselect 查询列表 from 表  limit (page-1)*size,size;\n\n**四，示例**\n\n```mysql\n#案例1：查询前五条员工信息\nSELECT * FROM  employees LIMIT 0,5;\nSELECT * FROM  employees LIMIT 5;\n#案例2：查询第11条——第25条\nSELECT * FROM  employees LIMIT 10,15;\n#案例3：有奖金的员工信息，并且工资较高的前10名显示出来\nSELECT * FROM employees WHERE commission_pct IS NOT NULL \nORDER BY salary DESC LIMIT 10 ;\n```\n\n## 5.9union联合查询\n\n​\tunion：  联合 合并。即将多条查询语句的结果合并成一个结果\n\n**一，应用场景：**\n\t\t要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时\n\n**二，语法**\n\n​\tselect 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】\n​\tselect 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】\n​\tselect 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】\n​\t.....\n​\tselect 字段|常量|表达式|函数 【from 表】 【where 条件】\n\n**三，特点**\n\n​\t\t1、多条查询语句的查询的列数必须是一致的\n​\t\t2、多条查询语句的查询的列的类型几乎相同\n​\t\t3、union代表去重，union all代表不去重\n\n**四，示例**\n\n```mysql\n#引入的案例：查询部门编号>90或邮箱包含a的员工信息\nSELECT * FROM employees WHERE email LIKE '%a%' OR department_id>90;;\n# 等价于\nSELECT * FROM employees  WHERE email LIKE '%a%'\nUNION\nSELECT * FROM employees  WHERE department_id>90;\n#案例：查询中国用户中男性的信息以及外国用户中年男性的用户信息\nSELECT id,cname FROM t_ca WHERE csex='男'\nUNION ALL\nSELECT t_id,tname FROM t_ua WHERE tGender='male';\n```\n\n## 5.10总结\n\n​\t执行顺序：\n\n```mys\nselect 查询列表    \t\t     ⑦\nfrom 表1 别名       \t      ①\n连接类型 join 表2   \t        ②\non 连接条件                  ③\nwhere 筛选                  ④\ngroup by 分组列表            ⑤\nhaving 筛选                 ⑥\norder by排序列表             ⑧\nlimit 起始条目索引，条目数;    ⑨\n```\n\n# 六、DML语言的学习\n\nDML语言:数据操作语言：\n\t\t\t插入：insert\n\t\t\t修改：update\n\t\t\t删除：delete\n\n## 6.1插入语句\n\n**一、方式一**\n\t\t语法：insert into 表名(字段名,...) values(值,...);\n\t\t特点：\n\t\t\t\t1、要求值的类型和字段的类型要一致或兼容\n\t\t\t\t2、字段的个数和顺序不一定与原始表中的字段个数和顺序一致，但必须保证值和字段一一对应\n\t\t\t\t3、假如表中有可以为null的字段，注意可以通过以下两种方式插入null值\n\t\t\t\t\t\t①字段和值都省略\n\t\t\t\t\t\t②字段写上，值使用null\n\t\t\t\t4、字段和值的个数必须一致\n\t\t\t\t5、字段名可以省略，默认所有列\n\n**二、方式二**\n\t\t语法：insert into 表名 set 字段=值,字段=值,...;\n\n**三，两种方式 的区别：**\n\t\t1.方式一支持一次插入多行，语法如下：\n\t\t\t\t\tinsert into 表名【(字段名,..)】 values(值，..),(值，...),...;\n\t\t2.方式一支持子查询，语法如下：\n\t\t\t\t\tinsert into 表名 查询语句;\n\n**四，示例**\n\n```mysql\n\tSELECT * FROM beauty;\n#1.插入的值的类型要与列的类型一致或兼容\n\tINSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)\n\tVALUES(13,'唐艺昕','女','1990-4-23','1898888888',NULL,2);\n#2.不可以为null的列必须插入值。可以为null的列如何插入值？\n#方式一：\n\tINSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)\n\tVALUES(13,'唐艺昕','女','1990-4-23','1898888888',NULL,2);\n#方式二：\n\tINSERT INTO beauty(id,NAME,sex,phone)\n\tVALUES(15,'娜扎','女','1388888888');\n#3.列的顺序是否可以调换\n\tINSERT INTO beauty(NAME,sex,id,phone)\n\tVALUES('蒋欣','女',16,'110');\n#4.列数和值的个数必须一致\n\tINSERT INTO beauty(NAME,sex,id,phone)\n\tVALUES('关晓彤','女',17,'110');\n#5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致\n\tINSERT INTO beauty\n\tVALUES(18,'张飞','男',NULL,'119',NULL,NULL);\n\t#方式二：\n\tINSERT INTO beauty\n\tSET id=19,NAME='刘涛',phone='999';\n#两种方式大pk ★\n#1、方式一支持插入多行,方式二不支持\n\tINSERT INTO beauty\n\tVALUES(23,'唐艺昕1','女','1990-4-23','1898888888',NULL,2)\n\t,(24,'唐艺昕2','女','1990-4-23','1898888888',NULL,2)\n\t,(25,'唐艺昕3','女','1990-4-23','1898888888',NULL,2);\n#2、方式一支持子查询，方式二不支持\n\tINSERT INTO beauty(id,NAME,phone)\n\tSELECT 26,'宋茜','11809866';\n\tINSERT INTO beauty(id,NAME,phone)\n\tSELECT id,boyname,'1234567'\n\tFROM boys WHERE id<3;\n```\n\n## 6.2修改语句\n\n**一，修改单表的记录**\n\n​\t\t语法：update 表名  set 列=新值,列=新值,...  where 筛选条件;\n\n**二，修改多表的记录【补充】**\n\n​\t\t语法：\n​\t\t\tsql92语法：update 表1 别名,表2 别名 set 列=值,... where 连接条件 and 筛选条件;\n\n​\t\t\tsql99语法：\n\n​\t\t\t\t\tupdate 表1 别名  inner|left|right join 表2 别名 on 连接条件 set 列=值,... where 筛选条件;\n\n**三，示例**\n\n```mysql\n#1.修改单表的记录\n\t#案例1：修改beauty表中姓唐的女神的电话为13899888899\n\t\tUPDATE beauty SET phone = '13899888899'\n\t\tWHERE NAME LIKE '唐%';\n\t#案例2：修改boys表中id好为2的名称为张飞，魅力值 10\n\t\tUPDATE boys SET boyname='张飞',usercp=10\n\t\tWHERE id=2;\n#2.修改多表的记录\n\t#案例 1：修改张无忌的女朋友的手机号为114\n\t\tUPDATE boys bo\n\t\tINNER JOIN beauty b ON bo.`id`=b.`boyfriend_id`\n\t\tSET b.`phone`='119',bo.`userCP`=1000\n\t\tWHERE bo.`boyName`='张无忌';\n\t#案例2：修改没有男朋友的女神的男朋友编号都为2号\n\t\tUPDATE boys bo\n\t\tRIGHT JOIN beauty b ON bo.`id`=b.`boyfriend_id`\n\t\tSET b.`boyfriend_id`=2\n\t\tWHERE bo.`id` IS NULL;\n```\n\n## 6.3删除语句\n\n**一，方式一：delete**\n\t\t语法：\n\n​\t\t\t\t1、单表的删除：delete from 表名 where 筛选条件\n\n​\t\t\t\t2、多表的删除【补充】\n\n​\t\t\t\t\t\tsql92语法：delete 表1的别名,表2的别名 \n\n​\t\t\t\t\t\t\t\t\t\t\t from 表1 别名,表2 别名 \n\n​\t\t\t\t\t\t\t\t\t\t\t where 连接条件 \n\n​\t\t\t\t\t\t\t\t\t\t\t and 筛选条件;\n\n​\t\t\t\t\t\tsql99语法：delete 表1的别名,表2的别名\n​\t\t\t\t\t\t\t\t\t\t\t from 表1 别名\n​\t\t\t\t\t\t\t\t\t\t\t inner|left|right join 表2 别名 on 连接条件\n​\t\t\t\t\t\t\t\t\t\t\t where 筛选条件;\n\n**二，方式二：truncate**\n语法：truncate table 表名;\n\n**三，delete 与 truncate的区别**\n\n​\t\t\t1.delete 可以加where 条件，truncate不能加\n\n​\t\t\t2.truncate删除，效率高一丢丢\n\n​\t\t\t3.假如要删除的表中有自增长列，\n\n​\t\t\t\t\t如果用delete删除后，再插入数据，自增长列的值从断点开始，\n\n​\t\t\t\t\t而truncate删除后，再插入数据，自增长列的值从1开始。\n\n​\t\t\t4.truncate删除没有返回值，delete删除有返回值\n\n​\t\t\t5.truncate删除不能回滚，delete删除可以回滚.\n\n**四，示例**\n\n```mysql\n#方式一：delete\n\t#1.单表的删除\n\t#案例：删除手机号以9结尾的女神信息\n\t\tDELETE FROM beauty WHERE phone LIKE '%9';\n\t\tSELECT * FROM beauty;\n\t#2.多表的删除\n\t#案例：删除张无忌的女朋友的信息\n\t\tDELETE b FROM beauty b\n\t\tINNER JOIN boys bo ON b.`boyfriend_id` = bo.`id`\n\t\tWHERE bo.`boyName`='张无忌';\n\t#案例：删除黄晓明的信息以及他女朋友的信息\n\t\tDELETE b,bo FROM beauty b\n\t\tINNER JOIN boys bo ON b.`boyfriend_id`=bo.`id`\n\t\tWHERE bo.`boyName`='黄晓明';\n#方式二：truncate语句\n\t#案例：将魅力值>100的男神信息删除\n\tTRUNCATE TABLE boys ;\n```\n\n## 6.4练习\n\n```mysql\n#1.\t运行以下脚本创建表my_employees\nUSE myemployees;\nCREATE TABLE my_employees(\n\tId INT(10),\n\tFirst_name VARCHAR(10),\n\tLast_name VARCHAR(10),\n\tUserid VARCHAR(10),\n\tSalary DOUBLE(10,2)\n);\nCREATE TABLE users(\n\tid INT,\n\tuserid VARCHAR(10),\n\tdepartment_id INT\n\n);\n\n#2.\t显示表my_employees的结构\nDESC my_employees;\n\n#3.\t向my_employees表中插入下列数据\n-- ID\tFIRST_NAME\tLAST_NAME\tUSERID\t   SALARY\n-- 1\tpatel\t\tRalph\t\tRpatel\t   895\n-- 2\tDancs\t\tBetty\t\tBdancs\t   860\n-- 3\tBiri\t\tBen\t\t    Bbiri\t   1100\n-- 4\tNewman\t\tChad\t\tCnewman\t   750\n-- 5\tRopeburn\tAudrey\t\tAropebur   1550\n#方式一：\nINSERT INTO my_employees\nVALUES(1,'patel','Ralph','Rpatel',895),\n(2,'Dancs','Betty','Bdancs',860),\n(3,'Biri','Ben','Bbiri',1100),\n(4,'Newman','Chad','Cnewman',750),\n(5,'Ropeburn','Audrey','Aropebur',1550);\nDELETE FROM my_employees;\n#方式二：\nINSERT INTO my_employees\nSELECT 1,'patel','Ralph','Rpatel',895 UNION\nSELECT 2,'Dancs','Betty','Bdancs',860 UNION\nSELECT 3,'Biri','Ben','Bbiri',1100 UNION\nSELECT 4,'Newman','Chad','Cnewman',750 UNION\nSELECT 5,'Ropeburn','Audrey','Aropebur',1550;\n\t\t\t\n#4.\t 向users表中插入数据\n-- 1\tRpatel\t10\n-- 2\tBdancs\t10\n-- 3\tBbiri\t20\n-- 4\tCnewman\t30\n-- 5\tAropebur\t40\nINSERT INTO users\nVALUES(1,'Rpatel',10),\n(2,'Bdancs',10),\n(3,'Bbiri',20);\n\n#5.将3号员工的last_name修改为“drelxer”\nUPDATE my_employees SET last_name='drelxer' WHERE id = 3;\n\n#6.将所有工资少于900的员工的工资修改为1000\nUPDATE my_employees SET salary=1000 WHERE salary<900;\n\n#7.将userid 为Bbiri的user表和my_employees表的记录全部删除\nDELETE u,e FROM users u\nJOIN my_employees e ON u.`userid`=e.`Userid`\nWHERE u.`userid`='Bbiri';\n\n#8.删除所有数据\nDELETE FROM my_employees;\nDELETE FROM users;\n\n#9.检查所作的修正\nSELECT * FROM my_employees;\nSELECT * FROM users;\n\n#10.清空表my_employees\nTRUNCATE TABLE my_employees;\n```\n\n# 七、DDL语言的学习\n\n## 7.1库和表的管理\n\n一、库的管理\n\t\t创建、修改、删除\n二、表的管理\n\t\t创建、修改、删除\n\n​\t\t创建： create\n​\t\t修改： alter\n​\t\t删除： drop\n\n**一，库的管理**\n\n1、创建库\n\t\tcreate database 【if not exists】 库名【 character set 字符集名】;\n2、修改库\n\t\talter database 库名 character set 字符集名;\n3、删除库\n\t\tdrop database 【if exists】 库名;\n\n```mysql\n#1、库的创建\n/*\n语法：\ncreate database  [if not exists]库名;\n*/\n#案例：创建库Books\n\tCREATE DATABASE IF NOT EXISTS books ;\n\t\n#2、库的修改\n\tRENAME DATABASE books TO 新库名;\n\t#更改库的字符集\n\tALTER DATABASE books CHARACTER SET gbk;\n\t\n#3、库的删除\n\tDROP DATABASE IF EXISTS books;\n```\n\n**二，表的管理**\n\n​\t\t1、创建表 \n​\t\t\t\tcreate table 【if not exists】 表名(\n​\t\t\t\t\t\t\t字段名 字段类型 【约束】,\n​\t\t\t\t\t字段名 字段类型 【约束】,\n​\t\t\t\t\t。。。\n​\t\t\t\t\t字段名 字段类型 【约束】 \n\n​\t\t\t\t)\n\n​\t2、修改表\n\n​\t\t\t\t1.添加列\n​\t\t\t\t\t\talter table 表名 add column 列名 类型 【first|after 字段名】;\n​\t\t\t\t2.修改列的类型或约束\n​\t\t\t\t\t\talter table 表名 modify column 列名 新类型 【新约束】;\n​\t\t\t\t3.修改列名\n​\t\t\t\t\t\talter table 表名 change column 旧列名 新列名 类型;\n​\t\t\t\t4 .删除列\n​\t\t\t\t\t\talter table 表名 drop column 列名;\n​\t\t\t\t5.修改表名\n​\t\t\t\t\t\talter table 表名 rename 【to】 新表名;\n\n​\t3、删除表\n​\t\t\t\t\t\tdrop table【if exists】 表名;\n\n​\t4、复制表\n​\t\t\t\t1、复制表的结构\n​\t\t\t\t\t\tcreate table 表名 like 旧表;\n​\t\t\t\t2、复制表的结构+数据\n​\t\t\t\t\t\tcreate table 表名 select 查询列表 from 旧表【where 筛选】;\n\n```mysql\n#1.表的创建 ★\n/*\n语法：\ncreate table 表名(\n\t列名 列的类型【(长度) 约束】,\n\t列名 列的类型【(长度) 约束】,\n\t列名 列的类型【(长度) 约束】,\n\t...\n\t列名 列的类型【(长度) 约束】\n)\n*/\n#案例：创建表Book\nCREATE TABLE book(\n\tid INT,#编号\n\tbName VARCHAR(20),#图书名\n\tprice DOUBLE,#价格\n\tauthorId  INT,#作者编号\n\tpublishDate DATETIME#出版日期\n);\n# 查看book表的结构\nDESC book;\n#案例：创建表author\nCREATE TABLE IF NOT EXISTS author(\n\tid INT,\n\tau_name VARCHAR(20),\n\tnation VARCHAR(10)\n)\n# 查看author表的结构\nDESC author;\n\n#2.表的修改\n/*\n语法\nalter table 表名 add|drop|modify|change column 列名 【列类型 约束】;\n*/\n#①修改列名\nALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;\n#②修改列的类型或约束\nALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;\n#③添加新列\nALTER TABLE author ADD COLUMN annual DOUBLE; \n#④删除列\nALTER TABLE book_author DROP COLUMN  annual;\n#⑤修改表名\nALTER TABLE author RENAME TO book_author;\n\n#3.表的删除\nDROP TABLE IF EXISTS book_author;\n# 查看所有表\nSHOW TABLES;\n\n#4.表的复制\nINSERT INTO author VALUES\n(1,'村上春树','日本'),\n(2,'莫言','中国'),\n(3,'冯唐','中国'),\n(4,'金庸','中国');\nSELECT * FROM Author;\nSELECT * FROM copy2;\n#1.仅仅复制表的结构\nCREATE TABLE copy LIKE author;\n#2.复制表的结构+数据\nCREATE TABLE copy2 \nSELECT * FROM author;\n#只复制部分数据\nCREATE TABLE copy3\nSELECT id,au_name\nFROM author \nWHERE nation='中国';\n#仅仅复制某些字段\nCREATE TABLE copy4 \nSELECT id,au_name\nFROM author\nWHERE 0;\n\n#通用的写法：\nDROP DATABASE IF EXISTS 旧库名;\nCREATE DATABASE 新库名;\nDROP TABLE IF EXISTS 旧表名;\nCREATE TABLE  表名();\n```\n\n## 7.2常见数据类型介绍\n\n**一，数值型**\n\n* 整数型\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095635.png)\n\n​\t特点：\n​\t\t\t① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字\n​\t\t\t② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值\n​\t\t\t③ 如果不设置长度，会有默认的长度\n​\t\t\t\t长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！此时为无符号类型。\n\n```mysql\n#1.如何设置无符号和有符号\nDROP TABLE IF EXISTS tab_int;\nCREATE TABLE tab_int(\n\tt1 INT(7) ,\n\tt2 INT(7) unsigned\n);\nCREATE TABLE tab_int(\n\tt1 INT(7) ZEROFILL,\n\tt2 INT(7) ZEROFILL \n);\n\nDESC tab_int;\n\nINSERT INTO tab_int VALUES(-123456);\nINSERT INTO tab_int VALUES(-123456,-123456);\nINSERT INTO tab_int VALUES(2147483648,4294967296);\nINSERT INTO tab_int VALUES(123,123);\nSELECT * FROM tab_int;\n```\n\n* 小数型\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095636.png)\n\n​\t\t分类：\n​\t\t\t\t1.浮点型\n​\t\t\t\t\t\tfloat(M,D)\n​\t\t\t\t\t\tdouble(M,D)\n​\t\t\t\t2.定点型\n​\t\t\t\t\t\tdec(M，D)\n​\t\t\t\t\t\tdecimal(M,D)\n\n​\t\t特点：\n\n​\t\t\t\t①    M：整数部位+小数部位 的长度\n​\t\t\t\t\t\tD：小数部位的长度\n​\t\t\t\t\t\t如果超过范围，则插入临界值\n\n​\t\t\t\t②\tM和D都可以省略\n​\t\t\t\t\t\t如果是decimal，则M默认为10，D默认为0\n​\t\t\t\t\t\t如果是float和double，则会根据插入的数值的精度来决定精度\n\n​\t\t\t\t③\t定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用\n\n```mysql\n#测试M和D\n\nDROP TABLE tab_float;\nCREATE TABLE tab_float(\n\tf1 FLOAT,\n\tf2 DOUBLE,\n\tf3 DECIMAL\n);\nSELECT * FROM tab_float;\nDESC tab_float;\n\nINSERT INTO tab_float VALUES(123.4523,123.4523,123.4523);\nINSERT INTO tab_float VALUES(123.456,123.456,123.456);\nINSERT INTO tab_float VALUES(123.4,123.4,123.4);\nINSERT INTO tab_float VALUES(1523.4,1523.4,1523.4);\n\n#原则：\n/*\n所选择的类型越简单越好，能保存数值的类型越小越好\n*/\n```\n\n* 位类型\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095637.png)\n\n**二，字符型**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095638.png)\n\n​\t\t较短的文本：\n\n​\t\t\t\tchar\n​\t\t\t\tvarchar\n\n​\t\t其他：\n\n​\t\t\t\tbinary和varbinary用于保存较短的二进制\n​\t\t\t\tenum用于保存枚举\n​\t\t\t\tset用于保存集合\n\n​\t\t较长的文本：\n​\t\t\t\ttext\n​\t\t\t\tblob(较大的二进制)\n\n​\t\t特点：\n\n​\t\t\t\t\t写法\t\t\t  M的意思\t\t\t\t\t\t\t\t\t\t\t          特点\t\t\t\t\t\t空间的耗费\t\t效率\n\nchar\t\t\tchar(M)\t\t最大的字符数，可以省略，默认为1\t\t固定长度的字符\t\t比较耗费\t\t\t高\n\nvarchar \tvarchar(M)\t最大的字符数，不可以省略\t\t\t\t\t可变长度的字符\t\t  比较节省\t\t\t低\n\n```mysql\nCREATE TABLE tab_char(\n\tc1 ENUM('a','b','c')\n);\n\nINSERT INTO tab_char VALUES('a');\nINSERT INTO tab_char VALUES('b');\nINSERT INTO tab_char VALUES('c');\nINSERT INTO tab_char VALUES('m');\nINSERT INTO tab_char VALUES('A');\n\nSELECT * FROM tab_set;\n\nCREATE TABLE tab_set(\n\ts1 SET('a','b','c','d')\n\n);\nINSERT INTO tab_set VALUES('a');\nINSERT INTO tab_set VALUES('A,B');\nINSERT INTO tab_set VALUES('a,c,d');\n```\n\n**三，日期型**\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095639.png)\n\n​\t\t分类：\n​\t\t\t\tdate只保存日期\n​\t\t\t\ttime 只保存时间\n​\t\t\t\tyear只保存年\n​\t\t\t\tdatetime保存日期+时间\n​\t\t\t\ttimestamp保存日期+时间\n\n特点：\n\n​\t\t\t\t\t\t\t字节\t\t\t\t\t范围\t\t\t\t\t\t时区等的影响\n\ndatetime\t\t\t\t8\t\t\t\t1000——9999\t    \t\t不受\ntimestamp\t\t\t4\t    \t\t1970-2038\t   \t\t\t\t\t受\n\n```mysql\nCREATE TABLE tab_date(\n\tt1 DATETIME,\n\tt2 TIMESTAMP\n\n);\nINSERT INTO tab_date VALUES(NOW(),NOW());\nSELECT * FROM tab_date;\nSHOW VARIABLES LIKE 'time_zone';\nSET time_zone='+9:00';\n```\n\n## 7.3常见约束\n\n**含义**：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性\n\n**分类**：六大约束\n\tNOT NULL：非空，用于保证该字段的值不能为空\n\t\t\t比如姓名、学号等\n\tDEFAULT:默认，用于保证该字段有默认值\n\t\t\t比如性别\n\tPRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空\n\t\t\t比如学号、员工编号等\n\tUNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空\n\t\t\t比如座位号\n\tCHECK:检查约束【mysql中不支持】\n\t\t\t比如年龄、性别\n\tFOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值\n\t\t\t\t在从表添加外键约束，用于引用主表中某列的值\n\t\t\t比如学生表的专业编号，员工表的部门编号，员工表的工种编号\n\n**添加约束的时机：**\n\t1.创建表时\n\t2.修改表时\n\n**约束的添加分类：**\n\t列级约束：六大约束语法上都支持，但外键约束没有效果\n\n​\t表级约束：除了非空、默认，其他的都支持\t\t\n**主键和唯一的大对比：**\n\n​\t\t\t保证唯一性  \t\t是否允许为空    \t\t\t一个表中可以有多少个  \t\t 是否允许组合\n主键\t\t\t√\t\t\t\t\t\t\t×\t\t\t\t\t\t\t\t\t至多有1个          \t\t\t\t √，但不推荐\n唯一\t\t\t√\t\t\t\t\t\t\t√\t\t\t\t\t\t\t\t\t可以有多个          \t\t\t\t√，但不推荐\n\n**外键：**\n\t1、要求在从表设置外键关系\n\t2、从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求\n\t3、主表的关联列必须是一个key（一般是主键或唯一）\n\t4、插入数据时，先插入主表，再插入从表；删除数据时，先删除从表，再删除主表\n\n**语法：**\tCREATE TABLE 表名(\n\t\t\t\t\t\t\t字段名 字段类型 列级约束,\n\t\t\t\t\t\t\t字段名 字段类型,\n\t\t\t\t\t\t\t表级约束\n\n​\t\t\t\t\t)\n\n**一、创建表时添加约束**\n\n​\t1.添加列级约束\n\n​\t\t\t语法：\n\n​\t\t\t\t直接在字段名和类型后面追加 约束类型即可。\n\n​\t\t\t\t只支持：默认、非空、主键、唯一\n\n```mysql\nUSE students;\nDROP TABLE stuinfo;\nCREATE TABLE stuinfo(\n\tid INT PRIMARY KEY,#主键\n\tstuName VARCHAR(20) NOT NULL UNIQUE,#非空\n\tgender CHAR(1) CHECK(gender='男' OR gender ='女'),#检查\n\tseat INT UNIQUE,#唯一\n\tage INT DEFAULT  18,#默认约束\n\tmajorId INT REFERENCES major(id)#外键\n\n);\n\nCREATE TABLE major(\n\tid INT PRIMARY KEY,\n\tmajorName VARCHAR(20)\n);\n\n#查看stuinfo中的所有索引，包括主键、外键、唯一\nSHOW INDEX FROM stuinfo;\n```\n\n​\t2.添加表级约束\n\n​\t\t\t语法：在各个字段的最下面\n \t\t\t\t\t【constraint 约束名】 约束类型(字段名) \n\n```mysql\nDROP TABLE IF EXISTS stuinfo;\nCREATE TABLE stuinfo(\n\tid INT,\n\tstuname VARCHAR(20),\n\tgender CHAR(1),\n\tseat INT,\n\tage INT,\n\tmajorid INT,\n\tCONSTRAINT pk PRIMARY KEY(id),#主键\n\tCONSTRAINT uq UNIQUE(seat),#唯一键\n\tCONSTRAINT ck CHECK(gender ='男' OR gender  = '女'),#检查\n\tCONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键\n);\nSHOW INDEX FROM stuinfo;\n```\n\n**通用的写法：**\n\n```mysql\nCREATE TABLE IF NOT EXISTS stuinfo(\n\tid INT PRIMARY KEY,\n\tstuname VARCHAR(20),\n\tsex CHAR(1),\n\tage INT DEFAULT 18,\n\tseat INT UNIQUE,\n\tmajorid INT,\n\tCONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)\n\n);\n```\n\n**二、修改表时添加约束**\n\n​\t1、添加列级约束\n​\t\t\t\talter table 表名 modify column 字段名 字段类型 新约束;\n\n​\t2、添加表级约束\n​\t\t\t\talter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;\n\n```mysql\nDROP TABLE IF EXISTS stuinfo;\nCREATE TABLE stuinfo(\n\tid INT,\n\tstuname VARCHAR(20),\n\tgender CHAR(1),\n\tseat INT,\n\tage INT,\n\tmajorid INT\n)\nDESC stuinfo;\n#1.添加非空约束\n\tALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;\n#2.添加默认约束\n\tALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;\n#3.添加主键\n\t#①列级约束\n\t\tALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;\n\t#②表级约束\n\t\tALTER TABLE stuinfo ADD PRIMARY KEY(id);\n#4.添加唯一\n\t#①列级约束\n\t\tALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;\n\t#②表级约束\n\t\tALTER TABLE stuinfo ADD UNIQUE(seat);\n#5.添加外键\n\tALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); \n```\n\n**三、修改表时删除约束**\n\n```mysql\n#1.删除非空约束\n\tALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;\n#2.删除默认约束\n\tALTER TABLE stuinfo MODIFY COLUMN age INT ;\n#3.删除主键\n\tALTER TABLE stuinfo DROP PRIMARY KEY;\n#4.删除唯一\n\tALTER TABLE stuinfo DROP INDEX seat;\n#5.删除外键\n\tALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;\nSHOW INDEX FROM stuinfo;\n```\n\n### 7.3.1标识列\n\n​\t\t又称为自增长列\n​\t\t含义：可以不用手动的插入值，系统提供默认的序列值\n\n**特点：**\n\t\t1、标识列必须和主键搭配吗？不一定，但要求是一个key\n\n​\t\t2、一个表可以有几个标识列？至多一个！\n\n​\t\t3、标识列的类型只能是数值型\n\n​\t\t4、标识列可以通过 SET auto_increment_increment=3;设置步长\n\n​\t\t\t\t可以通过 手动插入值，设置起始值\n\n```mysql\nDROP TABLE IF EXISTS tab_identity;\nCREATE TABLE tab_identity(\n\tid INT  ,\n\tNAME FLOAT UNIQUE AUTO_INCREMENT,\n\tseat INT \n);\nTRUNCATE TABLE tab_identity;\n\nINSERT INTO tab_identity(id,NAME) VALUES(NULL,'john');\nINSERT INTO tab_identity(NAME) VALUES('lucy');\nSELECT * FROM tab_identity;\n# 显示自动增长的属性配置\nSHOW VARIABLES LIKE '%auto_increment%';\n# 设置自动增长的步长配置\nSET auto_increment_increment=3;\n```\n\n# 八、TCL语言的学习\n\nTransaction Control Language: 事务控制语言\n\n## 8.1事务和事务处理\n\n案例：转账事件\n\t张三丰  1000\n\t郭襄\t1000\n\t当下面两条语句执行到一半时，因意外停止，数据就会出现异常\n\tupdate 表 set 张三丰的余额=500 where name='张三丰'\n\t意外\n\tupdate 表 set 郭襄的余额=1500 where name='郭襄'\n\n**一，事务的特性：ACID**\n\t原子性(A)：\t一个事务不可再分割，要么都执行要么都不执行\n\t一致性(C)：\t一个事务执行会使数据从一个一致状态切换到另外一个一致状态\n\t隔离性(I)：\t 一个事务的执行不受其他事务的干扰\n\t持久性(D)：\t一个事务一旦提交，则会永久的改变数据库的数据.\n\n**事务的创建**\n\t隐式事务：事务没有明显的开启和结束的标记\n\t\t\t比如insert、update、delete语句\n\t\t\tdelete from 表 where id =1;\n\t显式事务：事务具有明显的开启和结束的标记\n\t\t前提：必须先设置自动提交功能为禁用\n\n**关闭自动提交功能**，此设置只针对当前会话有效并不是永久的\n\tset autocommit=0;\n\n步骤1：开启事务\n\tset autocommit=0;\n\tstart transaction;可选的。因为当开启自动提交时会默认打开\n步骤2：编写事务中的sql语句(select insert update delete)\n\t语句1;\n\t语句2;\n\t...\n步骤3：结束事务\n\tcommit;提交事务，将当前语句执行到内存中\n\trollback;回滚事务，不执行当前语句\n\n**事务的隔离级别：**\n\n​\t不隔离引起的问题：\n\n**脏读**: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还**没有被提交**的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的\n\n**不可重复读**: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 **更新了**该字段. 之后, T1再次读取同一个字段, 值就不同了\n\n**幻读**: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中**插入**了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行.\n\n​\t4种隔离级别：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208095640.png)\n\n​\t\t\t\t\t\t\t\t\t\t脏读\t\t不可重复读\t   \t幻读\nread uncommitted：\t√\t\t\t\t√\t\t\t\t\t\t   √\nread committed：  \t   ×\t\t\t    √\t\t\t   \t\t\t√\nrepeatable read： \t\t×\t\t\t     ×\t\t\t\t\t\t  √\nserializable\t  \t\t\t   ×        \t     ×       \t\t\t\t\t×\n\nOracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ \n\nCOMMITED \n\nMysql 支持 4 种事务隔离级别. Mysql 默认的事务隔离级别为: REPEATABLE READ\n**查看隔离级别**：select @@tx_isolation;\n**设置隔离级别**：set session|global transaction isolation level 隔离级别;\n\n**设置保存点**： savepoint 节点名; \n与 rollback to 节点名一起使用\n\n**二，示例**\n\n1.演示事务的使用步骤\n\n```mysql\n#开启事务\n\tSET autocommit=0;\n\tSTART TRANSACTION;\n#编写一组事务的语句\n\tUPDATE account SET balance = 1000 WHERE username='张无忌';\n\tUPDATE account SET balance = 1000 WHERE username='赵敏';\n#结束事务\n\tROLLBACK;\n\t# commit;\n\nSELECT * FROM account;\n```\n\n2.演示事务对于delete和truncate的处理的区别\n\n```mysql\n\t# delete ：可以回滚\n\t# truncate：不可以回滚\nSET autocommit=0;\nSTART TRANSACTION;\nDELETE FROM account;\n# TRUNCATE TABLE account;\nROLLBACK;\n```\n\n3.演示savepoint 的使用\n\n```mysql\nSET autocommit=0;\nSTART TRANSACTION;\nDELETE FROM account WHERE id=25;\nSAVEPOINT a;#设置保存点\nDELETE FROM account WHERE id=28;\nROLLBACK TO a;#回滚到保存点\n\nSELECT * FROM account;\n```\n\n# 九、视图的讲解\n\n**含义**：虚拟表，和普通表一样使用\nmysql5.1版本出现的新特性，是通过表动态生成的数据\n\n**视图和表的区别**：\n\t\t\t创建语法的关键字\t是否实际占用物理空间\t\t\t\t\t\t使用\n视图\tcreate view\t\t\t\t只是保存了sql逻辑\t\t\t增删改查，只是一般不能增删改\n表\t\tcreate table\t\t\t  保存了数据\t\t\t \t\t\t\t\t\t增删改查\n\n```mysql\n#案例：查询姓张的学生名和专业名\n # 原来的写法\n\tSELECT stuname,majorname\n\tFROM stuinfo s\n\tINNER JOIN major m ON s.`majorid`= m.`id`\n\tWHERE s.`stuname` LIKE '张%';\n # 封装到一个视图\n\tCREATE VIEW v1\n\tAS\n\tSELECT stuname,majorname\n\tFROM stuinfo s\n\tINNER JOIN major m ON s.`majorid`= m.`id`;\n # 在使用时，使用视图边界查询\n\tSELECT * FROM v1 WHERE stuname LIKE '张%';\n```\n\n**一、创建视图**\n\n​\t语法：create view 视图名\n​\t \t\t  as\n​\t  \t\t 查询语句;\n\n```mysql\nUSE myemployees;\n\n#1.查询姓名中包含a字符的员工名、部门名和工种信息\n #①创建\n\tCREATE VIEW myv1\n\tAS\n\tSELECT last_name,department_name,job_title\n\tFROM employees e\n\tJOIN departments d ON e.department_id  = d.department_id\n\tJOIN jobs j ON j.job_id  = e.job_id;\n #②使用\n\tSELECT * FROM myv1 WHERE last_name LIKE '%a%';\n#2.查询各部门的平均工资级别\n #①创建视图查看每个部门的平均工资\n\tCREATE VIEW myv2\n\tAS\n\tSELECT AVG(salary) ag,department_id\n\tFROM employees\n\tGROUP BY department_id;\n #②使用\n\tSELECT myv2.`ag`,g.grade_level\n\tFROM myv2\n\tJOIN job_grades g\n\tON myv2.`ag` BETWEEN g.`lowest_sal` AND g.`highest_sal`;\n#3.查询平均工资最低的部门信息\n\tSELECT * FROM myv2 ORDER BY ag LIMIT 1;\n#4.查询平均工资最低的部门名和工资\n # ①创建视图\n\tCREATE VIEW myv3\n\tAS\n\tSELECT * FROM myv2 ORDER BY ag LIMIT 1;\n # ②使用视图\n\tSELECT d.*,m.ag\n\tFROM myv3 m\n\tJOIN departments d\n\tON m.`department_id`=d.`department_id`;\n```\n\n**二、视图的修改**\n\n方式一：如果试图存在就替换，不存在就创建\n\n​\t语法：create or replace view  视图名\n​\t  \t\tas\n​\t \t\t 查询语句;\n\n```mysql\nSELECT * FROM myv3 \n\nCREATE OR REPLACE VIEW myv3\nAS\nSELECT AVG(salary),job_id\nFROM employees\nGROUP BY job_id;\n```\n\n方式二：\n\n​\t语法：alter view 视图名\n​\t  \t\tas \n​\t  \t\t查询语句;\n\n```mysql\nALTER VIEW myv3\nAS\nSELECT * FROM employees;\n```\n\n**三、删除视图**\n\n​\t语法：drop view 视图名,视图名,...;\n\n```MYSQL\nDROP VIEW emp_v1,emp_v2,myv3;\n```\n\n**四、查看视图**\n\n```MYSQL\nDESC myv3;\nSHOW CREATE VIEW myv3;\n```\n\n**五、视图的更新**\n\n```MYSQL\nCREATE OR REPLACE VIEW myv1\n\tAS\n\tSELECT last_name,email\n\tFROM employees;\n\n\tSELECT * FROM myv1;\n\tSELECT * FROM employees;\n#1.插入：插入后不仅在视图表中插入了数据，在原始表中也插入了数据\nINSERT INTO myv1 VALUES('张飞','zf@qq.com');\n#2.修改：插入后不仅在视图表中修改了数据，在原始表中也修改了数据\nUPDATE myv1 SET last_name = '张无忌' WHERE last_name='张飞';\n#3.删除：插入后不仅在视图表中删除了数据，在原始表中也删除了数据\nDELETE FROM myv1 WHERE last_name = '张无忌';\n```\n\n​\t**视图的可更新性和视图中查询的定义有关系，以下类型的视图是不能更新的。**\n\n• 包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all\n\n• 常量视图\n\n• Select中包含子查询\n\n• join\n\n• from一个不能更新的视图\n\n• where子句的子查询引用了from子句中的表\n\n```MYSQL\n#①包含以下关键字的sql语句：分组函数、distinct、group  by、having、\n# union或者union all\n\tCREATE OR REPLACE VIEW myv1\n\tAS\n\tSELECT MAX(salary) m,department_id\n\tFROM employees\n\tGROUP BY department_id;\n\t#更新\n\tSELECT * FROM myv1;\n\tUPDATE myv1 SET m=9000 WHERE department_id=10;\n#②常量视图\n\tCREATE OR REPLACE VIEW myv2\n\tAS\n\tSELECT 'john' NAME;\n\t#更新\n\tSELECT * FROM myv2;\n\tUPDATE myv2 SET NAME='lucy';\n#③Select中包含子查询\n\tCREATE OR REPLACE VIEW myv3\n\tAS\n\tSELECT department_id,(SELECT MAX(salary) FROM employees) 最高工资\n\tFROM departments;\n\t#更新\n\tSELECT * FROM myv3;\n\tUPDATE myv3 SET 最高工资=100000;\n#④join\n\tCREATE OR REPLACE VIEW myv4\n\tAS\n\tSELECT last_name,department_name\n\tFROM employees e\n\tJOIN departments d\n\tON e.department_id  = d.department_id;\n\t#更新\n\tSELECT * FROM myv4;\n\tUPDATE myv4 SET last_name  = '张飞' WHERE last_name='Whalen';\n\tINSERT INTO myv4 VALUES('陈真','xxxx');\n#⑤from一个不能更新的视图\n\tCREATE OR REPLACE VIEW myv5\n\tAS\n\tSELECT * FROM myv3;\n\t#更新\n\tSELECT * FROM myv5;\n\tUPDATE myv5 SET 最高工资=10000 WHERE department_id=60;\n#⑥where子句的子查询引用了from子句中的表\n\tCREATE OR REPLACE VIEW myv6\n\tAS\n\tSELECT last_name,email,salary\n\tFROM employees\n\tWHERE employee_id IN(\n\t\tSELECT  manager_id\n\t\tFROM employees\n\t\tWHERE manager_id IS NOT NULL\n\t);\n\t#更新\n\tSELECT * FROM myv6;\n\tUPDATE myv6 SET salary=10000 WHERE last_name = 'k_ing';\n```\n\n# 十、变量\n\n系统变量：\n\t全局变量\n\t会话变量\n\n自定义变量：\n\t用户变量\n\t局部变量\n\n**一、系统变量**\n\n说明：变量由系统定义，不是用户定义，属于服务器层面 \n\n注意：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别 \n\n使用步骤： \n\n​\t\t1、查看所有系统变量 \tshow global|【session】variables; \n\n​\t\t2、查看满足条件的部分系统变量 \tshow global|【session】 variables like '%char%'; \n\n​\t\t3、查看指定的系统变量的值 \tselect @@global|【session】系统变量名; \n\n​\t\t4、为某个系统变量赋值 \t\n\n​\t\t\t\t方式一：set global|【session】系统变量名=值; \t\n\n​\t\t\t\t方式二：set @@global|【session】系统变量名=值;\n\n1,全局变量\n\n​\t作用域：针对于所有会话（连接）有效，但不能跨重启\n\n```mysql\n#①查看所有全局变量\n\tSHOW GLOBAL VARIABLES;\n#②查看满足条件的部分系统变量\n\tSHOW GLOBAL VARIABLES LIKE '%char%';\n#③查看指定的系统变量的值\n\tSELECT @@global.autocommit;\n#④为某个系统变量赋值\n\tSET @@global.autocommit=0;\n\tSET GLOBAL autocommit=0;\n```\n\n2,会话变量\n\n​\t\t作用域：针对于当前会话（连接）有效\n\n​\t\t\t\t\t\tsession一般默认省略。\n\n```mysql\n#①查看所有会话变量\n\tSHOW SESSION VARIABLES;\n#②查看满足条件的部分会话变量\n\tSHOW SESSION VARIABLES LIKE '%char%';\n#③查看指定的会话变量的值\n\tSELECT @@autocommit;\n\tSELECT @@session.tx_isolation;\n#④为某个会话变量赋值\n\tSET @@session.tx_isolation='read-uncommitted';\n\tSET SESSION tx_isolation='read-committed';\n\n```\n\n**二、自定义变量**\n\n说明：变量由用户自定义，而不是系统提供的\n使用步骤：\n\t\t\t1、声明\n\t\t\t2、赋值\n\t\t\t3、使用（查看、比较、运算等）\n\n1,用户变量\n\n​\t\t作用域：针对于当前会话（连接）有效，作用域同于会话变量\n\n```mysql\n#赋值操作符：=或:=\n#①声明并初始化\n\tSET @变量名=值;\n\tSET @变量名:=值;\n\tSELECT @变量名:=值;\n#②赋值（更新变量的值）\n\t#方式一：\n\t\tSET @变量名=值;\n\t\tSET @变量名:=值;\n\t\tSELECT @变量名:=值;\n\t#方式二：\n\t\tSELECT 字段 INTO @变量名\n\t\tFROM 表;\n#③使用（查看变量的值）\n\tSELECT @变量名;\n```\n\n2,局部变量\n\n​\t\t作用域：仅仅在定义它的begin end块中有效\n​\t\t\t\t\t\t应用在 begin end中的第一句话\n\n```mysql\n#①声明\n\tDECLARE 变量名 类型;\n\tDECLARE 变量名 类型 【DEFAULT 值】;\n#②赋值（更新变量的值）\n\t#方式一：\n\t\tSET 局部变量名=值;\n\t\tSET 局部变量名:=值;\n\t\tSELECT 局部变量名:=值;\n\t#方式二：\n\t\tSELECT 字段 INTO 具备变量名\n\t\tFROM 表;\n#③使用（查看变量的值）\n\tSELECT 局部变量名;\n```\n\n用户变量和局部变量的对比\n\n​\t\t\t\t\t作用域\t\t\t\t\t\t\t\t\t定义位置\t\t\t\t\t\t\t\t\t\t语法\n\n用户变量\t当前会话\t\t\t\t\t\t\t\t会话的任何地方\t\t\t\t加@符号，不用指定类型\n局部变量\t定义它的BEGIN END中 \tBEGIN END的第一句话\t\t一般不用加@,需要指定类型\n\n```mysql\n#案例：声明两个变量，求和并打印\n#用户变量\n\tSET @m=1;\n\tSET @n=1;\n\tSET @sum=@m+@n;\n\tSELECT @sum;\n#局部变量\n\tDECLARE m INT DEFAULT 1;\n\tDECLARE n INT DEFAULT 1;\n\tDECLARE SUM INT;\n\tSET SUM=m+n;\n\tSELECT SUM;\n```\n\n# 十一、存储过程和函数\n\n存储过程和函数：类似于java中的方法\n\t好处：\n\t\t1、提高代码的重用性\n\t\t2、简化操作\n\n## 11.1 存储过程\n\n含义：事先经过编译并存储在数据库中的一段sql语句的集合。，理解成批处理语句\n\t\t1、提高代码的重用性\n\t\t2、简化操作\n\t\t3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率\n\n**一、创建语法**\n\n​\t\tCREATE PROCEDURE 存储过程名(参数列表)\n​\t\tBEGIN\n\n​\t\t\t\t存储过程体（一组合法的SQL语句）\n\n​\t\tEND 结束标记\n\n注意：\n\n1、参数列表包含三部分\n参数模式  参数名  参数类型\n举例：\nin stuname varchar(20)\n\n参数模式：\nin：该参数可以作为输入，也就是该参数需要调用方传入值\nout：该参数可以作为输出，也就是该参数可以作为返回值\ninout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值\n\n2、如果存储过程体仅仅只有一句话，begin end可以省略\n存储过程体中的每条sql语句的结尾要求必须加分号。\n存储过程的结尾可以使用 delimiter 重新设置\n语法：\ndelimiter 结束标记\n案例：\ndelimiter $\n\n**二、调用语法**\n\n​\t\t\tCALL 存储过程名(实参列表);\n\n```mysql\n#1.空参列表\n\t#案例：插入到admin表中五条记录\n\t\tSELECT * FROM admin;\n\t# 创建结束标识符$\n\t\tDELIMITER $\n\t\tCREATE PROCEDURE myp1()\n\t\tBEGIN\n\t\t\tINSERT INTO admin(username,`password`) \n\t\t\tVALUES('john1','0000'),('lily','0000'),('rose','0000'),('jack','0000'),('tom','0000');\n\t\tEND $\n\t#调用\n\t\tCALL myp1()$\n\n#2.创建带in模式参数的存储过程\n\t#案例1：创建存储过程实现 根据女神名，查询对应的男神信息\n\t\tCREATE PROCEDURE myp2(IN beautyName VARCHAR(20))\n\t\tBEGIN\n\t\t\tSELECT bo.*\n\t\t\tFROM boys bo\n\t\t\tRIGHT JOIN beauty b ON bo.id = b.boyfriend_id\n\t\t\tWHERE b.name=beautyName;\n\t\tEND $\n\t#调用\n\t\tCALL myp2('柳岩')$\n\t#案例2 ：创建存储过程实现，用户是否登录成功\n\t\tCREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))\n\t\tBEGIN\n\t\t\tDECLARE result INT DEFAULT 0;#声明并初始化\n\t\t\t\n\t\t\tSELECT COUNT(*) INTO result#赋值\n\t\t\tFROM admin\n\t\t\tWHERE admin.username = username\n\t\t\tAND admin.password = PASSWORD;\n\t\t\t\n\t\t\tSELECT IF(result>0,'成功','失败');#使用\n\t\tEND $\n\t#调用\n\t\tCALL myp3('张飞','8888')$\n#3.创建out 模式参数的存储过程\n\t#案例1：根据输入的女神名，返回对应的男神名\n\t\tCREATE PROCEDURE myp6(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))\n\t\tBEGIN\n\t\t\tSELECT bo.boyname INTO boyname\n\t\t\tFROM boys bo\n\t\t\tRIGHT JOIN\n\t\t\tbeauty b ON b.boyfriend_id = bo.id\n\t\t\tWHERE b.name=beautyName ;\n\t\tEND $\n\t#案例2：根据输入的女神名，返回对应的男神名和魅力值\n\t\tCREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) \n\t\tBEGIN\n\t\t\tSELECT boys.boyname ,boys.usercp INTO boyname,usercp\n\t\t\tFROM boys \n\t\t\tRIGHT JOIN\n\t\t\tbeauty b ON b.boyfriend_id = boys.id\n\t\t\tWHERE b.name=beautyName ;\n\t\tEND $\n\t#调用\n\t\tCALL myp7('小昭',@name,@cp)$\n\t\tSELECT @name,@cp$\n#4.创建带inout模式参数的存储过程\n\t#案例1：传入a和b两个值，最终a和b都翻倍并返回\n\t\tCREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)\n\t\tBEGIN\n\t\t\tSET a=a*2;\n\t\t\tSET b=b*2;\n\t\tEND $\n\t#调用\n\t\tSET @m=10$\n\t\tSET @n=20$\n\t\tCALL myp8(@m,@n)$\n\t\tSELECT @m,@n$\n```\n\n**三、删除存储过程**\n\n```mysql\n#语法：drop procedure 存储过程名\nDROP PROCEDURE p1;\nDROP PROCEDURE p2,p3;-- 错误的写法\n```\n\n**四、查看存储过程的信息**\n\n```mysql\nDESC myp2;-- 错误的写法\nSHOW CREATE PROCEDURE  myp2;\n```\n\n## 11.2 函数\n\n​\t含义：一组预先编译好的SQL语句的集合，理解成批处理语句\n​\t\t\t1、提高代码的重用性\n​\t\t\t2、简化操作\n​\t\t\t3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率\n\n​\t区别：\n\n​\t\t\t存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新\n​\t\t\t函数：有且仅有1 个返回，适合做处理数据后返回一个结果\n\n**一、创建语法**\n\n​\t\t\tCREATE FUNCTION 函数名(参数列表) RETURNS 返回类型\n​\t\t\tBEGIN\n​\t\t\t\t\t\t函数体\n​\t\t\tEND   结束标记\n\n注意：\n1.参数列表 包含两部分：\n\t\t参数名 参数类型\n\n2.函数体：肯定会有return语句，如果没有会报错\n\t\t如果return语句没有放在函数体的最后也不报错，但不建议\n3.函数体中仅有一句话，则可以省略begin end\n4.使用 delimiter语句设置结束标记\n\n**二、调用语法**\n\n​\t\tSELECT 函数名(参数列表)\n\n```mysql\n#1.无参有返回\n\t#案例：返回公司的员工个数\n\t\tCREATE FUNCTION myf1() RETURNS INT\n\t\tBEGIN\n\t\t\tDECLARE c INT DEFAULT 0;#定义局部变量\n\t\t\tSELECT COUNT(*) INTO c#赋值\n\t\t\tFROM employees;\n\t\t\tRETURN c;\n\t\t\t\n\t\tEND $\n\t# 调用\n\t\tSELECT myf1()$\n#2.有参有返回\n\t#案例1：根据员工名，返回它的工资\n\t\tCREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLE\n\t\tBEGIN\n\t\t\tSET @sal=0;#定义用户变量 \n\t\t\tSELECT salary INTO @sal   #赋值\n\t\t\tFROM employees\n\t\t\tWHERE last_name = empName;\n\t\t\t\n\t\t\tRETURN @sal;\n\t\tEND $\n\t# 调用\n\t\tSELECT myf2('k_ing') $\n\t#案例2：根据部门名，返回该部门的平均工资\n\t\tCREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE\n\t\tBEGIN\n\t\t\tDECLARE sal DOUBLE ;\n\t\t\tSELECT AVG(salary) INTO sal\n\t\t\tFROM employees e\n\t\t\tJOIN departments d ON e.department_id = d.department_id\n\t\t\tWHERE d.department_name=deptName;\n\t\t\tRETURN sal;\n\t\tEND $\n\t# 调用\n\t\tSELECT myf3('IT')$\n```\n\n**三、查看函数**\n\t\tSHOW CREATE FUNCTION myf3;\n**四、删除函数**\n\t\tDROP FUNCTION myf3;\n\n# 十二、流程控制结构\n\n## 12.1顺序结构\n\n\n\n## 12.2分支结构\n\n **一.if函数**\n\n​\t\t语法：if(条件,值1，值2)\n​\t\t功能：实现双分支\n​\t应用在begin end中或外面\n\n**二.case结构**\n\n​\t语法：\n​\t情况1：类似于switch\n​\t\tcase 变量或表达式\n​\t\twhen 值1 then 语句1;\n​\t\twhen 值2 then 语句2;\n​\t\t...\n​\t\telse 语句n;\n​\t\tend \n\n​\t情况2：\n​\t\tcase 类似于多重if，应用在begin end 中或外面\n​\t\twhen 条件1 then 语句1;\n​\t\twhen 条件2 then 语句2;\n​\t\t...\n​\t\telse 语句n;\n​\t\tend \n\ncase结构——作为表达式\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208170512.png)\n\ncase结构——作为独立的语句\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208170517.png)\n\n**三.if结构**\n\n​\t语法：\n​\t\tif 条件1 then 语句1;\n​\t\telseif 条件2 then 语句2;\n​\t\t....\n​\t\telse 语句n;\n​\t\tend if;\n​\t功能：类似于多重if，只能应用在begin end 中\n\n```mysql\n#案例1：创建函数，实现传入成绩，如果成绩>90,返回A，如果成绩>80,返回B，如果成绩>60,返回C，否则返回D\n\tCREATE FUNCTION test_if(score FLOAT) RETURNS CHAR\n\tBEGIN\n\t\tDECLARE ch CHAR DEFAULT 'A';\n\t\tIF score>90 THEN SET ch='A';\n\t\tELSEIF score>80 THEN SET ch='B';\n\t\tELSEIF score>60 THEN SET ch='C';\n\t\tELSE SET ch='D';\n\t\tEND IF;\n\t\tRETURN ch;\n\tEND $\n# 调用\n\tSELECT test_if(87)$\n#案例2：创建存储过程，如果工资<2000,则删除，如果5000>工资>2000,则涨工资1000，否则涨工资500\n\tCREATE PROCEDURE test_if_pro(IN sal DOUBLE)\n\tBEGIN\n\t\tIF sal<2000 THEN DELETE FROM employees WHERE employees.salary=sal;\n\t\tELSEIF sal>=2000 AND sal<5000 THEN UPDATE employees SET salary=salary+1000 WHERE employees.`salary`=sal;\n\t\tELSE UPDATE employees SET salary=salary+500 WHERE employees.`salary`=sal;\n\t\tEND IF;\n\tEND $\n# 调用\n\tCALL test_if_pro(2100)$\n\n#案例1：创建函数，实现传入成绩，如果成绩>90,返回A，如果成绩>80,返回B，如果成绩>60,返回C，否则返回D\n\tCREATE FUNCTION test_case(score FLOAT) RETURNS CHAR\n\tBEGIN \n\t\tDECLARE ch CHAR DEFAULT 'A';\n\t\tCASE \n\t\tWHEN score>90 THEN SET ch='A';\n\t\tWHEN score>80 THEN SET ch='B';\n\t\tWHEN score>60 THEN SET ch='C';\n\t\tELSE SET ch='D';\n\t\tEND CASE;\n\t\tRETURN ch;\n\tEND $\n# 调用\n\tSELECT test_case(56)$\n```\n\n## 12.3循环结构\n\n​\t分类： while、loop、repeat\n\n​\t循环控制：\n\n​\t\titerate  类似于 continue，继续，结束本次循环，继续下一次\n​\t\tleave    类似于  break，跳出，结束当前所在的循环\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201208170556.png)\n\n**一.while**\n\n​\t语法：\n\n​\t\t【标签:】while 循环条件 do\n​\t\t\t循环体;\n​\t\tend while【 标签】;\n\n联想：类似与Java\n\n​\t\twhile(循环条件){\n\n​\t\t\t\t循环体;\n\n​\t\t}\n\n**二.loop**\n\n​\t语法：\n​\t\t【标签:】loop\n​\t\t\t\t循环体;\n​\t\tend loop 【标签】;\n\n可以用来模拟简单的死循环\n\n**三.repeat**\n\t语法：\n\t\t【标签：】repeat\n\t\t\t循环体;\n\t\t\tuntil 结束循环的条件\n\t\tend repeat 【标签】;\n\n```mysql\n#1.没有添加循环控制语句\n\t#案例：批量插入，根据次数插入到admin表中多条记录\n\t\tDROP PROCEDURE pro_while1$\n\t\tCREATE PROCEDURE pro_while1(IN insertCount INT)\n\t\tBEGIN\n\t\t\tDECLARE i INT DEFAULT 1;\n\t\t\tWHILE i<=insertCount DO\n\t\t\t\tINSERT INTO admin(username,`password`) VALUES(CONCAT('Rose',i),'666');\n\t\t\t\tSET i=i+1;\n\t\t\tEND WHILE;\n\t\tEND $\n\t# 调用\n\t\tCALL pro_while1(100)$\n-- 等价于Java\n/*\n\tint i=1;\n\twhile(i<=insertcount){\n\t\t//插入\n\t\ti++;\n\t}\n*/\n#2.添加leave语句\n\t#案例：批量插入，根据次数插入到admin表中多条记录，如果次数>20则停止\n\t\tTRUNCATE TABLE admin$\n\t\tDROP PROCEDURE test_while1$\n\t\tCREATE PROCEDURE test_while1(IN insertCount INT)\n\t\tBEGIN\n\t\t\tDECLARE i INT DEFAULT 1;\n\t\t\ta:WHILE i<=insertCount DO\n\t\t\t\tINSERT INTO admin(username,`password`) VALUES(CONCAT('xiaohua',i),'0000');\n\t\t\t\tIF i>=20 THEN LEAVE a;\n\t\t\t\tEND IF;\n\t\t\t\tSET i=i+1;\n\t\t\tEND WHILE a;\n\t\tEND $\n\t# 调用\n\t\tCALL test_while1(100)$\n#3.添加iterate语句\n\t#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次\n\t\tTRUNCATE TABLE admin$\n\t\tDROP PROCEDURE test_while1$\n\t\tCREATE PROCEDURE test_while1(IN insertCount INT)\n\t\tBEGIN\n\t\t\tDECLARE i INT DEFAULT 0;\n\t\t\ta:WHILE i<=insertCount DO\n\t\t\t\tSET i=i+1;\n\t\t\t\tIF MOD(i,2)!=0 THEN ITERATE a;\n\t\t\t\tEND IF;\n\t\t\t\tINSERT INTO admin(username,`password`) VALUES(CONCAT('xiaohua',i),'0000');\n\t\t\tEND WHILE a;\n\t\tEND $\n\t# 调用\n\t\tCALL test_while1(100)$\n-- 等价于Java\n/*\n\tint i=0;\n\twhile(i<=insertCount){\n\t\ti++;\n\t\tif(i%2==0){\n\t\t\tcontinue;\n\t\t}\n\t\t插入\n\t}\n*/\n```\n\n# 十三，常见英文单词\n\n\n\n","categories":["Java学习","数据库"]},{"title":"面向对象(中)","url":"/2020/12/13/尚硅谷说Java/Java基础语法/8-面向对象中/","content":"\nJava中的继承性,权限访问符,多态性\n\n<!--more-->\n# OOP特征二：继承性\n\n* 为什么要有继承？\n\n  * 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。\n\n* 此处的多个类称为子类(派生类)，单独的这个类称为父类(基类 或超类)。可以理解为:“子类 is a 父类”\n\n* 类继承语法规则:class Subclass extends SuperClass{ }\n\n* 继承的作用：\n\n  * 继承的出现减少了代码冗余，提高了代码的复用性。\n  * 继承的出现，更有利于功能的扩展。\n  * 继承的出现让类与类之间产生了关系，提供了多态的前提。 \n\n* 注意：不要仅为了获取其他类中某个功能而去继承\n\n* 子类继承了父类，就继承了父类的方法和属性。\n\n* 在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。\n\n* 在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展”。\n\n* 关于继承的规则：\n\n  * 子类不能直接访问父类中私有的(private)的成员变量和方法\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184321.png)\n\n  * Java只支持单继承和多层继承，不允许多重继承\n\n    * 一个子类只能有一个父类\n    * 一个父类可以派生出多个子类\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184322.png)\n\n```java\n//举例\npublic class Person {\n\tString name;\n\tint age;\n\tpublic void eat() {\n\t\tSystem.out.println(\"吃饭\");\n\t}\n}\npublic class Student extends Person{\n\tint id;\n\tpublic void say() {\n\t\tSystem.out.println(\"读书\");\n\t}\n}\npublic static void main(String[] args) {\n    Student student = new Student();\n    student.eat();\n    student.say();\n}\n//输出\n吃饭\n读书\n```\n\n# 方法的重写(override)\n\n* 定义：在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。\n* 要求：\n  * 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表\n  * 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型\n  * 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限\n    * 子类不能重写父类中声明为private权限的方法\n  * 子类方法抛出的异常不能大于父类被重写方法的异常\n* 注意：子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。\n\n```java\n//举例\npublic class Person {\n\tString name;\n\tint age;\n\tpublic void eat() {\n\t\tSystem.out.println(\"吃饭\");\n\t}\n}\npublic class Student extends Person{\n\tint id;\n    public  void eat() {\n\t\tSystem.out.println(\"学生吃饭\");\n\t}\n\tpublic void say() {\n\t\tSystem.out.println(\"读书\");\n\t}\n}\npublic static void main(String[] args) {\n    Student student = new Student();\n    student.eat();\n    student.say();\n    Person person = new Person();\n\tperson.eat();\n}\n//输出\n学生吃饭\n读书\n吃饭\n```\n\n# 四种访问权限修饰符\n\n  * Java权限修饰符public、protected、(缺省)、private置于类的成员定义前，用来限定对象对该类成员的访问权限。\n\n| 修饰符        | 类内部 | 同一个包 | 不同包的子类 | 同一个工程 |\n| ------------- | ------ | -------- | ------------ | ---------- |\n| private       | YES    |          |              |            |\n| default(缺省) | YES    | YES      |              |            |\n| protectd      | YES    | YES      | YES          |            |\n| public        | YES    | YES      | YES          | YES        |\n\n  * 对于class的权限修饰只可以用public和default(缺省)。\n    * public类可以在任何对方被访问\n    * default类之可以被同一个包内部的类访问\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184323.png)\n\n# 关键字super\n\n* 在Java类中使用super来调用父类中的指定操作：\n\n  * super可用于访问父类中定义的属性\n  * super可用于调用父类中定义的成员方法\n  * super可用于在子类构造器中调用父类的构造器\n\n* 注意：\n\n  * 尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员\n  * super的追溯不仅限于直接父类 \n  * super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识\n\n* 调用父类的构造器时：\n\n  * 子类中所有的构造器默认都会访问父类中空参数的构造器\n  * 当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器。同时，只能”二选一”，且必须放在构造器的首行\n  * 如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错\n\n* this和super的区别\n\n  |   区别点   |                          this                          |                  super                   |\n  | :--------: | :----------------------------------------------------: | :--------------------------------------: |\n  |  访问属性  | 访问本类中的属性，如果本类没有此属性则从父类中继续查找 |           直接访问父类中的属性           |\n  |  调用方法  | 访问本类中的方法，如果本类没有此方法则从父类中继续查找 |           直接访问父类中的方法           |\n  | 调用构造器 |          调用本类构造器，必须放在构造器的首行          | 调用父类构造器，必须放在子类构造器的首行 |\n\n  ```java\n  public class Person {\n  \tString name;\n  \tint age;\n  \tpublic Person() {\n  \t\tSystem.out.println(\"创建一个人\");\n  \t}\n  \tpublic  void eat() {\n  \t\tSystem.out.println(\"吃饭\");\n  \t}\n  }\n  public class Student extends Person{\n  \tint id;\n  \tpublic Student(){\n  \t\t//super() 首行隐藏了super()\n  \t\tSystem.out.println(\"创建一个学生\");\n  \t}\n  \tpublic  void eat() {\n  \t\tSystem.out.println(\"学生吃饭\");\n  \t\tsuper.eat();\n  \t}\n  \tpublic void say() {\n  \t\tSystem.out.println(\"读书\");\n  \t}\n  }\n  public static void main(String[] args) {\n      Student student = new Student();\n      student.eat();\n      student.say();\n  }\n  //输出\n  创建一个人  \n  创建一个学生\n  学生吃饭\n  吃饭\n  读书\n  ```\n\n# OOP特征三：多态性\n\n* 多态性，是面向对象中最重要的概念，在Java中的体现：\n\n  * 对象的多态性：父类的引用指向子类的对象\n  * 可以直接应用在抽象类和接口上\n\n* Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。\n\n  * 简称：编译时，看左边；运行时，看右边。\n  * 若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)\n  * 多态情况下，“看左边”：看的是父类的引用（父类中不具备子类特有的方法）\n  * “看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）\n\n* 对象的多态 —在Java中,子类的对象可以替代父类的对象使用\n\n  * 一个变量只能有一种确定的数据类型\n  * 一个引用类型变量可能指向(引用)多种不同类型的对象\n\n* 子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。\n\n* 一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法\n\n  ```java\n  Student m = new Student();\n  m.school = “pku”; //合法,Student类有school成员变量\n  Person e = new Student(); \n  e.school = “pku”; //非法,Person类没有school成员变量\n  ```\n\n  * 属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误\n\n* 虚拟方法调用(多态情况下)\n\n  * 子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。\n\n  ```java\n  Person e = new Student();\n  e.getInfo(); //调用Student类的getInfo()方法\n  ```\n\n  * 编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类 的getInfo()方法。——动态绑定\n\n* 从编译和运行的角度看\n\n  * 重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；\n  * 而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。\n  * 引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”\n\n* 多态作用：提高了代码的通用性，常称作接口重用\n\n* 前提：需要存在继承或者实现关系。有方法的重写\n\n* 成员方法：\n\n  * 编译时：要查看引用变量所声明的类中是否有所调用的方法。\n  * 运行时：调用实际new的对象所属的类中的重写方法。\n\n* 成员变量：不具备多态性，只看引用变量所声明的类\n\n* 子类继承父类\n\n  * 若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。\n  * 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量\n\n## instanceof操作符\n\n* x instanceof A：检验x是否为类A的对象，返回值为boolean型。\n  * 要求x所属的类与类A必须是子类和父类的关系，否则编译错误。\n  * 如果x属于类A的子类B，x instanceof A值也为true\n\n## 对象类型转换(Casting)\n\n* 基本数据类型的Casting：\n  * 自动类型转换：小的数据类型可以自动转换成大的数据类型\n  * 强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型\n* 对Java对象的强制类型转换称为造型\n  * 从子类到父类的类型转换可以自动进行\n  * 从父类到子类的类型转换必须通过造型(强制类型转换)实现\n  * 无继承关系的引用类型间的转换是非法的\n  * 在造型前可以使用instanceof操作符测试一个对象的类型\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184324.png)\n\n# Object类的使用\n\n* Object类是所有Java类的根父类\n* 如果在类的声明中未使用extends关键字指明其父类，则默认父类 为java.lang.Object类\n\n| 方法名称                          | 类型 | 描述           |\n| --------------------------------- | ---- | -------------- |\n| public Object()                   | 构造 | 构造器         |\n| public boolean equals(Object obj) | 普通 | 对象比较       |\n| public int hashCode()             | 普通 | 取得Hash码     |\n| public String toString()          | 普通 | 对象打印时调用 |\n\n* ==操作符与equals方法\n\n  * ==\n    * 基本类型比较值:只要两个变量的值相等，即为true。\n    * 引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，==才返回true。\n    * 用“==”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错\n  * equals\n    * 所有类都继承了Object，也就获得了equals()方法。还可以重写。 \n    * 只能比较引用类型，其作用与“==”相同,比较是否指向同一个对象。 \n    * 格式:obj1.equals(obj2) \n    * 特例：当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象.\n      * 原因：在这些类中重写了Object类的equals()方法。\n    * 当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等\n\n* 重写equals()方法的原则\n\n  * 对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。\n  * 自反性：x.equals(x)必须返回是“true”。\n  * 传递性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。\n  * 一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。\n  * 任何情况下，x.equals(null)，永远返回是“false”； x.equals(和x不同类型的对象)永远返回是“false”。\n\n* toString方法\n\n  * toString()方法在Object类中定义，其返回值是String类型，返回类名和它的引用地址。 \n  * 在进行String与其它类型数据的连接操作时，自动调用toString()方法\n\n  ```java\n  Date now=new Date();\n  System.out.println(“now=”+now); 相当于\n  System.out.println(“now=”+now.toString()); \n  ```\n\n  * 可以根据需要在用户自定义类型中重写toString()方法\n\n  ```java\n  如String 类重写了toString()方法，返回字符串的值。 \n  s1=“hello”;\n  System.out.println(s1);//相当于System.out.println(s1.toString());\n  ```\n\n  * 基本类型数据转换为String类型时，调用了对应包装类的toString()方法\n\n  ```java\n  int a=10; System.out.println(“a=”+a);\n  ```\n\n# JUnit单元测试步骤(Eclipse版)\n\n* 选中当前工程-右键选择-点击build path-点击add libraries-选中JUnit 4-下一步\n* 创建Java类，进行单元测试。\n  * 此时的Java类要求：①此类是public的，②此类有公共的无参构造器\n* 测试方法的格式：方法的权限是public的，没有返回值，方法名自定义\n* 此单元测试方法上需要声明注解：@Test,并在单元测试类中导入对应包：\n* 声明好单元测试方法以后，就可以在方法体内测试相关的代码\n* 写完代码以后，左键双击单元测试方法名，右键-run as-JUnit Test\n* 说明：如果执行结果没有任何异常，则显示为绿条。如果执行结果出现异常，则显示红条\n\n# 包装类的使用\n\n* 针对八种基本数据类型定义相应的引用类型—包装类（封装类）\n* 有了类的特点，就可以调用类中的方法，Java才是真正的面向对象\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184325.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184326.png)\n\n* 基本数据类型包装成包装类的实例 ---装箱\n\n  * 通过包装类的构造器实现：\n\n  ```java\n  //基本数据类型转换成包装类：调用包装类的构造器\n  int num = 10;\n  Integer in1 = new Integer(num);\n  System.out.println(in1);//10\n  \n  ```\n\n  * 还可以通过字符串参数构造包装类对象：\n\n  ```java\n  //基本数据类型转换成包装类：通过字符串参数构造包装类对象\n  Integer in2 = new Integer(\"123\");\n  System.out.println(in2);//123\n  //下面两行会报异常\n  //Integer in3 = new Integer(\"123asd\");\n  //System.out.println(in3);\n  //特殊情况:与其他类型相比，这个不会报异常\n  Boolean bool = new Boolean(\"true123\");\n  System.out.println(bool);//false\n  ```\n\n  * 自动封箱(JDK5.0以后支持),但类型必须匹配。\n\n  ```java\n  //基本数据类型转换成包装类：自动封箱(JDK5.0以后支持)\n  int a = 10;\n  Integer in = a;\n  System.out.println(in);//10\n  ```\n\n* 获得包装类对象中包装的基本类型变量 ---拆箱\n\n  * 调用包装类的.xxxValue()方法：\n\n  ```java\n  //包装类转换成基本数据类型：调用包装类的xxxValue()方法\n  \t\tInteger in = new Integer(\"123\");\n  \t\tint a = in.intValue();\n  \t\tSystem.out.println(a);//123\n  ```\n\n  * 自动拆箱(JDK5.0以后支持),但类型必须匹配。\n\n  ```jav\n  //包装类转换成基本数据类型：自动拆箱(JDK5.0以后支持)\n  Integer in = new Integer(\"123\");\n  int a = in;\n  System.out.println(a);//123\n  ```\n\n* 字符串转换成基本数据类型\n\n  * 通过包装类的构造器实现：\n  * 通过包装类的parseXxx(String s)静态方法：\n\n  ```java\n  //String类型转换成基本数据类型，包装类：\n  //1.调用包装类的parseXxx(String s)方法\n  String str1 = \"123\";\n  int num1 = Integer.parseInt(str1);\n  System.out.println(num1);//123\n  //报NumberFormatException异常\n  //String str4 = \"123a\";\n  //int num2 = Integer.parseInt(str4);\n  //System.out.println(num2);//123\n  \n  String str2 = \"true\";\n  boolean boo1 = Boolean.parseBoolean(str2);\n  System.out.println(boo1);//true\n  //特殊情况：不会报异常\n  String str3 = \"true1\";\n  boolean boo2 = Boolean.parseBoolean(str3);\n  System.out.println(boo2);//false\n  //2.调用包装类的构造器\n  String str5 = \"12\";\n  int num3 = new Integer(str5);\n  System.out.println(num3);//12\n  ```\n\n* 基本数据类型转换成字符串\n\n  * 调用字符串重载的valueOf()方法：\n  * 更直接的方式：连接运算\n\n  ```java\n  //基本数据类型，包装类转换成String类型\n  //1.连接运算\n  String str1 = 10 + \"\";\n  System.out.println(str1);//10\n  //2.调用String的valueOf(Object,object或基本数据类型)方法\n  int i = 10;\n  String str2 = String.valueOf(i);\n  System.out.println(str2);//10\n  \n  Double d = new Double(12.4);\n  String str3 = String.valueOf(d);\n  System.out.println(str3);//12.4\n  ```\n\n* 装箱：包装类使得一个基本数据类型的数据变成了类。有了类的特点，可以调用类中的方法。\n\n* 拆箱：将数字包装类中内容变为基本数据类型\n\n* 包装类在实际开发中用的最多的在于字符串变为基本数据类型\n\n* Integer的补充\n\n  ```java\n  //Integer内部定义了静态的IntegerCache结构，IntegerCache中定义了一个Integer[],\n  //数组静态保存了从-128~127范围的数。如果我们使用自动装箱的方式，给Integer赋值的范围在\n  //-128~127之间，可以直接使用数组中的元素，不用再去new了。\n  Integer a = 1;\n  Integer b = 1;\n  System.out.println(a);//1\n  System.out.println(b);//1\n  System.out.println(a == b);//true\n  \n  Integer in1 = 128;\n  Integer in2 = 128;\n  System.out.println(in1);//128\n  System.out.println(in2);//128\n  System.out.println(in1 == in2);//false\n  ```\n\n\n# 总结\n\n```java\n/**\n * 1.面向对象的特征之二\n * \t一，继承性的好处\n * \t\t①减少了代码的冗余，提高了代码的复用性\n * \t\t②便于功能的扩展\n * \t\t③为多态性的使用，提供了前提\n * \t二，继承的格式：class A extends B{}\n * \t\tA:子类，派生类，subclass\n * \t\tB:父类，超类，基类，superclass\n *\t\textends：延展，扩展\n * \t\t2.1体现：一旦子类A继承了父类B以后，子类A中就获取了父类B中声明的所有属性和方法。\n * \t\t\t特别的，父类中声明为private的属性和方法，子类继承父类后，仍然认为获取了父类中私有的结构。\n * \t\t\t只是因为封装性的影响，使得子类不能直接调用父类的结构而已\n * \t\t2.2子类继承父类以后，还可以声明自己特有的属性和方法：实现功能的扩展\n * \t\t\t子类和父类的关系，不同于子集和集合的关系\n * \t三，Java中关于继承的规定 \n * \t\t①一个类可以被多个子类继承\n * \t\t②Java中类的单继承性：一个类只能有一个父类\n * \t\t③子负类是相对的概念\n * \t\t④子类直接继承的父类称为：直接父类。间接继承的父类称为：间接父类\n * \t\t⑤子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法\n *\t四，如果我们没有显示的定义一个类的父类的话，则此类继承于java.lang.Object类\n *\t\t所有的java类(除java.lang.Object类)都直接或间接的继承于java.lang.Object\n *\t\t所以所有的java类具有java.lang.Object类声明的功能\n * 2.方法的重写(override)\n *\t一，重写：子类继承父类以后，可以对父类中同名参数的方法进行覆盖操作\n *\t二，应用：重写以后，当创建子类对象以后，通过子类对象调用父类中的同名同参数的方法时，\n *\t\t实际执行的是子类重写父类的方法\n *\t三，重写的规定：\n *\t\t\t方法的声明：权限修饰符 返回值类型 方法名(形参列表){\n *\t\t\t\t\t\t\t\t//方法体\n *\t\t\t\t\t\t}\n *\t\t\t约定俗称：\n *\t\t①子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和参数列表形同\n *\t\t②子类重写的方法的权限修饰符不小于父类被重写的 方法的权限修饰符\n *\t\t\t>特殊情况：子类不能重写父类中声明为private权限的方法\n *\t\t③返回值类型\n *\t\t\t>父类被重写的方法的返回值类型是void,则子类重写的方法的返回值只能是void\n *\t\t\t>父类被重写的方法的返回值类型是A类型(引用类型),则子类重写的方法的返回值可以是A类型的或A类的子类\n *\t\t\t>父类被重写的方法的返回值类型是基本数据类型,则子类重写的方法的返回值只能也是对应的基本类型\n *\t\t④子类重写的方法抛出的异常类型不大于父类被重写的方法排除的异常类型\n *\t\t⑤子类和父类中同名同参数的方法要么都声明为非static的(可以重写)，要么都声明为static的(不是重写)\n * 3.super关键字的使用\n * \t一，super理解为：父类的\n * \t二，super可以用来调用：属性，方法，构造器\n * \t三，super调用属性或方法：\n * \t\t①我们可以在子类的方法或构造器中，通过使用“super.属性”或“super.方法”的方式，显示的调用\n * \t\t父类中声明的属性或方法。但是通常情况下我们都习惯省略“super.”\n * \t\t②特殊情况：当子类和父类中定义了同名的属性时，我们想要在子类中调用父类中声明的属性，则必须显示的使用\n * \t\t“super.属性”的方式，表明调用的是父类中声明的属性。\n * \t\t③特殊情况：当子类重写了父类的方法以后，外卖想在子类的方法中调用父类中被重写的方法时，必须显示的使用\n * \t\t“super.方法”的方式，表明调用的是父类中被重写的方法。\n *\t四，super调用构造器：\n *\t\t①我们可以在子类的构造器中显式的使用“super(形参列表)”的方式，调用父类中声明的制定的构造器\n *\t\t②“super(形参列表)”的使用，必须声明在子类构造器的首行\n *\t\t③我们在类的构造器中，针对“this(形参列表)”或“super(形参列表)”只能二选一，不能同时出现\n *\t\t④在构造器的首行没有显示的声明“this(形参列表)”或“super(形参列表)”，则默认使用“super()”调用父类中空参的构造器\n *\t\t⑤在类的多个构造器中，至少有一个类的构造器中使用了“super(形参列表)”，调用父类中的构造器\n * 4.子类对象实例化的过程\n * \t一，从结果上看：（继承性）\n *\t\t子类继承父类后，就获取了父类中声明的属性或方法\n *\t\t创建子类的对象，在堆空间中，就会加载所有父类中的声明的属性\n *\t二，从过程上看：\n *\t\t当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器\n *\t\t直到调用了java.lang.Obkect类中空参的构造器为止，正因为加载了所有的父类的结构，所以才可以看到内存中有父类中\n *\t\t的结构，子类对象才可以调用父类的结构\n *\t明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建了一个对象，即为new的子类对象\n * 5.多态性的理解\n * \t一，理解多态性：可以理解为一个事务的多种形态\n * \t二，何为多态性\n * \t\t对象多态性：父类的引用指向子类的对象(或子类的对象赋给对象的引用)\n *\t三，多态的使用：虚拟方法调用\n *\t\t有了对象的多态性后，我们在编译时期，只能调用父类中声明的方法，但在运行时期，我们实际调用的是父类中重写子类的方法\n *\t\t举例。我们定义了一个A类，定义了一个B类，且B类继承A类。在A类中定义一个输出方法输出a。B类中重写这个输出方法输出b。\n *\t\t\t另外B类中在定义一个show()方法，输出show。\n *\t\t\t当执行A a = new B(); a.printf(); 此时的输出是B类中重写的内容。即输出b\n *\t\t\t但当编写a.show()时会编译不通过。\n *\t\t总结：编译看左边，运行看右边。\n *\t四，多态性的使用前提：\n *\t\t\t①类有继承关系。②方法要重写。\n *\t五，多态性的好处：\n *\t\t\t①在调用以对象为参数的方法时，将方法的参数设置为父类，那么当传进去不同子类的对象时，执行的结果也就不同。\n *\t\t\t如果此时没有多态性。我们必须将这个方法重写很多次以适应子类的不同。因此多态性可以减少代码的编写\n *\t六，多态性的注意点：\n *\t\t\t①对象多态性只适用于方法，不适用于属性(属性和方法都看左边)\t\t\n *\t七，内存中的变化。\n *\t\t\t多态性的使用时，内存中实际上是加载了子类特有的属性何方法的。但是由于变量被声明为父类类型，导致编译时，\n *\t\t\t只能调用父类中声明的属性何方法。子类特有的属性仍然存在在内存中但无法调用\n * 6.instanceof关键字\n *\t一，多态性使用后如何让变量调用子类特有的属性和方法？\n *\t\t①向下转型，使用强制类型转换符\n *\t\t\t缺点：A类是B类和C类的父类。当A a = new B();时，强转a为C类时会出现ClassCastException异常\n *\t\t②使用instanceof关键字提前判断是否可以强转\n *\t二，使用：a instanceof A：表示判断对象a是否是类A的实例。如果是返回true。如果不是返回false\n *\t三，使用情景：为了避免在向下转型时出现ClassCastException异常，我们在向下转型之前，先进行instanceof的判断\n *\t\t\t\t，一旦返回true就进行向下转型。如果返回false则不能进行向下转型\n *\t四，补充：B类是A类的父类的话那么a instanceof A返回true,且a instanceof B也返回true.\n * 7.Object类\n * \t ①：Object类是所有Java类的根父类\n * \t ②：如果在类的声明中未使用extends关键字指明其父类。则默认父类为java.lang.Object类\t\n * \t ③：Object类中的功能(属性，方法)具有通用性。\n * \t\t属性：无\n * \t\t方法：equals()/toStrings()/getClass()/hasCode()/clone()/finalize()/wait()/notify()/notifyAll()\n *   ④：Object类只声明了一个空参的构造器\n *  一，==和equals()的区别\n *   ==的使用：\n *   \t①：可以使用在基本数据类型和引用数据类型变量中\n *   \t②：如果比较的是基本数据类型变量，比较两个变量的数据是否相等。(不一定类型相同)\n *   \t③：如果比较的是引用数据类型变量，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体\n *   \t④：==符号在使用时要保证符号两边的数据类型要一致。既可以比较\n *   equals()的使用\n *   \t①：是一个方法，而非运算符\n *   \t②：只能适用于引用数据类型\n *   \t③：Object类中的equals()中对定义:和==是相同的，都是比较两个对象的地址值是否相同\n *   \t源码：public boolean equals(Object obj) {\n *       \t\t\treturn (this == obj);\n *   \t\t  }\n *   \t④：像String,Date,File,包装类等都重写了Object类中的equals()方法，重写后比较的是两个对象的“实体内容”是否相同\n *   \t\t而不是引用的地址是否相同\n *   \t⑤： 自定义类的比较需要我们重写equals()方法。一般情况下我们会选择自动生成的equals()方法。而不自己写。\n *\t二，toString()方法的使用\n *\t\t①：Object类的toString()方法输出的是对象的引用地址值\n *\t\t②：当我们输出一个对象的应用时，实际上是调用对象的toString()方法\n *\t\t③：像String,Date,File,包装类等都重写了Object类中的toString()方法。\n *\t\t\t使得在调用上述类型的对象的toString()方法时，返回的是对象的“实体内容”信息\n *\t\t④：自定义的类可以重写toString()方法。重写此方法一般使用自动生成，重写后的方法返回的是实体内容的信息\n * 8.包装类的使用\n * \t ①：Java提供了8中基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征\n *\t ②：基本数据类型，包装类，String三者之间的转换\n *\t\t一，基本数据类型转换成包装类\n *\t\t\t①：调用包装类的构造\n *\t\t\t②：自送封箱(JDK5.0以后支持)\n *\t\t二，包装类转换成基本数据类型\n *\t\t\t①：调用包装类的xxxValue()方法\n *\t\t\t②：自动拆箱(JDK5.0以后支持)\n *\t\t三，基本数据类型，包装类转换成String类型\n *\t\t\t①：连接运算\n *\t\t\t②：调用String的valueOf(Object,object或基本数据类型)方法\n *\t\t四，String类型转换成基本数据类型，包装类\n *\t\t\t①：调用包装类的parseXxx(String s)方法\n *\t\t\t②：调用包装类的构造器\n */\n```\n\n","categories":["Java学习","Java基础语法"]},{"title":"面向对象(上)","url":"/2020/12/12/尚硅谷说Java/Java基础语法/7-面向对象上/","content":"\nJava中的类的说明以及工具类，关键字this,import,package，封装性\n\n<!--more-->\n# 面向过程和面向对象\n\n* 面向过程：Procedure Oriented Programming(POP)强调的是功能行为，以函数为最小单位，考虑怎么做。\n* 面向对象：Object Oriented Programming(OOP)将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。\n* 二者都是一种思想，面向对象是相对于面向过程而言的。\n* 面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。\n* 面向对象的三大特征:\n  * 封装 (Encapsulation)\n  * 继承 (Inheritance)\n  * 多态 (Polymorphism)\n* 面向对象的思想概述\n  * 程序员从面向过程的<font color = \"red\">执行者</font>转化成了面向对象的<font color = \"red\">指挥者</font>\n  * 面向对象分析方法分析问题的思路和步骤：\n    * 根据问题需要，选择问题所针对的<font color = \"red\">现实世界中的实体</font>。\n    * 从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了<font color = \"red\">概念世界中的类</font>。 \n    * 把抽象的实体用计算机语言进行描述，<font color = \"red\">形成计算机世界中类的定义</font>。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。\n    * 将<font color = \"red\">类实例化成计算机世界中的对象</font>。对象是计算机世界中解决问题的最终工具。\n\n# Java的基本元素：类和对象\n\n* 面向对象的思想概述\n\n  * 类(Class)和对象(Object)是面向对象的核心概念。\n    * 类是对一类事物的描述，是抽象的、概念上的定义\n    * 对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。\n  *  “万事万物皆对象”\n  * 面向对象程序设计的重点是<font color = \"red\">类的设计</font>\n  * 类的设计，<font color = \"red\">其实就是类的成员的设计</font>\n\n* Java类及类的成员\n\n  * 现实世界的生物体，大到鲸鱼，小到蚂蚁，都是由最基本的细胞构成的。同理，Java代码世界是由诸多个不同功能的类构成的。\n  * 现实生物世界中的细胞又是由什么构成的呢？细胞核、细胞质、… 那么，Java中用类class来描述事物也是如此。常见的类的成员有：\n    * 属 性：对应类中的成员变量。Field = 属性 = 成员变量\n    * 行 为：对应类中的成员方法。Method = (成员)方法 = 函数\n\n  ```java\n  //1.创建类，设计类的成员\n  class Person{\n  \t//属性\n  \tString name;\n  \tint age = 1;\n  \tboolean isMale;\n  \t//构造器\n  \tpublic Person() {}\n  \tpublic Person(String n,boolean im) {\n  \t\tname = n;\n  \t\tisMale = im;\n  \t}\n  \t//方法\n  \tpublic void eat() {\n  \t\tSystem.out.println(\"人可以吃饭\");\n  \t}\n  \tpublic void sleep() {\n  \t\tSystem.out.println(\"人可以睡觉\");\n  \t}\n  \tpublic void talk(String language) {\n  \t\tSystem.out.println(\"人可以说话，语言为：\"+language);\n  \t}\n  \t//代码块\n  \t{\n  \t\tname = \"张三\";\n  \t\tage = 17;\n  \t\tisMale = true;\n  \t}\n  \t//内部类\n  \tclass pet{\n  \t\tString name;\n  \t\tfloat weight;\n  \t}\n  }\n  ```\n\n* 类的语法格式\n\n  ```java\n  修饰符 class 类名{\n  \t属性声明;\n      方法声明;\n  }\n  //说明：修饰符public:类可以被任意访问。类的正文要用{}括起来\n  ```\n\n# 对象的创建和使用\n\n* 创建对象语法： 类名 对象名 = new 类名();\n\n* 使用“对象名.对象成员”的方式访问对象成员（包括属性和方法）\n\n  ```java\n  //2.创建Person类的对象\n  Person person = new Person();\n  //调用对象的结构，属性，方法\n  //调用属性：“对象.属性”\n  person.name = \"Tom\";\n  person.isMale = true;\n  System.out.println(person.name);\n  //调用方法：“对象.方法”\n  person.eat();\n  person.sleep();\n  person.talk(\"Chinese\");\n  ```\n\n* 如果创建了一个类的多个对象，对于类中定义的属性，每个对象都拥有各自的一套副本，且互不干扰。\n\n* 类的访问机制：\n\n  * <font color = \"red\">在一个类中的访问机制</font>：类中的方法可以直接访问类中的成员变量。 （例外：<font color = \"red\">static方法访问非static，编译不通过</font>。）\n  * <font color = \"red\">在不同类中的访问机制</font>：先创建要访问类的对象，再用对象访问类中定义的成员。\n\n  ```java\n  Person person2 = new Person();\n  System.out.println(person2.name);//null\n  //***************************\n  Person person3 = person;\n  System.out.println(person3.name);//Tom\n  person3.age = 18;\n  System.out.println(person.age);//18\n  ```\n\n* 内存解析\n\n  * <font color = \"red\">堆（Heap）</font>，此内存区域的唯一目的就是<font color = \"red\">存放对象实例</font>，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。\n  * <font color = \"red\">栈（Stack）</font>，是指虚拟机栈。虚拟机栈用于<font color = \"red\">存储局部变量</font>等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char 、 short 、 int 、 float 、 long 、double）、对象引用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。 方法执行完，自动释放。 \n  * <font color = \"red\">方法区（Method Area）</font>，用于存储已被虚拟机加载的<font color = \"red\">类信息、常量、静态变量、即时编译器编译后的代码</font>等数据\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184311.png)\n\n* 匿名对象\n\n  * 我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。如：<font color = \"red\">new Person().shout();</font> \n  * 使用情况\n    * 如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。\n    * 我们经常将匿名对象作为实参传递给一个方法调用\n\n# 类的成员之一：属性\n\n* 语法格式：修饰符 数据类型 属性名 = 初始化值 ;\n\n  * 说明1: 修饰符\n    * 常用的权限修饰符有：private、缺省、protected、public\n    * 其他修饰符：static、final (暂不考虑)\n  * 说明2：数据类型\n    * 任何基本数据类型(如int、Boolean) 或 任何引用数据类型。\n  * 说明3：属性名\n    * 属于标识符，符合命名规则和规范即可。\n\n  ```java\n  //举例：\n  public class Person{\n      private int age; //声明private变量 age\n      public String name = “Lila”; //声明public变量 name\n  }\n  ```\n\n* 变量的分类：成员变量与局部变量\n\n  * 在方法体外，类体内声明的变量称为成员变量。\n  * 在方法体内部声明的变量称为局部变量。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184312.png)\n\n  * 注意：二者在初始化值方面的异同:\n    * 同：都有生命周期\n    * 异：局部变量除形参外，均需显式初始化。\n  * 成员变量（属性）和局部变量的区别\n\n  |              | 成员变量                      | 局部变量                                 |\n  | :----------: | :---------------------------- | ---------------------------------------- |\n  |  声明的位置  | 直接声明在类中                | 方法形参或内部，代码块内，构造器内等     |\n  |    修饰符    | private,public,static,final等 | 不能用权限修饰符，可以用final修饰        |\n  |   初始化值   | 有默认初始化值                | 没有默认初始化值。必须显式赋值，方可使用 |\n  | 内存加载位置 | 堆空间或静态域内              | 栈空间                                   |\n\n* 对象属性的默认初始化赋值：当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。除了基本数据类型之外的变量类型都是引用类型，如同数组的默认初始化值相同。\n\n# 类的成员之二：方法\n\n* 什么是方法(method、函数):\n\n  * 方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过程。\n  * 将功能封装为方法的目的是，可以实现代码重用，简化代码\n  * Java里的方法不能独立存在，所有的方法必须定义在类里。\n\n  ```java\n  //举例：\n  public class Person{\n      private int age;\n      public int getAge() { //声明方法getAge()\n          return age; \n      }\n      public void setAge(int i) { //声明方法setAge\n          age = i; //将参数i的值赋给类的成员变量age\n      } \n  }\n  ```\n\n* 方法的声明格式：\n\n  ```java\n  修饰符 返回值类型 方法名（参数类型 形参1, 参数类型 形参2, ….）｛\n  \t\t方法体程序代码\n  \t\treturn 返回值; \n  ｝\n  ```\n\n  * 说明1：修饰符：public,缺省,private, protected等\n  * 说明2：返回值类型：\n    * 没有返回值：void。\n    * 有返回值，声明出返回值的类型。与方法体中“return 返回值”搭配使用\n  * 说明3：方法名：属于标识符，命名时遵循标识符命名规则和规范，“见名知意”\n  * 说明4：形参列表：可以包含零个，一个或多个参数。多个参数时，中间用“,”隔开\n  * 说明5：返回值：方法在执行完毕后返还给调用它的程序的数据。\n\n* 方法的分类：按照是否有形参及返回值\n\n  |        |         无返回值          |             有返回值              |\n  | :----: | :-----------------------: | :-------------------------------: |\n  | 无形参 |     void 方法名（）{}     |     返回值的类型 方法名（）{}     |\n  | 有形参 | void 方法名（形参列表）{} | 返回值的类型 方法名（形参列表）{} |\n\n* 方法的调用\n\n  * 方法通过方法名被调用，且只有被调用才会执行。\n\n* 方法调用的过程分析\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184313.png)\n\n* 注 意：\n\n  * 方法被调用一次，就会执行一次\n  * 没有具体返回值的情况，返回值类型用关键字void表示，那么方法体中可以不必使用return语句。如果使用，仅用来结束方法。\n  * 定义方法时，方法的结果应该返回给调用者，交由调用者处理。\n  * 方法中只能调用方法或属性，不可以在方法内部定义方法\n\n[练习题一](E:\\Markdown笔记\\尚硅谷说Java\\Java基础语法\\练习题集.md)\n\n## 自定义Arrays工具类\n\n ```java\npublic class ArraysUtil {\n\t//求整型数组的最大值\n\tpublic int getMax(int[] arr) {\n\t\tint temp = arr[0];\n\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\tif(temp < arr[i]) {\n\t\t\t\ttemp = arr[i];\n\t\t\t}\n\t\t}\n\t\treturn temp;\n\t}\n\t//求整型数组的最小值\n\tpublic int getMin(int[] arr) {\n\t\tint temp = arr[0];\n\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\tif(temp > arr[i]) {\n\t\t\t\ttemp = arr[i];\n\t\t\t}\n\t\t}\n\t\treturn temp;\n\t}\n\t//求整型数组的总和\n\tpublic int getSum(int[] arr) {\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tsum += arr[i];\n\t\t}\n\t\treturn sum;\n\t}\n\t//求整型数组的平均值\n\tpublic double getAvg(int[] arr) {\n\t\treturn (double)getSum(arr) / arr.length;\n\t}\n\t//反转数组\n\tpublic void reverse(int[] arr) {\n\t\tfor(int i = 0,j = arr.length - 1;i < j;i++,j--) {\n\t\t    int temp = arr[i];\n\t\t    arr[i] = arr[j];\n\t\t    arr[j] = temp;  \n\t\t}\n\t}\n\t//复制数组\n\tpublic int[] copy(int[] arr) {\n\t\tint[] arr2 = new int[arr.length];\n\t\tfor (int i = 0; i < arr2.length; i++) {\n\t\t    arr2[i]= arr[i]; \n\t\t}\n\t\treturn arr2;\n\t}\n\t//数组排序\n\tpublic void sort(int[] arr) {\n\t\tfor (int i = 0; i < arr.length - 1; i++) {\n\t\t    boolean flag = true;\n\t\t    for (int j = 0; j < arr.length - 1 - i; j++) {\n\t\t        if(arr[j]> arr[j + 1]) {\n\t\t            flag = false;\n\t\t            int temp = arr[j];\n\t\t            arr[j] = arr[j + 1];\n\t\t            arr[j + 1] = temp;\n\t\t        }\n\t\t    }\n\t\t    if(flag) {\n\t\t        break;\n\t\t    }\n\t\t}\n\t}\n\t//遍历数组\n\tpublic void print(int[] arr) {\n\t\tSystem.out.print(\"[ \");\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tSystem.out.print(arr[i]);\n\t\t\tif(i!=arr.length-1) {\n\t\t\t\tSystem.out.print(\" , \");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\" ]\");\n\t}\n\t//查找指定元素\n\tpublic int getIndex(int[] arr,int dest) {\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t    if(arr[i] == dest) {\n\t\t    \treturn i;\n\t\t    }\n\t\t}\n\t\treturn -1;\n\t}\n}\n ```\n\n## 方法的重载\n\n* 概念：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。\n\n* 特点：与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。\n\n* 示例：\n\n  ```java\n  //返回两个整数的和\n  int add(int x,int y){return x+y;}\n  //返回三个整数的和\n  int add(int x,int y,int z){return x+y+z;}\n  //返回两个小数的和\n  double add(double x,double y){return x+y;}\n  ```\n\n## 可变形参的方法\n\n* JavaSE 5.0 中提供了Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。\n\n  ```java\n  //JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量\n  public static void test(int a ,String[] books);\n  //JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量\n  public static void test(int a ,String…books);\n  ```\n\n* 说明：\n\n  1.  声明格式：方法名(参数的类型名 ...参数名)\n  2. 可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个\n  3. 可变个数形参的方法与同名的方法之间，彼此构成重载\n  4. 可变参数方法的使用与方法参数部分使用数组是一致的\n  5. 方法的参数部分有可变形参，需要放在形参声明的最后\n  6. 在一个方法的形参位置，最多只能声明一个可变个数形参\n\n## 方法参数的值传递机制\n\n* 方法，必须由其所在类或对象调用才有意义。若方法含有参数：\n  * 形参：方法声明时的参数\n  * 实参：方法调用时实际传给形参的参数值\n* Java里方法的参数传递方式只有一种：值传递。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。 \n  * 形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参\n  * 形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参\n  \n  [练习5]()\n\n## 递归方法\n\n* 递归方法：一个方法体内调用它自身。\n\n* 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。\n\n* 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。\n\n  ```java\n  //求1~100的所有的数的和\n  System.out.println(getSum(100));\n  public int getSum(int n) {\n      if(n <= 1) {\n          return 1;\n      }else {\n          return n + getSum(n - 1);\n      }\n  }\n  ```\n\n  [练习6]()\n\n# OPP特征一：封装和隐藏\n\n* 我们程序设计追求“高内聚，低耦合”。\n  *  高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；\n  *  低耦合 ：仅对外暴露少量的方法用于使用。 \n  \n* 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。\n\n* 原因：使用者对类内部定义的属性(对象的成员变量)的直接操作会导致数据的错误、混乱或安全性问题。\n\n* Java中通过将数据声明为私有的(private)，再提供公共的（public）方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的：\n\n  * 隐藏一个类中不需要对外提供的实现细节；\n  * 使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；\n  * 便于修改，增强代码的可维护性；\n\n  [练习7]()\n\n# 类的成员之三：构造器\n\n* 构造器的特征\n\n  * 它具有与类相同的名称\n  * 它不声明返回值类型。（与声明为void不同）\n  * 不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值 \n\n* 构造器的作用：创建对象；给对象进行初始化\n\n  * 如：Order o = new Order(); Person p =new Person(“Peter”,15); \n  * 如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了。\n\n* 语法格式：\n\n  ```java\n  修饰符 类名 (参数列表) {\n  \t初始化语句；\n  }\n  ```\n\n* 根据参数不同，构造器可以分为如下两类：\n\n  * 隐式无参构造器（系统默认提供）\n  * 显式定义一个或多个构造器（无参、有参）\n  \n* 注 意：\n\n  * Java语言中，每个类都至少有一个构造器\n  \n* 默认构造器的修饰符与所属类的修饰符一致\n  \n  * 一旦显式定义了构造器，则系统不再提供默认构造器\n  \n* 一个类可以创建多个重载的构造器\n  \n* 父类的构造器不可被子类继承\n  \n* 构造器重载\n\n  * 构造器一般用来创建对象的同时初始化对象。如\n  * 构造器重载使得对象的创建更加灵活，方便创建各种不同的对象\n  * 构造器重载，参数列表必须不同\n  \n  [练习8]()\n\n## 扩展\n\n* 属性赋值过程：很多位置都可以对类的属性赋值。现总结这几个位置，并指明赋值的先后顺序。\n\n  * 赋值的位置：\n\n    ① 默认初始化\n\n​          \t② 显式初始化\n\n  \t        ③ 构造器中初始化\n\n  \t        ④ 通过“对象.属性“或“对象.方法”的方式赋值\n\n  * 赋值的先后顺序：① \\- ② \\- ③ \\- ④\n\n* JavaBean\n\n  * JavaBean是一种Java语言写成的可重用组件。\n  * 所谓javaBean，是指符合如下标准的Java类：\n    * 类是公共的\n    * 有一个无参的公共的构造器\n    * 有属性，且有对应的get、set方法\n  * 用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。\n\n* UML类图\n\n  * \\+表示 public 类型， \\- 表示 private 类型，#表示protected类型\n  * 方法的写法:方法的类型(+、\\-) 方法名(参数名： 参数类型)：返回值类型\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184314.png)\n\n# 关键字：this,import,package\n\n## this\n\n* 在Java中，this关键字比较难理解，它的作用和其词义很接近。\n  * 它在方法内部使用，即这个方法所属对象的引用；\n  * 它在构造器内部使用，表示该构造器正在初始化的对象。\n* this 可以调用类的属性、方法和构造器\n* 什么时候使用this关键字呢？\n  * 当在方法内需要用到调用该方法的对象时，就用this。具体的：我们可以用this来区分属性和局部变量。比如：this.name =name;\n* 使用this，调用属性、方法\n  * 在任意方法或构造器内，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的阅读性。不过，通常我们都习惯省略this。\n  *  当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量\n  * 使用this访问属性和方法时，如果在本类中未找到，会从父类中查找\n  * this可以作为一个类中构造器相互调用的特殊格式\n* 注意：\n  * 可以在类的构造器中使用\"this(形参列表)\"的方式，调用本类中重载的其他的构造器！\n  * 明确：构造器中不能通过\"this(形参列表)\"的方式调用自身构造器\n  * 如果一个类中声明了n个构造器，则最多有 n \\- 1个构造器中使用了 \"this(形参列表)\"\n  *  \"this(形参列表)\"必须声明在类的构造器的首行！\n  * 在类的一个构造器中，最多只能声明一个\"this(形参列表)\"\n  * \n\n## import\n\n* 为使用定义在不同包中的Java类，需用import语句来引入指定包层次下所需要的类或全部类(.*)。import语句告诉编译器到哪里去寻找类。\n\n* 语法格式：import 包名. 类名; \n\n* 应用举例：\n\n  ```java\n  import pack1.pack2.Test; //import pack1.pack2.*;表示引入pack1.pack2包中的所有结构\n  public class PackTest{\n      public static void main(String args[]){\n          Test t = new Test(); //Test类在pack1.pack2包中定义\n          t.display();\n      } \n  }\n  ```\n\n* 注意\n\n  * 在源文件中使用import显式的导入指定包下的类或接口\n  * 声明在包的声明和类的声明之间。\n  * 如果需要导入多个类或接口，那么就并列显式多个import语句即可\n  * 举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。\n  * 如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。\n  * 如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的是哪个类。\n  * 如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。\n  * import static组合的使用：调用指定类或接口下的静态的属性或方法\n  \n  ```java\n  import static java.lang.System.*;\n  public class Test1 {\n  \tpublic static void main(String[] args) {\n  \t\tout.println(\"hello\");\n  \t}\n  }\n  ```\n\n## package\n\n* package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。(若缺省该语句，则指定为无名包)。\n\n  * 它的格式为：package 顶层包名.子包名 **;**\n\n  ```java\n  举例：pack1\\pack2\\PackageTest.java\n  package pack1.pack2; //指定类PackageTest属于包pack1.pack2\n  public class PackageTest{\n      public void display(){\n          System.out.println(\"in method display()\");\n      } \n  }\n  ```\n\n* 包对应于文件系统的目录，package语句中，用“.” 来指明包(目录)的层次；\n\n* 包通常用小写单词标识。通常使用所在公司域名的倒置：com.baidu.xxx\n\n* 源文件的布局：\n\n* 包的作用：\n\n  * 包帮助管理大型软件系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式\n  * 包可以包含类和子包，划分项目层次，便于管理\n  *  解决类命名冲突的问题\n  * 控制访问权限\n\n* JDK中主要的包介绍\n\n  * java.lang----包含一些Java语言的核心类，如String、Math、Integer、 System和Thread，提供常用功能\n  * java.net----包含执行与网络相关的操作的类和接口。\n  * java.io ----包含能提供多种输入/输出功能的类。\n  * java.util----包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。\n  * java.text----包含了一些java格式化相关的类\n  * java.sql----包含了java进行JDBC数据库编程的相关类/接口\n  * java.awt----包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。\n\n# 总结\n\n```java\n/*\n * 一，Java面向对象学习的三条主线(非官方)：\n * \t1.Java类及类的成员：属性，方法，构造器，代码块，内部类\n *  2.面向对象的三大特征：封装性，继承性，多态性，(抽象性)\n *  3.其他关键字：this,super,static,final,abstract,interface,import,package \n * 目标：“大处着眼，小处着手”\n * 二，面向对象和面向过程来实现“人把大象装进冰箱”\n * \t1.面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做\n * \t\t①把冰箱打开\n * \t\t②抬起大象，塞进冰箱\n * \t\t③把冰箱关闭\n *  2.面向对象：强调具备功能的对象，以类/对象为最小基本单位，考虑谁来做\n *  \t人{\n *  \t\t打开(冰箱){\n *  \t\t\t冰箱.开();\n *  \t\t}\t\n *  \t\t抬起(大象){\n *  \t\t\t大象.进入(冰箱);\n *  \t\t}\n *  \t\t关闭(冰箱){\n *  \t\t\t冰箱.关();\n *  \t\t}\n *  \t}\n *  \t冰箱{\n *  \t\t开(){}\n *  \t\t关(){}\n *  \t}\n *  \t大象{\n *  \t\t进入(冰箱){}\n *  \t}\n *三，面向对象的两个要素\n * \t类：对一类事物的描述，是抽象的，概念上的定义\n * \t对象：是实际存在的该类事物的每个个体，因而也成为实例(instance)\n * \t>面向对象程序设计的重点是类的设计\n * \t>类的设计，其实就是类的成员的设计\n * \"万物皆对象\"的理解\n * \t①在Java语言范畴中，我们都将功能，结构等封装到类中，通过类的实例化，来调用具体的功能结构\n * \t\t>Scanner,String等\n * \t\t>文件：File\n * \t\t>网络资源：URL\n * \t②涉及到Java语言与前端Html,后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类，对象。\n *四，设计类，其实就是设计类的成员\n *\t属性 = 成员变量 = field = 域，字段\n *\t方法 = 成员方法 = 函数 = method\n *\t创建类的对象 = 类的实例化 = 实例化类\n *五，类和对象的使用(面向对象思想落地的实现)\n *  1.创建类，设计类的成员\n *  2.创建类的对象\n *  3.通过“对象.属性”或“对象.方法”调用对象的结构\n *六，如果创建了一个类的多个对象，则每个对象都独立拥有一套类的属性。(非static的)\n *\t意味着：如果我们修改一个对象的属性，则不会影响另一个对象属性的值\n *七，属性在类中的使用\n *属性(成员变量)VS局部变量\n * 相同点\n * \t\t定义变量的格式相同：数据类型 变量名 = 变量值\n * \t\t都是先声明后使用的\n * \t\t变量都有其对应的作用域\n * 不同点\n * \t\t在类中声明的位置不同。\n * \t\t\t属性：直接定义在类的一对{}内\n * \t\t\t局部变量：声明在方法中，方法形参，代码块内，构造器形参，构造器内部的变量\n * \t\t关于权限修饰符的不同\n * \t\t\t属性：可以在声明属性时，指明其权限，使用权限修饰符\n * \t\t\t局部变量：不可以使用权限修饰符\n * \t\t默认初始化值的情况。\n * \t\t\t属性：类的属性，根据其类型都有默认初始化值\n * \t\t\t局部变量：没有默认初始化值，意味着，我们在调用局部变量之前，一定要显式赋值。特别的：形参在调用时赋值即可。\n * \t\t在内存中加载的位置不同\n * \t\t\t属性：加载到堆空间中  (非static)\n * \t\t\t局部变量：加载到栈空间\n * 八，方法\n * 方法：描述类应该具有的功能\n * \t1.举例\n * \t\tpublic void eat(){}\n * \t\tpublic void sleep(){}\n *  \tpublic String getName(){}\n *  \tpublic String setNation(String nation)()\n *  2.方法的声明：权限修饰符 返回值类型 方法名(形参列表){\n *  \t\t\t\t\t方法体\n *  \t\t\t\t}\n * \t\t注意：static,final,abstract等关键字也可以修饰方法\n * \t3.说明：\n * \t\t3.1权限修饰符：方法的默认修饰符是public\n * \t\t\tJava规定的4种权限修饰符：private,public,缺省,protected\n * \t\t3.2返回值类型：有返回值 VS 没有返回值\n * \t\t\t\t如果方法有返回值，则必须在方法声明时指定返回值类型。同时方法中，\n * \t\t\t需要使用return关键字来返回指定类型的变量或常量：“return 数据;”\t\n * \t\t\t\t如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不使用return,\n * \t\t\t\t但是，如果使用的话，只能“return ;”表示结束此方法的意思\n * \t\t3.3方法名：属于标识符，遵循标识符的命名规则，“见名知意”\n * \t\t3.4形参列表：方法可以声明0个，一个或多个形参。\n * \t\t\t格式：数据类型1  形参1，数据类型2 形参2 ...\n * \t\t3.5 方法体：方法功能的体现\n *  4.return关键字的使用：\n * \t\t1.使用范围：使用在方法体中\n * \t\t2.作用：①结束方法 ②针对有返回值类型的方法，使用“return 数据”返回数据\n * \t\t3.注意：return关键字后面不可以声明执行语句 \n *  5.方法的使用：可以在方法中调用当前类的属性和方法。\n *  \t注意：方法中不可以定义方法\n *  6.方法的重载\n *  \t1.定义：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或者参数类型不同即可\n *  \t\t\"两同一不同\"：同一个类，相同方法名。参数列表不同 \n *  \t2.举例：Arrays类中重载的sort()和binarySearch()\n *  \t3.判断是否是重载：跟方法的权限修饰符，返回值类型，形参变量名，方法体都没有关系\n *  \t4.在通过对象调用方法时，如何确定某一个指定的方法：方法名--->参数列表\n *  7.可变个数形参的方法\n *  \t1.jdk5.0以后新增的内容\n *  \t2.具体使用\n *  \t\t2.1 可变个数形参的格式：数据类型 ... 变量名\n *  \t\t2.2 当调用可变个数形参的方法时，传入的参数个数可以是0个，1个，2个...\n *  \t\t2.3 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载\n *  \t\t2.4 可变个数形参的方法与本类中方法名相同，形参也相同的数组之间不构成重载。换句话说二者不能一起出现\n *  \t\t2.5 可变个数形参在方法的形参中，必须声明在末尾。 \n *  8.值传递机制\n *  \t1.变量的赋值\n *  \t\t如果变量是基本数据类型，此时赋值的是变量所保存的数据值\n *  \t\t如果变量是引用数据类型，此时赋值是变量所保存的数据的地址值\n *  \t2.方法的形参的传递机制：值传递\n *  \t\t形参：方法定义时，声明的小括号内的参数\n *  \t\t实参：方法调用时，实际传递给形参的数据\n *  \t\t如果参数是基本数据类型，此时实参传递给形参的是实参真实存储的数据值\n *  \t\t如果参数是引用数据类型，此时实参传递给形参的是实参存储数据的地址值\n *  9.递归方法的使用(使用)\n *  \t1.递归方法：一个方法体内调用它自身。\n * \t\t2.方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。\n * \t\t    递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。\n * \n * 九：补充：\n * \t内存解析的说明：引用类型的变量，只能存储两类值：null或地址值(含变量的类型)\n * \t匿名对象的使用\n * \t\t①理解：我们创建对象时，没有显示的赋给一个变量名。即匿名对象\n * \t\t②特征：匿名对象只能使用一次\n * 十：面向对象的特征一：封装与继承\n * \t一：问题的引入：当我们创建一个对象以后，我们可以通过\"对象.属性\"的方式，对对象的属性进行赋值。\n * \t\t这里，赋值操作要搜到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，\n * \t\t我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件\n * \t\t的添加。(比如setxxx()).同时，我们需要避免用户再使用\"对象.属性\"的方式对属性进行赋值。\n * \t\t则需要将其属性声明为私有的(private) -->此时，针对属性就体现了封装性\n *  二：封装性的体现：\n * \t\t我们将类的属性xxx私有化(private),同时，提供公共的(public)方法来获取(getxxx())和设置(setxxx())类都属性\n * \t   扩展：封装性的体现：①如上 ②不对外暴露私有的方法 ③单例模式...\n *  三：封装性的体现需要权限修饰符来配合。\n * \t\t1.Java规定的4种权限(从小到大排列)：private,缺省,protected,public\n * \t\t2.4种权限可以用来修饰类及类的内部结构：属性，方法，构造器，内部类\n * \t\t3.具体的，修饰类的话只能使用： 缺省，public\n * \t   总结封装性：Java提供了4种权限可以用来修饰类及类的内部结构，体现了类及类的内部结构在被调用时的可见性的大小\n * 十一：类的结构之三：构造器(或构造方法，constructor)的使用\n * \t  一：构造器的使用\n * \t\t创建对象 \t初始化对象的信息\n *   二：说明：\n *   \t1.如果没有显示的定义类的构造器的话，则系统默认提供一个空参的构造器\n *   \t2.定义构造器的格式：权限修饰符 类名(形参列表){}\n *   \t3.一个类中定义的多个构造器，彼此构成从重载\n *   \t4.一旦我们显示的定义了类的构造器后，系统就不再提供默认的空参构造器\n * \t\t5.一个类中至少会有一个构造器\n * \t总结：属性赋值的先后顺序\n * \t\t①默认初始化\n * \t\t②显式初始化\n * \t\t③构造器初始化\n * \n * \t\t④通过\"对象.方法\"或\"对象.属性\"的方式赋值\n * \t以后操作的先后顺序：① - ② - ③ - ④\n * 十二：this关键字的使用\n * \t1.this可以用来修饰：属性，方法，构造器\n * \t2.this修饰方法和属性：this可以理解为：当前对象 或 当前正在创建的对象\n * \t\t2.1 在类的方法中，可以使用“this.属性”或“this.方法”的方式，调用当前对象属性或方法，但是通常情况下\n * \t\t我们都选择省略“this.”。特殊情况下，如果方法的形参和类的属性同名时，必须显示的使用\n * \t\t“this.变量”的方式，表明此变量是属性，而非形参\n * \t\t2.2 在类的构造器中，可以使用“this.属性”或“this.方法”的方式，调用当前正在创建的对象属性或方法，但是通常情况下\n * \t\t我们都选择省略“this.”。特殊情况下，如果构造器的形参和类的属性同名时，必须显示的使用\n * \t\t“this.变量”的方式，表明此变量是属性，而非形参\n * \t3.this调用构造器\n * \t\t①我们在类的构造器中，可以显示的使用“this(形参列表)”的方式，调用本类中指定的其他构造器\n * \t\t②构造器中不能通过“this(形参列表)”的方式调用自己\n * \t\t③如果一个类中有n个构造器，则最多有n-1个构造器中使用“this(形参列表)”\n * \t\t④规定：“this(形参列表)”必须声明在当前构造器的首行\n * \t\t⑤构造器内不，最多只能声明一个“this(形参列表)”用来调用其他的构造器\n * 十三：package关键字的使用\n * \t1.为了更好的实现项目中的类的管理，提供了包的概念\n * \t2.使用package声明类或接口所在的包，声明在源文件的首行\n * \t3.包，属于标识符，遵循标识符的命名规则，规范(xxxyyyzzz 全小写),“见名知意”\n * \t4.每“.”以此就代表一层文件目录\n * \t5.补充：同一个包下，不能命名同名的接口，类。不同的包下，可以命名同名的接口，类\n * 十四：import关键字的使用\n * \t1.import意为导入\n * \t2.在源文件中显式的使用import结构导入指定包下的类，接口\n * \t3.声明在包的声明和类的声明之间\n * \t4.如果需要导入多个结构，则并列写出\n * \t5.可以使用“xxx.*”的方式，表示导入xxx包下的所有结构\n * \t6.如果使用的类或接口是java.lang包下定义的，则可以省略import结构\n * \t7.如果使用的类或接口是本包下定义的，则可以省略import结构\n * \t8.如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示\n * \t9.使用“xxx.*”的方式，可以表示导入xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显示导入\n * \t10.import static :表示导入指定类或接口中的静态结构：属性或方法\n */\n```\n\n\n\n\n","categories":["Java学习","Java基础语法"]},{"title":"数组","url":"/2020/12/11/尚硅谷说Java/Java基础语法/6-数组/","content":"\nJava中的一维数组，二维数组\n\n<!--more-->\n\n# 数组的概述\n\n* 数组(Array)，是多个<font color=\"red\">相同类型数据</font>按<font color=\"red\">一定顺序排列</font>的集合，并使用<font color=\"red\">一个名字命名</font>，并通过<font color=\"red\">编号</font>的方式对这些数据进行统一管理。\n* 数组的常见概念\n  * 数组名 \n  * 下标(或索引) \n  * 元素\n  * 数组的长度\n* 数组本身是<font color=\"red\">引用数据类型</font>，而数组中的元素可以是<font color=\"red\">任何数据类型</font>，包括基本数据类型和引用数据类型。\n* 创建数组对象会在内存中开辟一整块<font color=\"red\">连续的空间</font>，而数组名中引用的是这块连续空间的首地址。\n* 数组的长度<font color=\"red\">一旦确定，就不能修改</font>。\n* 我们可以直接通过下标(或索引)的方式调用指定位置的元素，速度很快。 \n* 数组的分类：\n  * 按照维度：一维数组、二维数组、三维数组、… \n  * 按照元素的数据类型分：基本数据类型元素的数组、引用数据类型元素的数组(即对象数组)\n\n# 一维数组\n\n* 一维数组的声明方式：\n\n```java\ntype var[] 或 type[] var;\n例如：int a[];\n\tint[] a1;\n\tdouble b[];\n\tString[] c; //引用类型变量数组\n```\n\n* Java语言中声明数组时不能指定其长度(数组中元素的数)， 例如： int a[5]; //<font color=\"red\">非法</font>\n\n* 动态初始化：数组声明且为数组元素分配空间与赋值的操作分开进行\n\n  ```java\n  int[] arr = new int[3];\n  arr[0] = 3;\n  arr[1] = 9;\n  arr[2] = 8;\n  或\n  String names[];\n  names = new String[3];\n  names[0] = “钱学森”;\n  names[1] = “邓稼先”;\n  names[2] = “袁隆平”;    \n  ```\n\n* 静态初始化：在定义数组的同时就为数组元素分配空间并赋值。\n\n  ```java\n  int arr[] = new int[]{ 3, 9, 8};或int[] arr = {3,9,8};\n  String names[] = {“李四光”,“茅以升”,“华罗庚” }\n  ```\n\n* 定义并用运算符<font color=\"red\">new</font>为之分配空间后，才可以引用数组中的每个元素；\n\n* 数组元素的引用方式：数组名[数组元素下标]\n\n  * 数组元素下标可以是整型常量或整型表达式。如a[3] , b[i] , c[6*i];\n  * <font color=\"red\">数组元素下标从0开始；长度为n的数组合法下标取值范围: 0 —>n-1；如int a[]=new int[3]; 可引用的数组元素为a[0]、a[1]、a[2]</font>\n\n* 每个数组都有一个属性<font color=\"red\">length</font>指明它的长度，例如：<font color=\"red\">a.length</font> 指明数组a的长度(元素个数)\n\n  * 数组一旦初始化，其长度是不可变的\n\n* 数组是引用类型，它的元素相当于类的成员变量，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化。例如：\n\n  ```java\n  int a[]= new int[5];\n  System.out.println(a[3]); //a[3]的默认值为0\n  ```\n\n  * 对于基本数据类型而言，默认初始化值各有不同\n  * 对于引用数据类型而言，默认初始化值为null(注意与0不同！\n\n  | 数组元素类型 |    元素的默认初始化值     |\n  | :----------: | :-----------------------: |\n  |     byte     |             0             |\n  |    short     |             0             |\n  |     int      |             0             |\n  |     long     |            0L             |\n  |    float     |           0.0F            |\n  |    double    |            0.0            |\n  |     char     | 0或写为'\\u0000'(表现为空) |\n  |   boolean    |           false           |\n  |   引用类型   |           null            |\n\n* Java中使用关键字new来创建数组\n\n  * 如下是创建基本数据类型元素的一维数组\n\n  ```java\n  int[] s;\n  s = new int[10];\n  //int[] s=new int[10];\n  //基本数据类型数组在显式赋值之前，\n  //Java会自动给他们赋默认值。\n  for ( int i=0; i<10; i++ ) {\n      s[i] =2*i+1;\n      System.out.println(s[i]);\n  }\n  ```\n\n  * 执行int[] s;后的内存变化\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184304.png)\n\n  * 执行s = new int[10];后的内存变化\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184305.png)\n\n  * 执行 s[i] =2*i+1;后的内存变化\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184306.png)\n\n```java\n//1.一维数组的声明和初始化\nint[] ids;//声明\n//1.1静态初始化：数组的初始化和元素的赋值操作同时进行\nids = new int[] {1001,1002,1003,1004};\n//1.2动态初始化：数组的初始化和数组元素的赋值操作分开进行\nString[] names = new String[5];\n//错误的写法\n//int[] arr1 = new int[];\n//int[5] arr2 = new int[];\n//int[] arr3 = new int[3]{1,2,3};\n//总结：数组一旦初始化完成，其长度就基本确定了\n\n//2.如何调用数组的指定位置的元素：通过下标的方式调用\n//数组的下标(或索引)从0开始的，到数组的长度-1结束\nnames[0] = \"zhangsan\";\nnames[1] = \"lisi\";\nnames[2] = \"wangwu\";\nnames[3] = \"liuliu\";\nnames[4] = \"zhaoyun\";\n\n//3.如何获取数组的长度。\n//属性：length\nSystem.out.println(names.length);//5\nSystem.out.println(ids.length);//4\n\n//4.如何遍历数组\nSystem.out.println(names[0]);\nSystem.out.println(names[1]);\nSystem.out.println(names[2]);\nSystem.out.println(names[3]);\nSystem.out.println(names[4]);\nfor(int i = 0;i < names.length;i++) {\n    System.out.println(names[i]);\n}\n\n//5.数组元素的默认初始化值\nint[] arr = new int[4];\nfor(int i = 0;i < arr.length;i++) {\n    System.out.println(arr[i]);//输出0\n}\nchar[] arr1 = new char[4];\nfor(int i = 0;i < arr1.length;i++) {\n    System.out.println((int)arr1[i]);//0\n}\n```\n\n# 多维数值\n\n* 对于二维数组的理解，我们可以看成是一维数array1又作为另一个一维数组array2的元素而存在。其实，从数组底层的运行机制来看，其实没有多维数组。\n\n* 二维数组\\[][]：数组中的数组。初始化方法\n\n  * 格式1（动态初始化）：int\\[][] arr = new int\\[3][2];\n\n    * 定义了名称为arr的二维数组\n    * 二维数组中有3个一维数组\n    * 每一个一维数组中有2个元素\n    * 一维数组的名称分别为arr[0], arr[1], arr[2]\n    * 给第一个一维数组1脚标位赋值为78写法是：arr\\[0][1] = 78;\n    * 格式2（动态初始化）：int\\[][] arr = new int\\[3][];\n    * 二维数组中有3个一维数组。\n    * 每个一维数组都是默认初始化值null (注意：区别于格式1）\n    * 可以对这个三个一维数组分别进行初始化\n\n    ```java\n    arr[0] = new int[3]; \n    arr[1] = new int[1]; \n    arr[2] = new int[2];\n    ```\n\n    * 注：int\\[][] arr = new int\\[][3]; //非法\n\n  * 格式3（静态初始化）：{% raw %}int\\[][] arr = new int\\[][]{{3,8,2},{2,7},{9,0,1,6}};{% endraw %}\n\n    * 定义一个名称为arr的二维数组，二维数组中有三个一维数组\n    * 每一个一维数组中具体元素也都已初始化\n    * 第一个一维数组 arr[0] = {3,8,2};\n    * 第二个一维数组 arr[1] = {2,7};\n    * 第三个一维数组 arr[2] = {9,0,1,6};\n    * 第三个一维数组的长度表示方式：arr[2].length;\n\n* 注意特殊写法情况：int[] x,y[]; x是一维数组，y是二维数组。\n\n* Java中多维数组不必都是规则矩阵形式\n\n* 内存的解析\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184307.png)\n\n```JAVA\n//1.一维数组的声明和初始化\nint[] arr = new int[] {1,2,3};//一维数组\n//静态初始化\nint[][] arr1 = new int[][]{{1,2,3},{1,2},{1,2,3}};\n//动态初始化1\nString[][] arr2 = new String[3][2];\n//动态初始化2\nString[][] arr3 = new String[3][];\n//错误的情况\n//String[][] arr4 = new String[][4];\n//String[4][3] arr5 = new String[][];\n//int[][] arr6 = new int[4][3]{{1,2,3},{1,4,2},{1,2,3}};\n//也是正确的\nint[] arr4[] = new int[][]{{1,2,3},{1,2,3,4,5,6},{1,2,3}};\nint[] arr5[] = {{1,2,3},{1,4,2},{1,2,3}};\n\n//2.如何调用数组的指定位置的元素：\nSystem.out.println(arr1[0][1]);//2\nSystem.out.println(arr2[1][1]);//null\narr3[1] = new String[4];\nSystem.out.println(arr3[1][0]);\n\n//3.如何获取数组的长度\nSystem.out.println(arr4.length);//3\nSystem.out.println(arr4[0].length);//3\nSystem.out.println(arr4[1].length);//6\n\n//4.如何遍历数组\nfor (int i = 0; i < arr4.length; i++) {\n    for (int j = 0; j < arr4[i].length; j++) {\n        System.out.print(arr4[i][j]+\" \");\n    }\n    System.out.println();\n}\n\n//5.数组元素的默认初始化值\nint[][] arr9 = new int[4][3];\nSystem.out.println(arr9);//[[I@15db9742  地址值，左边有两个[\nSystem.out.println(arr9[0]);//[I@6d06d69c  地址值，左边有一个[\nSystem.out.println(arr9[0][0]);//0\ndouble[][] ar1 = new double[4][3];\nSystem.out.println(ar1);//[[D@7852e922  地址值，左边有两个[\nSystem.out.println(ar1[0]);//[D@4e25154f  地址值，左边有一个[\nSystem.out.println(ar1[0][0]);//0.0\nString[][] ar2 = new String[4][3];\nSystem.out.println(ar2);//[[Ljava.lang.String;@70dea4e  地址值，左边有两个[\nSystem.out.println(ar2[0]);//[Ljava.lang.String;@5c647e05  地址值，左边有一个[\nSystem.out.println(ar2[0][0]);//null\n\nString[][] ar3 = new String[4][];\nSystem.out.println(ar3);//[[Ljava.lang.String;@33909752  地址值，左边有两个[\nSystem.out.println(ar3[0]);//null \n//System.out.println(ar3[0][0]);//报错\ndouble[][] ar4 = new double[4][];\nSystem.out.println(ar4);//[[D@55f96302  地址值，左边有两个[\nSystem.out.println(ar4[0]);//null\n//System.out.println(ar4[0][0]);//报错\n```\n\n#  数组中涉及到的常见算法\n\n* 数组元素的赋值(杨辉三角、回形数等)\n\n  ```java\n  //杨辉三角\n  /*\n  * 1 \n  * 1 1 \n  * 1 2 1 \n  * 1 3 3 1 \n  * 1 4 6 4 1 \n  * 1 5 10 10 5 1 \n  * 1 6 15 20 15 6 1\n  */\n  //1.声明并初始化二维数组\n  int[][] yangHui = new int[10][];\n  //2.给数组的元素赋值\n  for (int i = 0; i < yangHui.length; i++) {\n      yangHui[i]= new int[i+1];\n  \n      //2.1给首末元素赋值\n      yangHui[i][0] = yangHui[i][i]= 1;\n      //2.2给每行的非首末元素赋值\n      for (int j = 1; j < yangHui[i].length-1; j++) {\n          yangHui[i][j]= yangHui[i-1][j-1] + yangHui[i-1][j]; \n      }\n  }\n  //3.遍历二维数组\n  for (int i = 0; i < yangHui.length; i++) {\n      for (int j = 0; j < yangHui[i].length; j++) {\n          System.out.print(yangHui[i][j]+\" \");\n      }\n      System.out.println();\n  }\n  //回形数\n  /*\n  *1   2   3   4 \n  *12  13  14  5 \n  *11  16  15  6 \n  *10   9  8    7\n  */\n  int n = 4;\n  int[][] arr = new int[n][n];\n  int count = 0; //要显示的数据\n  int maxX = n-1; //X轴的最大下标\n  int maxY = n-1; //Y轴的最大下标\n  int minX = 0; //X轴的最小下标\n  int minY = 0; //Y轴的最小下标\n  while(minX <= maxX) {\n      for (int i = minX; i <= maxX; i++) {\n          arr[minY][i] = ++count; \n      }\n      minY++;\n      for (int i = minY; i <= maxY; i++) {\n          arr[i][maxX] = ++count; \n      }\n      maxX--;\n      for (int i = maxX; i >= minX; i--) {\n          arr[maxY][i]= ++count;\n      }\n      maxY--;\n      for (int i = maxY; i >= minY; i--) {\n          arr[i][minX] = ++count;\n      }\n      minX++;\n  }\n  for (int i = 0; i < arr.length; i++) {\n      for (int j = 0; j < arr.length; j++) {\n          String space = (arr[i][j] + \" \").length() ==1 ? \"0\" : \"\";\n          System.out.print(space + arr[i][j] + \" \" );\n      }\n      System.out.println();\n  }\n  ```\n\n* 求数值型数组中元素的最大值、最小值、平均数、总和等\n\n  ```java\n  //定义一个int型的一维数组，包含10个元素，分别赋一些随机整数，\n  //然后求出所有元素的最大值，最小值，和值，平均值，并输出出来。\n  //要求：所有随机数都是两位数。\n  //初始化数组\n  int[] arr = new int[10];\n  for (int i = 0; i < arr.length; i++) {\n      arr[i] = (int)(Math.random() * (99 - 10 + 1) + 10); \n  }\n  //遍历数组\n  for (int i = 0; i < arr.length; i++) {\n      System.out.print(arr[i]+ \" \");\n  }\n  System.out.println();\n  //求数组的最大值\n  int maxValue = arr[0];\n  for (int i = 1; i < arr.length; i++) {\n      if(maxValue < arr[i]) {\n          maxValue = arr[i];\n      }\n  }\n  System.out.println(\"最大值: \" + maxValue);\n  //求数组元素的最小值\n  int minValue = arr[0];\n  for (int i = 1; i < arr.length; i++) {\n      if(minValue > arr[i]) {\n          minValue = arr[i];\n      }\n  }\n  System.out.println(\"最小值: \" + minValue);\n  //求数组元素的和\n  int sum = 0;\n  for (int i = 0; i < arr.length; i++) {\n      sum += arr[i];\n  }\n  System.out.println(\"和: \" + sum);\n  //求数组元素的平均数\n  double avgValue = (double)sum/arr.length;\n  System.out.println(\"平均数: \" + avgValue);\n  ```\n\n* 数组的复制、反转、查找(线性查找、二分法查找)\n\n  ```java\n  int[] arr1 = new int[] {1,2,3,4,5,6,7,8};\n  //复制 \n  int[] arr2 = new int[arr1.length];\n  for (int i = 0; i < arr2.length; i++) {\n      arr2[i]= arr1[i]; \n  }\n  //反转\n  for(int i = 0,j = arr1.length - 1;i < j;i++,j--) {\n      int temp = arr1[i];\n      arr1[i] = arr1[j];\n      arr1[j] = temp;  \n  }\n  //查找\n  //1.线性查找\n  int dest = 6;//目标值\n  int flag = false;\n  for (int i = 0; i < arr1.length; i++) {\n      if(arr1[i] == dest) {\n          System.out.println(\"找到了，下标为：\"+i);\n  \t\tflag = true;\n          break;\n      }\n  }\n  if(flag){\n       System.out.println(\"没找到\");\n  }\n  //2.二分查找:前提是查找的数组必须是有序的\n  int dest = 6;//目标值\n  int left = 0;//初始的首索引\n  int right = arr1.length - 1;//初始的末索引\n  while(left < right) {\n      int mid = (right + left) / 2;\n      if(dest == arr1[mid]) {\n          System.out.println(\"找到了，下标为：\"+i);\n      }else if(arr1[mid] > dest) {\n          right = mid - 1;\n      }else {\n          left = mid + 1;\n      }\n  }\n  ```\n\n* 数组元素的排序算法\n\n  ```java\n  int[] arr = new int[] {1,5,9,3,8,7,6,4,2};\n  //冒泡排序\n  for (int i = 0; i < arr.length - 1; i++) {\n      boolean flag = true;\n      for (int j = 0; j < arr.length - 1 - i; j++) {\n          if(arr[j]> arr[j + 1]) {\n              flag = false;\n              int temp = arr[j];\n              arr[j] = arr[j + 1];\n              arr[j + 1] = temp;\n          }\n      }\n      if(flag) {\n          break;\n      }\n  }\n  ```\n\n# Arrays工具类的使用\n\n* java.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。\n\n  |  boolean equals(int[] a,int[] b)  |         判断两个数组是否相等。         |\n  | :-------------------------------: | :------------------------------------: |\n  |    void fill(int[] a,int val)     |        将指定值填充到数组之中。        |\n  |        void sort(int[] a)         |            对数组进行排序。            |\n  |     String toString(int[] a)      |             输出数组信息。             |\n  | int binarySearch(int[] a,int key) | 对排序后的数组进行二分法检索指定的值。 |\n\n  ```java\n  //boolean equals(int[] a,int[] b)\n  int[] arr = new int[] {1,2,3,4};\n  int[] arr2 = new int[] {1,5,3,8};\n  boolean isEquals = Arrays.equals(arr, arr2);\n  System.out.println(isEquals);//false\n  //void fill(int[] a,int val)\n  Arrays.fill(arr, 0);\n  //String toString(int[] a)\n  System.out.println(Arrays.toString(arr));//[0, 0, 0, 0]\n  //void sort(int[] a)\n  Arrays.sort(arr2);\n  System.out.println(Arrays.toString(arr2));//[1, 3, 5, 8]\n  //int binarySearch(int[] a,int key)\n  int index = Arrays.binarySearch(arr2, 5);\n  System.out.println(index);//2\n  ```\n\n#  数组使用中的常见异常\n\n| 数组脚标越界异常(<font color=\"red\"> ArrayIndexOutOfBoundsException</font>) |\n| ------------------------------------------------------------ |\n| int[] arr = new int[2];<br/>System.out.println(arr[2]);<br/>System.out.println(arr[-1]);<br/>访问到了数组中的不存在的脚标时发生。 |\n| 空指针异常(<font color=\"red\">NullPointerException</font>)    |\n| int[] arr = null;<br/>System.out.println(arr[0]);<br/>arr引用没有指向实体，却在操作实体中的元素时。 |\n\n# 总结\n\n```java\n/*\n * 一：数组的概述\n * \t1.数组(Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。\n * \t2.数组相关的概念\n * \t\t>数组名\n * \t\t>元素\n *  \t>角标，下标，索引\n *  \t>数组的长度，元素的个数\n *  3.数组的特点。\n *  \t1)数组是有序排列的\n *  \t2)数组属于引用数据类型的变量。数组的元素既可以是基本数据类型，也可以是引用数据类型\n *  \t3)创建数组对象会在内存中开辟一整块连续的内存空间\n *  \t4)数组的长度一旦确定，就不能改变\n *  4.数组的分类\n *  \t①按照维数：一维数组，二维数组。。。\n *  \t②按照数组元素的类型：基本数据类型元素的数组，引用数据类型元素的数组\n *  5.一维数组的使用\n *  \t①一维数组的声明和初始化\n *  \t②如何调用数组的指定位置的元素\n *  \t③如何获取数组的长度\n *  \t④如何遍历数组\n *  \t⑤数组元素的默认初始化值\n *  \t\t>数组元素是整型：0\n *  \t\t>数组元素是浮点型：0.0\n *  \t\t>数组元素是char型：0(ASCII码)或'\\u0000'\n *  \t\t>数组元素是boolean型：false\n *  \t\t>数组元素是引用数据型：null\n *  \t⑥数组的内存解析\n *  6.二维数组的使用\n *  \t对于二维数组的理解，我们可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。\n *  \t其实，从数组底层的运行机制来看，其实没有多维数组.\n *  \t二维数组的元素分为外层数组的元素和内层数组的元素\n *  \tint[][] arr = new int[4][3];\n *  \t外层数组元素：arr[0],arr[1]等\n *  \t内层数组元素：arr[0][0],arr[1][1]等\n *\t\t①一维数组的声明和初始化\n *  \t②如何调用数组的指定位置的元素\n *  \t③如何获取数组的长度\n *  \t④如何遍历数组\n *  \t⑤数组元素的默认初始化值\n *  \t针对与初始化方式一：例如：int[][] arr9 = new int[4][3];\n *  \t\t外层元素的初始值为：地址值\n *  \t\t内层元素的初始值为：与一维数组初始情况相同\n *  \t针对于初始化方式二：例如：int[][] arr9 = new int[4][];\t\n *  \t\t外层元素的初始值为：null\n *  \t\t内层元素的初始值为：不能调用，否则报错\n *  \t⑥数组的内存解析\n */\n```\n\n","categories":["Java学习","Java基础语法"]},{"title":"流程控制","url":"/2020/12/10/尚硅谷说Java/Java基础语法/5-流程控制/","content":"\nJava中的if-else-if和switch-case-default,以及while\n\n<!--more-->\n# 程序控制结构\n\n* 定义：程序控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑块\n* 其流程控制方式采用结构化程序设计中的三种基本流程结构，即\n  * 顺序结构：程序从上到下逐行执行，中间没有任何判断和跳转\n  * 分支结构：\n    * 根据条件，选择性的执行某段代码\n    * 有if...else和switch-case两种分支语句\n  * 循环结构\n    * 根据循环条件，重复性的执行某段代码\n    * 有while,do....while,for三种循环语句\n    * 注：JDK1.5提供了foreach循环，方便的遍历集合，数组元素\n\n# 顺序结构\n\n* Java中定义成员变量时采用合法的前向引用。如：\n\n```java\npublic class Test{\nint num1 = 12;\nint num2 = num1 + 2;\n}\n错误形式：\npublic class Test{\nint num2 = num1 + 2；\nint num1 = 12;\n}\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184254.png)\n\n# 分支结构\n\n## if-else结构\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184255.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184256.png)\n\n```java\n//举例1\nint heartBeats=79;\nif(heartBeats <60||heartBeats>100){\n    System.out.println(\"你需要做进一步检查\");\n}\nSystem.out.println(\"检查结束\");\n//举例2\nint age = 23;\nif(age<18){\n    System.out.println(\"你还可以看动画片\");\n}else{\n    System.out.println(\"你可以看成人电影了\");\n}\n//举例3\nif(age<0){\n    System.out.println(\"你输入的数据非法\");\n}else if(age<18){\n    System.out.println(\"青少年时期\");\n}else if(age<35){\n    System.out.println(\"青壮年时期\");\n}else if(age<60){\n    System.out.println(\"中年时期\");\n}else if(age<120){\n    System.out.println(\"老年时期\");\n}else {\n    System.out.println(\"你已经成仙了\");\n}\n```\n\n* 条件表达式必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量\n* 语句块只有一条执行语句时，一对{}可以省略，但建议保留\n* if-else语句结构，根据需要可以嵌套使用\n* 当if-else结构是“多选一”时，最后的else是可选的，根据需要可以省略\n* 当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓\n* 当多个条件是“包含”关系时，“小上大下 / 子上父下”\n\n## switch-case结构\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184257.png)\n\n* switch(表达式)中表达式的值必须是下述几种类型之一：byte，short，\n  char，int，枚举 (jdk 5.0)，String (jdk 7.0)； \n* case子句中的值必须是常量，不能是变量名或不确定的表达式值；\n*  同一个switch语句，所有case子句中的常量值互不相同；\n*  break语句用来在执行完一个case分支后使程序跳出switch语句块；如\n  果没有break，程序会顺序执行到switch结尾\n* default子句是可任选的。同时，位置也是灵活的。当没有匹配的case时，\n  执行default\n\n```java\nint number = 2;\nswitch(number){\n    case 0:\n        System.out.println(\"zero\");\n        break;\n    case 1:\n        System.out.println(\"one\");\n        break;\n    case 2:\n        System.out.println(\"two\");\n        break;\n    case 3:\n        System.out.println(\"three\");\n        break;\n    default:\n        System.out.println(\"other\");\n}\n//**********编译错误的情况***********\n//举例1：③的反例\nboolean isHandsome = true;\nswitch(isHandsome){\n    case true:\n        System.out.println(\"true\");\n        break;\n    case false:\n        System.out.println(\"false\");\n        break;\n    default:\n        System.out.println(\"error\");\n}\n//举例2：④的反例\nint age = 10;\nswitch(age){\n    case age>18:\n        System.out.println(\"成年了\");\n        break;\n    default:\n        System.out.println(\"未成年\");\n}\n```\n\n\n\n# 循环结构\n\n* 循环结构:在某些条件满足的情况下，反复执行特定代码的功能\n* 循环语句分类\n  * for 循环\n  * while 循环\n  * do-while 循环\n* 循环语句的四个组成部分\n  * 初始化部分(init_statement)\n  * 循环条件部分(test_exp) \n  * 循环体部分(body_statement) \n  * 迭代部分(alter_statement)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184258.png)\n\n## for 循环\n\n* 语法格式\n\n  ```java\n  for (①初始化部分; ②循环条件部分; ④迭代部分)｛\n      ③循环体部分;\n  ｝ \n  ```\n\n* 执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ...-②\n\n*  说明\n\n  * 循环条件部分为boolean类型表达式，当值为false时，退出循环\n  * 初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔\n  * 迭代部分可以有多个变量更新，用逗号分隔\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184259.png)\n\n```java\nfor(int i = 1;i <= 5;i++){\n    System.out.println(\"Hello World!\");\n}\n//练习\nint num = 1;\nfor(System.out.print(\"a\");num<=3;System.out.print(\"c\"),num++){\n    System.out.print(\"b\");\n}\n//输出abcbcbc\n//例题：遍历100以内的偶数，输出所有偶数的和和偶数的个数\nint sum = 0;//记录所有偶数的和\nint count = 0;//记录偶数的个数\nfor(int i = 1;i <= 100;i++){\n    if(i%2==0){\n        System.out.println(i);\n        sum += i;\n        count++;\n    }\n}\nSystem.out.println(\"所有偶数的和：\"+sum);\nSystem.out.println(\"偶数的个数：\"+count);\n```\n\n## while循环\n\n* 语法格式\n\n```java\n①初始化部分\nwhile(②循环条件部分)｛\n    ③循环体部分;\n\t④迭代部分; \n} \n```\n\n* 执行过程：①-②-③-④-②-③-④-②-③-④-...-②\n* 说明：\n  * 注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。\n  * for循环和while循环可以相互转换\n\n```java\n//遍历100以内的偶数\nint i = 1;\nwhile(i <= 100){\n    if(i % 2 == 0){\n        System.out.println(i);\n    }\n    i++;\n}\n//出了while循环以后，仍可以调用\nSystem.out.println(i);//101\n```\n\n## do-while 循环\n\n* 语法格式\n\n```java\n①初始化部分;\ndo{\n\t③循环体部分\n\t④迭代部分\n}while(②循环条件部分);\n```\n\n* 执行过程：<font color = \"red\">①-③-④-②-③-④-②-③-④-...② </font>\n* 说明：\n  * do-while循环至少执行一次循环体\n\n```java\n//遍历100以内的偶数,并计算所有偶数的和即偶数的个数\nint sum = 0;//记录所有偶数的和\nint count = 0;//记录偶数的个数\nint num = 1;\ndo{\n    if(num%2==0){\n        System.out.println(num);\n        sum += num;\n        count++;\n    }\n    num++;\n}while(num <= 100);\nSystem.out.println(\"所有偶数的和：\"+sum);\nSystem.out.println(\"偶数的个数：\"+count);\n```\n\n# 嵌套循环\n\n* 将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for ,while ,do…while均可以作为外层循环或内层循环。\n* 实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环。\n* 设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次。\n\n```java\n//打印******\n//System.out.println(\"******\");\nfor(int i = 1;i <= 6;i++){\n    System.out.print('*');//也可以写成\"*\"\n}\nSystem.out.println();\n/*\n打印******\n******\n******\n******\n******\n*/\nfor(int i = 1;i <= 5;i++){\n    for(int j = 1;j <= 6;j++){\n        System.out.print('*');\n    }\n    System.out.println();\n}\n/*\t\t\t\ti(行号)\t\tj(*的个数)\n打印*\t\t\t   1\t\t\t1\n   **\t\t    2\t\t\t 2\n   ***\t\t\t3\t\t\t 3\n   ****\t\t    4\t\t\t 4\n   *****\t\t5\t\t\t 5\n*/\nfor(int i = 1;i <= 5;i++){\t\t//控制行数\n    for(int j = 1;j <= i;j++){ \t//控制列数\n        System.out.print('*');\n    }\n    System.out.println();\n}\n/*\t\t\t\ti(行号)\t\tj(*的个数) 规律：i + j = 5 换句话说：j = 5 - i \n打印*****\t\t   5\t\t\t5\n   ****\t\t    4\t\t\t 4\n   ***\t\t\t3\t\t\t 3\n   **\t\t\t2\t\t\t 2\n   *\t\t\t1\t\t\t 1\n*/\nfor(int i = 1;i <= 5;i++){\t\t//控制行数\n    for(int j = 0;j <= 5-i;j++){ \t//控制列数\n        System.out.print('*');\n    }\n    System.out.println();\n}\n\n//输出100000以内的质数\nboolean isFlag = true;//标识i是否被j除尽，一旦除尽，修改其值\n//获取当前时间距1970-01-01 00:00:00 的毫秒数\nlong start = System.currentTimeMillis();\nfor(int i = 2;i <= 100000;i++){\n    for(int j = 2;j <= Math.sqrt(i);j++){//优化二：对本身质数的自然数是有效的\n        if(i % j == 0){\n            isFlag = false;\n            break;//优化1：只对本身非质数的自然数是有效的\n        }\n    } \n    if(isFlag){\n        System.out.println(i);\n    }\n    //重置isFlag\n    isFlag = true;\n}\n//获取当前时间距1970-01-01 00:00:00 的毫秒数\nlong end = System.currentTimeMillis();\n//输出运算的时间\nSystem.out.println(end-start);\n/*\n优化前：15232\n优化1后: 1965\n优化1和2后: 660\n*/\n```\n\n# 特殊关键字的使用：break、continue\n\n* break语句\n\n  * break语句用于终止某个语句块的执行\n\n  ```java\n  { ……\n  break;\n  ……\n  } \n  ```\n\n  * break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块\n\n  ```java\n  label1: { ……\n  label2: \t{ ……\n  label3: \t\t{ ……\n  \t\t\t\t  break label2;\n  \t\t\t\t  ……\n  \t\t\t\t} \n              } \n          }\n  ```\n\n* continue 语句\n\n  * continue只能使用在循环结构中\n  * continue语句用于跳过其所在循环语句块的一次执行，继续下一次循环\n  * continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环\n  * continue语句用法举例\n\n  ```java\n  for (int i = 0; i < 100; i++) {\n  \tif (i%10==0)\n  \t\tcontinue;\n  \tSystem.out.println(i); \n  }\n  ```\n\n```java\nlabel:for(int i = 0;i <= 4;i++){\n    for(int j = 1;j <= 10;j++){\n        if(j % 4 == 0){\n            //break;//默认跳出包裹此关键字最近的一层循环\n            //continue;\n            //break label;//结束指定标识的一层循环结构\n            continue label;//结束指定标识的一层循环结构当此循环\t\t\t\n        }\n        System.out.print(j);\n    }\n}\n```\n\n\n\n# 附加：特殊流程控制语句3\n\n## Scanner输入\n\n* 从键盘或控制台获取输入的变量\n\n* 具体实现步骤\n\n  1. 导包：import java.util.Scanner\n\n  2. Scanner的实例化：Scanner scan  = new Scanner(System.in);\n  3. 调用Scanner类的相关方法(next()/nextXxx())，来获取指定类型的变量\n  * 注意：需要根据相应的方法来输入指定类型的数据。如果输入的数据类型跟要求的类型不匹配时会报异常：InputMismatchException 导致程序终止\n\n```java\nimport java.util.Scanner;\nclass Test{\n\tpublic static void main(String[] args){\n\t\tScanner scan  = new Scanner(System.in);\n\t\tSystem.out.println(\"请输入你的姓名：\");\n\t\tString name  = scan.next();\n\t\tSystem.out.println(name);\n\t\tSystem.out.println(\"请输入你的芳龄：\");\n\t\tint age  = scan.nextInt();\n\t\tSystem.out.println(age);\n\t\tSystem.out.println(\"请输入你的体重：\");\n\t\tdouble weight  = scan.nextDouble();\n\t\tSystem.out.println(weight);\n\t\tSystem.out.println(\"你是否相中了我呢？(true/false)\");\n\t\tboolean isLove  = scan.nextBoolean();\n\t\tSystem.out.println(isLove);\n\t\t//对于char类型的获取，Scanner没有提供相关的方法。只能获取一个字符串\n\t\tSystem.out.println(\"请输入你的性别：(男/女)\");\n\t\tString gender = scan.next();//\"男”\n\t\tchar genderChar = gender.charAt(0);//获取字符串索引为0位置上的字符\n\t\tSystem.out.println(genderChar);\n\t\n\t}\n}\t\n```\n\n# 总结\n\n```java\n*一，分支结构中的if-else（条件判断结构）\n*\t三种形式\n*\t\t第一种：\n*\t\tif(条件表达式){\n*\t\t}\n*\t\t第二种：二选一\n*\t\tif(条件表达式){\n*\t\t\t执行语句1\n*\t\t}else{\n*\t\t\t执行语句2\n*\t\t}\n*\t\t第三种：多选一\n*\t\tif(条件表达式1){\n*\t\t\t执行语句1\n*\t\t}else if(条件表达式2){\n*\t\t\t执行语句2\n*\t\t}else if(条件表达式3){\n*\t\t\t执行语句3\n*\t\t}else if(条件表达式3){\n*\t\t\t执行语句3\n*\t\t}.....else{\n*\t\t\t执行语句n\n*\t\t}\n*\n*二，分支结构中的switch-case\n*\t1.格式\n*\t\tswitch(表达式){\n*\t\t\tcase 常量1：\n*\t\t\t\t执行语句1；\n*\t\t\t\t//break;\n*\t\t\tcase 常量2：\n*\t\t\t\t执行语句2；\n*\t\t\t\t//break;\n*\t\t\t...\n*\t\t\tdefault：\n*\t\t\t\t执行语句n；\n*\t\t\t\t//break;\n*\t\t}\n*\t2.说明\n*\t\t①根据switch表达式中的值，依次匹配各个case中的常量。\n*\t\t一旦匹配成功，则进入相应的case结构中。调用其执行语句。\n*\t\t当调用完执行语句后，则仍然继续向下执行其他case结构中的执行语句，\n*\t\t直到遇到break关键字或此switch-case结构末尾为止结束\n*\t\t②break关键字可以使用在switch-case中，表示一但执行到此关键字，\n*\t\t就跳出switch-case结构\n*\t\t③switch-case结构中的表达式，只能是如下的6种数据类型之一：\n*\t\t\tbyte,short,char,int,枚举类型(JDK5.0新增)，String类型(JDK7.0新增)\n*\t\t④case之后只能声明常量，不能声明范围\n*\t\t⑤break关键字是可选的\n*\t\t⑥default:相当于if-else的else.也是可选的。而且位置是灵活的\n*\t\t⑦凡是可以使用switch-case的结构，都可以转换成if-else.反之不成立\n*\t\t⑧我们在写分支语句时，当发现既可以使用switch-case的结构(同时，\n*\t\tswitch中表达式的取值情况不太多)，又可以使用if-else时，我们会优先使用switch-case。\n*\t\t原因：switch-case的执行效率比if-else稍高\n*三，循环结构\n*\t循环语句的四个要素\n*\t\t①初始化部分\n*\t\t②循环条件部分 -->是boolean类型\n*\t\t③循环体部分\n*\t\t④迭代部分\n*\t1:for循环结构\n*\t\tfor(①;②;④){\n*\t\t\t③\n*\t\t}\n*\t\t执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ...-②\n*\tbreak:在循环中，一旦遇到break,则跳出循环\n*\t2:while循环结构\n*\t\t①\n*\t\twhile(②){\n*\t\t\t③;\n*\t\t\t④;\n*\t\t}\n*\t\t执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ...-②\n*\t\t注意：\n*\t\t1.写while循环时千万不要丢了迭代条件。一旦丢了，就可能导致死循环！\n*\t\t2.我们写程序，要避免死循环\n*\t\t3.for循环和while循环是可以相互转换的！\n*\t\t  区别：for循环和while循环的初始化条件的作用范围不同\n*\t\t\n*\t算法：局限性\t\n*\t3:do-while循环结构\n*\t\t①\n*\t\tdo{\n*\t\t\t③;\n*\t\t\t④;\n*\t\t}while(②);\n*\t\t执行过程：① - ③ - ④ - ② - ③ - ④ - ...-②\n*\t\t说明：\n*\t\t1.do-while循环至少会执行一次循环\n*\t\t2.开发中，使用for和while会更多一些，较少使用do-while\n*\t补充：\n*\t1.不在循环条件部分限制次数的结构：for(;;)或while(true)\n*\t2.结束循环有几种方式？\n*\t\t方式一：循环条件部分返回false\n*\t\t方式二：在循环体中，执行break;\n*四，嵌套循环\n*\t1.嵌套循环：将一个循环结构A声明在另一个循环结构B中，就构成了嵌套循环\n*\t2.外层循环：循环结构A\n*\t  内层循环：循环结构B\n*\t3.说明：\n*\t\t①内层循环结构遍历一遍，只是相当于外层循环循环体执行了一次\n*\t\t②假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体共执行了m * n次\n*\t4.技巧：外层循环控制行数，内层循环控制列数\n*五，break和continue关键字的使用\n*\t\t\t\t使用范围\t\t\t循环中使用的作用(不同点)\t\t\t\t相同点\n*break \t\t\tswitch-case\t\t\t\t结束当前循环\t\t\t\t关键字后面不能声明执行语句\n*\t\t\t\t循环结构中\n*\t\t\t\t\n*continue  \t\t循环结构中\t\t\t\t结束当次循环\t\t\t\t关键字后面不能声明执行语句\n*\n*\n*如何从键盘获取不同类型的变量：需要使用Scanner类\n*具体实现步骤：\n*\t1.导包：import java.util.Scanner\n*\t2.Scanner的实例化：Scanner scan  = new Scanner(System.in);\n*\t3.调用Scanner类的相关方法(next()/nextXxx())，来获取指定类型的变量\n*\t注意：\n*\t需要根据相应的方法来输入指定类型的数据。如果输入的数据类型跟要求的类型不匹配时\n*\t会报异常：InputMismatchException 导致程序终止\n*\t\n*\n//练习：从键盘读入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时结束程序\nScanner scan = new Scanner(System.in);\nint positiveNumber = 0;//记录正数的个数\nint negativeNumber = 0;//记录负数的个数\nwhile(true){\n    int number = scan.nextInt();\n    //判断number的正负情况\n    if(number > 0){\n        positiveNumber++;\n    }else if(number < 0){\n        negativeNumber++;\n    }else{\n        //一旦执行break,跳出循环\n        break;\n    }\n}\nSystem.out.println(\"输入的正数的个数为：\"+positiveNumber);\nSystem.out.println(\"输入的负数的个数为：\"+negativeNumber);\n\t\t\n```\n\n","categories":["Java学习","Java基础语法"]},{"title":"运算符","url":"/2020/12/09/尚硅谷说Java/Java基础语法/4-运算符/","content":"\nJava中算术运算，赋值，位运算\n\n<!--more-->\n* 运算符是一种特殊的符号，用以表示数据的运算，赋值和比较等\n\n# 算术运算符\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184224.png)\n\n```java\n//除号：/\nint num1 =12;\nint num2 = 5;\nint result1 = num1 / num2;\nSystem.out.println(result1);//2\nint result2 = num1 / num2 * num2;\nSystem.out.println(result2);//10\ndouble result4 = num1 /num2 + 0.0;//2.0\ndouble result5 = num1 /(num2 + 0.0);//2.4\ndouble result6 = (double)num1 /num2;//2.4\ndouble result7 = (double)(num1 /num2);//2.0\nSystem.out.println(result5);\nSystem.out.println(result6);\n\n//%:取余运算\n//结果的符号与被模数的符号相同\n//开发中，经常使用%来判断能否被除尽的情况\nint m1 = 12;\nint n1 = 5;\nSystem.out.println(\"m1%n1 = \"+m1%n1);//2\nint m2 = -12;\nint n2 = 5;\nSystem.out.println(\"m2%n2 = \"+m2%n2);//-2\nint m3 = 12;\nint n3 = -5;\nSystem.out.println(\"m3%n3 = \"+m3%n3);//2\nint m4 = -12;\nint n4 = -5;\nSystem.out.println(\"m4%n4 = \"+m4%n4);//-1\n\n//(前)++ :先自增1，后运算\n//(后)++ :先运算，后自增1\nint a1 = 10;\nint b1 = ++a1;\nSystem.out.println(\"a1: \" + a1 + \" b1: \"+ b1);//a1: 11 b1: 11\nint a2 = 10;\nint b2 = a2++;\nSystem.out.println(\"a2: \" + a2 + \"b2: \"+ b2);//a1: 11 b1: 10\nint a3 = 10;\n++a3;//a3++\nint b3 = a3;\n//注意点\nshort s1 = 10;\n//s1 = s1 + 1;//编译失败\ns1 = (short)(s1+1);//正确的\ns1++;//自增1不会改变本身变量的数据类型\nbyte by1 = 127;\nby1++;\nSystem.out.println(by1);//-128\n\n//(前)-- :先自减1，后运算\n//(后)-- :先运算，后自减1\nint a4 = 10;\nint b4 = a4--;\nSystem.out.println(\"a4: \" + a4 + \" b4: \"+ b4);//a4: 9 b4: 10\nbyte by2 = -128;\nby2--;\nSystem.out.println(by2);//127\n```\n\n# 赋值运算符\n\n* 符号：=\n  * 当=两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理\n  * 支持连续赋值\n* 扩展赋值运算符：+=，-=，*=，/=，%=\n\n```java\n//赋值符号：=\nint i1 = 10;\nint j1 = 10;\nint i2,j2;\n//连续赋值\ni2=j2=10;\nint i3=10,j3=10;\nint num =10;\nnum += 2;\nSystem.out.println(num);//12\nint num2 = 12;\nnum2 %= 5;\nSystem.out.println(num2);\n//开发中，如果希望变量实现+2操作，有几种方法？(前提：int num = 10)\n//方式一：num = num +2;\n//方式二：num += 2;(推荐)\n//开发中，如果希望变量实现+1操作，有几种方法？(前提：int num = 10)\n//方式一：num = num +1;\n//方式二：num += 1;\n//方式三：num++;(推荐)\n//练习一\nshort s1 = 10;\n//s1 = s1 + 2;//编译失败\ns1 += 2;//不会改变变量自身的数据类型\nSystem.out.println(s1);\n//练习二\nint i =1;\ni*=0.1;\nSystem.out.println(i);//1\ni++;\nSystem.out.println(i);\n//练习三\nint m = 2;\nint n = 3;\nn *= m++;\nSystem.out.println(\"m=\"+m);\nSystem.out.println(\"n=\"+n);\n//练习四\nint n1 = 10;\nn1 +=(n1++) + (++n1);\nSystem.out.println(n1);//32\n```\n\n# 比较运算符\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184225.png)\n\n* 比较运算符的结果都是boolean型，也就是要么是true,要么是false\n* 比较运算符“==”不能误写成“=”\n\n```java\nint i=10;\nint j=20;\nSystem.out.println(i==j);//false\nSystem.out.println(i=j);//20\nboolean b1 = true;\nboolean b2 =false;\nSystem.out.println(b2==b1);//false\nSystem.out.println(b2 = b1);//true\n```\n\n# 逻辑运算符\n\n* &：逻辑与。|：逻辑或。！：逻辑非\n* &&：短路与。||：短路或。^：逻辑异或\n* 逻辑运算符操作的都是boolean类型的变量\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184226.png)\n\n```java\n//区分&与&&\n//相同点1：&与&&的运算结果相同\n//相同点2：当符号左边是true时，二者都会执行符号右边的运算\n//不同点3：当符号左边是false时，&会继续执行符号右边的运算，而&&不再执行符号右边的运算\n//开发中推荐使用&&\nboolean b1 = true;\nb1=false;\nint num1 =10;\nif(b1&(num1++>0)){\n    System.out.println(\"是\");\n}else{\n    System.out.println(\"否\");\n}\nSystem.out.println(\"num1: \" + num1);\n//输出否\n//num1: 11\nboolean b2 = true;\nb2=false;\nint num2 =10;\nif(b2&&(num2++>0)){\n    System.out.println(\"是\");\n}else{\n    System.out.println(\"否\");\n}\nSystem.out.println(\"num2: \" + num2);\n//输出否\n//num2: 10\n//区分|与||\n//相同点1：|与||的运算结果相同\n//相同点2：当符号左边是false时，二者都会执行符号右边的运算\n//不同点3：当符号左边是true时，|会继续执行符号右边的运算，而||不再执行符号右边的运算\n//开发中推荐使用||\nboolean b3 = true;\nint num3 =10;\nif(b3|(num3++>0)){\n    System.out.println(\"是\");\n}else{\n    System.out.println(\"否\");\n}\nSystem.out.println(\"num3: \" + num3);\n//输出是\n//num3: 11\nboolean b4 = true;\nint num4 =10;\nif(b4 || (num4++>0)){\n    System.out.println(\"是\");\n}else{\n    System.out.println(\"否\");\n}\nSystem.out.println(\"num4: \" + num4);\n//输出是\n//num4: 10\n```\n\n# 位运算符\n\n* 位运算符是直接对整数的二进制进行的运算\n\n*  <<:在一定范围内，每向左移一位，相当于*2\n\n*  \\>>:在一定范围内，每向右移一位，相当于/2\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184227.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184228.png)\n\n```java\nint i = 21;\ni =-21;\nSystem.out.println(\"i << 2 :\"+(i<<2));//-84\nSystem.out.println(\"i << 3 :\"+(i<<3));//-168\nSystem.out.println(\"i << 27 :\"+(i<<27));//1476395008\nint m =12;\nint n =5;\nSystem.out.println(\"m&n: \"+(m&n));//4\nSystem.out.println(\"m|n: \"+(m|n));//13\nSystem.out.println(\"m^n: \"+(m^n));//9\nint k=6;\nSystem.out.println(~k);//-7\n```\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184229.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184230.png)\n\n```java\n//练习：交换两个变量的值\nint num1 = 10;\nint num2 = 20;\nSystem.out.println(\"num1:\"+num1+\" num2: \"+num2);\n//方式一:定义临时变量的方式\nint temp = num1;\nnum1 = num2;\nnum2 = temp;\n//方式二：相加的方式\n//好处：不用定义临时变量\n//弊端：①相加操作可能超出存储范围②有局限性，只能适用于数值类型\nnum1 = num1 + num2;\nnum2 = num1 - num2;\nnum1 = num1 - num2;\n//方式三：使用位运算符\n//有局限性，只能适用于数值类型\nnum1 = num1 ^ num2;\nnum2 = num1 ^ num2;\nnum1 = num1 ^ num2;\nSystem.out.println(\"num1:\"+num1+\" num2: \"+num2);\n```\n\n# 三元运算符\n\n* (条件表达式)?表达式1:表达式2\n  * 条件表达式为true,运算后的结果是表达式1\n  * 条件表达式为false,运算后的结果是表达式2\n* 表达式1和表达式2为<font color=\"red\">同种类型</font>\n\n```java\nObject o1 = true ? new Integer(1) : new Double(2.0);\nSystem.out.println(o1);//1.0\n//三目运算符中的Integer型的数字1会自动提升为1.0.以与后面的类型相同\n```\n\n* 三元运算符与if-else的联系与区别\n  * 三元运算符可以简化if-else语句\n  * 三元运算符要求必须返回一个结果\n  * if后的代码块可有多个语句\n  \n\n```java\n//获取两个整数的较大值\nint m = 12;\nint n = 5;\nint max = (m>n)? m : n;\nSystem.out.println(max);//12\ndouble num = (m>n)?2:1.0;\n//(m>n)?2:\"n大\";//编译错误\nint a=5;\nint b=12;\nString maxStr = (a>b)?\"a大\":((a==b)?\"a和b相等\":\"b大\");\nSystem.out.println(maxStr);//b大\n//获取三个数的最大值\nint n1 = 12;\nint n2 = 30;\nint n3 = -23;\nint max1 = (n1>n2)?n1:n2;\nint max2 = (max1>n3)?max1:n3;\nSystem.out.println(\"三个数中最大的是：\"+max2);//30\nint max3 = (((n1>n2)?n1:n2)>n3)?((n1>n2)?n1:n2):n3;//不建议这样编写\nSystem.out.println(\"三个数中最大的是：\"+max2);//30\n```\n\n# 运算符的优先级\n\n* 运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如下表，上一行运算符总是优先于下一行\n* 只有单目运算符，三元运算符，赋值运算符是从右向左运算的。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184231.png)\n\n# 总结\n\n```java\n运算符之一：算术运算符\n\t+ - * / (前)++ (后)++ (前)-- (后)-- +(连接符)\n\t%:取余运算\n\t\t结果的符号与被模数的符号相同\n\t\t开发中，经常使用%来判断能否被除尽的情况\n\t(前)++ :先自增1，后运算\n\t(后)++ :先运算，后自增1\n\t(前)-- :先自减1，后运算\n\t(后)-- :先运算，后自减1\n\t\t不会改变本身变量的数据类型\n运算符之二：赋值运算符\n\t= += -= *= /= %=\n\t不会改变变量自身的数据类型\n运算符之三：比较运算符\n\t== != < > <= >= instanceof\n\t1.比较运算符的结果是boolean类型\n\t2.区分==和=\n运算符之四：逻辑运算符\n\t&,&&,|,||,^,!\n\t1.逻辑运算符操作的都是boolean类型的变量\n运算符之五：位运算符\n\t<< >> >>> & | ^ ~\n\t1.位运算符操作的都是整型的数据\n\t2.<<:在一定范围内，每向左移一位，相当于*2\n\t  >>:在一定范围内，每向右移一位，相当于/2\n\t面试题：最高效的方式计算2*8？2<<3或8<<1\n运算符之六：三元运算符\n\t(条件表达式)?表达式1:表达式2\n\t1.条件表达式的结果为boolean类型\n\t2.根据条件表达式真或假，决定执行表达式1还是表达式2\n\t3.表达式1和表达式2要求是一致的\n\t4.三元运算符可以嵌套使用\n\t5.凡是可以用三元运算符的地方都可以改写成if-else结构。\n\t反之不可以\n\t6.如果程序既可以用三元运算符还可以用if-else结构。\n\t那么推荐使用三元运算符。原因：简洁，执行效率高\n```\n\n","categories":["Java学习","Java基础语法"]},{"title":"进制","url":"/2020/12/08/尚硅谷说Java/Java基础语法/3-进制/","content":"\nJava中进制的表示\n\n<!--more-->\n# 进制的表达方式\n\n* 关于进制\n\n  * 所有数字在计算机底层都以二进制形式存在\n  * 对于整数，有四种表达方式：\n    * 二进制：0，1，满2进1，以0b或0B开头\n    * 十进制：0-9，满10进1\n    * 八进制：0-8，满8进1，以数字0开头\n    * 十六进制：0-9及A-F，满16进1，以0x或0X开头表示。此处的A-F不区分大小写。如：ox21AF +1 =0x21B0 \n\n  ```java\n  int num1 = 0b110;\n  int num2 = 110;\n  int num3 = 0127;\n  int num4 = 0x110A;\n  System.out.println(\"num1= \"+num1);//6\n  System.out.println(\"num2= \"+num2);//110\n  System.out.println(\"num3= \"+num3);//87\n  System.out.println(\"num4= \"+num4);//4362\n  ```\n\n  | 十进制 | 二进制 | 八进制 | 十六进制 |\n  | ------ | ------ | ------ | -------- |\n  | 0      | 0000   | 0      | 0        |\n  | 1      | 0001   | 1      | 1        |\n  | 2      | 0010   | 2      | 2        |\n  | 3      | 0011   | 3      | 3        |\n  | 4      | 0100   | 4      | 4        |\n  | 5      | 0101   | 5      | 5        |\n  | 6      | 0110   | 6      | 6        |\n  | 7      | 0111   | 7      | 7        |\n  | 8      | 1000   | 10     | 8        |\n  | 9      | 1001   | 11     | 9        |\n  | 10     | 1010   | 12     | A        |\n  | 11     | 1011   | 13     | B        |\n  | 12     | 1100   | 14     | C        |\n  | 13     | 1101   | 15     | D        |\n  | 14     | 1110   | 16     | E        |\n  | 15     | 1111   | 17     | F        |\n  | 16     | 10000  | 20     | 10       |\n# 二进制\n\n  * Java整数常量默认是int类型，当用二进制定义整数时，其第32位时符号位；当是long类型时，二进制默认占64位，第64位是符号位\n  * 二进制的整数有如下三种形式\n    * 原码：直接将一个数值换成二进制数。最高位是符号位\n    * 负数的反码：是对原码按位取反，只是最高位(符号位)确定为1\n    * 负数的补码：其反码+1\n  * 计算机以二进制补码的形式保存所有的整数。\n    * 整数的原码，反码，补码都相同\n    * 负数的补码是其反码+1\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184212.png)\n\n","categories":["Java学习","Java基础语法"]},{"title":"eclipse的配置maven","url":"/2020/12/07/工具的使用/工具配置/","content":"\neclipse的配置maven\n<!--more-->\n\n# 在 Eclipse 中使用 Maven\n\n## 安装 Maven 核心程序\n\n1. 下载地址：http://maven.apache.org/\n\n   * 检查 JAVA_HOME 环境变量。Maven 是使用 Java 开发的，所以必须知道当前系统环境中 JDK 的安装目录。\n   * 按windows + R 输出cmd.输入Java-verbose\n\n   ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210321201356.png)\n\n2. 解压 Maven 的核心程序。将 apache-maven-3.6.3-bin.zip 解压到一个非中文无空格的目录下。例如：\n\n   ```java\n   D:\\apache-maven-3.6.3\n   ```\n\n3. 配置环境变量。\n\n   ```java\n   MAVEN_HOME\n   D:\\apache-maven-3.6.3\n   \n   path\n   %MAVEN_HOME%\\bin\n   ```\n\n4. 查看 Maven 版本信息验证安装是否正确。\n\n   * 按windows + R 输出cmd.输入mvn -v\n\n   ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20210321201402.png)\n\n","categories":["工具的使用"]},{"title":"基本数据类型","url":"/2020/12/07/尚硅谷说Java/Java基础语法/2-基本数据类型/","content":"\nJava基础知识之数据类型\n\n<!--more-->\n# 变量的分类-按数据类型\n\n* 对于每一种数据都定义了明确的具体数据类型(强类型语言)，在内存中分配了不同大小的内存空间\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207180627.png)\n\n# 变量的分类-按声明的位置不同\n\n* 在方法体外，类变量声明的变量称为成员变量\n* 在方法体内部声明的变量称为局部变量。\n* ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207180628.png)\n\n* 注意：二者在初始化值方便的异同\n  * 同：二者都有生命周期\n  * 不同：局部变量除形参外，需显式初始化\n\n# 整数类型：byte,short,int,long\n\n  * Java各整数类型有固定的表数范围和字段长度，不受具体OS(操作系统)影响，以保证Java程序的可移植性。\n  * Java的整型变量默认为int型，声明long型常量须后加\"l\"或\"L\"\n  * Java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207180629.png)\n\n  * 1MB =  1024KB ,1KB = 1024B, 1B = 1byte\n  * bit:计算机中最小存储单位。byte:计算机中基本存储单元\n```JAVA\n//1.整型：byte(1字节=8bit) / short(2字节) / int(4字节) / long(8字节)\n//① byte范围：-128~127\nbyte b1 = 12;\nbyte b2= -128;\n//b2=128；超出范围编译不通过\nSystem.out.println(b1);\nSystem.out.println(b2);\n//② 声明long类型变量，必须以\"l\"或\"L\"结尾。通常写L结尾容易识别\nshort s1 = 128;\nint i1 = 1234;\nlong l1= 12344L;\nSystem.out.println(l1);\n//③ 通常，定义整型变量时，使用int型\n```\n\n# 浮点类型：float,double\n\n  * 与整数类型类似，Java浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响\n\n  * 浮点型常量由两种表现形式\n\n    * 十进制数形式：如5.12\t512.0f \t.512(必须有小数点)\n\n    * 科学计数法形式：如5.12e2\t 512E2\t 100E-2\n\n  * float:单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求\n  * double:双精度，精度是float的两倍。通常采用此类型\n  * Java的浮点型常量默认为double型，声明float型常量，须在后面加\"f\"或\"F\"\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207180630.png)\n\n```JAVA\n//2.浮点型：float(4字节)/double(8字节)\n//① 浮点型，表示带小数点的数值\n//② float表示数值的范围比long还大\ndouble d1 = 123.3;\nfloat f1 = 12.3F;\n//③ 定义float类型变量时，变量要以\"f\"或\"F\"结尾\nSystem.out.println(f1);\n//④ 通常，定义浮点型变量时，使用double型\n```\n\n# 字符类型：char\n\n  * char型数据用来表示通常意义上“字符”(2字节)\n\n  * Java中所有字符都是用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符\n\n  *\t字符型变量的三种表现形式\n     \n  * 字符常量使用单引号('')括起来的单个字符，例如：char c1 = 'a'; char c2 = '中';char c3 = '9';\n     * Java中还允许使用转义字符'\\\\\\'来将其后面的字符转变成字符型常量。例如：char c3 = '\\n'; '\\n'表示换行符\n\n     ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207180758.png)\n\n     * 直接使用Unicode值来表示字符型常量：'\\uXXXX'。其中，XXXX代表一个十六进制整数。如：\\u000a表示\\n\n\n  * char类型是可以进行运算的。因为它都对应有Unicode码\n\n```JAVA\n//3.字符型：char(1字符=2字节)\n//① 定义char类型变量，通常使用一对''，内部只能写一个字符\nchar c1 = 'a';\n//编译不通过\n//c1 = 'AB';\nSystem.out.println(c1);\nchar c2 = '1';\nchar c3 = '中';\nchar c4 = 'ぇ';\nSystem.out.println(c2);\nSystem.out.println(c3);\nSystem.out.println(c4);\n//② 表示方式：1.声明一个字符 2.转义字符 3.直接使用Unicode值来表示字符型常量\nchar c5 = '\\n';//换行符\nc5 = '\\t';//制表符，相当于Tab键\nSystem.out.print(\"hello\"+c5);\nSystem.out.println(\"world\");\nchar c6 = '\\u0043';\nSystem.out.println(c6);\n```\n\n# 布尔型：boolean\n\n```java\n//4.布尔型：boolean\n//① 只能取两个值之一：true,false\n//② 常常在条件判断，循环结构中使用\nboolean bl1 = true;\nSystem.out.println(bl1);\nboolean isMarried = true;\nif(isMarried){\n    System.out.println(\"你就不能参加\\\"单身\\\"party了！\\\\n很遗憾\");\n}else{\n    System.out.println(\"你要多谈谈女朋友\");\n}\t\t\n```\n\n# 字符串类型：String\n\n* String不是基本数据类型，属于引用数据类型\n\n* 使用方式与基本数据类型一致。例如：String str = \"abcd\";\n\n* 一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。例如\n\n  ```java\n  str = str + \"xyz\";\n  int n = 100;\n  str = str + n;\n  //String类型变量的使用\n  String str = \"Hello World!\";\n  System.out.println(str);\n  String str2 = \"a\";\n  String str3 = \"\";\n  int number = 1001;\n  String numberStr = \"学号：\";\n  numberStr = numberStr + number;\n  System.out.println(numberStr);\n  boolean info = true;\n  numberStr = numberStr + info;\n  System.out.println(numberStr);\n  //*************************\n  //练习一\n  char ch = 'a';//编码位置是97\n  int num = 10;\n  String strs = \"hello\";\n  System.out.println(ch + num + strs);//107hello\n  System.out.println(ch + strs + num);//ahello10\n  System.out.println(ch + (num + strs));//a10hello\n  System.out.println((ch + num) + strs);//107hello\n  System.out.println(strs + num + ch);//hello10a\n  //练习二\n  System.out.println(\"*\t*\");//*       *\n  System.out.println('*' + '\\t' + '*');//93\n  System.out.println('*' + \"\\t\" + '*');//*       *\n  System.out.println('*' + '\\t' + \"*\");//51*\n  System.out.println('*' + ('\\t' + \"*\"));//*       *\n  ```\n\n# 基本数据类型转换\n\n* 自动类型转换 ：容量小的类型自动转换成容量大的数据类型。数据类型按容量大小排序为：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184206.png)\n\n  * 有多种类型的数据混合运算时，系统首先自动将书友数据转换成容量大的那种数据类型，然后再进行计算。\n  * byte,short,char之间不会相互转换，它们三者在计算时首先转换成int类型\n  * boolean类型不能与其他数据类型运算\n  * 当把任何基本数据类型的值与字符串(String)进行来连接运算(+)时，基本数据类型的值将自动转换成字符串类型(String)\n\n  ```java\n  //自动类型转换\n  byte by1 = 2;\n  int in1 = 129;\n  //编译不通过。\n  //byte by2 = by1 + in1;\n  int in2 = by1 + in1;\n  long lo1 = by1 + in1;\n  System.out.println(in2);\n  float fl1 = by1 + in1;\n  System.out.println(fl1);\n  short sh1 =123;\n  double do1 = sh1;\n  System.out.println(do1);\n  ```\n\n* 强制类型转换\n\n  * 自动类型转换的逆过程，将容量大的数据类型转换成容量小的数据类型。使用时要加上强制转换符：(),但可能造成精度丢失或溢出，要格外注意。\n  * 通常，字符串不能直接转换成基本数据类型，但可以通过基本数据类型对应的包装类则可以实现把字符串转换成基本数据类型。\n  * 如：String a = \"43\";int i = Integer.parseInt(a);\n  * boolean类型不可以转换成其他数据类型\n\n  ```java\n  //强制类型转换\n  double dou1 = 12.9;\n  //精度损失举例1\n  int int1 = (int)dou1;//截断操作\n  System.out.println(int1);\n  //没有精度损失\n  long lon1 =123;\n  short sho1 = (short)lon1;\n  //精度损失举例2\n  int int2 = 128;\n  byte byt1 = (byte)int2;\n  System.out.println(byt1);//-128\n  ```\n\n  # 总结\n\n```java\nJava定义的数据类型\n一，变量按照数据类型来分：\n\t基本数据类型：\n\t\t整型：byte/short/int/long\n\t\t浮点型：float/double\n\t\t字符型：char\n\t\t布尔型：boolean\n\t引用数据类型：\n\t\t类(class)\n\t\t接口(interface)\n\t\t数组(array)\t\n二，变量在类中声明的位置\n\t成员变量\n\t局部变量\n三，基本数据类型之间的运算规则\n前提：这里讨论的只是7中基本数据类型变量间的运算。不包含boolean类型的\n说明：容量大小指的是表示数的范围的大小。比如：float容量要大于long的容量\n\t1.自动类型提升：\n\t\t结论：当容量小的数据类型的变量与容量大的数据类型的变量运算时，结果自动提升为容量大的\n\t\tbyte ,char , short --> int --> long --> float --> double\n\t\t特别的：当byte ,char , short三种类型的变量做运算时，结果为int型\n\t2.强制类型转换：自动类型提升的逆运算\n\t\t1.需要使用强转符:()\n\t\t2.注意点：强制类型转换，可能导致精度损失。\n四，String类型变量的使用\n\t1.String属于引用数据类型，翻译为：字符串\n\t2.声明String类型变量时，使用一对\"\"\n\t3.String可以和8中数据类型变量做运算，且运算只能是连接运算：+\n\t4.运算的结果仍然是String类型\n\t5.判断+是否为连接运算的方法是看+两边是否有字符串类型的值\n```\n\n\n\n  \n\n\n","categories":["Java学习","Java基础语法"]},{"title":"CSS学习","url":"/2020/12/07/尚硅谷说Java/前端/CSS/","content":"CSS学习\n<!--more-->\n# 1.CSS技术介绍\n\nCSS 是「层叠样式表单」。是用于(增强)控制网页样式并允许将样式信息与网页内容分离的一种标记性语言。\n\n# 2.CSS语法规则\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210404.png)\n\n**选择器**：浏览器根据“选择器”决定受 CSS 样式影响的 HTML 元素（标签）。\n\n**属性**(property) 是你要改变的样式名，并且每个属性都有一个值。属性和值被冒号分开，并 由花括号包围，这样就组成了一个完整的样式声明（declaration），例如：p {color: blue}\n\n**多个声明**：如果要定义不止一个声明，则需要用分号将每个声明分开。虽然最后一条声明的 最后可以不加分号(但尽量在每条声明的末尾都加上分号)\n\n例如：\n\n```css\np{ \n    color:red;\n    font-size:30px; \n}  \nCSS 注释：/*注释内容*/\n```\n\n<font color = \"red\">注：一般每行只描述一个属性</font>\n\n# 3.CSS和HTML结合的方式\n\n## 3.1第一种\n\n​\t\t\t在标签的 style 属性上设置”key:value value;”，修改标签样式\n\n需求 1：分别定义两个 div、span 标签，分别修改每个 div 标签的样式为：边框 1 个像素，实线，红色。\n\n```html\n<body>\n    <!--需求1：分别定义两个 div、span标签，分别修改每个 div 标签的样式为：边框1个像素，实线，红色。-->\n    <div style=\"border: 1px solid red;\">div标签1</div>\n    <div style=\"border: 1px solid red;\">div标签2</div>\n    <span style=\"border: 1px solid red;\">span标签1</span>\n    <span style=\"border: 1px solid red;\">span标签2</span>\n</body>\n```\n\n效果：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210405.png)\n\n**问题：这种方式的缺点？** \n\n​\t1.如果标签多了。样式多了。代码量非常庞大。 \n\n​\t2.可读性非常差。 \n\n​\t3.Css 代码没什么复用性可方言\n\n## 3.2第二种\n\n​\t\t\t在 head 标签中，使用 style 标签来定义各种自己需要的 css 样式。\n\n​\t\t\t格式如下： \n\n​\t\t\txxx {\n\n​\t\t\t\t\tKey : value value; \n\n​\t\t\t}\n\n需求1：分别定义两个 div、span标签，分别修改每个 div 标签的样式为：边框1个像素，实线，红色\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <!--style标签专门用来定义css样式代码-->\n    <style type=\"text/css\">\n        /* 需求1：分别定义两个 div、span标签，分别修改每个 div 标签的样式为：边框1个像素，实线，红色。*/\n        div{\n            border: 1px solid red;\n        }\n        span{\n            border: 1px solid red;\n        }\n    </style>\n</head>\n\n<body>\n    <div>div标签1</div>\n    <div>div标签2</div>\n\n    <span>span标签1</span>\n    <span>span标签2</span>\n</body>\n</html>\n```\n\n效果：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210405.png)\n\n**问题：这种方式的缺点。**\n\n \t1.只能在同一页面内复用代码，不能在多个页面中复用 css 代码。 \n\n​\t2.维护起来不方便，实际的项目中会有成千上万的页面，要到每个页面中去修改。工作量太大了。\n\n## 3.3第三种\n\n​\t\t\t把 css 样式写成一个单独的 css 文件，再通过 link 标签引入即可复用。\n\n​\t\t使用 html 的 \\<link rel=\"stylesheet\" type=\"text/css\" href=\"./styles.css\" /> 标签 导入 css 样 式文件\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <!--link标签专门用来引入css样式代码-->\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"1.css\"/>\n\n</head>\n\n<body>\n    <div>div标签1</div>\n    <div>div标签2</div>\n\n    <span>span标签1</span>\n    <span>span标签2</span>\n</body>\n</html>\n```\n\nCSS代码：\n\n```css\ndiv{\n     border: 1px solid yellow;\n }\nspan{\n    border: 1px solid red;\n}\n```\n\n效果：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210406.png)\n\n# 4.CSS选择器\n\n## 4.1标签名选择器\n\n​\t\t\t标签名选择器的格式是： \n\n​\t\t\t\t标签名{ \n\n​\t\t\t\t\t\t属性：值; \n\n​\t\t\t\t}\n\n​\t\t\t标签名选择器，可以决定哪些标签被动的使用这个样式。\n\n需求1：在所有div标签上修改字体颜色为蓝色，字体大小30个像素。边框为1像素黄色实线。\n\t并且修改所有span 标签的字体颜色为黄色，字体大小20个像素。边框为5像素蓝色虚线。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>CSS选择器</title>\n\t<style type=\"text/css\">\n\t\tdiv{\n\t\t\tborder: 1px solid yellow;\n\t\t\tcolor: blue;\n\t\t\tfont-size: 30px;\n\t\t}\n\t\tspan{\n\t\t\tborder: 5px dashed  blue;\n\t\t\tcolor: yellow;\n\t\t\tfont-size: 20px;\n\t\t}\n\t</style>\n</head>\n<body>\n\t<!-- \n\t需求1：在所有div标签上修改字体颜色为蓝色，字体大小30个像素。边框为1像素黄色实线。\n\t并且修改所有span 标签的字体颜色为黄色，字体大小20个像素。边框为5像素蓝色虚线。\n\t -->\n\t<div>div标签1</div>\n\t<div>div标签2</div>\n\t<span>span标签1</span>\n\t<span>span标签2</span>\n</body>\n</html>\n\n\n```\n\n效果：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210407.png)\n\n## 4.2id选择器\n\n​\t\t\t\tid 选择器的格式是： \n\n​\t\t\t\t\t\t#id 属性值{ \n\n​\t\t\t\t\t\t\t\t属性：值; \n\n​\t\t\t\t\t\t}\n\n​\t\t\t\tid 选择器，可以让我们通过 id 属性选择性的去使用这个样式。\n\n需求1：分别定义两个 div 标签，\n\t第一个div 标签定义 id 为 id001 ，然后根据id 属性定义css样式修改字体颜色为蓝色，\n\t字体大小30个像素。边框为1像素黄色实线。\n\n​\t第二个div 标签定义 id 为 id002 ，然后根据id 属性定义css样式 修改的字体颜色为红色，字体大小20个像素。\n​\t边框为5像素蓝色点线。\t\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>ID选择器</title>\n\t<style type=\"text/css\">\n\n\t\t#id001{\n\t\t\tcolor: blue;\n\t\t\tfont-size: 30px;\n\t\t\tborder: 1px yellow solid;\n\t\t}\n\n\t\t#id002{\n\t\t\tcolor: red;\n\t\t\tfont-size: 20px;\n\t\t\tborder: 5px blue dotted ;\n\t\t}\n\n\t</style>\n</head>\n<body>\t\t\n\t<!--\n\t需求1：分别定义两个 div 标签，\n\t第一个div 标签定义 id 为 id001 ，然后根据id 属性定义css样式修改字体颜色为蓝色，\n\t字体大小30个像素。边框为1像素黄色实线。\n\t\n\t第二个div 标签定义 id 为 id002 ，然后根据id 属性定义css样式 修改的字体颜色为红色，字体大小20个像素。\n\t边框为5像素蓝色点线。\n\t -->\n\t\n\t<div id=\"id002\">div标签1</div>\n\t<div id=\"id001\">div标签2</div>\n</body>\n</html>\n\n\n```\n\n效果：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210408.png)\n\n## 4.3class选择器\n\n​\t\t\t\tclass 类型选择器的格式是：\n\n \t\t\t\t\t\t\t.class 属性值{ \n\n​\t\t\t\t\t\t\t\t\t属性：值; \n\n​\t\t\t\t\t\t\t} \n\n​\t\t\t\tclass 类型选择器，可以通过 class 属性有效的选择性地去使用这个样式\n\n需求1：修改 class 属性值为 class01的 span 或 div 标签，字体颜色为蓝色，字体大小30个像素。边框为1像素黄色实线。\n需求2：修改 class 属性值为 class02的 div 标签，字体颜色为灰色，字体大小26个像素。边框为1像素红色实线。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>class类型选择器</title>\n\t<style type=\"text/css\">\n\t\t.class01{\n\t\t\tcolor: blue;\n\t\t\tfont-size: 30px;\n\t\t\tborder: 1px solid yellow;\n\t\t}\n\n\t\t.class02{\n\t\t\tcolor: grey;\n\t\t\tfont-size: 26px;\n\t\t\tborder: 1px solid red;\n\t\t}\n\t</style>\n</head>\n<body>\n\t<!--\n\t\t需求1：修改 class 属性值为 class01的 span 或 div 标签，字体颜色为蓝色，字体大小30个像素。边框为1像素黄色实线。\n\t\t需求2：修改 class 属性值为 class02的 div 标签，字体颜色为灰色，字体大小26个像素。边框为1像素红色实线。\n\t -->\n\n\t<div class=\"class02\">div标签class01</div>\n\t<div class=\"class02\">div标签</div>\n\t<span class=\"class02\">span标签class01</span>\n\t<span>span标签2</span>\n</body>\n</html>\n```\n\n效果：\n\n​\t![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210409.png)\n\n## 4.4组合选择器\n\n​\t\t\t\t组合选择器的格式是： \n\n​\t\t\t\t\t\t选择器 1，选择器 2，选择器 n{ \n\n​\t\t\t\t\t\t\t\t\t属性：值; \n\n​\t\t\t\t\t\t\t} \n\n​\t\t\t组合选择器可以让多个选择器共用同一个 css 样式代码\n\n需求1：修改 class=\"class01\" 的div 标签 和 id=\"id01\" 所有的span标签，字体颜色为蓝色，字体大小20个像素。边框为1像素黄色实线。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>class类型选择器</title>\n    <style type=\"text/css\">\n        .class01 , #id01{\n            color: blue;\n            font-size: 20px;\n            border:  yellow 1px solid;\n        }\n    </style>\n</head>\n<body>\n\t<!-- \n\t需求1：修改 class=\"class01\" 的div 标签 和 id=\"id01\" 所有的span标签，\n\t字体颜色为蓝色，字体大小20个像素。边框为1像素黄色实线。\n\t -->\n   <div id=\"id01\">div标签class01</div> <br />\n   <span>span 标签</span>  <br />\n   <div>div标签</div> <br />\n   <div>div标签id01</div> <br />\n</body>\n</html>\n\n\n```\n\n效果：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210410.png)\n\n# 5.常用样式\n\n1、字体颜色 \n\n​\t\t<font color=\"red\">color：red； </font>\n\n​\t\t颜色可以写颜色名如：black, blue, red, green 等 \n\n​\t\t颜色也可以写 rgb 值和十六进制表示值：如 rgb(255,0,0)，#00F6DE，如果写十六进制值必 须加#\n2、宽度\n\n​\t\t<font color=\"red\">width:19px; </font>\n\n​\t\t宽度可以写像素值：19px； \n\n​\t\t也可以写百分比值：20%； \n\n3、高度\n\n​\t\t<font color=\"red\">height:20px;</font>\n\n \t\t高度可以写像素值：19px； \n\n​\t\t也可以写百分比值：20%； \n\n4、背景颜色\n\n \t\t<font color=\"red\">background-color:#0F2D4C </font>\n\n5、字体样式：\n\n \t\t<font color=\"red\">color：#FF0000；</font>字体颜色红色 \n\n​\t\t<font color=\"red\"> font-size：20px; </font>字体大小 \n\n6、红色 1 像素实线边框 \n\n​\t\t<font color=\"red\"> border：1px solid red; </font>\n\n7、DIV 居中\n\n \t  <font color=\"red\"> margin-left: auto; </font>\n\n​\t\t<font color=\"red\">margin-right: auto; </font>\n\n8、文本居中： \n\n​\t\t<font color=\"red\">text-align: center;</font>\n9、超连接去下划线\n\n \t\t<font color=\"red\">text-decoration: none; </font>\n\n10、表格细线 \n\n​\t\t<font color=\"red\">table { </font>\n\n​\t\t\t<font color=\"red\">border: 1px solid black;</font> /\\*设置边框*/ \n\n​\t\t\t<font color=\"red\">border-collapse: collapse;</font> /\\*将边框合并*/ \n\n​\t\t<font color=\"red\">}</font>\n\n​\t\t<font color=\"red\">td,th {</font>\n\n​\t\t\t<font color=\"red\">border: 1px solid black; </font>/\\*设置边框*/ \n\n​\t<font color=\"red\">\t} </font>\n\n11、列表去除修饰 \n\n​\t\t<font color=\"red\">ul { </font>\n\n​\t\t\t<font color=\"red\">list-style: none; </font>\n\n​\t<font color=\"red\">\t}</font>\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>06-css常用样式.html</title>\n    <style type=\"text/css\">\n\n        div{\n            color: red;\n            border: 1px yellow solid;\n            width: 300px;\n            height: 300px;\n            background-color: green;\n            font-size: 30px;\n            margin-left: auto;\n            margin-right: auto;\n            text-align: center;\n        }\n        table{\n            border: 1px red solid;\n            border-collapse: collapse;\n        }\n\n        td{\n            border: 1px red solid;\n        }\n\n        a{\n            text-decoration: none;\n\n        }\n\n        ul{\n            list-style: none;\n        }\n\n    </style>\n</head>\n<body>\n    <ul>\n        <li>11111111111</li>\n        <li>11111111111</li>\n        <li>11111111111</li>\n        <li>11111111111</li>\n        <li>11111111111</li>\n    </ul>\n    <table>\n        <tr>\n            <td>1.1</td>\n            <td>1.2</td>\n        </tr>\n    </table>\n    <a href=\"http://www.baidu.com\">百度</a>\n    <div>我是div标签</div>\n</body>\n</html>\n```\n\n效果：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210411.png)","categories":["Java学习","前端"]},{"title":"枚举类与注解","url":"/2020/12/07/尚硅谷说Java/Java高级语法/3-枚举类与注解/","content":"\nenum定义枚举类，Annotation注解以及四个元注解\n\n<!--more-->\n# 枚举类\n\n* 类的对象只有有限个，确定的。举例如下：\n  * 星期：Monday(星期一)、......、Sunday(星期天) \n  * 性别：Man(男)、Woman(女) \n  * 季节：Spring(春节)......Winter(冬天) \n  * 支付方式：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡) \n  * 就职状态：Busy、Free、Vocation、Dimission\n  * 订单状态：Nonpayment（未付款）、Paid（已付款）、Delivered（已发货）、Return（退货）、Checked（已确认）Fulfilled（已配货）、\n  * 线程状态：创建、就绪、运行、阻塞、死亡\n* 当需要定义一组常量时，强烈建议使用枚举类\n* 枚举类的实现\n  * JDK1.5之前需要自定义枚举类\n  * JDK 1.5 新增的 enum 关键字用于定义枚举类\n* 若枚举只有一个对象, 则可以作为一种单例模式的实现方式。\n* 枚举类的属性\n  * 枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰\n  * 枚举类的使用 private final 修饰的属性应该在构造器中为其赋值\n  * 若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数\n\n## 自定义枚举类\n\n* 步骤\n\n  1. 私有化类的构造器，保证不能在类的外部创建其对象\n  2. 在类的内部创建枚举类的实例。声明为：public static final \n  3. 对象如果有实例变量，应该声明为private final，并在构造器中初始化\n\n  ```java\n  public class WeekState {\n      //1.创建私有的常量属性：private final\n      private final String WEEK;\n      //2.创建私有的构造方法：private\n      private WeekState(String week){\n          this.WEEK = week;\n      }\n      //3.创建公共的静态的常量状态量：public static final\n      /**\n       * 星期一\n       */\n      public static final WeekState  MONDAY = new WeekState(\"MONDAY\");\n      /**\n       * 星期二\n       */\n      public static final WeekState  TUESDAY = new WeekState(\"TUESDAY\");\n      /**\n       * 星期三\n       */\n      public static final WeekState  WEDNESDAY = new WeekState(\"WEDNESDAY\");\n      /**\n       * 星期四\n       */\n      public static final WeekState  THURSDAY = new WeekState(\"THURSDAY\");\n      /**\n       * 星期五\n       */\n      public static final WeekState  FRIDAY = new WeekState(\"FRIDAY\");\n      /**\n       * 星期六\n       */\n      public static final WeekState  SATURDAY = new WeekState(\"SATURDAY\");\n      /**\n       * 星期七\n       */\n      public static final WeekState  SUNDAY = new WeekState(\"SUNDAY\");\n      //4.其他诉求1：获取枚举类对象的属性\n      public String getWEEK() {\n          return WEEK;\n      }\n      //4.其他诉求2：提供toString方法\n      @Override\n      public String toString() {\n          return \"WeekState{\" +\n                  \"WEEK='\" + WEEK + '\\'' +\n                  '}';\n      }\n  }\n  ```\n\n## enum关键字定义枚举类\n\n* 使用说明\n\n  * 使用 enum 定义的枚举类默认继承了 java.lang.Enum类，因此不能再继承其他类\n  * 枚举类的构造器只能使用 private 权限修饰符\n  * 枚举类的所有实例必须在枚举类中显式列出(, 分隔 ; 结尾)。列出的实例系统会自动添加 public static final 修饰\n  * 必须在枚举类的第一行声明枚举类对象\n\n* JDK 1.5 中可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字, 无需添加枚举类作为限定。\n\n  ```java\n  public enum WeekState implements Info{\n      //1.提供当前枚举类的对象，多个对象之间用逗号隔开，最后使用分号结束\n      MONDAY(\"MONDAY\"){\n          @Override\n          public void show() {\n              System.out.println(\"这是星期一\");\n          }\n      },\n      TUESDAY(\"TUESDAY\"){\n          @Override\n          public void show() {\n              System.out.println(\"这是星期二\");\n          }\n      },\n      WEDNESDAY(\"WEDNESDAY\"){\n          @Override\n          public void show() {\n              System.out.println(\"这是星期三\");\n          }\n      },\n      THURSDAY(\"THURSDAY\"){\n          @Override\n          public void show() {\n              System.out.println(\"这是星期四\");\n          }\n      },\n      FRIDAY(\"FRIDAY\"){\n          @Override\n          public void show() {\n              System.out.println(\"这是星期五\");\n          }\n      },\n      SATURDAY(\"SATURDAY\"){\n          @Override\n          public void show() {\n              System.out.println(\"这是星期六\");\n          }\n      },\n      SUNDAY(\"SUNDAY\"){\n          @Override\n          public void show() {\n              System.out.println(\"这是星期七\");\n          }\n      };\n      //0.当提供的枚举对象的要赋予参数时，需要有构造方法和属性；(当不需要设计属性时，这一步可以省略)\n      private final String WEEK;\n      private WeekState(String monday) {\n          this.WEEK = monday;\n      }\n  }\n  ```\n\n* Enum类的主要方法\n\n  * values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。\n  * valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。\n    * 如不是，会有运行时异常：IllegalArgumentException。 \n  * toString()：返回当前枚举类对象常量的名称\n\n  ```java\n  WeekState monday = WeekState.MONDAY;\n  //toString()\n  System.out.println(monday.toString());\n  //values()\n  WeekState[] values = WeekState.values();\n  System.out.println(Arrays.toString(values));\n  //valueOf(name)\n  WeekState sunday = WeekState.valueOf(\"SUNDAY\");\n  System.out.println(sunday.toString());\n  //定制接口实现方法\n  monday.show();\n  //获取WeekState的父类\n  //System.out.println(WeekState.class.getSuperclass());\n  ```\n\n* 和普通 Java 类一样，枚举类可以实现一个或多个接口\n\n* 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。\n\n* 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式, 则可以让每个枚举值分别来实现该方法\n\n# 注解\n\n## 注解(Annotation)概述\n\n* 从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解) \n* Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。\n* Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器, 方 法, 成员变量, 参数, 局部变量的声明, 这些信息被保存在 Annotation 的 “name=value” 对中。\n* 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 \n* 未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：框架 = 注解 + 反射 + 设计模式。\n\n## 常见的Annotation示例\n\n* 使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素\n\n* 示例一：生成文档相关的注解\n\n  |    注解    |                             作用                             |\n  | :--------: | :----------------------------------------------------------: |\n  |  @author   |        标明开发该类模块的作者，多个作者之间使用,分割         |\n  |  @version  |                      标明该类模块的版本                      |\n  |    @see    |                   参考转向，也就是相关主题                   |\n  |   @since   |                     从哪个版本开始增加的                     |\n  |   @param   |          对方法中某参数的说明，如果没有参数就不能写          |\n  |  @return   |    对方法返回值的说明，如果方法的返回值类型是void就不能写    |\n  | @exception | 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写 |\n\n  * 其中\n    * @param @return 和 @exception 这三个标记都是只用于方法的。\n    * @param的格式要求：@param 形参名 形参类型 形参说明\n    * @return 的格式要求：@return 返回值类型 返回值说明\n    * @exception的格式要求：@exception 异常类型 异常说明\n    * @param和@exception可以并列多个\n\n  ```java\n  /**\n  * @author:luc\n  * @version:1.0\n  * @param a\n  * @param b\n  * @return \n  * @exception Exception\n  */\n  public int maxInt(int a,int b) throws Exception{\n      return a>b ? a : b;\n  }\n  ```\n\n* 示例二：在编译时进行格式检查(JDK内置的三个基本注解) \n\n  | 注解              | 作用                                                         |\n  | ----------------- | ------------------------------------------------------------ |\n  | @Override         | 限定重写父类方法, 该注解只能用于方法                         |\n  | @Deprecated       | 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择 |\n  | @SuppressWarnings | 抑制编译器警告                                               |\n\n  * 说明@SuppressWarnings\n    * 当使用eclipse编译代码时，如果只定义了变量而未使用它，eclipse会提示一个警告。这是用@SuppressWarnings(\"unused\")时。警告就会消失\n\n* 示例三：跟踪代码依赖性，实现替代配置文件功能\n\n  * Servlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署。\n  * 例如下述Java代码通过注解而能实现下述xml配置内容的作用\n\n  ```java\n  @WebServlet(\"/login\")\n  public class LoginServlet extends HttpServlet {\n      private static final long serialVersionUID = 1L;\n  \n      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws\n              ServletException, IOException {\n      }\n  \n      protected void doPost(HttpServletRequest request, HttpServletResponse response) throws\n              ServletException, IOException {\n          doGet(request, response);\n      }\n  }\n  ```\n\n  ```xml\n  <servlet> \n  \t<servlet-name>LoginServlet</servlet-name> \n  \t<servlet-class>com.servlet.LoginServlet</servlet-class>\n  </servlet> \n  <servlet-mapping> \n  \t<servlet-name>LoginServlet</servlet-name> \n  \t<url-pattern>/login</url-pattern>\n  </servlet-mapping>\n  ```\n\n## 自定义Annotation\n\n* 定义新的 Annotation 类型使用 @interface 关键字\n\n* 自定义注解自动继承了java.lang.annotation.Annotation接口\n\n* Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组。 \n\n* 可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字\n\n* 如果只有一个参数成员，建议使用参数名为value\n\n* 如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value，可以省略“value=”  \n\n* 没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数据 Annotation\n\n* 注意：自定义注解必须配上注解的信息处理流程才有意义。\n\n  ```java\n  @Retention(RetentionPolicy.RUNTIME)\n  @Target(ElementType.TYPE)\n  public @interface CustomAnnotation {\n      String value() default \"hello\";\n  }\n  ```\n\n## JDK中的元注解\n\n* JDK 的元 Annotation 用于修饰其他 Annotation 定义\n* JDK5.0提供了4个标准的meta-annotation类型，分别是：Retention；Target；Documented；Inherited。\n* 引申 :元数据的理解：String name = “atguigu”;\n* @Retention: 只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命周期, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用@Rentention 时必须为该 value 成员变量指定值: \n\n|          取值           |                             作用                             |\n| :---------------------: | :----------------------------------------------------------: |\n| RetentionPolicy.SOURCE  | 在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释 |\n|  RetentionPolicy.CLASS  | 在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM 不会保留注解。 <font color=\"red\">默认值</font> |\n| RetentionPolicy.RUNTIME | 在运行时有效（即运行时保留），当运行 Java 程序时, JVM 会保留注释。程序可以通过反射获取该注释。 |\n\n​\t![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184354.png)\t\n\n* @Target: 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。\n\n|            取值             |                         作用                         |\n| :-------------------------: | :--------------------------------------------------: |\n|   ElementType.CONSTRUCTOR   |                  可以用于描述构造器                  |\n|      ElementType.FIELD      |                    可以用于描述域                    |\n| ElementType.LOCAL_VARIABLE  |                 可以用于描述局部变量                 |\n|     ElementType.METHOD      |                   可以用于描述方法                   |\n|     ElementType.PACKAGE     |                    可以用于描述包                    |\n|    ElementType.PARAMETER    |                   可以用于描述参数                   |\n|      ElementType.TYPE       |     可以用于描述类，接口(包括注解类型)或enum声明     |\n|    ElementType.TYPE_USE     |         表示该注解能写在使用类型的任何注解中         |\n| ElementType.TYPE_PARAMETER  | 表示该注解能写在类型变量的声明语句中（如：泛型声明） |\n| ElementType.ANNOTATION_TYPE |                     注释类型声明                     |\n\n* @Documented: 用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。 \n  * 定义为Documented的注解必须设置Retention值为RUNTIME。 \n* @Inherited: 被它修饰的 Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解。\n  * 比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解。\n  * 实际应用中，使用较少。\n\n## 利用反射获取注解信息（在反射部分涉及）\n\n* JDK 5.0 在 java.lang.reflect 包下新增了 AnnotatedElement 接口, 该接口代表程序中可以接受注解的程序元素\n\n* 当一个 Annotation 类型被定义为运行时 Annotation 后, 该注解才是运行时可见, 当 class 文件被载入时保存在 class 文件中的 Annotation 才会被虚拟机读取\n\n* 程序可以调用 AnnotatedElement对象的如下方法来访问 Annotation 信息\n\n  |      |      |\n  | ---- | ---- |\n  |      |      |\n  |      |      |\n  |      |      |\n  |      |      |\n\n## JDK 8中注解的新特性\n\n* Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。此外，反射也得到了加强，在Java8中能够得到方法参数的名称。这会简化标注在方法参数上的注解。\n\n* 可重复注解\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184355.png)\n\n* 类型注解：\n\n  * JDK1.8之后，关于元注解@Target的参数类型ElementType枚举值多了两个：TYPE_PARAMETER,TYPE_USE。 \n\n* 在Java 8之前，注解只能是在声明的地方所使用，Java8开始，注解可以应用在任何地方。 \n\n  * ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。  \n  * ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中\n\n  ```java\n  public class TestTypeDefine<@TypeDefine() U> {\n  \tprivate U u;\n  \tpublic <@TypeDefine() T> void test(T t){\n  \t} \n  }\n  @Target({ElementType.TYPE_PARAMETER})\n  @interface TypeDefine{ \n  }\n  ///////////////////////////////////////////////////////////////////\n  @MyAnnotation\n  public class AnnotationTest<U> {\n      @MyAnnotation\n      private String name;\n      public static void main(String[] args) {\n          AnnotationTest<@MyAnnotation String> t = null;\n          int a = (@MyAnnotation int) 2L;\n          @MyAnnotation\n          int b = 10;\n      }\n      public static <@MyAnnotation T> void method(T t) {\n      }\n      public static void test(@MyAnnotation String arg) throws @MyAnnotation Exception {\n      }\n  }\n  @Target(ElementType.TYPE_USE)\n  @interface MyAnnotation {\n  }\n  ```\n\n# 总结\n\n```java\n * 枚举类的使用\n *  1.自定义枚举类 JDK 1.5之间常用的\n *    步骤：\n *      ①：创建私有的常量属性：private final\n *      ②：创建私有的构造方法：private\n *      ③：创建公共的静态的常量状态量：public static final\n *      ④：其他诉求1：获取枚举类对象的属性。其他诉求2：提供toString方法。\n *\n *  2.enum关键字定义枚举类 JDK 1.5以后开始支持enum关键字\n *    步骤：\n *      o：当提供的枚举对象的要赋予参数时，需要有构造方法和属性；(当不需要设计属性时，这一步可以省略)\n *      ①：提供当前枚举类的对象，多个对象之间用逗号隔开，最后使用分号结束\n *     定义的枚举类默认继承于java.lang.Enum类，Enum类重写了toString()方法\n * 3.Enum类的使用\n *      values()：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。\n *      valueOf()：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。\n *          当转换不成功时会抛出异常：IllegalArgumentException\n *      toString()：返回当前枚举类对象常量的名称\n * 4.关于enum枚举类的实现接口的情况\n *     情况一：实现接口后，在enum类中实现方法即可。和class方法实现接口的的使用一样\n *     情况二：让枚举类的对象都实现接口中的方法。这样可以为每一个对象定制不同的实现方法。\n * 注解的使用\n *  自定义注解\n *      1.声明为 @interface。\n *      2.定义属性时，属性的样式：类型 属性名(); 属性名一般定义为value。\n *      3.当为属性设置默认值时，用default来定义，样式：类型 属性名() default 默认值；\n *      4.如果自定义注解没有成员，则表明这个注解是个标识。\n *      5.如果注解有成员且没有默认值时，则在使用注解时，需要指明成员的值。\n *      6.通常都会指定两个元注解Retention和Target\n *  4种元注解：\n *      元注解：对现有的注解进行解释说明的注解\n *          Retention:指定所修饰的注解的生命周期。默认为CLASS\n *          Target：指定被修饰的注解能用于修饰哪些程序元素。默认为全都能修饰\n *          Documented：表示被修饰的注解在转换成Javadoc时会被保留下来\n *          Inherited：被它修饰的注解将具有继承性。\n *              即假设Inherited修饰了注解A，父类被注解A修饰，则子类会自动被A修饰\n * JDK 8的注解的新特性：可重复注解，类型注解\n *  可重复注解\n *      当我们需要对一个元素赋予多个同一个注解A时，\n *          8之前的写法：创建一个注解B，这个注解B中用注解A的数组作为元素，然后为这个元素赋予注解B，且B的值取多个注解A。\n *          8之后的写法：在注解A上加一个元注解@Repeatable,这个元注解的值位注解B，然后再元素上就可以添加对各A注解了。\n *      注意注解A的Target，Retention等元注解和注解B的要相同\n *  类型注解\n```\n\n","categories":["Java学习","Java高级语法"]},{"title":"泛型","url":"/2020/12/07/尚硅谷说Java/Java高级语法/5-泛型/","content":"\n泛型，通配符，自定义泛型\n\n<!--more-->\n# 泛型的概念\n\n* 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。 \n\n* 从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念，允许我们在创建集合时再指定集合元素的类型，正如：List<String>，这表明该List只能保存字符串类型的对象。 \n\n* JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参\n\n* 那么为什么要有泛型呢，直接Object不是也可以存储数据吗？\n\n  * 解决元素存储的安全性问题，好比商品、药品标签，不会弄错。\n  * 解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184413.png)\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184414.png)\n\n* Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。\n\n```java\nArrayList list = new ArrayList();\n//需求：存放学生的成绩\nlist.add(12);\nlist.add(45);\nlist.add(65);\nlist.add(76);\n//问题一：类型不安全\n// list.add(\"tom\");\nfor (Object o : list) {\n    //问题二，强转时，可能出现类型转换异常：ClassCastException\n    int score = (Integer) o;\n    System.out.println(score);\n}\n```\n\n# 在集合中使用泛型\n\n```java\nArrayList<Integer> list = new ArrayList<Integer>();\nlist.add(12);\nlist.add(45);\nlist.add(67);\n//编译时，就会进行类型检查，保证数据的安全\n//list.add(\"asd\");\n//方式一\n//循环时避免了类型强转，可以直接指明类型\nfor (Integer integer : list) {\n    System.out.println(integer);\n}\nSystem.out.println(\"*************\");\n//方式二\nIterator<Integer> iterator = list.iterator();\nwhile (iterator.hasNext()){\n    System.out.println(iterator.next());\n}\n\n//标准写法\n//Map<String,Integer> map = new HashMap<String,Integer>();\n//JDK7 7新特性：类型推断\nMap<String,Integer> map = new HashMap<>();\nmap.put(\"asd\", 12);\nmap.put(\"qw\", 52);\nmap.put(\"zx\", 19);\nmap.put(\"fg\", 45);\n//编译报错\n//map.put(123, 45);\n//泛型的嵌套\nSet<Map.Entry<String, Integer>> entries = map.entrySet();\nIterator<Map.Entry<String, Integer>> iterator = entries.iterator();\nwhile (iterator.hasNext()) {\n    Map.Entry<String, Integer> next = iterator.next();\n    String key = next.getKey();\n    Integer value = next.getValue();\n    System.out.println(key + \" : \" + value);\n}\n```\n\n# 自定义泛型\n\n* 泛型的声明\n\n  * interface List<T> 和 class GenTest<K,V> \n  * 其中，T,K,V不代表值，而是表示类型。这里使用任意字母都可以。\n  * 常用T表示，是Type的缩写。\n\n* 泛型的实例化：\n\n  * 一定要在类名后面指定类型参数的值（类型）。如：\n    * List<String> strList = new ArrayList<String>();\n    * Iterator<Customer> iterator = customers.iterator();\n  * T只能是类，不能用基本数据类型填充。但可以使用包装类填充\n  * 把一个集合中的内容限制为一个特定的数据类型，这就是generics背后的核心思想\n  * 使用泛型的主要优点是能够在编译时而不是在运行时检测错误。\n\n* 使用泛型的细节规则\n\n  * 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：<E1,E2,E3>\n  * 泛型类的构造器如下：public GenericClass(){}。而下面是错误的：public GenericClass<E>(){}\n  * 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。\n  * 泛型不同的引用不能相互赋值。\n    * 尽管在编译时ArrayList<String>和ArrayList<Integer>是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。\n  * 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。\n    * 经验：泛型要使用一路都用。要不用，一路都不要用。\n  * 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。\n  * jdk1.7后，泛型的简化操作：ArrayList<Fruit> flist = new ArrayList<>();\n  * 泛型的指定中不能使用基本数据类型，可以使用包装类替换\n\n  ```java\n  class GenericTest {\n      public static void main(String[] args) {\n          // 1、使用时：类似于Object，不等同于Object\n          ArrayList list = new ArrayList();\n          // list.add(new Date());//有风险\n          list.add(\"hello\");\n          test(list);// 泛型擦除，编译不会类型检查\n          // ArrayList<Object> list2 = new ArrayList<Object>();\n          // test(list2);//一旦指定Object，编译会类型检查，必须按照Object处理\n      }\n      public static void test(ArrayList<String> list) {\n          String str = \"\";\n          for (String s : list) {\n              str += s + \",\"; }\n          System.out.println(\"元素:\" + str);\n      } \n  }\n  ```\n\n  * 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。\n  * 异常类不能是泛型的\n\n  ```java\n  //静态方法中不能使用类的泛型。 编译不通过\n  //    public static void show(T orderT){\n  //        System.out.println(orderT);\n  //    }\n  public  void show(){\n  //异常类不能有泛型 。编译不通过\n  //            try {\n  //\n  //            }catch (T e){\n  //\n  //            }\n  }\n  ```\n\n  * 不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity];\n\n    * 参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。\n\n  * 父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：\n\n    * 子类不保留父类的泛型：按需实现\n      * 没有类型 擦除\n      * 具体类型\n    * 子类保留父类的泛型：泛型子类\n      * 全部保留\n      * 部分保留\n\n    ```java\n    class Father<T1, T2> {\n    }\n    // 子类不保留父类的泛型\n    // 1)没有类型 擦除\n    class Son1 extends Father {// 等价于class Son extends Father<Object,Object>{\n    }\n    // 2)具体类型\n    class Son2 extends Father<Integer, String> {\n    }\n    // 子类保留父类的泛型\n    // 1)全部保留\n    class Son3<T1, T2> extends Father<T1, T2> {\n    }\n    // 2)部分保留\n    class Son4<T2> extends Father<Integer, T2> {\n    }\n    \n    class Father<T1, T2> {\n    }\n    // 子类不保留父类的泛型\n    // 1)没有类型 擦除\n    class Son<A, B> extends Father{//等价于class Son extends Father<Object,Object>{\n    }\n    // 2)具体类型\n    class Son2<A, B> extends Father<Integer, String> {\n    }\n    // 子类保留父类的泛型\n    // 1)全部保留\n    class Son3<T1, T2, A, B> extends Father<T1, T2> {\n    }\n    // 2)部分保留\n    class Son4<T2, A, B> extends Father<Integer, T2> {\n    }\n    ```\n\n    * 结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型\n\n```java\npublic class Order<T> {\n    String orderName;\n    int orderId;\n    //类的内部结构可以使用类的泛型\n    T orderT;\n\n    public Order() {\n        //编译不通过\n        //T[] arr = new T[10];\n        //正确写法\n        T[] arr = (T[]) new Object[10];\n    }\n\n    public Order(String orderName, int orderId, T orderT) {\n        this.orderName = orderName;\n        this.orderId = orderId;\n        this.orderT = orderT;\n    }\n\n    public String getOrderName() {\n        return orderName;\n    }\n\n    public void setOrderName(String orderName) {\n        this.orderName = orderName;\n    }\n\n    public int getOrderId() {\n        return orderId;\n    }\n\n    public void setOrderId(int orderId) {\n        this.orderId = orderId;\n    }\n    //如下的方法都不是泛型方法\n    public T getOrderT() {\n        return orderT;\n    }\n\n    public void setOrderT(T orderT) {\n        this.orderT = orderT;\n    }\n\n    @Override\n    public String toString() {\n        return \"Order{\" +\n            \"orderName='\" + orderName + '\\'' +\n            \", orderId=\" + orderId +\n            \", orderT=\" + orderT +\n            '}';\n    }\n}\n\n//如果定义了泛型类，实例化时没有指明类的泛型，则认为此泛型类型为Object类型\n//要求：如果定义了类是带泛型的，建议在实例化时要指明类的泛型。\nOrder order = new Order();\norder.setOrderT(123);\norder.setOrderT(\"asd\");\n//建议实例化时指明类的泛型\nOrder<String> order1 = new Order<>(\"asd\",10,\"orderASD\");\n//编译出错\n//order1.setOrderT(123);\norder1.setOrderT(\"asda\");\n\nSubOrder subOrder = new SubOrder();\n//由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不需要再指明泛型\nsubOrder.setOrderT(123);\nSubOrder<String> subOrder1 = new SubOrder<>();\nsubOrder1.setOrderT(\"asda...\");\n\n```\n\n## 泛型方法\n\n* 方法，也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型\n  方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。 \n*  泛型方法的格式：\n  * [访问权限] <泛型> 返回类型 方法名([泛型标识 参数名称]) 抛出的异常\n* 泛型方法声明泛型时也可以指定上限\n\n```java\n//泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系\n//即：泛型方法所属的类是不是泛型类都没有关系\n//泛型方法可以声明为静态的，原因：泛型参数是在调用时确定的，不是在实例化时确定的。\npublic <E> List<E> copyFromArrayToList(E[] arr){\n    ArrayList<E> list = new ArrayList<>();\n    for (E e : arr) {\n        list.add(e);\n    }\n    return list;\n}\n/////////////////////////////\nOrder<String> order = new Order<>();\nInteger[] arr = new Integer[]{1,2,3,4};\nList<Integer> integers = order.copyFromArrayToList(arr);\nSystem.out.println(integers);\n```\n\n# 泛型在继承上的体现\n\n* 如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，G<B>并不是G<A>的子类型！\n* 比如：String是Object的子类，但是List<String >并不是List<Object>的子类。\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184415.png)\n\n```java\npublic void testGenericAndSubClass() {\n    Person[] persons = null;\n    Man[] mans = null;\n    // 而 Person[] 是 Man[] 的父类.\n    persons = mans;\n    Person p = mans[0];\n    // 在泛型的集合上\n    List<Person> personList = null;\n    List<Man> manList = null;\n    // personList = manList;(报错) \n}\n```\n\n# 通配符的使用\n\n* 使用类型通配符：？\n  * 比如：List<?> ，Map<?,?>\n  * List<?>是List<String>、List<Object>等各种泛型List的父类。\n* 读取List<?>的对象list中的元素时，永远是安全的，因为不管list的真实类型是什么，它包含的都是Object。\n* 写入list中的元素时，不行。因为我们不知道c的元素类型，我们不能向其中添加对象。\n  * 唯一的例外是null，它是所有类型的成员\n* 将任意元素加入到其中不是类型安全的：\n  * Collection<?> c = new ArrayList<String>();\n  * c.add(new Object()); // 编译时错误\n  * 因为我们不知道c的元素类型，我们不能向其中添加对象。add方法有类型参数E作为集合的元素类型。我们传给add的任何参数都必须是一个未知类型的子类。因为我们不知道那是什么类型，所以我们无法传任何东西进去。\n* 另一方面，我们可以调用get()方法并使用其返回值。返回值是一个未知的类型，但是我们知道，它总是一个Object。\n\n```java\nList<String> list1 = null;\nList<Integer> list2 = null;\nList<?> list = null;\n//list = list1;\n//list = list2;\n//show(list1);\n//show(list2);\n\nList<String> list3 = new ArrayList<>();\nlist3.add(\"aa\");\nlist3.add(\"bb\");\nlist3.add(\"cc\");\nlist = list3;\n//添加(写入)。对于List<?>就不能想起内部添加数据\n//除了添加null之外\n//编译不通过\n//list.add(\"aa\");\n//list.add(12);\n\nlist.add(null);\n\n//获取(读取)：允许读取数据。读取的数据类型为Object\nObject o = list.get(2);\nSystem.out.println(o);\n///////////////////////////////////////////\npublic void show(List<?> list){\n    Iterator<?> iterator = list.iterator();\n    while (iterator.hasNext()) {\n        System.out.println(iterator.next());\n    }\n}\n```\n\n* 注意点：\n  * 不能用在泛型方法声明上，返回值类型前面<>不能使用?\n  * 不能用在泛型类的声明上\n  * 不能用在创建对象上，\n\n```java\n//注意点1：编译错误：不能用在泛型方法声明上，返回值类型前面<>不能使用?\npublic static <?> void test(ArrayList<?> list){\n}\n//注意点2：编译错误：不能用在泛型类的声明上\nclass GenericTypeClass<?>{\n}\n//注意点3：编译错误：不能用在创建对象上，右边属于创建集合对象\nArrayList<?> list2 = new ArrayList<?>();\n```\n\n* 有限制的通配符\n\n  * <?>允许所有泛型的引用调用\n  * 通配符指定上限\n    * 上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即<= \n  * 通配符指定下限\n    * 下限super：使用时指定的类型不能小于操作的类，即>=\n  * 举例： \n  * <? extends Number> (无穷小 , Number]\n    * 只允许泛型为Number及Number子类的引用调用\n  * <? super Number> [Number , 无穷大) \n    * 只允许泛型为Number及Number父类的引用调用\n  * <? extends Comparable>\n    * 只允许泛型为实现Comparable接口的实现类的引用调用\n\n  ```java\n  List<? extends Person> list1 = null;\n  List<? super Person> list2 = null;\n  List<Student> list3 = new ArrayList<>();\n  List<Person> list4 = new ArrayList<>();\n  List<Object> list5 = new ArrayList<>();\n  \n  list1 = list3;\n  list1 = list4;\n  //list1 = list5;\n  //list2 = list3;\n  list2 = list4;\n  list2 = list5;\n  \n  //读取数据：\n  list1 = list3;\n  Person person = list1.get(0);\n  //编译不通过\n  //Student student = list1.get(0);\n  list2 = list4;\n  Object object = list2.get(0);\n  //编译不通过\n  //Person person1 = list2.get(0);\n  \n  //写入数据\n  //编译不通过\n  //list1.add(new Student());\n  //list1.add(new Object());\n  //list2.add(new Object());\n  //编译通过\n  list2.add(new Person());\n  list2.add(new Student());\n  ```\n\n# 总结\n\n```java\n * 泛型的使用\n *  1.JDK 5新增的特性\n *  2.泛型不能是基本数据类型，但是可以是它们的包装类\n *  3.在集合中使用泛型\n *      ① 集合接口或集合类在JDK5时都修改为带泛型的结构\n *      ② 在实例化集合类时，可以指明那个具体的泛型类型\n *      ③ 指明完后。在集合类或接口中凡是定义类或接口时，内部结构(比如方法，构造器，属性)使用到类的泛型的位置，\n *      都指定为实例化的泛型类型。比如：add(E e) -->实例化后 add(Integer e)\n *      ④如果实例化时，没有指明泛型的类型。默认类型为java.lang.Object类型\n *  4.泛型的使用细节\n *      >泛型可以有多个参数。例如<T,E,K>。\n *      >泛型不同的引用不能相互赋值。\n *      >静态方法中不能使用类的泛型。\n *      >异常类不能有泛型\n *      >不能使用new T[]\n *  5.泛型再继承方面的体现\n *      类A是类B的父类，G<A>和G<B>二者不具备父子关系，二者是并列关系，\n *      补充：类A是类B的父类，A<G>是B<G>的父类\n *  6.通配符的使用\n *      通配符：?\n *      类A是类B的父类，G<A>和G<B>是没有关系的，二者共同的父类是：G<?>\n```\n\n","categories":["Java学习","Java高级语法"]},{"title":"网络编程","url":"/2020/12/07/尚硅谷说Java/Java高级语法/7-网络编程/","content":"\nJava的TCP网络通信和UDP网络通信\n\n<!--more-->\n# 网络编程概述\n\n* Java是 Internet 上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序。\n* Java提供的网络类库，可以实现无痛的网络连接，联网的底层细节被隐藏在 Java 的本机安装系统里，由 JVM 进行控制。并且 Java 实现了一个跨平台的网络库，程序员面对的是一个统一的网络编程环境\n\n## 网络基础\n\n* 计算机网络：\n  * 把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源。\n* 网络编程的目的：\n  * 直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。\n* 网络编程中有两个主要的问题：\n  * 如何准确地定位网络上一台或多台主机；定位主机上的特定的应用\n  * 找到主机后如何可靠高效地进行数据传输\n\n# 网络通信要素概述\n\n* 通信双方地址\n\n  * IP\n  * 端口号\n\n* 一定的规则（即：网络通信协议。有两套参考模型）\n\n  * OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广\n  * TCP/IP参考模型(或TCP/IP协议)：事实上的国际标准\n\n* 网络通信协议\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184428.png)\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184429.png)\n\n# 通信要素一：IP和端口号\n\n* IP 地址：InetAddress\n  * 唯一的标识 Internet 上的计算机（通信实体）\n  * 本地回环地址(hostAddress)：127.0.0.1 主机名(hostName)：localhost\n  * IP地址分类方式1：IPV4 和 IPV6\n    * IPV4：4个字节组成，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已经用尽。以点分十进制表示，如192.168.0.1\n    * IPV6：128位（16个字节），写成8个无符号整数，每个整数用四个十六进制位表示，数之间用冒号（：）分开，如：3ffe:3201:1401:1280:c8ff:fe4d:db39:1984\n  * IP地址分类方式2：公网地址(万维网使用)和私有地址(局域网使用)。192.168.开头的就是私有址址，范围即为192.168.0.0--192.168.255.255，专门为组织机构内部使用\n  * 特点：不易记忆\n* 端口号标识正在计算机上运行的进程（程序）\n  * 不同的进程有不同的端口号\n  * 被规定为一个 16 位的整数 0~65535。  \n  * 端口分类：\n    * 公认端口：0~1023。被预先定义的服务通信占用（如：HTTP占用端口80，FTP占用端口21，Telnet占用端口23） \n    * 注册端口：1024~49151。分配给用户进程或应用程序。（如：Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）。 \n    * 动态/私有端口：49152~65535。 \n* 端口号与IP地址的组合得出一个网络套接字：Socket。\n\n## InetAddress类 \n\n* Internet上的主机有两种方式表示地址：\n  * 域名(hostName)：www.atguigu.com\n  * IP 地址(hostAddress)：202.108.35.210\n* InetAddress类主要表示IP地址，两个子类：Inet4Address、Inet6Address。 \n* InetAddress 类 对 象 含 有 一 个 Internet 主 机 地 址 的 域 名 和 IP 地 址 ：www.atguigu.com 和 202.108.35.210。 \n* 域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS)负责将域名转化成IP地址，这样才能和主机建立连接。 -------域名解析\n* InetAddress类没有提供公共的构造器，而是提供了如下几个静态方法来获取\n  InetAddress实例\n  * public static InetAddress getLocalHost()\n  * public static InetAddress getByName(String host)\n* InetAddress提供了如下几个常用的方法\n  * public String getHostAddress()：返回 IP 地址字符串（以文本表现形式）。 \n  * public String getHostName()：获取此 IP 地址的主机名\n  * public boolean isReachable(int timeout)：测试是否可以达到该地址\n\n```java\ntry {\n    //根据ip实例化InetAddress\n    InetAddress address1 = InetAddress.getByName(\"8.8.8.8\");\n    System.out.println(address1);\n    //根据域名实例化InetAddress\n    InetAddress address2 = InetAddress.getByName(\"www.baudu.com\");\n    System.out.println(address2);\n    //实例化本地InetAddress\n    InetAddress address3 = InetAddress.getByName(\"127.0.0.1\");\n    System.out.println(address3);\n    //实例化本地InetAddress\n    InetAddress address4 = InetAddress.getLocalHost();\n    System.out.println(address4);\n    //getHostName()：获取域名\n    System.out.println(address1.getHostName());\n    //getHostAddress()：获取IP\n    System.out.println(address1.getHostAddress());\n\n\n} catch (UnknownHostException e) {\n    e.printStackTrace();\n}\n```\n\n# 通信要素二：网络协议\n\n* 网络通信协议：计算机网络中实现通信必须有一些约定，即通信协议，对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准。 \n\n* 问题：网络协议太复杂\n\n* 计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩解压缩，差错控制，流量控制，路由控制，如何实现如此复杂的网络协议呢？ \n\n* 通信协议分层的思想\n\n* 在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展。\n\n* 传输层协议中有两个非常重要的协议：\n\n* 传输控制协议TCP(Transmission Control Protocol)\n\n* 用户数据报协议UDP(User Datagram Protocol)。 \n\n* TCP/IP 以其两个主要协议：传输控制协议(TCP)和网络互联协议(IP)而得名，实际上是一组协议，包括多个具有不同功能且互为关联的协议。\n\n* IP(Internet Protocol)协议是网络层的主要协议，支持网间互连的数据通信。\n\n* TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即物理链路层、IP层、传输层和应用层。\n\n* TCP协议：\n\n  * 使用TCP协议前，须先建立TCP连接，形成传输数据通道\n  * 传输前，采用“三次握手”方式，点对点通信，是可靠的\n  * TCP协议进行通信的两个应用进程：客户端、服务端。\n  * 在连接中可进行大数据量的传输\n  * 传输完毕，需释放已建立的连接，效率低\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184430.png)\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184431.png)\n\n* UDP协议：\n\n  * 将数据、源、目的封装成数据包，不需要建立连接\n  * 每个数据报的大小限制在64K内 \n  * 发送不管对方是否准备好，接收方收到也不确认，故是不可靠的 \n  * 可以广播发送\n  * 发送数据结束时无需释放资源，开销小，速度快\n\n## Socket\n\n* 利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。 \n\n* 网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。 \n\n* 通信的两端都要有Socket，是两台机器间通信的端点。 \n\n* 网络通信其实就是Socket间的通信。\n\n* Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。\n\n* 一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。\n\n* Socket分类：\n\n  * 流套接字（stream socket）：使用TCP提供可依赖的字节流服务\n  * 数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务\n\n* Socket类的常用构造器：\n\n  |                    方法                     |                          作用                          |\n  | :-----------------------------------------: | :----------------------------------------------------: |\n  | public Socket(InetAddress address,int port) | 创建一个流套接字并将其连接到指定 IP 地址的指定端口号。 |\n  |     public Socket(String host,int port)     |  创建一个流套接字并将其连接到指定主机上的指定端口号。  |\n\n* Socket类的常用方法：\n\n  |                 方法                  |                             作用                             |\n  | :-----------------------------------: | :----------------------------------------------------------: |\n  |  public InputStream getInputStream()  |          返回此套接字的输入流。可以用于接收网络消息          |\n  | public OutputStream getOutputStream() |          返回此套接字的输出流。可以用于发送网络消息          |\n  |  public InetAddress getInetAddress()  | 此套接字连接到的远程 IP 地址；如果套接字是未连接的，则返回 null。 |\n  | public InetAddress getLocalAddress()  |         获取套接字绑定的本地地址。 即本端的IP地址。          |\n  |         public int getPort()          |  此套接字连接到的远程端口号；如果尚未连接套接字，则返回 0。  |\n  |       public int getLocalPort()       | 返回此套接字绑定到的本地端口。 如果尚未绑定套接字，则返回 -1。即本端的端口号。 |\n  |          public void close()          | 关闭此套接字。套接字被关闭后，便不可在以后的网络连接中使用（即无法重新连接或重新绑定）。需要创建新的套接字对象。 关闭此套接字也将会关闭该套接字的 InputStream 和OutputStream。 |\n  |      public void shutdownInput()      | 如果在套接字上调用 shutdownInput() 后从套接字输入流读取内容，则流将返回 EOF（文件结束符）。 即不能在从此套接字的输入流中接收任何数据。 |\n  |     public void shutdownOutput()      | 禁用此套接字的输出流。对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 如果在套接字上调用 shutdownOutput() 后写入套接字输出流，则该流将抛出 IOException。 即不能通过此套接字的输出流发送任何数据。 |\n\n# TCP网络编程\n\n* 基于Socket的TCP编程\n\n  * Java语言的基于套接字编程分为服务端编程和客户端编程，其通信模型如图所示：\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184432.png)\n\n* 客户端Socket的工作过程包含以下四个基本的步骤： \n\n  * 创建 Socket：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。\n  * 打开连接到 Socket 的输入/出流： 使用 getInputStream()方法获得输入流，使用getOutputStream()方法获得输出流，进行数据传输\n  * 按照一定的协议对 Socket 进行读/写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线程。\n  * 关闭 Socket：断开客户端到服务器的连接，释放线路\n\n* 客户端创建Socket对象\n\n  * 客户端程序可以使用Socket类创建对象，创建的同时会自动向服务器方发起连接。Socket的构造器是： \n    * Socket(String host,int port)throws UnknownHostException,IOException：向服务器(域名是host。端口号为port)发起TCP连接，若成功，则创建Socket对象，否则抛出异常。\n    * Socket(InetAddress address,int port)throws IOException：根据InetAddress对象所表示的IP地址以及端口号port发起连接。\n\n  * 客户端建立socketAtClient对象的过程就是向服务器发出套接字连接请求\n\n  ```java\n  Socket socket = null;\n  OutputStream stream = null;\n  try {\n      //1.指明IP地址\n      InetAddress ia = InetAddress.getByName(\"127.0.0.1\");\n      //2.指明端口号，创建客服端套接字\n      socket = new Socket(ia,8899);\n      //3.写入数据\n      stream = socket.getOutputStream();\n      stream.write(\"你好，我是客户端\".getBytes());\n  } catch (IOException e) {\n      e.printStackTrace();\n  } finally {\n      //4.关闭资源\n      if (stream != null){\n          try {\n              stream.close();\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n      if (socket != null){\n          try {\n              socket.close();\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n  }\n  ```\n\n* 服务器程序的工作过程包含以下四个基本的步骤：\n\n  * 调用 ServerSocket(int port) ：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。\n  * 调用 accept()：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。 \n  * 调用 该Socket类对象的 getOutputStream() 和 getInputStream ()：获取输出流和输入流，开始网络数据的发送和接收。\n  * 关闭ServerSocket和Socket对象：客户端访问结束，关闭通信套接字。\n\n* 服务器建立 ServerSocket 对象\n\n  * ServerSocket 对象负责等待客户端请求建立套接字连接，类似邮局某个窗口中的业务员。也就是说，服务器必须事先建立一个等待客户请求建立套接字连接的ServerSocket对象。\n  * 所谓“接收”客户的套接字请求，就是accept()方法会返回一个 Socket 对象\n\n  ```java\n  ServerSocket ss = null;\n  Socket socket = null;\n  InputStream inputStream = null;\n  ByteArrayOutputStream baos = null;\n  try {\n      //实例化服务器接口\n      ss = new ServerSocket(8899);\n      //2.创建套接字\n      socket = ss.accept();\n      //3.获取输入流\n      inputStream = socket.getInputStream();\n      //4.使用ByteArrayOutputStream接受数据。防止乱码\n      baos = new ByteArrayOutputStream();\n      byte[] bytes = new byte[1024];\n      int len;\n      while ((len = inputStream.read(bytes)) != -1){\n          //将bytes数组中的数据写入ByteArrayOutputStream类中的数组中\n          baos.write(bytes,0,len);\n      }\n      System.out.println(baos.toString());\n  } catch (IOException e) {\n      e.printStackTrace();\n  } finally {\n      //5.关闭流等\n      if (baos != null){\n          try {\n              baos.close();\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n      if (inputStream != null){\n          try {\n              inputStream.close();\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n      if (socket != null){\n          try {\n              socket.close();\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n      if (ss != null){\n          try {\n              ss.close();\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n  }\n  ```\n\n* 补充\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184433.png)\n\n# UDP网络编程\n\n* 类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。\n\n* UDP数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。\n\n* DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。\n\n* UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。如同发快递包裹一样。\n\n* DatagramSocket 类的常用方法\n\n  |                       方法                        |                             作用                             |\n  | :-----------------------------------------------: | :----------------------------------------------------------: |\n  |          public DatagramSocket(int port)          | 创建数据报套接字并将其绑定到本地主机上的指定端口。套接字将被绑定到通配符地址，IP 地址由内核来选择。 |\n  | public DatagramSocket(int port,InetAddress laddr) | 创建数据报套接字，将其绑定到指定的本地地址。本地端口必须在 0 到 65535 之间（包括两者）。如果 IP 地址为 0.0.0.0，套接字将被绑定到通配符地址，IP 地址由内核选择。 |\n  |                public void close()                |                     关闭此数据报套接字。                     |\n  |        public void send(DatagramPacket p)         | 从此套接字发送数据报包。DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号。 |\n  |       public void receive(DatagramPacket p)       | 从此套接字接收数据报包。当此方法返回时，DatagramPacket的缓冲区填充了接收的数据。数据报包也包含发送方的 IP 地址和发送方机器上的端口号。 此方法在接收到数据报前一直阻塞。数据报包对象的 length 字段包含所接收信息的长度。如果信息比包的长度长，该信息将被截短。 |\n  |       public InetAddress getLocalAddress()        |                  获取套接字绑定的本地地址。                  |\n  |             public int getLocalPort()             |            返回此套接字绑定的本地主机上的端口号。            |\n  |        public InetAddress getInetAddress()        |   返回此套接字连接的地址。如果套接字未连接，则返回 null。    |\n  |               public int getPort()                |      返回此套接字的端口。如果套接字未连接，则返回 -1。       |\n\n* DatagramPacket类的常用方法\n\n  |                             方法                             |                             作用                             |\n  | :----------------------------------------------------------: | :----------------------------------------------------------: |\n  |         public DatagramPacket(byte[] buf,int length)         | 构造 DatagramPacket，用来接收长度为 length 的数据包。 length 参数必须小于等于 buf.length。 |\n  | public DatagramPacket(byte[] buf,int length,InetAddress address,int port) | 构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。length参数必须小于等于 buf.length。 |\n  |               public InetAddress getAddress()                | 返回某台机器的 IP 地址，此数据报将要发往该机器或者是从该机器接收到的。 |\n  |                     public int getPort()                     | 返回某台远程主机的端口号，此数据报将要发往该主机或者是从该主机接收到的。 |\n  |                   public byte[] getData()                    | 返回数据缓冲区。接收到的或将要发送的数据从缓冲区中的偏移量 offset 处开始，持续 length 长度。 |\n  |                    public int getLength()                    |              返回将要发送或接收到的数据的长度。              |\n\n* UDP网络编程流 程：\n\n  * DatagramSocket与DatagramPacket\n  * 建立发送端，接收端\n  * 建立数据包\n  * 调用Socket的发送、接收方法\n  * 关闭Socket\n\n* 发送端与接收端是两个独立的运行程序\n\n* 发送端\n\n```java\nDatagramSocket da = null;\ntry {\n    //1.创建传送通道\n    da = new DatagramSocket();\n\n    //2.将要发送的信息放到包中\n    String string = \"通知明天上课\";\n    byte[] bytes = string.getBytes();\n    InetAddress ia = InetAddress.getLocalHost();\n    DatagramPacket dp = new DatagramPacket(bytes,0,bytes.length,ia,8899 );\n    //3.发送包\n    da.send(dp);\n} catch (SocketException e) {\n    e.printStackTrace();\n} catch (UnknownHostException e) {\n    e.printStackTrace();\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    //4.关闭通道\n    if (da != null){\n        da.close();\n    }\n}\n```\n\n* 接收端\n\n```java\nDatagramSocket ds = null;\ntry {\n    //1.创建通道\n    ds = new DatagramSocket(8899);\n    byte[] bytes = new byte[1024];\n    //2.创建接受信息用的包\n    DatagramPacket dp = new DatagramPacket(bytes,0,bytes.length);\n    //3.接受信息\n    ds.receive(dp);\n    //getData()：获取包中的数据\n    //getLength()：获取包中数据的长度\n    System.out.println(new String(dp.getData(),0,dp.getLength()));\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    //4.关闭通道\n    if (ds != null){\n        ds.close();\n    }\n}\n```\n\n# URL编程\n\n* URL(Uniform Resource Locator)：统一资源定位符，它表示 Internet 上某一资源的地址。 \n\n* 它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。\n\n* 通过 URL 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp 站点。浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源。\n\n* URL的基本结构由5部分组成： <传输协议>://<主机名>:<端口号>/<文件名>#片段名?参数列表\n\n  * 例如: http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&password=123\n  * #片段名：即锚点，例如看小说，直接定位到章节\n  * 参数列表格式：参数名=参数值&参数名=参数值....\n\n* 为了表示URL，java.net 中实现了类 URL。我们可以通过下面的构造器来初始化一个 URL 对象：\n\n  * public URL (String spec)：通过一个表示URL地址的字符串可以构造一个URL对象。\n    * 例如：URL url = new URL (\"http://www. atguigu.com/\"); \n  * public URL(URL context, String spec)：通过基 URL 和相对 URL 构造一个 URL 对象。\n    * 例如：URL downloadUrl = new URL(url, “download.html\")\n  * public URL(String protocol, String host, String file);\n    * 例如：new URL(\"http\", \"www.atguigu.com\", “download. html\");\n  * public URL(String protocol, String host, int port, String file); \n    * 例如: URL gamelan = new URL(\"http\", \"www.atguigu.com\", 80, “download.html\");\n\n* URL类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通常是用 try-catch 语句进行捕获\n\n* 一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的方法来获取这些属性：\n\n  |             方法             |        作用         |\n  | :--------------------------: | :-----------------: |\n  | public String getProtocol( ) |  获取该URL的协议名  |\n  |   public String getHost( )   |  获取该URL的主机名  |\n  |   public String getPort( )   |  获取该URL的端口号  |\n  |   public String getPath( )   | 获取该URL的文件路径 |\n  |   public String getFile( )   |  获取该URL的文件名  |\n  |  public String getQuery( )   |  获取该URL的查询名  |\n\n```JAVA\nHttpURLConnection urlConnection = null;\nInputStream is = null;\nBufferedOutputStream bos = null;\ntry {\n    URL url = new URL(\"https://xigua-cdn.haima-zuida.com/20201030/16376_77e9ec0c/1000k/hls/index.m3u8\");\n    //获取协议名\n    System.out.println(url.getProtocol());\n    //获取主机名\n    System.out.println(url.getHost());\n    //获取端口号\n    System.out.println(url.getPath());\n    //获取文件路径\n    System.out.println(url.getPath());\n    //获取文件名\n    System.out.println(url.getFile());\n    //获取查询名\n    System.out.println(url.getQuery());\n\n    //获取资源的连接\n    urlConnection = (HttpURLConnection) url.openConnection();\n    urlConnection.connect();\n    is = urlConnection.getInputStream();\n    bos = new BufferedOutputStream(new FileOutputStream(\"F:\\\\void.ts\"));\n    byte[] bytes = new byte[1024];\n    int len;\n    while ((len = is.read(bytes)) != -1){\n        bos.write(bytes,0,len);\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (bos != null){\n        try {\n            bos.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    if (is != null){\n        try {\n            is.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    if (urlConnection != null){\n        urlConnection.disconnect();\n    }\n}\n```\n\n## URLConnection类\n\n* 针对HTTP协议的URLConnection类 \n\n* URL的方法 openStream()：能从网络上读取数据\n\n* 若希望输出数据，例如向服务器端的 CGI （公共网关接口-Common Gateway Interface-的简称，是用户浏览器和服务器端的应用程序进行连接的接口）程序发送一些数据，则必须先与URL建立连接，然后才能对其进行读写，此时需要使用URLConnection 。 \n\n* URLConnection：表示到URL所引用的远程对象的连接。当与一个URL建立连接时，首先要在一个 URL 对象上通过方法 openConnection() 生成对应的 URLConnection对象。如果连接过程失败，将产生IOException. \n\n  * URL netchinaren = new URL (\"http://www.atguigu.com/index.shtml\"); \n  * URLConnectonn u = netchinaren.openConnection( );\n\n* 通过URLConnection对象获取的输入流和输出流，即可以与现有的CGI程序进行交互。\n\n  |                           方法                           |               作用               |\n  | :------------------------------------------------------: | :------------------------------: |\n  |      public Object getContent( ) throws IOException      |      检索此URL连接的内容。       |\n  |              public int getContentLength( )              | 返回content-length标题字段的值。 |\n  |             public String getContentType( )              | 返回 content-type标题字段的值。  |\n  |                  public long getDate( )                  |     返回 date标题字段的值。      |\n  |              public long getLastModified( )              | 返回 last-modified标题字段的值。 |\n  |  public InputStream getInputStream( )throws IOException  | 返回从此打开的连接读取的输入流。 |\n  | public OutputSteram getOutputStream( )throws IOException |     返回写入此连接的输出流。     |\n\n* URI、URL和URN的区别\n\n  * URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。\n  * URL是uniform resource locator，统一资源定位符，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。\n  * URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。\n  * 而也就是说，URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。\n  * URL和URN都是一种URI。 \n  * 在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184434.png)\n\n# 总结\n\n* 位于网络中的计算机具有唯一的IP地址，这样不同的主机可以互相区分。\n* 客户端－服务器是一种最常见的网络应用程序模型。服务器是一个为其客户端提供某种特定服务的硬件或软件。客户机是一个用户应用程序，用于访问某台服务器提供的服务。端口号是对一个服务的访问场所，它用于区分同一物理计算机上的多个服务。套接字用于连接客户端和服务器，客户端和服务器之间的每个通信会话使用一个不同的套接字。TCP协议用于实现面向连接的会话。\n* Java 中有关网络方面的功能都定义在 java.net 程序包中。Java 用 InetAddress 对象表示 IP 地址，该对象里有两个字段：主机名(String) 和 IP 地址(int)。 \n* 类 Socket 和 ServerSocket 实现了基于TCP协议的客户端－服务器程序。Socket是客户端和服务器之间的一个连接，连接创建的细节被隐藏了。这个连接提供了一个安全的数据传输通道，这是因为 TCP 协议可以解决数据在传送过程中的丢失、损坏、重复、乱序以及网络拥挤等问题，它保证数据可靠的传送。\n* 类 URL 和 URLConnection 提供了最高级网络应用。URL 的网络资源的位置来同一表示Internet 上各种网络资源。通过URL对象可以创建当前应用程序和 URL 表示的网络资源之间的连接，这样当前程序就可以读取网络资源数据，或者把自己的数据传送到网络上去。\n\n```java\n * 网络编程\n *  一，通信的要素一：IP和端口号\n *      1.IP：唯一的标识Internet上的计算机(通信实体)\n *      2.在Java中使用InetAddress类代表IP\n *      3.IP分类：IPv4 / IPv6 ;万维网和局域网。\n *      4.域名：www.baidu.com\n *      5.本地回路地址：127.0.0.1 对应域名：localhost\n *      6.如何实例化InetAddress：两个方法：getByName(String host),getLocalHost()\n *          两个常用方法：getHostName()/getHostAddress()\n *      7.端口号：正在计算机上运行的进程。\n *          要求：不同的进程有不同的端口号\n *          范围：被规定为一个16位的整数 0~65535\n *      8.端口号与IP地址的组合得出一个网络套接字：Socket\n *          shutdownOutput()：关闭数据传输\n *      9.服务器的套接字：ServerSocket类\n *          accept():将服务器连接上其他客户端套接字\n *      10.TCP传输协议使用ServerSocket类和Socket类\n *         UDP传输协议使用DatagramSocket类和DatagramPacket类\n *      11.DatagramSocket类\n *          send(DatagramPacket )：发送包\n *          receive(DatagramPacket )：接受包\n *      12.DatagramPacket类\n *          getData()：获取包中的数据\n *          getLength()：获取包中数据的长度\n *  二，URL编程\n *      1.URL：统一资源定位符，对应着互联网的某一资源地址\n *      2.格式：\n *          https://xigua-cdn.haima-zuida.com/20201030/16376_77e9ec0c/1000k/hls/index.m3u8\n *          协议      主机名             端口号     资源地址                        参数列表\n```\n\n","categories":["Java学习","Java高级语法"]},{"title":"HTMI学习","url":"/2020/12/07/尚硅谷说Java/前端/HTML/","content":"HTMI学习\n<!--more-->\n# 1.B/S软件的结构\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210434.png)\n\n# 2.前端的开发流程\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210435.png)\n\n# 3.网页的组成成分\n\n页面由三部分内容组成！ \n\n分别是内容（结构）、表现、行为。\n\n* 内容（结构），是我们在页面中可以看到的数据。我们称之为内容。一般内容 我们使用 html 技术来展示\n* 表现，指的是这些内容在页面上的展示形式。比如说。布局，颜色，大小等等。一般使用 CSS 技术实现\n* 行为，指的是页面中元素与输入设备交互的响应。一般使用 javascript 技术实现。\n\n# 4.HTML简介\n\nHyper Text Markup Language （超文本标记语言） 简写：HTML \n\nHTML 通过标签来标记要显示的网页中的各个部分。网页文件本身是一种文本文件， 通过在文本文件中添加标记符，可以告诉浏览器如何显示其中的内容（如：文字如何处理，画 面如何安排，图片如何显示等）\n\n# 5.创建HTML文件\n\n1.创建一个web工程(静态工程，以IDEA2020为例)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210436.png)\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210437.png)\n\n2.在工程下创建HTML页面\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210438.png)\n\n3.选择浏览器执行页面\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210439.png)\n\n第一个html文件示例\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>标题</title>\n</head>\n<body>\n    hello\n</body>\n</html>\n```\n\n注：Java 文件是需要先编译，再由 java 虚拟机跑起来。但 HTML 文件它不需要编译，直接由浏览器进行解析执行。\n\n# 6.HTML文件的书写规范\n\n```html\n<html> 表示整个 html 页面的开始 \n    <head> 头信息 \n        <title>标题</title> 标题 \n    </head> \n    <body> body 是页面的主体内容 页面主体内容 \n    </body> \n</html> 表示整个 html 页面的结束 \nHtml 的代码注释 <!-- 这是 html 注释，可以在页面右键查看源代码中看到 -->\n```\n\n```html\n<!DOCTYPE html><!-- 约束,声明 -->\n<!-- html标签表示html的开始   lang=\"zh_CN\"表示中文    html标签中一般分为两部分,分别是:head和body    -->\n<head><!-- 表示头部信息,一般包含三部分内容,title标签,css样式,js代码 -->\n    <meta charset=\"UTF-8\"><!-- 表示当前页面使用UTF-8字符集 -->\n    <title>某东</title><!--表示标题-->\n</head>\n<!--bgcolor是背景颜色属性\n    onclick表示单击(点击)事件\n\n    alert() 是javaScript语言提供的一个警告框函数.\n    它可以接收任意参数.参数就是警告框的函数信息\n-->\n<body ><!--body标签是整个html页面显示的主体内容-->\nhello\n<button onclick=\"alert('hello')\">按钮</button>\n我<br/>好帅\n<hr/>\n呀\n</body>\n</html>\n```\n\n\n\n# 7.HTML标签介绍\n\n1.标签的格式: \n\n​\t\t<标签名>封装的数据</标签名> \n\n2.标签名大小写不敏感。 \n\n3.标签拥有自己的属性。 \n\n​\t\ti. 分为基本属性：bgcolor=\"red\" 可以修改简单的样式效果 \n\n​\t\tii. 事件属性： onclick=\"alert('你好！');\" 可以直接设置事件响应后的代码。 \n\n4.标签又分为，单标签和双标签。 \n\n​\t\ti. 单标签格式： <标签名 />          \tbr 换行 \thr 水平线 \n\n​\t\tii. 双标签格式: <标签名> ...封装的数据...</标签名> \n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210440.png)\n\n标签的语法：\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>0-标签语法.html</title>\n</head>\n<body>\n\n\t<!-- ①标签不能交叉嵌套 -->\n\t正确：<div><span>早安，尚硅谷</span></div>\n\t错误：<div><span>早安，尚硅谷</div></span>\n\t<hr />\n\n\t<!-- ②标签必须正确关闭(闭合) -->\n\t<!-- i.有文本内容的标签： -->\n\t正确：<div>早安，尚硅谷</div>\n\t错误：<div>早安，尚硅谷\n\t<hr />\n\t\n\t<!-- ii.没有文本内容的标签： -->\n\t正确：<br />1\n\t错误：<br >2\n\t<hr />\n\t\n\t<!-- ③属性必须有值，属性值必须加引号 -->\n\t正确：<font color=\"blue\">早安，尚硅谷</font>\n\t错误：<font color=blue>早安，尚硅谷</font>\n\t错误：<font color>早安，尚硅谷</font>\n\t<hr />\n\t\t\n\t<!-- ④注释不能嵌套 -->\n\t正确：<!-- 注释内容 --> <br/>\n\t错误：<!-- 注释内容 <!-- 注释内容 -->-->\n\t<hr />\n</body>\n</html>\n```\n\n效果：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210441.png)\n\n<font color = \"red\">注意事项： </font>\n\n1.html 代码不是很严谨。有时候标签不闭合，也不会报错。\n\n# 8.常用标签介绍    \n\n​\t\t\t参考文档：w3cschool.CHM\n\n## 8.1font字体标签\n\n需求 1：在网页上显示 我是字体标签 ，并修改字体为 宋体，颜色为红色。\n\n```html\n<body>\n    <!-- 字体标签 需求 1：在网页上显示 我是字体标签 ，并修改字体为 宋体，颜色为红色。 \n        font 标签是字体标签,它可以用来修改文本的字体,颜色,大小(尺寸) \n            color 属性修改颜色 \n            face 属性修改字体 \n            size 属性修改文本大小 \n    -->\n    <font color=\"red\" face=\"宋体\" size=\"7\">我是字体标签</font>\n</body>\n```\n\n效果：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210442.png)\n\n## 8.2特殊字符\n\n需求1：把\\<br>换行标签 变成文本 转换成字符显示在页面\n\n```html\n<body> \n    <!-- 特殊字符 \n        需求 1：把 <br> 换行标签 变成文本 转换成字符显示在页面上 \n        常用的特殊字符: \n            < ===>>>> &lt; \n            > ===>>>> &gt; \n            空格 ===>>>> &nbsp; \n    --> \n    我是&lt;br&gt;标签<br/>\n    我&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;被你发现了\n</body>\n```\n\n效果：\n\n![效果](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210443.png)\n\n常用特殊字符表：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210444.png)\n\n其他特殊字符表：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210445.png)\n\n## 8.3标题标签\n\n​\t\t\t标题标签是 h1 到 h6 \n\n需求 1：演示标题 1 到 标题 6 的\n\n```html\n<body>\n\t<!-- 标题标签\n\t 需求1：演示标题1到 标题6的\n\n\t \th1 - h6 都是标题标签\n\t \th1 最大\n\t \th6 最小\n\t\t\talign 属性是对齐属性\n\t\t\t\tleft\t\t左对齐(默认)\n\t\t\t\tcenter\t\t剧中\n\t\t\t\tright\t\t右对齐\n\t -->\n\t<h1 align=\"left\">标题1</h1>\n\t<h2 align=\"center\">标题2</h2>\n\t<h3 align=\"right\">标题3</h3>\n\t<h4>标题4</h4>\n\t<h5>标题5</h5>\n\t<h6>标题6</h6>\n\t<h7>标题7</h7>\n</body>\n```\n\n效果：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210446.png)\n\n## 8.4超链接\n\n​\t\t在网页中所有点击之后可以跳转的内容都是超连接\n\n需求 1：普通的 超连接。\n\n```html\n<body>\n\t<!-- a标签是 超链接\n\t \t\thref属性设置连接的地址\n\t \t\ttarget属性设置哪个目标进行跳转\n\t \t\t\t_self\t\t表示当前页面(默认值)\n\t \t\t\t_blank\t\t表示打开新页面来进行跳转\n\t -->\n\t<a href=\"http://localhost:8080\">百度</a><br/>\n\t<a href=\"http://localhost:8080\" target=\"_self\">百度_self</a><br/>\n\t<a href=\"http://localhost:8080\" target=\"_blank\">百度_blank</a><br/>\n</body>\n```\n\n## 8.5列表标签\n\n​\t\t无序列表 、 有序列表 \n\n需求1：使用无序，列表方式，把东北F4，赵四，刘能，小沈阳，宋小宝，展示出来\n\n```html\n<body>\n    <!--需求1：使用无序，列表方式，把东北F4，赵四，刘能，小沈阳，宋小宝，展示出来\n        ul 是无序列表\n            type属性可以修改列表项前面的符号\n        li  是列表项\n    -->\n    <ul type=\"none\">\n        <li>赵四</li>\n        <li>刘能</li>\n        <li>小沈阳</li>\n        <li>宋小宝</li>\n    </ul>\n</body>\n```\n\n效果：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210447.png)\n\n## 8.6 img标签\n\n​\t\timg 标签可以在 html 页面上显示图片\n\n需求1：使用img标签显示一张美女的照片。并修改宽高，和边框属性\n\n```html\n<body>\n    <!--需求1：使用img标签显示一张美女的照片。并修改宽高，和边框属性\n\n        img标签是图片标签,用来显示图片\n            src属性可以设置图片的路径\n            width属性设置图片的宽度\n            height属性设置图片的高度\n            border属性设置图片边框大小\n            alt属性设置当指定路径找不到图片时,用来代替显示的文本内容\n\n        在JavaSE中路径也分为相对路径和绝对路径.\n            相对路径:从工程名开始算\n\n            绝对路径:盘符:/目录/文件名\n\n        在web中路径分为相对路径和绝对路径两种\n            相对路径:\n                .           表示当前文件所在的目录\n                ..          表示当前文件所在的上一级目录\n                文件名      表示当前文件所在目录的文件,相当于 ./文件名            ./ 可以省略\n\n            绝对路径:\n                正确格式是:  http://ip:port/工程名/资源路径\n\n                错误格式是:  盘符:/目录/文件名\n    -->\n    <img src=\"1.jpg\" width=\"200\" height=\"260\" border=\"1\" alt=\"美女找不到\"/>\n    <img src=\"../../2.jpg\" width=\"200\" height=\"260\" />\n    <img src=\"../imgs/3.jpg\" width=\"200\" height=\"260\" />\n \n</body>\n```\n\n效果：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210448.png)\n\n目录图\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210449.png)\n\n## 8.7表格标签\n\n需求1：做一个 带表头的 ，三行，三列的表格，并显示边框\n需求2：修改表格的宽度，高度，表格的对齐方式，单元格间距。\n\n```html\n<body>\n<!--\n\t需求1：做一个 带表头的 ，三行，三列的表格，并显示边框\n\t需求2：修改表格的宽度，高度，表格的对齐方式，单元格间距。\n\n\t\ttable 标签是表格标签\n\t\t\tborder 设置表格标签\n\t\t\twidth 设置表格宽度\n\t\t\theight 设置表格高度\n\t\t\talign 设置表格相对于页面的对齐方式\n\t\t\tcellspacing 设置单元格间距\n\n\t\ttr\t 是行标签\n\t\tth\t是表头标签\n\t\ttd  是单元格标签\n\t\t\talign 设置单元格文本对齐方式\n\n\t\tb 是加粗标签\n\n\t-->\n\n<table align=\"center\" border=\"1\" width=\"300\" height=\"300\" cellspacing=\"0\">\n    <tr>\n        <th>1.1</th>\n        <th>1.2</th>\n        <th>1.3</th>\n    </tr>\n    <tr>\n        <td>2.1</td>\n        <td>2.2</td>\n        <td>2.3</td>\n    </tr>\n    <tr>\n        <td>3.1</td>\n        <td>3.2</td>\n        <td>3.3</td>\n    </tr>\n</table>\n</body>\n```\n\n效果：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210450.png)\n\n## 8.8跨行跨列表格\n\n```html\n<body>\n <!--\t需求1：\n新建一个五行，五列的表格，\n第一行，第一列的单元格要跨两列，\n第二行第一列的单元格跨两行，\n第四行第四列的单元格跨两行两列。\n\ncolspan 属性设置跨列\nrowspan 属性设置跨行\n-->\n\n    <table width=\"500\" height=\"500\" cellspacing=\"0\" border=\"1\">\n        <tr>\n            <td colspan=\"2\">1.1</td>\n            <td>1.3</td>\n            <td>1.4</td>\n            <td>1.5</td>\n        </tr>\n        <tr>\n            <td rowspan=\"2\">2.1</td>\n            <td>2.2</td>\n            <td>2.3</td>\n            <td>2.4</td>\n            <td>2.5</td>\n        </tr>\n        <tr>\n            <td>3.2</td>\n            <td>3.3</td>\n            <td>3.4</td>\n            <td>3.5</td>\n        </tr>\n        <tr>\n            <td>4.1</td>\n            <td>4.2</td>\n            <td>4.3</td>\n            <td colspan=\"2\" rowspan=\"2\">4.4</td>\n        </tr>\n        <tr>\n            <td>5.1</td>\n            <td>5.2</td>\n            <td>5.3</td>\n        </tr>\n    </table>\n</body>\n```\n\n效果：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210451.png)\n\n## 8.9了解iframe框架标签(内嵌窗口)\n\n​\t\t\tifarme 标签它可以在一个 html 页面上,打开一个小窗口,去加载一个单独的页面. \n\n```html\n<body>\n\t我是一个单独的完整的页面<br/><br/>\n    <!--ifarme标签可以在页面上开辟一个小区域显示一个单独的页面\n            ifarme和a标签组合使用的步骤:\n                1 在iframe标签中使用name属性定义一个名称\n                2 在a标签的target属性上设置iframe的name的属性值\n    -->\n    <iframe src=\"3.标题标签.html\" width=\"500\" height=\"400\" name=\"abc\"></iframe>\n    <br/>\n\n    <ul>\n        <li><a href=\"0-标签语法.html\" target=\"abc\">0-标签语法.html</a></li>\n        <li><a href=\"1.font标签.html\" target=\"abc\">1.font标签.html</a></li>\n        <li><a href=\"2.特殊字符.html\" target=\"abc\">2.特殊字符.html</a></li>\n    </ul>\n</body>\n```\n\n效果：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210452.png)\n\n## 8.10表单标签\n\n什么是表单? \n\n表单就是 html 页面中,用来收集用户信息的所有元素集合.然后把这些信息发送给服务器.\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210453.png)\n\n\n\n表单的显示：\n\n```html\n<body>\n<!--需求1:创建一个个人信息注册的表单界面。包含用户名，密码，确认密码。性别（单选），兴趣爱好（多选），国籍（下拉列表）。\n隐藏域，自我评价（多行文本域）。重置，提交。-->\n\n    <!--\n        form标签就是表单\n            input type=text     是文件输入框  value设置默认显示内容\n            input type=password 是密码输入框  value设置默认显示内容\n            input type=radio    是单选框    name属性可以对其进行分组   checked=\"checked\"表示默认选中\n            input type=checkbox 是复选框   checked=\"checked\"表示默认选中\n            input type=reset    是重置按钮      value属性修改按钮上的文本\n            input type=submit   是提交按钮      value属性修改按钮上的文本\n            input type=button   是按钮          value属性修改按钮上的文本\n            input type=file     是文件上传域\n            input type=hidden   是隐藏域    当我们要发送某些信息，而这些信息，不需要用户参与，就可以使用隐藏域（提交的时候同时发送给服务器）\n\n            select 标签是下拉列表框\n            option 标签是下拉列表框中的选项 selected=\"selected\"设置默认选中\n\n            textarea 表示多行文本输入框 （起始标签和结束标签中的内容是默认值）\n                rows 属性设置可以显示几行的高度\n                cols 属性设置每行可以显示几个字符宽度\n    -->\n    <form>\n        <h1 align=\"center\">用户注册</h1>\n        <table align=\"center\">\n            <tr>\n                <td> 用户名称：</td>\n                <td>\n                    <input type=\"text\" value=\"默认值\"/>\n                </td>\n            </tr>\n            <tr>\n                <td> 用户密码：</td>\n                <td><input type=\"password\" value=\"abc\"/></td>\n            </tr>\n            <tr>\n                <td>确认密码：</td>\n                <td><input type=\"password\" value=\"abc\"/></td>\n            </tr>\n             <tr>\n                <td>性别：</td>\n                <td>\n                    <input type=\"radio\" name=\"sex\"/>男\n                    <input type=\"radio\" name=\"sex\" checked=\"checked\"  />女\n                </td>\n            </tr>\n             <tr>\n                <td> 兴趣爱好：</td>\n                <td>\n                    <input type=\"checkbox\" checked=\"checked\" />Java\n                    <input type=\"checkbox\" />JavaScript\n                    <input type=\"checkbox\" />C++\n                </td>\n            </tr>\n             <tr>\n                <td>国籍：</td>\n                <td>\n                    <select>\n                        <option>--请选择国籍--</option>\n                        <option selected=\"selected\">中国</option>\n                        <option>美国</option>\n                        <option>小日本</option>\n                    </select>\n                </td>\n            </tr>\n             <tr>\n                <td>自我评价：</td>\n                <td><textarea rows=\"10\" cols=\"20\">我才是默认值</textarea></td>\n            </tr>\n             <tr>\n                <td><input type=\"reset\" /></td>\n                <td align=\"center\"><input type=\"submit\"/></td>\n            </tr>\n        </table>\n    </form>\n</body>\n```\n\n效果：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210454.png)\n\n表单提交细节：\n\n```html\n<body>\n    <!--\n        form标签是表单标签\n            action属性设置提交的服务器地址\n            method属性设置提交的方式GET(默认值)或POST\n\n        表单提交的时候，数据没有发送给服务器的三种情况：\n            1、表单项没有name属性值\n            2、单选、复选（下拉列表中的option标签）都需要添加value属性，以便发送给服务器\n            3、表单项不在提交的form标签中\n\n        GET请求的特点是：\n            1、浏览器地址栏中的地址是：action属性[+?+请求参数]\n                请求参数的格式是：name=value&name=value\n            2、不安全\n            3、它有数据长度的限制\n\n        POST请求的特点是：\n            1、浏览器地址栏中只有action属性值\n            2、相对于GET请求要安全\n            3、理论上没有数据长度的限制\n    -->\n    <form action=\"http://localhost:8080\" method=\"post\">\n        <input type=\"hidden\" name=\"action\" value=\"login\" />\n        <h1 align=\"center\">用户注册</h1>\n        <table align=\"center\">\n            <tr>\n                <td> 用户名称：</td>\n                <td>\n                    <input type=\"text\" name=\"username\" value=\"默认值\"/>\n                </td>\n            </tr>\n            <tr>\n                <td> 用户密码：</td>\n                <td><input type=\"password\" name=\"password\" value=\"abc\"/></td>\n            </tr>\n             <tr>\n                <td>性别：</td>\n                <td>\n                    <input type=\"radio\" name=\"sex\" value=\"boy\"/>男\n                    <input type=\"radio\" name=\"sex\" checked=\"checked\" value=\"girl\" />女\n                </td>\n            </tr>\n             <tr>\n                <td> 兴趣爱好：</td>\n                <td>\n                    <input name=\"hobby\" type=\"checkbox\" checked=\"checked\" value=\"java\"/>Java\n                    <input name=\"hobby\" type=\"checkbox\" value=\"js\"/>JavaScript\n                    <input name=\"hobby\" type=\"checkbox\" value=\"cpp\"/>C++\n                </td>\n            </tr>\n             <tr>\n                <td>国籍：</td>\n                <td>\n                    <select name=\"country\">\n                        <option value=\"none\">--请选择国籍--</option>\n                        <option value=\"cn\" selected=\"selected\">中国</option>\n                        <option value=\"usa\">美国</option>\n                        <option value=\"jp\">小日本</option>\n                    </select>\n                </td>\n            </tr>\n             <tr>\n                <td>自我评价：</td>\n                <td><textarea name=\"desc\" rows=\"10\" cols=\"20\">我才是默认值</textarea></td>\n            </tr>\n             <tr>\n                <td><input type=\"reset\" /></td>\n                <td align=\"center\"><input type=\"submit\"/></td>\n            </tr>\n        </table>\n    </form>\n</body>\n```\n\n效果：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210454.png)\n\n## 8.11 其他标签\n\n需求1：div、span、p标签的演示\n\n```html\n<body>\n        <!--需求1：div、span、p标签的演示\n            div标签       默认独占一行\n            span标签      它的长度是封装数据的长度\n            p段落标签     默认会在段落的上方或下方各空出一行来（如果已有就不再空）\n        -->\n    <div>div标签1</div>\n    <div>div标签2</div>\n    <span>span标签1</span>\n    <span>span标签2</span>\n    <p>p段落标签1</p>\n    <p>p段落标签2</p>\n</body>\n```\n\n效果：\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207210455.png)\n\n","categories":["Java学习","前端"]},{"title":"多线程","url":"/2020/12/07/尚硅谷说Java/Java高级语法/1-多线程/","content":"\nJava的线程同步，调度，阻塞，通信，Thread类和Runnable接口\n\n<!--more-->\n# 基本概念\n\n* 程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。\n\n* 进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：\n\n  * 有它自身的产生、存在和消亡的过程。——生命周期\n  * 程序是静态的，进程是动态的\n  * 进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域\n\n* 线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。\n\n  * 若一个进程同一时间并行执行多个线程，就是支持多线程的\n  * 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)。而且线程切换的开销小 。\n  * 一个进程中的多个线程共享相同的内存单元/内存地址空间-->它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184339.png)\n\n* 单核CPU和多核CPU的理解\n\n  * 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时间单元特别短，因此感觉不出来。\n  * 如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）\n  * 一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。\n\n* 并行与并发\n\n  * 并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。\n  * 并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。\n\n* 多线程程序的优点：\n\n  * 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。\n  * 提高计算机系统CPU的利用率\n  * 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改\n\n* 多线程程序的使用场景\n\n  * 程序需要同时执行两个或多个任务。\n  * 程序需要实现一些需要等待的任务时，如用户输入、文件读写\n    操作、网络操作、搜索等。\n  * 需要一些后台运行的程序时。\n\n# 线程的创建和使用\n\n* Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现。\n* Thread类的特性\n\n  * 每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常\n    把run()方法的主体称为线程体\n  * 通过该Thread对象的start()方法来启动这个线程，而非直接调用run()\n  * 构造器\n    * Thread()：创建新的Thread对象\n    * Thread(String threadname)：创建线程并指定线程实例名\n    * Thread(Runnable target)：指定创建线程的目标对象，它实现了Runnable接口中的run方法\n    * Thread(Runnable target, String name)：创建新的Thread对象\n  * 有关方法\n    * void start(): 启动线程，并执行对象的run()方法\n    * run(): 线程在被调度时执行的操作\n    * String getName(): 返回线程的名称\n    * void setName(String name):设置该线程名称\n    * static Thread currentThread(): 返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类\n    * static void yield()：释放当前线程CPU的执行权\n      * 暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程\n      * 若队列中没有同优先级的线程，忽略此方法\n    * join() ：当某个程序执行流中调用其他线程的 join() 方法时，当前线程将被阻塞，直到被调用的其他线程执行完为止\n      * 低优先级的线程也可以获得执行\n    * static void sleep(long millis)：(指定时间:毫秒) \n      * 令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。\n      * 抛出InterruptedException异常\n    * stop(): 强制线程生命期结束，不推荐使用\n    * boolean isAlive()：返回boolean，判断线程是否还活着\n\n## 线程的创建\n\n* JDK1.5之前创建新执行线程有两种方法：①  继承Thread类的方式 ② 实现Runnable接口的方式\n\n* 方式一：继承Thread类\n\n  1. 定义子类继承Thread类。\n  2. 子类中重写Thread类中的run方法。\n  3. 创建Thread子类对象，即创建了线程对象。\n  4. 调用线程对象start方法：启动线程，调用run方法。\n  ```java\n  public class ThreadTest {\n      public static void main(String[] args) {\n          //3.在主线程中创建Thread类的子类的对象\n          MyThread thread = new MyThread();\n          //4.通过此对象调用start()方法开启对象的线程\n          //作用：①启动thread的线程。② 调用thread线程的run()\n          thread.start();\n      }\n  }\n   //1.创建一个继承于Thread类的子类\n  class MyThread extends Thread{\n      @Override\n      public void run() {\n          //2.重写Thread类的run()  -->将此线程执行的操作声明在run()中\n          for (int i = 0;i < 100;i++){\n              if(i % 2 == 0){\n                  System.out.println(i);\n              }\n          }\n      }\n  }\n  ```\n\n  * 注意点：\n\n  1.  如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。\n  2.  run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。\n  3.  想要启动多线程，必须调用start方法。\n  4.  一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常“IllegalThreadStateException”。\n\n* 方式二：实现Runnable接口\n\n  1. 定义子类，实现Runnable接口。\n  2. 子类中重写Runnable接口中的run方法。\n  3. 通过Thread类含参构造器创建线程对象。\n  4. 将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。\n  5. 调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。\n\n  ```java\n  public class ThreadTest2 {\n      public static void main(String[] args) {\n          //3.在主线程中创建实现类的对象\n          MThread mThread = new MThread();\n          //4.在主线程中创建以实现类对象为构造方法参数的Thread对象。\n          Thread thread = new Thread(mThread);\n          //5.通过Thread类的对象调用start()\n          thread.start();\n      }\n  }\n  // 1.创建一个实现了Runnable接口的类\n  class MThread implements Runnable{\n      //2.实现类去实现Runnable中的抽象方法run()\n      @Override\n      public void run() {\n          for (int i = 0;i < 100;i++){\n              if(i % 2 == 0){\n                  System.out.println(Thread.currentThread().getName()+\":\"+i);\n              }\n          }\n      }\n  }\n  ```\n\n* 方式三：实现Callable接口\n\n  1. 创建一个实现了Callable接口的类。\n\n  2. 实现类去实现Runnable中的抽象方法call()。\n\n  3. 在主线程中创建实现类的对象\n\n  4. 将实现类的对象作为FutureTask构造方法的参数，创建FutureTask对象\n\n  5. 将FutureTask对象作为Thread构造方法的参数，创建Thread对象\n\n  6. 根据Thread对象调用start()方法\n\n  ```java\n  public class CallableThreadTest{\n      public static void main(String[] args) {\n          //3.在主线程中创建实现类的对象\n          CallableThread callableThread = new CallableThread();\n          //4.将实现类的对象作为FutureTask构造方法的参数，创建FutureTask对象\n          FutureTask futureTask = new FutureTask(callableThread);\n          //5.将FutureTask对象作为Thread构造方法的参数，创建Thread对象，并调用start()方法\n          new Thread(futureTask).start();\n      }\n  }\n  //1.创建一个实现了Callable接口的类。\n  class CallableThread implements Callable {\n      //2.实现类去实现Runnable中的抽象方法call()。\n      @Override\n      public Object call() throws Exception {\n          for (int i = 0;i < 100;i++){\n              if(i % 2 == 0){\n                  System.out.println(i);\n              }\n          }\n          return null;\n      }\n  }\n  ```\n\n  * 优点：\n    * 与使用Runnable相比， Callable功能更强大些\n    * 相比run()方法，可以有返回值\n    * 方法可以抛出异常\n    * 支持泛型的返回值\n  * Future接口\n    * 可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。\n    * FutrueTask是Futrue接口的唯一的实现类\n    * FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值\n\n* 方式四：使用线程池\n\n  1. 创建一个Runnable接口或Callable接口实现类\n  2. 在主线程中通过Executors创建执行数量的线程池\n  3. 执行指定的线程操作。需要提供实现Runnable接口或Callable接口实现类的对象,\n     1. execute(Runnable)可以指定Runnable接口实现类的对象\n  4. 关闭线程池：shutdown()方法\n  \n  ```java\n  public class ExecutorServiceTest {\n      public static void main(String[] args) {\n          //1.创建指定线程数量的线程池\n          ExecutorService executorService = Executors.newFixedThreadPool(10);\n          //ThreadPoolExecutor是ExecutorService接口的唯一是实现类\n          ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executorService;\n          //2.执行指定的线程操作。需要提供实现Runnable接口或Callable接口实现类的对象\n          executorService.execute(new ExecutorThread());\n          //executorService.submit();\n          //3.关闭线程池\n          executorService.shutdown();\n      }\n  }\n  class ExecutorThread implements Runnable{\n      @Override\n      public void run() {\n          for (int i = 0;i < 100;i++){\n              if(i % 2 == 0){\n                  System.out.println(i);\n              }\n          }\n      }\n  }\n  ```\n  \n  *  背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。\n  * 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。\n  * 好处：\n    * 提高响应速度（减少了创建新线程的时间）\n    * 降低资源消耗（重复利用线程池中线程，不需要每次都创建）\n    * 便于线程管理\n      * corePoolSize：核心池的大小\n      *  maximumPoolSize：最大线程数 \n  \n      * keepAliveTime：线程没有任务时最多保持多长时间后会终止\n  * JDK 5.0起提供了线程池相关API：ExecutorService 和 Executors\n  * ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor\n    *  void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行Runnable\n    * Future<T> submit(Callable<T> task)：执行任务，有返回值，一般又来执行Callable\n    * void shutdown() ：关闭连接池\n  * Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池\n    * Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池\n    * Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池\n    * Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池\n    * Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\n  \n* 继承Thread 方式和实现Runnable方式的联系与区别\n\n  * 联系：public class Thread  implements Runnable\n  * 区别：\n    * 继承Thread：线程代码存放Thread子类run方法中。\n    * 实现Runnable：线程代码存在接口的子类的run方法。\n  * 实现方式的好处\n    * 避免了单继承的局限性\n    * 多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源\n\n## 线程的调度\n\n* 调度策略：① 时间片。② 抢占式：高优先级的线程抢占CPU\n* Java的调度方法\n  * 同优先级线程组成先进先出队列（先到先服务），使用时间片策略\n  * 对高优先级，使用优先调度的抢占式策略\n\n## 线程的优先级等级：\n\n* 等级范围1~10\n  * MAX_PRIORITY：10 \n  * MIN _PRIORITY：1 \n  * NORM_PRIORITY：5   -->默认线程优先级\n* 涉及的方法\n  * getPriority() ：返回线程优先级\n  * setPriority(int newPriority) ：改变线程的优先级\n* 说明\n  * 线程创建时继承父线程的优先级\n  * 低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用\n\n## 线程的分类\n\n* Java中的线程分为两类：一种是守护线程，一种是用户线程。 \n* 它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。\n* 守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程。\n* Java垃圾回收就是一个典型的守护线程。\n* 若JVM中都是守护线程，当前JVM将退出。\n\n\n# 线程的生命周期\n\n* JDK中用Thread.State类定义了线程的几种状态：\n\n  ```java\n  public enum State {\n      NEW,//尚未启动的线程处于此状态。\n      RUNNABLE,//在Java虚拟机中执行的线程处于此状态\n      BLOCKED,//在等待监视器锁时被阻塞的线程处于这种状态。\n      WAITING,//无限期等待另一个线程执行特定操作的线程处于此状态。\n      TIMED_WAITING,//正在等待另一个线程执行某个操作达指定等待时间的线程处于此状态。\n      TERMINATED;//已退出的线程处于此状态\n  }\n  ```\n\n* 要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态\n\n  * 新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态\n  * 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源\n  * 运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能\n  * 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态\n  * 死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184340.png)\n\n# 线程的同步\n\n* 问题的提出：有三个窗口，卖同一种车票。三个窗口可以是三个线程。卖票过程中，可能会出现重票，错票问题。\n  * 多个线程执行的不确定性引起执行结果的不稳定\n  * 多个线程对账本的共享，会造成操作的不完整性，会破坏数据。\n\n*  问题的原因：当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。\n\n* 解决办法：对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。\n\n* Java对于多线程的安全问题提供了专业的解决方式：同步机制\n\n  * 同步代码块：\n\n    ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184341.png)\n\n  * synchronized还可以放在方法声明中，表示整个方法为同步方法。\n\n  * Lock锁方法\n\n* 同步代码块解决方法\n\n  ```java\n  class SellTicket implements Runnable{\n      private int ticket = 1000;\n      @Override\n      public void run() {\n          while (true){\n              //同步代码块\n              synchronized (this){\n                  try {\n                      Thread.sleep(10);\n                  } catch (InterruptedException e) {\n                      e.printStackTrace();\n                  }\n                  if (ticket > 0){\n                      System.out.println(Thread.currentThread().getName() + \":\" + ticket);\n                      ticket--;\n                  }else{\n                      break;\n                  }\n              }\n          }\n      }\n  }\n  ```\n\n* 同步方法解决方法\n\n  ```java\n  class SellTicket2 implements Runnable{\n      private int ticket = 1000;\n      @Override\n      public void run() {\n          while (true){\n              show();\n          }\n      }\n      //同步方法\n      public synchronized void show(){\n          if (ticket > 0){\n              try {\n                  Thread.sleep(10);\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n              System.out.println(Thread.currentThread().getName() + \":\" + ticket);\n              ticket--;\n          }\n      }\n  }\n  ```\n\n* Lock锁解决方法\n\n  ```java\n  class SellTicket3 implements Runnable{\n      private int ticket = 100;\n      //1.实例化ReentrantLock\n      private ReentrantLock reentrantLock = new ReentrantLock();\n      @Override\n      public void run() {\n          while (true){\n              //调用锁定的方法：lock()\n              reentrantLock.lock();\n              try {\n                  if (ticket > 0){\n                      try {\n                          Thread.sleep(10);\n                      } catch (InterruptedException e) {\n                          e.printStackTrace();\n                      }\n                      System.out.println(Thread.currentThread().getName() + \":\" + ticket);\n                      ticket--;\n                  }\n              } finally {\n                  //调用释放锁的方法：unlock()\n                  reentrantLock.unlock();\n              }\n          }\n      }\n  }\n  ```\n\n* 同步锁机制：在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。\n\n* synchronized的锁是什么？\n\n  * 任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。 \n  * 同步方法的锁：静态方法（类名.class）、非静态方法（this） \n  * 同步代码块：自己指定，很多时候也是指定为this或类名.class\n\n*  注意：\n\n  * 必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全\n  *  一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this），同步代码块（指定需谨慎）\n\n* 同步的范围\n\n  * 如何找问题，即代码是否存在线程安全？（非常重要） \n\n    * 明确哪些代码是多线程运行的代码\n    * 明确多个线程是否有共享数据\n    * 明确多线程运行代码中是否有多条语句操作共享数据\n  * 如何解决呢？（非常重要）\n    * 对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。\n    *  即所有操作共享数据的这些语句都要放在同步范围中\n  * 切记：\n    * 范围太小：没锁住所有有安全问题的代码\n    * 范围太大：没发挥多线程的功能。\n  \n* 释放锁的操作\n\n  *  当前线程的同步方法、同步代码块执行结束。\n  * 当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。\n  * 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。\n  * 当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。\n\n* 不会释放锁的操作\n\n  * 线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行\n  * 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。\n    * 应尽量避免使用suspend()和resume()来控制线程\n\n* 线程的死锁问题\n\n  * 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁\n  * 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续。\n  * 解决方法\n    * 专门的算法、原则\n    * 尽量减少同步资源的定义\n    * 尽量避免嵌套同步\n\n* Lock(锁) \n\n  * 从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。\n  * java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。\n  * ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。\n\n  ```java\n  //格式\n  class A{\n  \tprivate final ReentrantLock lock = new ReenTrantLock();\n  \tpublic void m(){\n  \t\tlock.lock();\n  \t\ttry{\n  \t\t\t//保证线程安全的代码; \n          }finally{\n  \t\t\tlock.unlock(); \n  \t\t} \n      } \n  }\n  ```\n\n* synchronized 与 Lock 的对比\n\n  * Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放\n  * Lock只有代码块锁，synchronized有代码块锁和方法锁\n  * 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）\n\n* 优先使用顺序：Lock-->同步代码块(已经进入了方法体，分配了相应资源)-> 同步方法(在方法体之外）\n\n# 线程的通信\n\n* 引入\n\n  ```java\n  //使用两个线程打印 1-100。线程1, 线程2 交替打印\n  public class ThreadCommunicationTest {\n      public static void main(String[] args) {\n          CommunicationTest communicationTest = new CommunicationTest();\n          Thread thread1 = new Thread(communicationTest);\n          Thread thread2 = new Thread(communicationTest);\n          thread1.setName(\"线程1\");\n          thread2.setName(\"线程2\");\n          thread1.start();\n          thread2.start();\n      }\n  }\n  class CommunicationTest implements Runnable{\n      private int cout = 1;\n      @Override\n      public void run() {\n          while (true) {\n              synchronized (this) {\n                  //唤醒另一个线程\n                  notify();\n                  if (cout < 100) {\n                      System.out.println(Thread.currentThread().getName() + \":\" + cout);\n                      cout++;\n                      try {\n                          //阻塞当前线程\n                          wait();\n                      } catch (InterruptedException e) {\n                          e.printStackTrace();\n                      }\n                  } else {\n                      break;\n                  }\n              }\n          }\n      }\n  }\n  ```\n\n* wait() 与 notify() 和 notifyAll()\n  * wait():令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。\n  * notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待\n  * notifyAll ()：唤醒正在排队等待资源的所有线程结束等待。\n* 这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常。\n* 因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁，因此这三个方法只能在Object类中声明。\n* wait() 方法\n  * 在当前线程中调用方法： 对象名.wait()\n  * 使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify (或notifyAll) 为止。\n  * 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）\n  * 调用此方法后，当前线程将释放对象监控权 ，然后进入等待\n  * 在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。\n* notify()/notifyAll()\n  * 在当前线程中调用方法： 对象名.notify()\n  * 功能：唤醒等待该对象监控权的一个/所有线程。 \n  * 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）\n\n# 总结\n\n```java\n/**\n * 一，多线程的创建：\n *   方式一：继承Thread类\n *      1.创建一个继承于Thread类的子类\n *      2.重写Thread类的run()  -->将此线程执行的操作声明在run()中\n *      3.在主线程中创建Thread类的子类的对象\n *      4.通过此对象调用start()方法开启对象的线程\n *     问题一：不能通过直接调用run()方法来启动线程\n *     问题二：不能让同一个线程对象启动两次，会报\n *    方式二：实现Runable接口\n *      1.创建一个实现了Runnable接口的类。\n *      2.实现类去实现Runnable中的抽象方法run()。\n *      3.在主线程中创建实现类的对象\n *      4.在主线程中创建以实现类对象为构造方法参数的Thread对象。\n *      5.通过Thread类的对象调用start()\n *    两种创建线程的方式的比较\n *      开发中优先选择：实现Runnable接口的方式\n *      原因：1.实现的方式没有类的单继承性的局限性\n *          2.实现的方式更适合用来处理多个线程有共享数据的情况\n *      联系：class Thread implements Runnable\n *      相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中\n *     方式三：实现Callable接口\n *        1.创建一个实现了Callable接口的类。\n *        2.实现类去实现Runnable中的抽象方法call()。\n *        3.在主线程中创建实现类的对象\n *        4.将实现类的对象作为FutureTask构造方法的参数，创建FutureTask对象\n *        5.将FutureTask对象作为Thread构造方法的参数，创建Thread对象\n *        6.根据Thread对象调用start()方法\n *        使用：可以通过FutureTask对象.get()方法获取call()的返回值\n *        问题：Callable接口比Runnable接口强大的原因\n *          1.call()方法有返回值\n *          2.call()方法可以报出异常，被外面的操作捕获，获取异常情况\n *          3.Callable是支持泛型的\n *     方式四：使用线程池\n *         1.创建一个Runnable接口或Callable接口实现类\n *         2.在主线程中通过Executors创建执行数量的线程池\n *         3.执行指定的线程操作。需要提供实现Runnable接口或Callable接口实现类的对象\n *              execute(Runnable)可以指定Runnable接口实现类的对象\n *              submit(参数)既可以指定Runnable接口实现类的对象，也可以指定Callable接口实现类的对象\n *         4.关闭线程池：shutdown()方法\n *         好处：1.提高响应速度(减少了创建新线程的时间)\n *              2.降低资源消耗(从夫利用线程池里的线程，不需要每次都创建)\n *              3.便于线程管理\n *                  corePoolSize：核心池的大小\n *                  maximumPoolSize：最大线程数\n *                  keepAliveTime：线程没有任务时最多保持多长时间后会终止\n *  二，Thread类常用的方法\n *      1.start(): 启动当前线程，并且调用当前线程的run()方法\n *      2.run(): 通常需要重写Thread类中的此方法，并且将要执行的操作声明在此方法中\n *      3.static currentThread()：返回执行当前代码的线程\n *      4.final getName()：获取当前线程的名字\n *      5.final setName()：设置当前线程的名字\n *      6.static yield()：释放当前CPU的执行权，线程将进入就绪状态\n *      7.final join()：在线程A中调用线程B的join()方法，此时线程A就进入阻塞状态，直到线程B执行完后，\n \t\t\t\t\t\t线程A会结束阻塞状态\n *      8.final stop()：强制结束当前线程.这个方法已过时，不推荐使用\n *      9.static sleep(long millis)：让当前线程陷入”睡眠“状态，时间为millis毫秒。在”睡眠“期间，当前线程处于阻塞状态\n *      10.final isAlive()：判断当前线程是否存活。\n *  三，线程的优先级\n *      1.范围是1~10。已定义的三个优先级常量\n *          MIN_PRIORITY = 1\n *          NORM_PRIORITY = 5  -->默认线程的优先级\n *          MAX_PRIORITY = 10\n *      2.相关方法\n *          getPriority()：获取线程的优先级\n *          setPriority()：设置当前线程的优先级\n *         说明：高优先级的线程会抢占低优先级线程CPU的执行权。\n *          但只是从概率上说高优先级的线程会先执行。\n *          并不意味着只有当高优先级的线程执行完后，低优先级的线程才执行\n *  四，线程的同步\n *      例如：有三个窗口，卖同一种车票。\n *          卖票过程中，可能会出现重票，错票问题。 -->出现了线程的安全问题\n *       1.原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来了也操作车票。\n *       2.解决方法：设定当一个线程在操作车票的时候，其他线程不能参与进来。直到这个线程操作完成后，其他线程才能开始操作车 \n *          票。而且即使这个线程出现阻塞，其他线程也不能参与。\n *       3.Java中的解决方法：通过同步机制来解决线程的安全问题。\n *          共享数据：多个线程共同操作的变量。比如车票\n *          方式一：同步代码块\n *              synchronized(同步监视器){\n *                  //需要被同步的代码\n *              }\n *              说明：\n *                  1.同步监视器：俗称锁。任意一类给的对像都可以充当锁。\n *                      要求:多个线程必须共享同一把锁\n *                      一般情况下，在实现Runnable接口创建线程的方式中，一般使用this当作同步监视器\n *                      在继承Thread创建线程的方式中，一般使用\"类名.class\"当作同步监视器\n *                  2.被同步的代码：操作共享数据的代码\n *          方式二：同步方法\n *              如果操作共享数据的代码完整的声明在一个方法中，那么我们可以将这个方法声明为同步的\n *              方式：① 将操作共享数据代码封装成一个方法\n *                   ② 将synchronized作为修饰符去修饰这个方法\n *               说明：\n *                  1.同步放啊仍然涉及到同步监视器，只是不需要我们显示的声明监视器。\n *                  2.非静态的同步方法中同步监视器是：this。静态的同步方法中同步监视器是：当前类本身(类名.class)\n *                  3.在实现Runnable接口创建线程的方式中，同步方法的监视器一般是this\n *                    在继承Thread创建线程的方式中，同步方法的监视器慎用this,一般方法设置为静态的\n *          方式三：Lock锁  --JDK1.5新增\n *              1.创建ReentrantLock的对象。 ReentrantLock是Lock的实现类\n *              2.用try-finally包围需要被同步的代码\n *              3.用ReentrantLock对象调用锁定的方法：lock()。这个方法必须声明在try的上一行\n *              4.在finally中用ReentrantLock对象调用释放锁的方法：unlock()\n *              注意：对于多线程来说，它们的ReentrantLock的对象必须是同一个\n *          问题：synchronized与Lock的异同\n *              相同：二者都可以解决线程安全问题\n *              不同之处：synchronized机制在执行完相应的同步代码后，自动的释放同步监视器\n *                      Lock需要手动的启动同步(lock())，同时也需要手动的结束同步(unlock())\n *       5.同步的方式，解决了线程的安全问题。-->好处\n *         操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程 -->局限性\n *  五，线程通信的例子：使用两个线程打印 1- 100.线程1，线程2 交替打印\n *      涉及到的三个方法：\n *        wait()：一旦执行此方法，当前线程就会进入阻塞状态，并释放同步监视器\n *        notify()：一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait,就唤醒优先级高的哪个\n *        notifyAll()：一旦执行此方法，就会唤醒所有被wait的线程。\n *      说明：\n *          1.wait(),notify(),notifyAll()三个方法必须使用在同步代码块或同步方法中\n *          2.wait(),notify(),notifyAll()三个方法的调用者必须是同步监视器，否则会出现\n *             IllegalMonitorStateException异常\n *          3.wait(),notify(),notifyAll()三个方法是定义在java.lang.Object类中的\n *      sleep()和wait()的异同\n *         相同点：一旦执行方法，都可以使当前线程进入阻塞状态\n *         不同点：1.两个方法声明的位置不同：Thread类中声明sleep()，Object类中声明wait()。\n *                2.调用的要求不同：sleep()可以在任何需要的场景下使用，wait()必须使用在同步代码块或同步方法中。\n *                3.关于是否释放同步监视器：如果两个方法都声明在同步代码块或同步方法中，sleep()不会释放锁，wait()会释\n *                  放锁。\n */\n```\n\n","categories":["Java学习","Java高级语法"]},{"title":"反射机制","url":"/2020/12/07/尚硅谷说Java/Java高级语法/8-反射机制/","content":"\nJava的Class类和动态代理\n\n<!--more-->\n# Java反射机制概述\n\n* Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 \n\n* 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184442.png)\n\n* 动态语言 vs 静态语言\n\n  * 动态语言：是一类在运行时可以改变其结构的语言：\n    * 例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。\n    * 主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。 \n  * 静态语言：运行时结构不可变的语言\n    * 如Java、C、C++。\n  * Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。\n  * Java的动态性让编程的时候更加灵活！\n\n  ```java\n  /**\n   * Java作为动态语言的体现\n   */\n  @Test\n  public void test7(){\n      for (int i = 0; i < 100; i++) {\n          int num = new Random().nextInt(3);\n          String className = \"\";\n          switch (num){\n              case 0:\n                  className = \"java.util.Random\";\n                  break;\n              case 1:\n                  className = \"java.util.Date\";\n                  break;\n              case 2:\n                  className = \"com.atguigu.reflex.Person\";\n                  break;\n          }\n          try {\n              Object object = getInstance(className);\n              System.out.println(object);\n          } catch (ClassNotFoundException e) {\n              e.printStackTrace();\n          } catch (IllegalAccessException e) {\n              e.printStackTrace();\n          } catch (InstantiationException e) {\n              e.printStackTrace();\n          }\n      }\n  }\n  public Object getInstance(String className) throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n      Class clazz = Class.forName(className);\n      return clazz.newInstance();\n  }\n  ```\n\n  \n\n* Java反射机制提供的功能\n\n  * 在运行时判断任意一个对象所属的类\n  * 在运行时构造任意一个类的对象\n  * 在运行时判断任意一个类所具有的成员变量和方法\n  * 在运行时获取泛型信息\n  * 在运行时调用任意一个对象的成员变量和方法\n  * 在运行时处理注解\n  * 生成动态代理\n\n* 反射相关的主要API\n\n  * java.lang.Class:代表一个类 \n  * java.lang.reflect.Method:代表类的方法\n  * java.lang.reflect.Field:代表类的成员变量\n  * java.lang.reflect.Constructor:代表类的构造器\n\n* \n\n# Class类的理解\n\n* 在Object类中定义了以下的方法，此方法将被所有子类继承：\n\n  * public final Class getClass()\n\n* 以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。\n\n* 对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息。 \n\n  * Class本身也是一个类\n  * Class 对象只能由系统建立对象\n  * 一个加载的类在 JVM 中只会有一个Class实例\n  * 一个Class对象对应的是一个加载到JVM中的一个.class文件\n  * 每个类的实例都会记得自己是由哪个 Class 实例所生成\n  * 通过Class可以完整地得到一个类中的所有被加载的结构\n  * Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象\n\n* Class类的常用方法\n\n  |                       方法                       |                             作用                             |\n  | :----------------------------------------------: | :----------------------------------------------------------: |\n  |        static Class forName(String name)         |               返回指定类名 name 的 Class 对象                |\n  |               Object newInstance()               |         调用缺省构造函数，返回该Class对象的一个实例          |\n  |                    getName()                     | 返回此Class对象所表示的实体（类、接口、数组类、基本类型或void）名称 |\n  |              Class getSuperClass()               |              返回当前Class对象的父类的Class对象              |\n  |             Class [] getInterfaces()             |                   获取当前Class对象的接口                    |\n  |           ClassLoader getClassLoader()           |                      返回该类的类加载器                      |\n  |              Class getSuperclass()               |           返回表示此Class所表示的实体的超类的Class           |\n  |         Constructor[] getConstructors()          |            返回一个包含某些Constructor对象的数组             |\n  |           Field[] getDeclaredFields()            |                   返回Field对象的一个数组                    |\n  | Method getMethod(String name,Class … paramTypes) |       返回一个Method对象，此对象的形参类型为paramType        |\n\n* 获取Class类的实例(四种方法) \n\n  * 前提：若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高\n    * 实例：Class clazz = String.class; \n  * 前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象\n    * 实例：Class clazz = “www.atguigu.com”.getClass();\n  * 前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException\n    * 实例：Class clazz = Class.forName(“java.lang.String”);\n  * 其他方式(不做要求)\n    * ClassLoader cl = this.getClass().getClassLoader();\n    * Class clazz4 = cl.loadClass(“类的全类名”);\n\n  ```java\n  /**\n   * Class实例化的方式：4种\n   */\n  @Test\n  public void test3() throws ClassNotFoundException {\n      //方式一：调用运行时类的属性：.class\n      Class<Person> clazz1 = Person.class;\n      System.out.println(clazz1);\n      //方式二：通过运行时类的对象：调用getClass()\n      Person person = new Person();\n      Class clazz2 = person.getClass();\n      System.out.println(clazz2);\n      //方式三：调用Class的静态方法：foeName(String classPath) -->常用\n      //classPath：类的全列名路径。包含包路径和类名\n      Class clazz3 = Class.forName(\"com.atguigu.reflex.Person\");\n      //clazz3 = Class.forName(\"java.lang.String\");\n      System.out.println(clazz3);\n  \n      System.out.println(clazz1 == clazz2);//true\n      System.out.println(clazz1 == clazz3);//true\n  \n      //方式四：使用类的加载器：ClassLoader  -->了解即可\n      //ClassLoader classLoader = Person.class.getClassLoader();\n      ClassLoader classLoader = ReflesTest.class.getClassLoader();\n      Class clazz4 = classLoader.loadClass(\"com.atguigu.reflex.Person\");\n      System.out.println(clazz4);\n      System.out.println(clazz4 == clazz3);//true\n  }\n  ```\n\n* 哪些类型可以有Class对象？\n\n  * class： 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类\n  * interface：接口\n  * []：数组\n  * enum：枚举\n  * annotation：注解@interface\n  * primitive type：基本数据类型\n  * void\n\n```java\n/**\n     * 有反射式，可以对Person的操作\n     */\n@Test\npublic void test2() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException {\n    Class<Person> pclass = Person.class;\n    //getConstructor()：可以获取类声明的公共的构造器对象\n    Constructor constructors1 = pclass.getConstructor(String.class,int.class);\n    //getDeclaredConstructor()：可以获取类声明的所有构造器对象，包括四个权限以内的，不包括继承的\n    Constructor constructors2 = pclass.getDeclaredConstructor(String.class);\n    //setAccessible(flag)：flag --> true ：表示禁用Java语言检查\n    //flag --> false (默认值)：表示不禁用Java语言检查\n    //当要使用私有构造器对象，私有方法对象，私有属性对象时\n    //需要将此设置为true，然后这个对象才能正常使用\n    constructors2.setAccessible(true);\n    //newInstance()：通过构造器对象创建这个类的对象\n    Object o = constructors2.newInstance(\"tom\");\n    System.out.println(o.toString());\n    //通过反射获取类的指定的属性和方法。\n    //getDeclaredField()：获取类对象声明的属性\n    Field name = pclass.getDeclaredField(\"name\");\n    name.setAccessible(true);\n    //set(obj,value)：属性对象调用此方法后，可以设置obj对象的这个属性的值为value\n    name.set(o,\"jack\");\n    System.out.println(o.toString());\n    //getDeclaredMethod()：获取类对象声明的方法\n    Method show = pclass.getDeclaredMethod(\"show\", String.class);\n    show.setAccessible(true);\n    //Object show(obj,args)：方法对象调用此方法后，可以调用obj对象的此方法，并传入参数args，\n    // 返回obj对象的此方法会返回的值\n    show.invoke(o,\"中国\");\n\n}\n/**\n     * 没有反射时。对Person的操作\n     */\n@Test\npublic void test1(){\n    //1.创建Person类的对象\n    Person p1 = new Person(\"tom\",16);\n    //2.通过对象，调用其内部公共的属性，方法\n    p1.age = 23;\n    System.out.println(p1.getAge());\n    System.out.println(p1.toString());\n    //在Person类外部，不可以通过Person类的对象调用其内部的私有的属性，方法，构造器\n    //比如此Person类的name,show()以及私有的构造器\n}\n```\n\n# ClassLoader的理解\n\n* 类的加载过程\n\n  * 当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184443.png)\n\n* 加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要类加载器参与。 \n\n* 链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。\n\n  * 验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题\n  * 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。 \n  * 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 \n\n* 初始化：\n\n  * 执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。 \n  * 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 \n  * 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步\n\n* 什么时候会发生类初始化？\n\n* 类的主动引用（一定会发生类的初始化）\n\n  * 当虚拟机启动，先初始化main方法所在的类 \n  * new一个类的对象\n  * 调用类的静态成员（除了final常量）和静态方法\n  * 使用java.lang.reflect包的方法对类进行反射调用\n  * 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类\n\n* 类的被动引用（不会发生类的初始化） \n\n  * 当访问一个静态域时，只有真正声明这个域的类才会被初始化\n    * 当通过子类引用父类的静态变量，不会导致子类初始化\n  * 通过数组定义类引用，不会触发此类的初始化\n  * 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）\n\n* 类加载器的作用：\n\n  * 类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。 \n  * 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184444.png)\n\n* ClassLoader类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的类的加载器。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184445.png)\n\n* 引导类加载器：用C++编写的，是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库。该加载器无法直接获取\n\n* 扩展类加载器：负责jre/lib/ext目录下的jar包或 –D java.ext.dirs 指定目录下的jar包装入工作库\n\n* 系统类加载器：负责java –classpath 或 –D java.class.path所指的目录下的类与jar包装入工作 ，是最常用的加载器\n\n```java\n/**\n * ClassLoader的使用\n */\n@Test\npublic void test4(){\n    //对于自定义类，使用系统类加载器进行加载\n    ClassLoader classLoader1 = Person.class.getClassLoader();\n    System.out.println(classLoader1);\n    //获取系统类加载器的父类：扩展类加载器\n    ClassLoader classLoader2 = classLoader1.getParent();\n    System.out.println(classLoader2);\n    //扩展类加载器的父类是引导类加载器\n    //引导类加载器是无法获取的，因此，此时返回为null\n    //引导类加载器主要负责加载Java核心类库，无法加载自定义类\n    ClassLoader classLoader3 = classLoader2.getParent();\n    System.out.println(classLoader3);\n\n    ClassLoader classLoader4 = String.class.getClassLoader();\n    System.out.println(classLoader4);\n}\n```\n\n# 创建运行时类的对象\n\n* 创建类的对象：调用Class对象的newInstance()方法\n* 要 求： \n  * 类必须有一个无参数的构造器。\n  * 类的构造器的访问权限需要足够。\n* 难道没有无参的构造器就不能创建对象了吗？\n  * 不是！只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。\n* 步骤如下：\n  * 通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器\n  * 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。\n  * 通过Constructor实例化对象。\n\n```java\nClass<Person> clazz1 = Person.class;\n//newInstance():调用此方法，创建对应的运行时类的对象。内部调用的是运行时类的空参构造器\n//要想此方法正常运行：①运行时类必须提供空参构造器。②构造器的权限要能被访问到。\nPerson person = clazz1.newInstance();\nSystem.out.println(person);\n```\n\n# 获取运行时类的完整结构\n\n* 类的完整结构包括：Field、Method、Constructor、Superclass、Interface、Annotation\n* 使用反射可以取得：\n* 实现的全部接口\n  * public Class<?>[] getInterfaces() ：确定此对象所表示的类或接口实现的接口。\n* 所继承的父类\n  * public Class<? Super T> getSuperclass()：返回表示此 Class 所表示的实体（类、接口、基本类型）的父类的Class。\n* 全部的构造器\n  * public Constructor<T>[] getConstructors()：返回此 Class 对象所表示的类的所有public构造方法。\n  * public Constructor<T>[] getDeclaredConstructors()：返回此 Class 对象表示的类声明的所有构造方法。\n* Constructor类中：\n  * 取得修饰符: public int getModifiers();\n  * 取得方法名称: public String getName();\n  * 取得参数的类型：public Class<?>[] getParameterTypes();\n* 全部的方法\n  * public Method[] getDeclaredMethods()：返回此Class对象所表示的类或接口的全部方法\n  * public Method[] getMethods()：返回此Class对象所表示的类或接口的public的方法\n* Method类中：\n  * public Class<?> getReturnType()：取得全部的返回值\n  * public Class<?>[] getParameterTypes()：取得全部的参数\n  * public int getModifiers()：取得修饰符\n  * public Class<?>[] getExceptionTypes()：取得异常信息\n* 全部的Field\n  * public Field[] getFields()： 返回此Class对象所表示的类或接口的public的Field。 \n  * public Field[] getDeclaredFields() ：返回此Class对象所表示的类或接口的全部Field。 \n* Field方法中：\n  * public int getModifiers() ：以整数形式返回此Field的修饰符\n  * public Class<?> getType() ：得到Field的属性类型\n  * public String getName() ：返回Field的名称。\n*  Annotation相关\n  * get Annotation(Class<T> annotationClass) \n  * getDeclaredAnnotations() \n* 泛型相关\n  * 获取父类泛型类型：Type getGenericSuperclass()\n* 泛型类型：ParameterizedType\n  * 获取实际的泛型类型参数数组：getActualTypeArguments()\n* 类所在的包 Package getPackage()\n\n```java\n//获取运行时类的完整结构\n//属性的获取\nClass clazz2 = Student.class;\n//getFields()：能获取当前运行时类及其父类中声明为public的属性\nField[] fields1 = clazz2.getFields();\nfor (Field field : fields1) {\n    System.out.println(field.toString());\n}\nSystem.out.println();\n//getDeclaredFields()：获取当前运行时类中声明的所有属性。(不包含父类的)\nField[] fields2 = clazz2.getDeclaredFields();\nfor (Field field : fields2) {\n    System.out.println(field.toString());\n    //获取属性的权限修饰符\n    int modifiers = field.getModifiers();\n    System.out.println(Modifier.toString(modifiers));\n    //获取属性的类型\n    Class type = field.getType();\n    System.out.println(type.getName());\n    //获取属性名\n    String name = field.getName();\n    System.out.println(name);\n    //获取属性的注解\n    Annotation[] annotations = field.getAnnotations();\n    for (Annotation annotation : annotations) {\n        System.out.println(annotation);\n    }\n}\n\n//方法的获取\n//getMethods()：能获取当前运行时类及其父类中声明为public的方法\nMethod[] methods1 = clazz2.getMethods();\nfor (Method method : methods1) {\n    System.out.println(method);\n}\nSystem.out.println();\n//getDeclaredMethods()：获取当前运行时类中声明的所有方法。(不包含父类的)\nMethod[] methods2 = clazz2.getDeclaredMethods();\nfor (Method method : methods2) {\n    System.out.println(method);\n    //获取方法的权限修饰符\n    int modifiers = method.getModifiers();\n    System.out.println(Modifier.toString(modifiers));\n    //获取方法的名字\n    String name = method.getName();\n    System.out.println(name);\n    //获取方法的注解\n    Annotation[] annotations = method.getAnnotations();\n    for (Annotation annotation : annotations) {\n        System.out.println(annotation);\n    }\n    //获取方法的返回值类型\n    Class returnType = method.getReturnType();\n    System.out.println(returnType.getName());\n    //获取方法的参数信息\n    Parameter[] parameters = method.getParameters();\n    for (Parameter parameter : parameters) {\n        System.out.println(parameter.getType());\n        System.out.println(parameter.getName());\n    }\n    //获取方法的异常信息\n    Class<?>[] exceptionTypes = method.getExceptionTypes();\n    for (Class<?> exceptionType : exceptionTypes) {\n        System.out.println(exceptionType);\n    }\n}\n\n//构造器的获取\nConstructor[] constructors1 = clazz2.getConstructors();\nfor (Constructor constructor : constructors1) {\n    System.out.println(constructor);\n}\nSystem.out.println();\nConstructor[] constructors2 = clazz2.getDeclaredConstructors();\nfor (Constructor constructor : constructors2) {\n    System.out.println(constructor);\n}\n//获取父类\nClass superclass = clazz2.getSuperclass();\nSystem.out.println(superclass);\n//获取带泛型的父类\nType genericSuperclass = clazz2.getGenericSuperclass();\nSystem.out.println(genericSuperclass);\n//获取父类的泛型\nParameterizedType parameterizedType = (ParameterizedType) genericSuperclass;\nType[] actualTypeArguments = parameterizedType.getActualTypeArguments();\nSystem.out.println(actualTypeArguments[0].getTypeName());\n//获取接口\nClass[] interfaces = clazz2.getInterfaces();\nSystem.out.println(Arrays.toString(interfaces));\n//获取带泛型的接口\nType[] genericInterfaces = clazz2.getGenericInterfaces();\nSystem.out.println(Arrays.toString(genericInterfaces));\n//获取运行时类所在的包\nPackage aPackage = clazz2.getPackage();\nSystem.out.println(aPackage);\n//获取运行时类的注解\nAnnotation[] annotations = clazz2.getAnnotations();\nfor (Annotation annotation : annotations) {\n    System.out.println(annotation);\n}\n```\n\n# 调用运行时类的指定结构\n\n* 调用指定方法\n\n  * 通过反射，调用类中的方法，通过Method类完成。步骤：\n  * 通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。\n  * 之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184446.png)\n\n* Object invoke(Object obj, Object … args)说明：\n\n  * Object 对应原方法的返回值，若原方法无返回值，此时返回null\n  * 若原方法若为静态方法，此时形参Object obj可为null\n  * 若原方法形参列表为空，则Object[] args为null\n  * 若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。\n\n* 调用指定属性\n\n  * 在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设置和取得属性内容的操作。\n  * public Field getField(String name) 返回此Class对象表示的类或接口的指定的public的Field。 \n  * public Field getDeclaredField(String name)返回此Class对象表示的类或接口的指定的Field。 \n  * 在Field中：\n    * public Object get(Object obj) 取得指定对象obj上此Field的属性内容\n    * public void set(Object obj,Object value) 设置指定对象obj上此Field的属性内容\n\n* 关于setAccessible方法的使用\n\n  * Method和Field、Constructor对象都有setAccessible()方法。 \n  * setAccessible启动和禁用访问安全检查的开关。\n  * 参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。 \n    * 提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。 \n    * 使得原本无法访问的私有成员也可以访问\n  * 参数值为false则指示反射的对象应该实施Java语言访问检查。\n\n```java\n/**\n     * 调用运行时类中指定的结构：属性，方法，构造器\n     */\n@Test\npublic void test8()throws Exception{\n    Class<Person> clazz = Person.class;\n    Person person = clazz.newInstance();\n    //获取指定的属性。要求属性为public的\n    Field age = clazz.getField(\"age\");\n    //设置属性的值\n    age.set(person, 18);\n    Field name = clazz.getDeclaredField(\"name\");\n    name.setAccessible(true);\n    name.set(person,\"jack\");\n    System.out.println(person);\n    //获取指定的方法\n    //getDeclaredMethod(String name, Class<?>... parameterTypes)\n    //name表示方法名，parameterTypes表示方法的形参，根据形参的不同可确定是哪个方法\n    Method show = clazz.getDeclaredMethod(\"show\", String.class);\n    show.setAccessible(true);\n    //Object invoke(Object obj, Object... args):\n    //obj表示方法的调用者，args表示要给方法的形参传递的实参\n    //Object：表示方法的返回值\n    Object o = show.invoke(person, \"中国\");\n    System.out.println(o);\n    //获取静态的结构\n    Method method = clazz.getEnclosingMethod();\n    System.out.println(method);\n    //获取指定的构造器\n    Constructor<Person> declaredConstructor = clazz.getDeclaredConstructor();\n    declaredConstructor.setAccessible(true);\n    Person person1 = declaredConstructor.newInstance();\n    System.out.println(person1);\n}\n```\n\n# 反射的应用：动态代理\n\n* 代理设计模式的原理: \n  * 使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 \n* 静态代理，特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。最好可以通过一个代理类完成全部的代理功能\n\n```java\n/**\n * 静态代理举例\n * 特点：代理类和被代理类在编译期间就确定下来了\n */\ninterface ClothFactory{\n    void produceCloth();\n}\n//代理类\nclass ProxyClothFactory implements ClothFactory{\n    private ClothFactory clothFactory;\n    public ProxyClothFactory(ClothFactory clothFactory){\n        this.clothFactory = clothFactory;\n    }\n\n    @Override\n    public void produceCloth() {\n        System.out.println(\"进行准备工作\");\n        clothFactory.produceCloth();\n        System.out.println(\"进行收尾工作\");\n    }\n}\n//被代理类\nclass NikeClothFactory implements ClothFactory{\n\n    @Override\n    public void produceCloth() {\n        System.out.println(\"生产商品\");\n    }\n}\npublic class StaticProxyTest {\n    public static void main(String[] args) {\n        ClothFactory clothFactory = new NikeClothFactory();\n        ProxyClothFactory factory = new ProxyClothFactory(clothFactory);\n        factory.produceCloth();\n    }\n}\n    \n```\n\n* 动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。\n* 动态代理使用场合: \n  * 调试\n  * 远程方法调用\n* 动态代理相比于静态代理的优点：\n  * 抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。\n* Java动态代理相关API\n  * Proxy ：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态地生成实现类。\n  * 提供用于创建动态代理类和动态代理对象的静态方法\n    * static Class<?> getProxyClass(ClassLoader loader, Class<?>... interfaces) 创建一个动态代理类所对应的Class对象\n    * static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) 直接创建一个动态代理对象\n* 动态代理步骤\n  * 创建一个实现接口InvocationHandler的类，它必须实现invoke方法，以完成代理的具体操作。\n  * 创建被代理的类以及接口\n  * 通过Proxy的静态方法newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 创建一个Subject接口代理\n  * 通过 Subject代理调用RealSubject实现类的方法\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\n/**\n * 动态代理的举例\n */\ninterface Human{\n    String getBelief();\n    void eat(String food);\n}\n//被代理类\nclass SuperMan implements Human{\n    @Override\n    public String getBelief() {\n        return \"I have a dream\";\n    }\n    @Override\n    public void eat(String food) {\n        System.out.println(\"我喜欢吃\"+food);\n    }\n}\n\n/**\n * 实现动态代理，需要解决的问题\n * 问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。\n * 问题二：当通过代理类的对象调用方法时，如何让动态的去调用被代理类的同名方法。\n */\n\nclass ProxyFactory{\n    /**\n     * 调用此方法，返回一个代理类的对象。解决问题一。\n     * @param obj 被代理类的对象\n     * @return 代理类的对象\n     */\n    public static Object getProxyInstance(Object obj){\n        MyInvocationHandler handler = new MyInvocationHandler(obj);\n        //第一个参数：类加载器。由被代理类的对象引出\n        //第二个参数：接口列表。让代理类实现和被代理类一样的接口\n        //第三个参数：调用方法的调用处理程序\n        //返回值即为代理类的对象\n        return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);\n    }\n}\nclass MyInvocationHandler implements InvocationHandler{\n    //被代理类的对象\n    private Object object;\n\n    public MyInvocationHandler() {\n    }\n\n    public MyInvocationHandler(Object object) {\n        this.object = object;\n    }\n\n    /**\n     * 当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()\n     * 将被代理类要执行的方法a的功能声明在incoke()中\n     * @param proxy 代理类的对象\n     * @param method 用代理类对象调用的方法对象\n     * @param args\n     * @return\n     * @throws Throwable\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        //method:代理类的方法的对象\n        //object：被代理类的对象\n        //args：方法的参数\n        Object returnValue = method.invoke(object, args);\n        return returnValue;\n    }\n}\n\npublic class DynamicProxyTest {\n    public static void main(String[] args) {\n        //创建被代理类的对象\n        Human human = new SuperMan();\n        //传入被代理类的对象，返回代理类的对象\n        Object proxyInstance1 = ProxyFactory.getProxyInstance(human);\n        Human human1 = (Human) proxyInstance1;\n        //通过代理类对象调用方法，从而执行被代理类中相应的方法\n        System.out.println(human1.getBelief());\n        human1.eat(\"肉\");\n        System.out.println(\"*************************\");\n        ClothFactory clothFactory = new NikeClothFactory();\n        ClothFactory proxyInstance2 = (ClothFactory) ProxyFactory.getProxyInstance(clothFactory);\n        proxyInstance2.produceCloth();\n    }\n}\n\n```\n\n* 使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有太大的意义。通常都是为指定的目标对象生成动态代理\n* 这种动态代理在AOP中被称为AOP代理，AOP代理可代替目标对象，AOP代理包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异：AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理\n\n# 总结\n\n```java\n * 反射的使用\n *  一，关于java.lang.Class类的理解\n *      1.类的加载过程：程序经过javac.exe编译后会生成一个或多个字节码文件(.class结尾)。\n *          接着我们使用java.exe对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。\n *          解释运行的过程被称为类的加载。加载到内存中的类，我们就称为运行时类，\n *          此运行时类就作为Class的一个实例。\n *      2.换句话说，Class的实例就对应着一个运行时类\n *      3.加载到内存中的运行时类，会缓存一定的时间。在此时间内，可以通过不同方式获取此运行时类\n *      4.对于数组而言，只要维度和元素类型一致，就是同一个class实例\n```\n\n\n\n","categories":["Java学习","Java高级语法"]},{"title":"Java8新特性","url":"/2020/12/07/尚硅谷说Java/Java高级语法/Java8部分新特性/","content":"\nLambda表达式,函数式接口，空指针处理，StreamAPI集合\n\n<!--more-->\nJava8新特性简介\n\n![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184450.png)\n\n# Lambda表达式\n\n* Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。\n\n* 从匿名类到 Lambda 的转换举例1\n\n  ```java\n  //原来的写法\n  Runnable runnable = new Runnable() {\n      @Override\n      public void run() {\n          System.out.println(\"你好\");\n      }\n  };\n  runnable.run();\n  System.out.println(\"*******************\");\n  //Lambda表达式的写法一\n  Runnable runnable2 = () -> System.out.println(\"你好\");\n  runnable2.run();\n  ```\n\n* 从匿名类到 Lambda 的转换举例2\n\n  ```java\n  //原来的写法\n  Comparator<Integer> comparator1 = new Comparator<Integer>() {\n      @Override\n      public int compare(Integer o1, Integer o2) {\n          return Integer.compare(o1,o2);\n      }\n  };\n  System.out.println(comparator1.compare(12, 34));\n  System.out.println(\"*****************\");\n  //lambda写法\n  Comparator<Integer> comparator2 = (o1,o2) -> Integer.compare(o1,o2);\n  System.out.println(comparator2.compare(54, 34));\n  System.out.println(\"*****************\");\n  //方法引用的写法\n  Comparator<Integer> comparator3 = Integer::compare;\n  System.out.println(comparator3.compare(4, 54));\n  ```\n\n* Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。\n  这个操作符为 “->” ， 该操作符被称为 Lambda 操作符或箭头操作符。\n\n* 它将 Lambda 分为两个部分：\n\n  * 左侧：指定了 Lambda 表达式需要的参数列表\n  * 右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即Lambda 表达式要执行的功能\n\n* 语法\n\n  ```java\n  //1.无参，无返回值\n  Runnable runnable = new Runnable() {\n      @Override\n      public void run() {\n          System.out.println(\"你好\");\n      }\n  };\n  runnable.run();\n  System.out.println(\"*******************\");\n  Runnable runnable2 = () -> {\n      System.out.println(\"你好\");\n  };\n  runnable2.run();\n  //2.有参数，无返回值\n  Consumer<String> consumer = new Consumer<String>() {\n      @Override\n      public void accept(String s) {\n          System.out.println(s);\n      }\n  };\n  consumer.accept(\"格式二:正常情况\");\n  System.out.println(\"**********************\");\n  Consumer<String> consumer2 = (String s) -> {\n      System.out.println(s);\n  };\n  consumer2.accept(\"格式二:Lambda\");\n  //3.数据类型可以省略，因为可由编译器推断得出，称为“类型推断”;\n  Consumer<String> consumer3 = (String s) -> {\n      System.out.println(s);\n  };\n  consumer3.accept(\"格式三:\");\n  System.out.println(\"**********************\");\n  Consumer<String> consumer4 = (s) -> {\n      System.out.println(s);\n  };\n  consumer4.accept(\"格式三:Lambda\");\n  //4.只有一个参数，没有返回值，小括号也可以省略\n  Consumer<String> consumer5 = (s) -> {\n      System.out.println(s);\n  };\n  consumer5.accept(\"格式四:Lambda\");\n  System.out.println(\"**********************\");\n  Consumer<String> consumer6 = s -> {\n      System.out.println(s);\n  };\n  consumer6.accept(\"格式四:Lambda\");\n  //5.有多个参数，多条执行语句，且有返回值\n  Comparator<Integer> comparator1 = new Comparator<Integer>() {\n      @Override\n      public int compare(Integer o1, Integer o2) {\n          System.out.println(o1);\n          System.out.println(o2);\n          return Integer.compare(o1,o2);\n      }\n  };\n  System.out.println(comparator1.compare(12, 34));\n  System.out.println(\"*****************\");\n  Comparator<Integer> comparator2 = (o1,o2) -> {\n      System.out.println(o1);\n      System.out.println(o2);\n      return Integer.compare(o1,o2);\n  };\n  System.out.println(comparator2.compare(54, 34));\n  //6.若只有一条执行语句，return和大括号若有可以省略\n  Comparator<Integer> comparator3 = (o1,o2) -> {\n      return Integer.compare(o1,o2);\n  };\n  System.out.println(comparator3.compare(54, 34));\n  System.out.println(\"*****************\");\n  Comparator<Integer> comparator4 = (o1,o2) -> Integer.compare(o1,o2);\n  System.out.println(comparator4.compare(54, 34));\n  ```\n\n  * 上述 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的“类型推断”。\n\n\n# 函数式接口\n\n* 只包含一个抽象方法的接口，称为函数式接口。 \n* 你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。\n* 我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。\n* 在java.util.function包下定义了Java 8 的丰富的函数式接口\n* 如何理解函数式接口\n  * Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还可以支持OOF（面向函数编程） \n  * 在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。 \n  * 简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。\n  * 所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。\n\n```java\n@FunctionalInterface\npublic interface Runnable {\n    public abstract void run();\n}\n```\n\n* 作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。\n\n* Java 内置四大核心函数式接口\n\n  | 函数式接口               | 参数类型 | 返回类型 | 用途                                                         |\n  | ------------------------ | -------- | -------- | ------------------------------------------------------------ |\n  | Consumer<T>消费型接口    | T        | void     | 对类型为T的对象应用操作，包含方法：void accept(T t)          |\n  | Supplier<T>供给型接口    | 无       | T        | 返回类型为T的对象，包含方法：T get()                         |\n  | Function<T, R>函数型接口 | T        | R        | 对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t) |\n  | Predicate<T>断定型接口   | T        | boolean  | 确定类型为T的对象是否满足某约束，并返回boolean 值。包含方法：boolean test(T t) |\n\n* 其他接口\n\n  | 函数式接口               | 参数类型 | 返回类型 | 用途   |\n  | :--: | :--: | :--: | :--: |\n  | BiFunction<T, U, R> | T, U | R | 对类型为 T, U 参数应用操作，返回 R 类型的结果。包含方法为： R apply(T t, U u); |\n  | UnaryOperator<T>(Function子接口) | T | T | 对类型为T的对象进行一元运算，并返回T类型的结果。包含方法为：T apply(T t); |\n  | BinaryOperator<T>(BiFunction 子接口) | T,T | T | 对类型为T的对象进行二元运算，并返回T类型的结果。包含方法为： T apply(T t1, T t2); |\n  | BiConsumer<T, U> | T, U | void | 对类型为T, U 参数应用操作。包含方法为： void accept(T t, U u) |\n  | BiPredicate<T,U> | T, U | boolean | 包含方法为： boolean test(T t,U u) |\n  | ToIntFunction<T><br/>ToLongFunction<T><br/>ToDoubleFunction<T> | T | int<br/>long<br/>double | 分别计算int、long、double值的函数 |\n  | IntFunction<R><br/>LongFunction<R><br/>DoubleFunction<R> | int<br/>long<br/>double | R | 参数分别为int、long、double 类型的函数 |\n\n\n# 方法引用与构造器引用\n\n## 方法引用\n\n* 当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！\n* 方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。\n* 要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！\n* 格式：使用操作符 “::” 将类(或对象) 与 方法名分隔开来。\n* 如下三种主要使用情况： \n  * 对象::实例方法名\n  * 类::静态方法名\n  * 类::实例方法名\n* 注意：当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二个参数是需要引用方法的参数(或无参数)时：ClassName::methodName\n\n```java\n//情况一： 对象 :: 实例方法\n//Consumer中的void accept(T t)\n//PrintStream中的void println(T t)\nConsumer<String> consumer = string -> System.out.println(string);\nconsumer.accept(\"背景\");\nSystem.out.println(\"*****************\");\nPrintStream out = System.out;\nConsumer<String> consumer1 =out::println;\nconsumer1.accept(\"beijing\");\n\n//情况二： 类 :: 静态方法\n//Comparator中的int compare(T t1,T t2)\n//Integer中的int compare(T t1,T t2)\nComparator<Integer> comparator = (t1,t2) -> Integer.compare(t1,t2);\nSystem.out.println(comparator.compare(12,35));\nSystem.out.println(\"********************\");\nComparator<Integer> comparator1 = Integer::compareTo;\nSystem.out.println(comparator1.compare(12,8));\n\n//情况三： 类 :: 实例方法\n//Comparator中的int compare(T t1,T t2)\n//String中的int t1.compareTo(t2);\nComparator<String> comparator = (t1, t2) -> t1.compareTo(t2);\nSystem.out.println(comparator.compare(\"as\", \"zx\"));\nSystem.out.println(\"******************\");\nComparator<String> comparator1 = String::compareTo;\nSystem.out.println(comparator1.compare(\"ds\", \"re\"));\n```\n\n## 构造器引用\n\n* 格式： ClassName::new \n* 与函数式接口相结合，自动与函数式接口中方法兼容。\n* 可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。\n\n```java\n//构造器引用\nSupplier<Person> supplier = ()->new Person();\nSystem.out.println(supplier.get());\nSystem.out.println(\"*************\");\nSupplier<Person> supplier1 = Person :: new;\nSystem.out.println(supplier1.get());\n```\n\n## 数组引用\n\n* 格式： type[] :: new\n\n```java\n//数组引用\nFunction<Integer,String[]> function = length -> new String[length];\nString[] arr1 = function.apply(5);\nSystem.out.println(Arrays.toString(arr1));\nSystem.out.println(\"********************\");\nFunction<Integer,String[]> function1 = String[]::new;\nString[] arr2 = function1.apply(10);\nSystem.out.println(Arrays.toString(arr2));\n```\n\n# StreamAPI\n\n* Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API。 \n\n* Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 \n\n* Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。\n\n* Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。\n\n* Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。\n\n* “集合讲的是数据，Stream讲的是计算！”\n\n* 注意：\n\n  * ①Stream 自己不会存储元素。\n  * ②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 \n  * ③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。\n\n* Stream 的操作三个步骤\n\n  * 创建 Stream\n    * 一个数据源（如：集合、数组），获取一个流\n  * 中间操作\n    * 一个中间操作链，对数据源的数据进行处理\n  * 终止操作(终端操作)\n    * 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184451.png)\n\n* 创建 Stream方式一：通过集合\n\n  * Java8 中的 Collection 接口被扩展，提供了两个获取流的方法： \n    * default Stream<E> stream() : 返回一个顺序流\n    * default Stream<E> parallelStream() : 返回一个并行流\n\n  ```java\n  //方式一：通过集合\n  List<Integer> list = new ArrayList<>();\n  list.add(2);\n  list.add(5);\n  list.add(3);\n  //default Stream<E> stream()：返回一个顺序流\n  Stream<Integer> stream = list.stream();\n  //default Stream<E> parallelStream()：返回一个并行流\n  Stream<Integer> integerStream = list.parallelStream();\n  ```\n\n* 创建 Stream方式二：通过数组\n\n  * Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：\n  * static <T> Stream<T> stream(T[] array): 返回一个流\n  * 重载形式，能够处理对应基本类型的数组：\n    * public static IntStream stream(int[] array)\n    * public static LongStream stream(long[] array)\n    * public static DoubleStream stream(double[] array)\n\n  ```java\n  //方式二：通过数组\n  int[] ints = new int[]{1,5,9,4};\n  //static <T>Stream<T> stream(T[] array)：返回一个流\n  IntStream stream1 = Arrays.stream(ints);\n  ```\n\n* 创建 Stream方式三：通过Stream的of()\n\n  * 可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数。\n  * public static<T> Stream<T> of(T... values) : 返回一个流\n\n  ```java\n  //方式三：通过Stream的of()\n  Stream<Integer> stream2 = Stream.of(1, 5, 9, 3);\n  ```\n\n* 创建 Stream方式四：创建无限流\n\n  * 可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。\n  * 迭代\n    * public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) \n  * 生成\n    * public static<T> Stream<T> generate(Supplier<T> s)\n\n  ```java\n  //方式四：创建无限流\n  //迭代的方式：遍历前10个偶数\n  //iterate(T seed, UnaryOperator<T> f)：seed:种子，初始值。f：要执行的操作\n  //limit(long maxSize)：maxSize:限制执行的次数\n  //forEach(Consumer<? super T> action)：action：终止操作，终止后执行的操作\n  Stream.iterate(0, t->t+2).limit(10).forEach(System.out::println);\n  //生成的方式：生成10个随机数\n  Stream.generate(Math::random).limit(10).forEach(System.out::println);\n  ```\n\n* Stream 的中间操作\n\n  * 多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。\n  * 1-筛选与切片\n\n  |        方 法        |                            描 述                             |\n  | :-----------------: | :----------------------------------------------------------: |\n  | filter(Predicate p) |              接收 Lambda ， 从流中排除某些元素               |\n  |     distinct()      | 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 |\n  | limit(long maxSize) |                截断流，使其元素不超过给定数量                |\n  |    skip(long n)     | 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补 |\n\n  ```java\n  List<Integer> list = new ArrayList<>();\n  list.add(5);\n  list.add(7);\n  list.add(3);\n  list.add(1);\n  //筛选和切片\n  //Stream<T> filter(Predicate<? super T> predicate)：接受Lambda，从流中排除一些元素\n  //输出list中值大于4的数\n  list.stream().filter(i->(i>4)).forEach(System.out::println);\n  System.out.println();\n  //Stream<T> limit(long maxSize)：截断流，使其元素不超过给定的数量\n  //输出前2个元素\n  list.stream().limit(2).forEach(System.out::println);\n  System.out.println();\n  //Stream<T> distinct()：筛选，通过流所生成元素的hashCode()和equals()方法去除重复元素\n  list.add(9);\n  list.add(9);\n  list.add(9);\n  //输出不含重复元素的数据\n  list.stream().distinct().forEach(System.out::println);\n  System.out.println();\n  //Stream<T> skip(long n):跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n个则返回一个空流\n  list.stream().skip(3).forEach(System.out::println);\n  ```\n\n  * 2-映 射\n\n  |              方 法              |                            描 述                             |\n  | :-----------------------------: | :----------------------------------------------------------: |\n  |         map(Function f)         | 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 |\n  | mapToDouble(ToDoubleFunction f) | 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。 |\n  |    mapToInt(ToIntFunction f)    | 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。 |\n  |   mapToLong(ToLongFunction f)   | 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。 |\n  |       flatMap(Function f)       | 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 |\n\n  ```java\n  //映射\n  List<String> list1 = new ArrayList<>();\n  list1.add(\"aa\");\n  list1.add(\"bb\");\n  list1.add(\"cc\");\n  //Stream<R> map(Function mapper)：接受一个函数作为参数，函数会被应用到所有的元素上，并将映射后的元素构建成一个流后输出.\n  //函数表示映射关系\n  //将字符串都转换成大写的，然后输出\n  list1.stream().map(String::toUpperCase).forEach(System.out::println);\n  //Stream<R> flatMap(Function mapper)：接受一个函数作为参数。元素经函数转换后的变成新元素\n  //如果这个新元素是一个流，则将所有新元素流中的元素都取出从新构成一个大流，然后返回这个大流\n  //换句话说，这个大流中的元素：是新元素流中的元素，而不是新元素流。\n  Stream<Character> characterStream = list1.stream().flatMap(str -> toStream(str));\n  characterStream.forEach(System.out::println);\n  //对照map(Function mapper)方法\n  Stream<Stream<Character>> streamStream = list1.stream().map(str -> toStream(str));\n  streamStream.forEach(s->{\n      s.forEach(System.out::println);\n  });\n  ```\n\n  * 3-排序\n\n  |          方法          |                描述                |\n  | :--------------------: | :--------------------------------: |\n  |        sorted()        |  产生一个新流，其中按自然顺序排序  |\n  | sorted(Comparator com) | 产生一个新流，其中按比较器顺序排序 |\n\n  ```java\n  //排序\n  //Stream<T> sorted():返回自然排序后的流\n  list.stream().sorted().forEach(System.out::println);\n  //Stream<T> sorted(Comparator comparator):返回定制排序后的流\n  list.stream().sorted(Integer::compareTo).forEach(System.out::println);\n  ```\n\n* Stream 的终止操作\n\n  * 终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void \n  * 流进行了终止操作后，不能再次使用。\n  * 1-匹配与查找\n\n  |          方法          |                             描述                             |\n  | :--------------------: | :----------------------------------------------------------: |\n  | allMatch(Predicate p)  |                     检查是否匹配所有元素                     |\n  | anyMatch(Predicate p)  |                   检查是否至少匹配一个元素                   |\n  | noneMatch(Predicate p) |                   检查是否没有匹配所有元素                   |\n  |      findFirst()       |                        返回第一个元素                        |\n  |       findAny()        |                    返回当前流中的任意元素                    |\n  |        count()         |                       返回流中元素总数                       |\n  |   max(Comparator c)    |                        返回流中最大值                        |\n  |   min(Comparator c)    |                        返回流中最小值                        |\n  |  forEach(Consumer c)   | 内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代——它帮你把迭代做了) |\n\n  ```java\n  List<Integer> list= new ArrayList<>();\n  list.add(8);\n  list.add(6);\n  list.add(4);\n  list.add(5);\n  //匹配与查找\n  //boolean allMatch(Predicate predicate):对于每个元素predicate都返回true，则allMatch返回true\n  boolean b1 = list.stream().allMatch(i -> (i > 4));\n  System.out.println(b1);\n  //boolean anyMatch(Predicate predicate):对于每个元素predicate有一个返回true，则anyMatch返回true\n  boolean b2 = list.stream().anyMatch(i -> (i > 4));\n  System.out.println(b2);\n  //boolean noneMatch(Predicate predicate):对于每个元素predicate都返回false，则noneMatch返回true\n  boolean b3 = list.stream().noneMatch(i -> (i > 4));\n  System.out.println(b3);\n  //Optional<T> findFirst()：返回第一个元素\n  Optional<Integer> first = list.stream().findFirst();\n  System.out.println(first);\n  //Optional<T> findAny()：返回随机的元素\n  Optional<Integer> any = list.parallelStream().findAny();\n  System.out.println(any);\n  //long count()：返回元素的个数\n  long count = list.stream().count();\n  System.out.println(count);\n  //Optional<T> max(Comparator comparator)：返回排序后的最大值\n  Optional<Integer> max = list.stream().max(Integer::compareTo);\n  System.out.println(max);\n  //Optional<T> min(Comparator comparator)：返回排序后的最小值\n  Optional<Integer> min = list.stream().min(Integer::compareTo);\n  System.out.println(min);\n  //void forEach(Consumer action):内部迭代\n  list.stream().forEach(System.out::println);\n  ```\n\n  * 2-归约\n\n  |               方法               |                           描述                           |\n  | :------------------------------: | :------------------------------------------------------: |\n  | reduce(T iden, BinaryOperator b) |      可以将流中元素反复结合起来，得到一个值。返回 T      |\n  |     reduce(BinaryOperator b)     | 可以将流中元素反复结合起来，得到一个值。返回 Optional<T> |\n\n  * 备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。\n\n  ```java\n  //规约\n  List<Integer> list1 = Arrays.asList(1,2,3,4,5,6,7,8,9,10);\n  //T reduce(T identity, BinaryOperator accumulator)：从初始值开始，将流中的元素返回结合起来得到一个值\n  //identity：初始值\n  //计算前十个数的和\n  Integer reduce = list1.stream().reduce(0, Integer::sum);\n  System.out.println(reduce);\n  //Optional<T> reduce(BinaryOperator<T> accumulator)：将流中的元素返回结合起来得到一个值\n  //计算前十个数的和\n  Optional<Integer> reduce1 = list1.stream().reduce(Integer::sum);\n  System.out.println(reduce1);\n  ```\n\n  * 3-收集\n\n  |        方 法         |                            描 述                             |\n  | :------------------: | :----------------------------------------------------------: |\n  | collect(Collector c) | 将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法 |\n\n  ```java\n  //收集\n  //collect(Collector collector):将流转换成其他的形式。接受一个Collectors接口的实现方法，\n  List<Integer> collect = list1.stream().collect(Collectors.toList());\n  collect.forEach(System.out::println);\n  ```\n\n* Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。\n\n* 另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，\n  具体方法与实例如下表：\n\n  |       方法        |       返回类型        |                             作用                             |\n  | :---------------: | :-------------------: | :----------------------------------------------------------: |\n  |      toList       |        List<T>        |                     把流中元素收集到List                     |\n  |       toSet       |        Set<T>         |                     把流中元素收集到Set                      |\n  |   toCollection    |     Collection<T>     |                  把流中元素收集到创建的集合                  |\n  |     counting      |         Long          |                      计算流中元素的个数                      |\n  |    summingInt     |        Integer        |                   对流中元素的整数属性求和                   |\n  |   averagingInt    |        Double         |               计算流中元素Integer属性的平均值                |\n  |  summarizingInt   | IntSummaryStatistics  |           收集流中Integer属性的统计值。如：平均值            |\n  |      joining      |        String         |                      连接流中每个字符串                      |\n  |       maxBy       |      Optional<T>      |                     根据比较器选择最大值                     |\n  |       minBy       |      Optional<T>      |                     根据比较器选择最小值                     |\n  |     reducing      |    归约产生的类型     | 从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值 |\n  | collectingAndThen |  转换函数返回的类型   |              包裹另一个收集器，对其结果转换函数              |\n  |    groupingBy     |    Map<K, List<T>>    |            根据某属性值对流分组，属性为K，结果为V            |\n  |  partitioningBy   | Map<Boolean, List<T>> |                   根据true或false进行分区                    |\n\n  * 举例\n\n  ```java\n  List<Employee> emps= list.stream().collect(Collectors.toList());\n  Set<Employee> emps= list.stream().collect(Collectors.toSet());\n  Collection<Employee> emps =list.stream().collect(Collectors.toCollection(ArrayList::new));\n  long count = list.stream().collect(Collectors.counting());\n  int total=list.stream().collect(Collectors.summingInt(Employee::getSalary));\n  double avg = list.stream().collect(Collectors.averagingInt(Employee::getSalary));\n  int SummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary));\n  String str= list.stream().map(Employee::getName).collect(Collectors.joining());\n  Optional<Emp>max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));\n  Optional<Emp> min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));\n  int total=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));\n  int how= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));\n  Map<Emp.Status, List<Emp>> map= list.stream().collect(Collectors.groupingBy(Employee::getStatus));\n  Map<Boolean,List<Emp>> vd = list.stream().collect(Collectors.partitioningBy(Employee::getManage));\n  ```\n\n# Optional类\n\n* 到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。\n\n* Optional<T> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 \n\n* Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。\n\n* Optional提供很多有用的方法，这样我们就不用显式进行空值检测。\n\n* 创建Optional类对象的方法：\n\n  |           方法           |                作用                 |\n  | :----------------------: | :---------------------------------: |\n  |     Optional.of(T t)     | 创建一个 Optional 实例，t必须非空； |\n  |     Optional.empty()     |     创建一个空的 Optional 实例      |\n  | Optional.ofNullable(T t) |             t可以为null             |\n\n* 判断Optional容器中是否包含对象：\n\n  |                     方法                     |                             作用                             |\n  | :------------------------------------------: | :----------------------------------------------------------: |\n  |             boolean isPresent()              |                       判断是否包含对象                       |\n  | void ifPresent(Consumer<? super T> consumer) | 如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。 |\n\n* 获取Optional容器的对象：\n\n  |                          方法                          |                            作用                            |\n  | :----------------------------------------------------: | :--------------------------------------------------------: |\n  |                        T get()                         |          如果调用对象包含值，返回该值，否则抛异常          |\n  |                   T orElse(T other)                    |       如果有值则将其返回，否则返回指定的other对象。        |\n  |        T orElseGet(Supplier<? extends T> other)        | 如果有值则将其返回，否则返回由Supplier接口实现提供的对象。 |\n  | T orElseThrow(Supplier<? extends X> exceptionSupplier) | 如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。 |\n\n```java\n//Optional.of(T t)：创建一个值为t的Optional实例。t不可以为空\nBoy boy = new Boy();\nOptional<Boy> optionalBoy1 = Optional.of(boy);\nSystem.out.println(optionalBoy1);\n//Optional.ofNullable(T t)：创建一个值为t的Optional实例。t可以为空\nboy=null;\nOptional<Boy> optionalBoy2 = Optional.ofNullable(boy);\nSystem.out.println(optionalBoy2);\n//T orElse(T other):如果对象不为空则返回对象的值，如果对象为空则返回other\nBoy cl = optionalBoy2.orElse(new Boy(new Student(\"cl\")));\nSystem.out.println(cl);\n```\n\n# 总结\n\n```java\n * Lambda表达式的使用\n *  1.举例：(o1,o2) -> Integer.compare(o1,o2);\n *  2.格式：\n *      -> ：lambda操作符 或 箭头操作符\n *          左边：lambda形参列表 (其实就是接口中抽象方法的形参列表)\n *          右边：lambda体 (其实就是重写的抽象方法的方法体)\n *  3.Lambda表达式的使用：(6种情况)\n *      总结：\n *         ① 左边参数列表\n *              没有参数时一个小括号即可\n *              只有一个参数时，可以将参数类型和小括号都省略\n *              有多个参数时，可以省略参数类型，不能省略小括号\n *         ② 右边：正常时，由一对大括号包裹\n *              当只有一条执行语句语句(或只有一条返回语句),大括号也可以省略\n *         ③  要求接口是函数式接口\n *  4.Lambda表达式的本质：作为接口的实例\n * 函数式接口：只有一个抽象方法的接口就是一个函数式接口。\n *      一般情况下在函数式接口上用@FunctionalInterface注解标识，此注解可以判断这个接口是否是一个函数式接口\n * 方法引用的使用\n *      1.使用情景：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用\n *      2.方法引用，本质就是Lambda表达式，而Lambda表达式作为函数式接口的实例。\n *          所以方法引用也是函数式接口的实例\n *      3.使用格式： 类(或对象) :: 方法名\n *      4.使用情况：\n *          ① 对象 :: 非静态方法\n *          ② 类 :: 静态方法\n *          ③ 类 :: 实例方法\n *      5.使用要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的一样\n *      6.构造器引用：和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。\n *              抽象方法的返回值类型即为构造器所属的类的类型\n *      7.数组引用：当把数组看成一个特殊的类，则写法与构造器引用相同\n * StreamAPI\n *      1.Stream关注的式对数据的运算，与CPU打交道\n *          集合关注的是数据的存储，与内存打交道。\n *      2.Stream自己不会存储元素；\n *        Stram不会改变源对象。相反，他们会返回一个持有结果的新Stream;\n *        Stream操作是延迟执行的，这意味着它们会等到需要结果的时候才执行。\n *      3.Stream执行流程：\n *          ① Stream的实例化\n *          ② 一系列中间操作(过滤，映射)\n *          ③ 终止操作\n *      4.说明：\n *          ① 一个中间操作链，对数据源的数据进行处理\n *          ② 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用\n```\n\n\n\n","categories":["Java学习","Java高级语法"]},{"title":"Java常用类","url":"/2020/12/07/尚硅谷说Java/Java高级语法/2-Java常用类/","content":"\n包含字符串，日期，数组，排序，以及大数的表示\n\n<!--more-->\n# 字符串相关的类\n## String的特性\n* String类：代表字符串。Java 程序中的所有字符串字面值（如 \"abc\" ）都作为此类的实例实现。\n* String是一个final类，代表不可变的字符序列。 \n* 字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。 \n* String对象的字符内容是存储在一个字符数组value[]中的。\n* 部分源码\n```java\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n}\n```\n* String对象的创建\n  ```java\n   String str = \"hello\";\n  //本质上this.value = new char[0];\n  String s1 = new String(); \n  //this.value = original.value;\n  String s2 = new String(String original); \n  //this.value = Arrays.copyOf(value, value.length);\n  String s3 = new String(char[] a); \n  String s4 = new String(char[] a,int startIndex,int count);\n  ```\n* String的赋值方法：字面量赋值；构造方法赋值\n  * 字面量赋值：字符串常量存储在字符串常量池，目的是共享。\n  ```java\n  //在内存的字符串常量池中开辟了一块空间存放“abc\"，假设地址为0x1212\n  //s1指向0x1212\n  String s1 = \"abc\";\n  //s2指向0x1212\n  String s2 = \"abc\";\n  System.out.println(s1 == s2);\n \n  //在内存的字符串常量池中又开辟了一块空间存放“hello\"\n  s1 = \"hello\";\n  System.out.println(s1 == s2);\n  System.out.println(s1);\n  System.out.println(s2);\n  \n  //s3指向0x1212\n  String s3 = \"abc\";\n  //由s3指向：在堆空间内开辟了一片空间存放”abcdef\"\n  s3 += \"def\";\n  //由s6指向：在字符串常量池内开辟了一片空间存放”abcdef\"\n  String s6 = \"abcdef\";\n  System.out.println(s3 == s6);//false\n  System.out.println(s3);\n  System.out.println(s2);\n  //s4指向0x1212\n  String s4 = \"abc\";\n  //s4不变。\n  // s5指向 ：在内存的字符串常量池中又开辟了一块空间存放“mbc\"\n  String s5 = s4.replace('a', 'm');\n  System.out.println(s4);\n  System.out.println(s5);\n  ```\n  * 构造方法赋值：字符串非常量对象存储在堆中。\n  ```java\n  //在堆空间中开辟了一个存放String对象的空间0x1111\n  //在内存的字符串常量池中开辟了一块空间存放“abc\"，假设地址为0x1212\n  //s1指向0x1111,s1中的value属性指向0x1212\n  String s1 = new String(\"abc\");\n  //在堆空间中开辟了一个存放String对象的空间0x2222\n  //s2指向0x2222,s2中的value属性指向0x1212\n  String s2 = new String(\"abc\");\n  //s3指向0x1212\n  String s3 = \"abc\";\n  System.out.println(s1 == s2);//false\n  System.out.println(s1 == s3);//false\n  \n  //在堆空间中开辟了一个存放Person对象的空间0x3333\n  //person1指向0x3333,person1中的属性name指向0x1212\n  Person person1 = new Person(\"abc\",11);\n  //在堆空间中开辟了一个存放Person对象的空间0x4444\n  //person2指向0x4444,person2中的属性name指向0x1212\n  Person person2 = new Person(\"abc\",12);\n  System.out.println(person1.name == person2.name);//true\n  ```\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184348.png)\n* 字符串的特性\n  * 常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。 \n  * 只要其中有一个是变量，结果就在堆中\n  * 如果拼接的结果调用intern()方法，返回值就在常量池中\n  ```java\n  //s1,s2的指向在常量池中\n  String s1 = \"abc\";\n  String s2 = \"def\";\n  //s3,s4的指向在常量池中\n  String s3 = \"abcdef\";\n  String s4 = \"abc\"+\"def\";\n  //s5,s6的指向在堆中\n  String s5 = s1+\"def\";\n  String s6 = \"abc\" + s2;\n  //s7的指向在常量池中\n  String s7 = s5.intern();\n  System.out.println(s3 == s4);//true\n  System.out.println(s3 == s5);//false\n  System.out.println(s3 == s6);//false\n  System.out.println(s5 == s6);//false\n  System.out.println(s3 == s7);//true\n  System.out.println(s5 == s7);//false\n  \n  String str1 = \"abcdef\";\n  final String str2 = \"abc\";\n  String str3 = str2 + \"def\";\n  //由于str2在声明时就被确认为常量，因此str3右边的赋值操作中两个都是常量\n  System.out.println(str1 == str3);//true\n  ```\n* String使用陷阱\n  ```java\n  String s1 = \"a\"; \n  说明：在字符串常量池中创建了一个字面量为\"a\"的字符串。\n      \n  s1 = s1 + \"b\"; \n  说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+\"b\"（也就是\"ab\")。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。 \n      \n  String s2 = \"ab\";\n  说明：直接在字符串常量池中创建一个字面量为\"ab\"的字符串。\n      \n  String s3 = \"a\" + \"b\";\n  说明：s3指向字符串常量池中已经创建的\"ab\"的字符串。\n      \n  String s4 = s1.intern();\n  说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的\"ab\"字符串赋值给s4。\n  ```\n* String常用的方法\n  ```java\n  int length()：返回字符串的长度： return value.length\n  char charAt(int index)： 返回某索引处的字符return value[index] \n  boolean isEmpty()：判断是否是空字符串：return value.length == 0 \n  String toLowerCase()：使用默认语言环境，将 String 中的所有字符转换为小写\n  String toUpperCase()：使用默认语言环境，将 String 中的所有字符转换为大写\n  String trim()：返回字符串的副本，忽略前导空白和尾部空白\n  boolean equals(Object obj)：比较字符串的内容是否相同\n  boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写\n  String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”\n  int compareTo(String anotherString)：比较两个字符串的大小\n  String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。\n  String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。\n  ---------------------------------------------------------------------------\n  \t\tString s1 = \"helloworld\";\n          //返回字符串的长度\n          System.out.println(s1.length());\n          // 返回某索引处的字符\n          System.out.println(s1.charAt(2));\n          //判断是否是空字符串：根据字符串长度判断，长度等于0则为空\n          System.out.println(s1.isEmpty());\n          String s2 = \"\";\n          System.out.println(s2.isEmpty());\n  \n          //转换为大写\n          String s3 = s1.toUpperCase();\n          //转换为小写\n          String s4 = s3.toLowerCase();\n          System.out.println(s1);\n          System.out.println(s3);\n          System.out.println(s4);\n          String s5 = \"  asd fgh  \";\n          System.out.println(\"---\" + s5 + \"---\");\n          //返回字符串忽略前导空白和尾部空白后的副本\n          System.out.println(\"---\" + s5.trim() + \"---\");\n          //比较字符串的内容是否相同\n          System.out.println(s4.equals(s1));\n          //比较字符串的内容是否相同。忽略大小写\n          System.out.println(s3.equalsIgnoreCase(s1));\n          //将指定字符串连接到此字符串的结尾。\n          String s6 = s1.concat(\"pig\");\n          System.out.println(s6);\n          String s7 = \"abc\";\n          String s8 = \"abe\";\n          //比较两个字符串的大小，返回差值\n          System.out.println(s7.compareTo(s8));\n          //返回一个新的字符串，从给定位置开始截取，到最后\n          System.out.println(s1.substring(5));\n          //返回一个新的字符串，从给定位置开始截取，到给定的位置截止。前闭后开\n          System.out.println(s1.substring(5, 10));    \n  ---------------------------------------------------------------------------\n  boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束\n  boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始\n  boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始\n  boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true\n  int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引\n  int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始\n  int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引\n  int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索\n  注：indexOf和lastIndexOf方法如果未找到都是返回-1    \n  ---------------------------------------------------------------------------\n      \tString str1 = \"helloworld\";\n          //返回字符串是否以指定的后缀结束\n          System.out.println(str1.endsWith(\"ld\"));\n          //返回此字符串是否以指定的前缀开始\n          System.out.println(str1.startsWith(\"he\"));\n          //返回字符串从指定索引开始往后的子字符串是否以指定前缀开始\n          System.out.println(str1.startsWith(\"lo\",3));\n  \n          //返回指定的字符串是否是字符串的子串\n          System.out.println(str1.contains(\"wor\"));\n          //返回指定子字符串在此字符串中第一次出现处的索引\n          System.out.println(str1.indexOf(\"lo\"));\n          //返回从指定索引开始往后的字符串中指定子字符串第一次出现的索引\n          System.out.println(str1.indexOf(\"wo\", 2));\n          String str2 = \"helohelohelo\";\n          //返回指定子字符串在此字符串中最右边出现处的索引\n          System.out.println(str2.lastIndexOf(\"he\"));\n          //返回从指定索引开始往前的字符串中指定子字符串最右边出现处的索引\n          System.out.println(str2.lastIndexOf(\"he\", 7));\n  ---------------------------------------------------------------------------\n  String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 \n  String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。 \n  String replaceAll(String regex, String replacement) ： 使 用 给 定 的\n  replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 \n  String replaceFirst(String regex, String replacement) ： 使 用 给 定 的\n  replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 \n  boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。 \n  String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。 \n  String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。\n  ```\n* 字符串与其他类型之间的转换\n  * 字符串 --> 基本数据类型、包装类\n    * Integer包装类的public static int parseInt(String s)：可以将由“数字”字符组成的字符串转换为整型。\n    * 类似地,使用java.lang包中的Byte、Short、Long、Float、Double类调相应的类方法可以将由“字”字符组成的字符串，转化为相应的基本数据类型。\n  * 基本数据类型、包装类 --> 字符串\n    * 调用String类的public String valueOf(int n)可将int型转换为字符串\n    * 相应的valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double d)、valueOf(boolean b)可由参数的相应类型到字符串的转换\n  * 字符数组 --> 字符串\n    * String 类的构造器：String(char[]) 和 String(char[]，int offset，int length) 分别用字符数组中的全部字符和部分字符创建字符串对象。\n* 字符串 --> 字符数组\n    * public char[] toCharArray()：将字符串中的全部字符存放在一个字符数组中的方法。\n  * public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)：提供了将指定索引范围内的字符串存放到数组中的方法。\n* 字节数组 --> 字符串\n    * String(byte[])：通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。 \n  * String(byte[]，int offset，int length) ：用指定的字节数组的一部分，即从数组起始位置offset开始取length个字节构造一个字符串对象。 \n  * 字符串 --> 字节数组\n  * public byte[] getBytes() ：使用平台的默认字符集将此 String 编码为byte 序列，并将结果存储到一个新的 byte 数组中。 \n    * public byte[] getBytes(String charsetName) ：使用指定的字符集将 此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。\n  ```java\n  String s = \"TRUE\";\n  boolean b = Boolean.parseBoolean(s);\n  System.out.println(b);\n  \n  String string = \"sadad\";\n  char[] chars = string.toCharArray();\nSystem.out.println(Arrays.toString(chars));\n  \n  String string1 = new String(chars);\n  System.out.println(string1);\n  \n  String str1 = \"123asd中国\";\n  //以默认编码方式编码\n  byte[] bytes = str1.getBytes();\n  System.out.println(Arrays.toString(bytes));\n  byte[] gbks=null;\n  try {\n      //以gbk编码方式编码\n      gbks = str1.getBytes(\"gbk\");\n      System.out.println(Arrays.toString(gbks));\n  } catch (UnsupportedEncodingException e) {\n      e.printStackTrace();\n  }\n  \n  //以默认的解码方式解码\n  String str2 = new String(bytes);\n  System.out.println(str2);\n  \n  //输出乱码：因为解码方式与编码方式不一致\n  String str3 = new String(gbks);\n  System.out.println(str3);\n  \n  try {\n      String str4 = new String(gbks, \"gbk\");\n      //输出正常：因为解码方式与编码方式相同\n      System.out.println(str4);\n  } catch (UnsupportedEncodingException e) {\n      e.printStackTrace();\n  }\n  ```\n## StringBuffer类\n* java.lang.StringBuffer代表可变的字符序列，JDK1.0中声明，可以对字符\n  串内容进行增删，此时不会产生新的对象。\n* 很多方法与String相同。\n* 作为参数传递时，方法内部可以改变值。\n* StringBuffer类不同于String，其对象必须使用构造器生成。有三个构造器： \n  * StringBuffer()：初始容量为16的字符串缓冲区\n  * StringBuffer(int size)：构造指定容量的字符串缓冲区\n  * StringBuffer(String str)：将内容初始化为指定字符串内容\n* StringBuffer类的常用方法\n  ```java\n  StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接\n  StringBuffer delete(int start,int end)：删除指定位置的内容\n  StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str\n  StringBuffer insert(int offset, xxx)：在指定位置插入xxx\n  StringBuffer reverse() ：把当前字符序列逆转\n  当append和insert时，如果原来value数组长度不够，可扩容。 \n  \n  此外，还定义了如下的方法：\n  public int indexOf(String str)\n  public String substring(int start,int end)\n  public int length()\n  public char charAt(int n )\n  public void setCharAt(int n ,char ch)\n  ---------------------------------------------------------------------------\n  \t\tStringBuffer stringBuffer = new StringBuffer(\"abcdef\");\n          //返回字符串存储字符的数量\n          System.out.println(stringBuffer.length());\n  \n          //在原有字符串后拼接字符串\n          stringBuffer.append(\"asd\");\n          System.out.println(stringBuffer);\n  \n          //删除指定范围内的字符，前闭后开\n          stringBuffer.delete(2, 4);;\n          System.out.println(stringBuffer);\n  \n          //修改指定位置的字符\n          stringBuffer.setCharAt(5,'y');\n          System.out.println(stringBuffer);\n  \n          //修改指定范围内的字符字符串，前闭后开\n          stringBuffer.replace(2, 4, \"china\");\n          System.out.println(stringBuffer);\n  \n          //在指定位置上插入字符串\n          stringBuffer.insert(2, \"hello\");\n          System.out.println(stringBuffer);\n  ```\n## StringBuilder类\n* StringBuilder 和 StringBuffer 非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样\n* 面试题：对比String、StringBuffer、StringBuilder\n  * String(JDK1.0)：不可变字符序列\n  * StringBuffer(JDK1.0)：可变字符序列、效率低、线程安全\n  * StringBuilder(JDK 5.0)：可变字符序列、效率高、线程不安全\n  * 注意：作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值。\nString与StringBuffer，StringBuilder的效率的差别\n```java\n//初始设置\nlong startTime = 0L;\nlong endTime = 0L;\nString text = \"\";\nStringBuffer buffer = new StringBuffer(\"\");\nStringBuilder builder = new StringBuilder(\"\");\n//开始对比\nstartTime = System.currentTimeMillis();\nfor (int i = 0; i < 20000; i++) {\n    buffer.append(String.valueOf(i));\n}\nendTime = System.currentTimeMillis();\nSystem.out.println(\"StringBuffer的执行时间：\" + (endTime - startTime));\nstartTime = System.currentTimeMillis();\nfor (int i = 0; i < 20000; i++) {\n    builder.append(String.valueOf(i));\n}\nendTime = System.currentTimeMillis();\nSystem.out.println(\"StringBuilder的执行时间：\" + (endTime - startTime));\nstartTime = System.currentTimeMillis();\nfor (int i = 0; i < 20000; i++) {\n    text = text + i; }\nendTime = System.currentTimeMillis();\nSystem.out.println(\"String的执行时间：\" + (endTime - startTime));\n//实际的一次记录：StringBuffer的执行时间：4\n//             StringBuilder的执行时间：1\n//             String的执行时间：1057\n```\n# 日期时间API\n## JDK8之前的\n* 继承关系图\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184349.png)\n*  java.lang.System类\n  * System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。\n    * 此方法适于计算时间差。\n  ```java\n  long time = System.currentTimeMillis();\n  ```\n* 计算世界时间的主要标准有：\n  * UTC(Coordinated Universal Time)\n  * GMT(Greenwich Mean Time) 格林威治标准时间\n  * CST(Central Standard Time) 中部标准时间\n* java.util.Date类\n  * 表示特定的瞬间，精确到毫秒\n  *  构造器： \n    * Date()：使用无参构造器创建的对象可以获取本地当前时间。\n    * Date(long date)\n  * 常用方法\n    * getTime():返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。\n    * toString():把此 Date 对象转换为以下形式的 String： dow mon ddhh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准。 \n    * 其它很多方法都过时了。\n  ```java\n  //构造器一：创建一个当前时间的Date对象\n  Date date1 = new Date();\n  //getTime()方法：返回date对象对应的毫秒数\n  System.out.println(date1.getTime());\n  //toString():Date重写了这个方法；方法返回Date对象的年，月，日，时，分，秒，星期\n  System.out.println(date1.toString());\n  //构造器二：创建一个指定毫秒时间(时间戳)的Date对象\n  Date date2 = new Date(1604639688137L);\n  System.out.println(date2.getTime());\n  System.out.println(date2.toString());\n  \n  java.sql.Date date3 = new java.sql.Date(1604639688137L);\n  System.out.println(date3.toString());\n  ```\n* java.text.SimpleDateFormat类 \n  * java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类。\n  * 它允许进行格式化：日期 --> 文本；解析：文本 --> 日期。\n  * 格式化：\n    *  SimpleDateFormat() ：默认的模式和语言环境创建对象\n    *  public SimpleDateFormat(String pattern)：该构造方法可以用参数pattern\n      指定的格式创建一个对象，该对象调用： \n    * public String format(Date date)：方法格式化时间对象date\n  * 解析：\n    * public Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期。\n  ```java\n  //实例化SimpleDateFormat\n  SimpleDateFormat simpleDateFormat = new SimpleDateFormat();\n  \n  Date date1= new Date();\n  System.out.println(date1);\n  //格式化：日期 --->字符串\n  String format = simpleDateFormat.format(date1);\n  System.out.println(format);\n  \n  //解析：字符串 --->日期。解析堆字符串的样式由一定要求\n  String string =  \"20-11-6 下午2:06\";\n  Date date2 = simpleDateFormat.parse(string);\n  System.out.println(date2);\n  \n  SimpleDateFormat simpleDateFormat1 = new SimpleDateFormat(\"yyyy.MM.dd hh:mm:ss\");\n  //格式化\n  String format1 = simpleDateFormat1.format(date1);\n  System.out.println(format1);\n  //解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现)，否则抛异常\n  Date date3 = simpleDateFormat1.parse(format1);\n  System.out.println(date3);\n  ```\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184350.png)\n* java.util.Calendar(日历)类 \n  * Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。\n  *  获取Calendar实例的方法\n    * 使用Calendar.getInstance()方法\n    * 调用它的子类GregorianCalendar的构造器。\n  * 一个Calendar的实例是系统时间的抽象表示，通过get(int field)方法来取得想要的时间信息。比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND\n    * public void set(int field,int value)   设置操作\n    * public void add(int field,int amount)  增加操作\n    * public final Date getTime()  //获取操作\n    * public final void setTime(Date date)  //设置操作\n  *  注意: \n    * 获取月份时：一月是0，二月是1，以此类推，12月是11\n    * 获取星期时：周日是1，周二是2 ， 。。。。周六是7\n  ```java\n  //GregorianCalendar\n  Calendar instance = Calendar.getInstance();\n  System.out.println(instance.getClass());\n  //get()方法的使用\n  //获取instance中的日期是这个月中的第几天\n  System.out.println(instance.get(Calendar.DAY_OF_MONTH));\n  //获取instance中的日期是这个星期中的第几天\n  System.out.println(instance.get(Calendar.DAY_OF_WEEK));\n  //set()方法\n  //设置instance中的日期是这个月的第10天\n  instance.set(Calendar.DAY_OF_MONTH, 10);\n  //add()方法\n  //instance中的日期是这个月的第几天的基础上加上几天\n  instance.add(Calendar.DAY_OF_MONTH, 5);\n  //getTime()方法：日历类 --> Date\n  Date date = instance.getTime();\n  System.out.println(date);\n  //setTime()方法: Date --> 日历类\n  Date date1 = new Date();\n  instance.setTime(date1);\n  System.out.println(instance.get(Calendar.DAY_OF_MONTH));\n  ```\n## JDK8以后的\n* Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。新的 java.time 中包含了所有关于本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了日期时间和本地化的管理。\n* 新时间日期API\n  * java.time – 包含值对象的基础包\n  * java.time.chrono – 提供对不同的日历系统的访问\n  * java.time.format – 格式化和解析时间和日期\n  * java.time.temporal – 包括底层框架和扩展特性\n  * java.time.zone – 包含时区支持的类\n* LocalDate、LocalTime、LocalDateTime 类\n  * 它们的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。\n  * 它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。 \n  * LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期。\n  * LocalTime表示一个时间，而不是日期。 \n  * LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。\n  * 注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历。\n  * 常用方法\n\n  |                             方法                             |                             描述                             |\n  | :----------------------------------------------------------: | :----------------------------------------------------------: |\n  |     <font color=\"red\">now() / * now(ZoneId zone)</font>      |        静态方法，根据当前时间创建对象/指定时区的对象         |\n  |                <font color=\"red\">of()</font>                 |             静态方法，根据指定日期/时间创建对象              |\n  |   <font color=\"blue\">getDayOfMonth()/getDayOfYear()</font>   |           获得月份天数(1-31) /获得年份天数(1-366)            |\n  |           <font color=\"blue\">getDayOfWeek()</font>           |            获得星期几(返回一个 DayOfWeek 枚举值)             |\n  |             <font color=\"blue\">getMonth()</font>             |               获得月份, 返回一个 Month 枚举值                |\n  |    <font color=\"blue\">getMonthValue() / getYear()</font>     |                   获得月份(1-12) /获得年份                   |\n  | <font color=\"blue\">getHour()/getMinute()/getSecond()</font>  |               获得当前对象对应的小时、分钟、秒               |\n  | <font color=\"green\">withDayOfMonth()/withDayOfYear()/withMonth()/withYear()</font> | 将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象 |\n  | <font color=\"purple\">plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours()</font> |        向当前对象添加几天、几周、几个月、几年、几小时        |\n  | <font color=\"purple\">minusMonths() / minusWeeks()/minusDays()/minusYears()/minusHours()</font> |         从当前对象减去几月、几周、几天、几年、几小时         |\n  ```java\n  //now()：获取当前的日期，时间，日期+时间\n  LocalDate localDate = LocalDate.now();\n  LocalTime localTime = LocalTime.now();\n  LocalDateTime localDateTime = LocalDateTime.now();\n  System.out.println(localTime);\n  System.out.println(localDate);\n  System.out.println(localDateTime);\n  //of():设置指定的年，月，日，时，分，秒。\n  LocalDateTime of = LocalDateTime.of(2020, 11, 1, 10, 5, 20);\n  System.out.println(of);\n  //getXxx()：获取一些时间的信息\n  System.out.println(localDateTime.getDayOfMonth());\n  System.out.println(localDateTime.getDayOfWeek());\n  System.out.println(localDateTime.getDayOfYear());\n  System.out.println(localDateTime.getHour());\n  System.out.println(localDateTime.getMonth());\n  System.out.println(localDateTime.getMonthValue());\n  //withXxx()：设置一些时间的信息，返回新的对象\n  //体现了不可变性\n  LocalDateTime localDateTime1 = localDateTime.withDayOfMonth(22);\n  System.out.println(localDateTime);\n  System.out.println(localDateTime1);\n  //plusXxx():加时间操作\n  LocalDateTime localDateTime2 = localDateTime.plusDays(5);\n  System.out.println(localDateTime);\n  System.out.println(localDateTime2);\n  //minusXxx():减时间操作\n  LocalDateTime localDateTime3 = localDateTime.minusDays(6);\n  System.out.println(localDateTime3);\n  System.out.println(localDateTime);\n  ```\n*  瞬时：Instant类\n  * Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。 \n  * 在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位。\n  * java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。 \n  * (1 ns = 10-9 s) 1秒 = 1000毫秒 =10^6微秒=10^9纳秒\n  * 常用方法\n  |                          方法                          |                             描述                             |\n  | :----------------------------------------------------: | :----------------------------------------------------------: |\n  |             <font color=\"red\">now()</font>             |          静态方法，返回默认UTC时区的Instant类的对象          |\n  | <font color=\"red\">ofEpochMilli(long epochMilli)</font> | 静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象 |\n  | <font color=\"blue\">atOffset(ZoneOffset offset)</font>  |           结合即时的偏移来创建一个 OffsetDateTime            |\n  |       <font color=\"green\">toEpochMilli()</font>        |    返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳     |\n  *  时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。\n  ```java\n  //now():获取基于本初子午线对应的标准时间\n  Instant instant = Instant.now();\n  System.out.println(instant);\n  //atOffset()添加事件的偏移量\n  OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8));\n  System.out.println(offsetDateTime);\n  //toEpochMilli()：获取自1970-1-1开始的毫秒数。\n  long milli = instant.toEpochMilli();\n  System.out.println(milli);\n  //ofEpochMilli(long time)：通过指定的毫秒数创建Instant对象\n  Instant instant1 = Instant.ofEpochMilli(1604662722362L);\n  System.out.println(instant1);\n  ```\n* DateTimeFormatter 类:格式化与解析日期或时间\n  * java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：\n  *  预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME\n  * 本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)\n  * 自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)\n  |                          方法                          |                             格式                             |\n  | :----------------------------------------------------: | :----------------------------------------------------------: |\n  |   <font color=\"red\">ofPattern(String pattern)</font>   | 静态方法 ， 返 回 一 个 指 定 字 符 串 格 式 的DateTimeFormatter |\n  | <font color=\"purple\">format(TemporalAccessor t)</font> |               格式化一个日期、时间，返回字符串               |\n  |   <font color=\"blue\">parse(CharSequence text)</font>   |           将指定格式的字符序列解析为一个日期、时间           |\n  ```java\n  DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;\n  //格式化\n  LocalDateTime localDateTime1 = LocalDateTime.now();\n  String string = formatter.format(localDateTime1);\n  System.out.println(string);\n  System.out.println(localDateTime1);\n  //解析\n  String string1 = \"2020-11-06T20:07:39.608\";\n  TemporalAccessor parse = formatter.parse(string1);\n  System.out.println(parse);\n  \n  DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);\n  //格式化\n  String format = formatter1.format(localDateTime1);\n  System.out.println(format);\n  \n  DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);\n  //格式化\n  String format1 = formatter2.format(LocalDate.now());\n  System.out.println(format1);\n  \n  DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern(\"yyyy-MM-dd hh:mm:ss\");\n  //格式化\n  String format2 = formatter3.format(LocalDateTime.now());\n  System.out.println(format2);\n  ```\n* 其它API\n* ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris\n* ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12-03T10:15:30+01:00 Europe/Paris。 \n  \n  * 其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如：Asia/Shanghai等 \n* Clock：使用时区提供对当前即时、日期和时间的访问的时钟。 \n* 持续时间：Duration，用于计算两个“时间”间隔\n* 日期间隔：Period，用于计算两个“日期”间隔\n* TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。\n* TemporalAdjusters : 该类通过静态方法(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用TemporalAdjuster 的实现。\n# Java比较器\n* 在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题。\n* Java实现对象排序的方式有两种：\n  * 自然排序：java.lang.Comparable接口\n  *  定制排序：java.util.Comparator接口\n## 自然排序：java.lang.Comparable接口\n* Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。 \n* 实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。如果当前对象this大 于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零。 \n* 实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 \n* 对于类 C 的每一个 e1 和 e2 来说，当且仅当 e1.compareTo(e2) == 0 与e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals 一致。建议（虽然不是必需的）最好使自然排序与 equals 一致。\n* Comparable 的典型实现：(默认都是从小到大排列的) \n  * String：按照字符串中字符的Unicode值进行比较\n  * Character：按照字符的Unicode值来进行比较\n  * 数值类型对应的包装类以及BigInteger、BigDecimal：按照它们对应的数值大小进行比较\n  * Boolean：true 对应的包装类实例大于 false 对应的包装类实例\n  * Date、Time等：后面的日期时间比前面的日期时间大\n```java\nString[] arr = new String[]{\"aa\",\"cc\",\"dd\",\"bb\",\"ee\",\"gg\"};\nArrays.sort(arr);\nSystem.out.println(Arrays.toString(arr));\n\nPerson[] peoples = new Person[5];\npeoples[0] = new Person(\"aa\",18);\npeoples[1] = new Person(\"bb\",32);\npeoples[2] = new Person(\"cc\",21);\npeoples[3] = new Person(\"dd\",53);\npeoples[4] = new Person(\"ee\",32);\n//3.排序\nArrays.sort(peoples);\nSystem.out.println(Arrays.toString(peoples));\n/////////////////////////////////////////////////////////////\n//实现Comparable接口\npublic class Person implements Comparable{\n    String name;\n    int age;\n\n    public Person() {\n    }\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n    /**\n     * 2.重写方法\n     * 指明对象比较大小的具体方式：按年龄从低到高进行排序,再按照姓名从大到小进行排序\n     * @param o\n     * @return\n     */\n    @Override\n    public int compareTo(Object o) {\n        if (o instanceof Person){\n            Person person = (Person) o;\n            //方式一\n            if (this.age > person.age){\n                return 1;\n            }else if (this.age < person.age){\n                return -1;\n            }else{\n                //return 0;\n                return -this.name.compareTo(person.name);\n            }\n            //方式二\n            //return Integer.compare(this.age,person.age);\n        }\n        throw new RuntimeException(\"传入的数据类型不一致\");\n    }\n}\n```\n## 定制排序：java.util.Comparator接口\n* 当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序，强行对多个对象进行整体排序的比较。\n* 重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。\n* 可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。 \n* 还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。\n```java\nString[] arr = new String[]{\"aa\",\"cc\",\"dd\",\"bb\",\"ee\",\"gg\"};\n\n//1.排序时传入一个比较器\n//这个比较器可以采用匿名对象的方式实现\nArrays.sort(arr, new Comparator() {\n    /**\n     * 2.重写方法\n     * 按照字符串从大到小排序\n     * @param o1\n     * @param o2\n     * @return\n     */\n    @Override\n    public int compare(Object o1, Object o2) {\n        if (o1 instanceof String && o2 instanceof String){\n            String string1 = (String) o1;\n            String string2 = (String) o2;\n            return -string1.compareTo(string2);\n        }\n        throw  new RuntimeException(\"传入的数据类型不一致\");\n    }\n});\nSystem.out.println(Arrays.toString(arr));\n\nPerson[] peoples = new Person[5];\npeoples[0] = new Person(\"aa\",18);\npeoples[1] = new Person(\"bb\",32);\npeoples[2] = new Person(\"cc\",21);\npeoples[3] = new Person(\"dd\",53);\npeoples[4] = new Person(\"ee\",32);\n\nArrays.sort(peoples,new Comparator(){\n    @Override\n    public int compare(Object o1, Object o2) {\n        if (o1 instanceof Person && o2 instanceof Person){\n            Person person1 = (Person) o1;\n            Person person2 = (Person) o2;\n            if (person1.age == person2.age){\n                return -person1.name.compareTo(person2.name);\n            }else{\n                return -Integer.compare(person1.age,person2.age);\n            }\n        }\n        throw new RuntimeException(\"传入的数据类型不一致\");\n    }\n});\nSystem.out.println(Arrays.toString(peoples));\n```\n# 其他常用类\n## System类\n* System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。 \n* 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。  \n* 成员变量\n  \n  * System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。 \n* 成员方法\n  * native long currentTimeMillis()： 该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。\n  * void exit(int status)： 该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等\n  * void gc()： 该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。\n  * String getProperty(String key)： 该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：\n  |    属性名    |         属性说明         |\n  | :----------: | :----------------------: |\n  | java.version |    Java运行时环境版本    |\n  |  java.home   |    Java的JRE安装目录     |\n  |   os.name    |       操作系统名称       |\n  |  os.version  |      操作系统的版本      |\n  |  user.name   |      用户的账户名称      |\n  |  user.home   |       用户的主目录       |\n  |   user.dir   | 用户的当前项目的工作目录 |\n```java\nString javaVersion = System.getProperty(\"java.version\");\nSystem.out.println(\"java的version:\" + javaVersion);\nString javaHome = System.getProperty(\"java.home\");\nSystem.out.println(\"java的home:\" + javaHome);\nString osName = System.getProperty(\"os.name\");\nSystem.out.println(\"os的name:\" + osName);\nString osVersion = System.getProperty(\"os.version\");\nSystem.out.println(\"os的version:\" + osVersion);\nString userName = System.getProperty(\"user.name\");\nSystem.out.println(\"user的name:\" + userName);\nString userHome = System.getProperty(\"user.home\");\nSystem.out.println(\"user的home:\" + userHome);\nString userDir = System.getProperty(\"user.dir\");\nSystem.out.println(\"user的dir:\" + userDir);\n```\n## Math类\n* java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。\n  |                 方法名                 |           作用            |\n  | :------------------------------------: | :-----------------------: |\n  |                 abs()                  |          绝对值           |\n  | acos(),asin(),atan(),cos(),sin(),tan() |         三角函数          |\n  |                 sqrt()                 |          平方根           |\n  |         pow(double a,double b)         |         a的b次幂          |\n  |                 log()                  |         自然对数          |\n  |                 exp()                  |        e为底的指数        |\n  |         max(double a,double b)         |          最大值           |\n  |         min(double a,double b)         |          最小值           |\n  |                random()                |   返回0.0到1.0的随机数    |\n  |          long round(double a)          | double型数据a转换成long型 |\n  |        toDegrees(double angrad)        |       弧度 --> 角度       |\n  |        toRadians(double angdeg)        |       角度 --> 弧度       |\n## BigInteger类与BigDecimal类\n### BigInteger类\n* Integer类作为int的包装类，能存储的最大整型值为2^31-1，Long类也是有限的，最大为2^63-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。\n* java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。\n* 另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。\n* 构造器   \n  \n  * BigInteger(String val)：根据字符串构建BigInteger对象\n* 常用方法\n  * public BigInteger abs()：返回此 BigInteger 的绝对值的 BigInteger。 \n  * BigInteger add(BigInteger val) ：返回其值为 (this + val) 的 BigInteger\n  * BigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigInteger\n  * BigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigInteger\n  * BigInteger divide(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数相除只保留整数部分。 \n  * BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。 \n  * BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (this / val) 后跟(this % val) 的两个 BigInteger 的数组。 \n  * BigInteger pow(int exponent) ：返回其值为 (thisexponent) 的 BigInteger。\n  ```java\n  BigInteger bi = new BigInteger(\"1243351685481215471241123\");\n  System.out.println(bi);\n  ```\n### BigDecimal类\n* 一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。 \n* BigDecimal类支持不可变的、任意精度的有符号十进制定点数。\n* 构造器     \n  * public BigDecimal(double val) \n  *  public BigDecimal(String val) \n* 常用方法\n  * public BigDecimal add(BigDecimal augend)\n  * public BigDecimal subtract(BigDecimal subtrahend)\n  * public BigDecimal multiply(BigDecimal multiplicand)\n  * public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)\n  ```java\n  BigDecimal bd = new BigDecimal(\"12435.351\");\n  BigDecimal bd2 = new BigDecimal(\"11\");\n  System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));\n  System.out.println(bd.divide(bd2, 15, BigDecimal.ROUND_HALF_UP));\n  ```\n# 总结\n```java\n/**\n *  String:字符串，使用一对\"\"引起来表示\n *      1.String声明为final的，不可以被继承\n *      2.String实现了Serializable接口，表示字符串是支持序列化的，因此它可以被网络传输\n *              实现了Comparable接口：表示String可以比较大小\n *      3.String内部定义了final char[] value用于存储字符串数据\n *      4.String：代表不可变的字符序列。简称：不可变性。\n *          体现：1.当对字符串重新赋值时，需要重新开一片空间进行赋值，不会使用原有的空间进行赋值。\n *               2.当对现有的字符串进行连接操作时，会重新开一片空间存放连接后的值，不会让原有的空间存放连接后的值。\n *               3.当调用String的replace()方法修改指定字符或字符串时，也会会重新开一片空间存放修改后的值，不会让原有的\n *                 空间存放连接后的值。\n *          总结：当创建很多字符串，让他们的值都是一样的时候，它们在内存中指向的都是同一个区域。\n *             当修改字符串(无论是拼接替换等等)，都是在内存中重新开辟一片空间存放新的字符串。\n *      5.通过字面量的方式(区别于new方式)给一个字符串赋值，此时的字符串值声明在字符串常量池(值具有唯一性)中\n *      6.字符串常量池中是不会存储相同内容的字符串的。\n *  String实例化方式：\n *      方式一：通过字面量定义的方式。 例 String str=\"asd\";\n *      方式二：通过new+构造器的方式。 例 String str=new String();\n *      面试题：String s = new String(\"abc\")，这句代码在内存中创建了几个对象？\n *          两个：一个是堆空间中new结构，另一个是char[]对应的常量池中的数据\n *       String中的常见构造方式\n *          public String() {}  <--> 本质上相当于this.value = new char[0]。注意char数组的长度为0.\n *          public String(String original) {}  <--> 本质上相当于this.value = original.value;\n *          public String(char value[]) {} <--> 本质上相当于this.value = \n *             Arrays.copyOf(value,value.length);\n *          public String(char value[], int offset, int count) {}\n *  String字面量的实例化结论\n *      1.常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量\n *      2.拼接字符串时，只要其中一个是变量，则拼接后的字符串就在堆中\n *      3.如果拼接的结果调用intern()方法，方法的返回值的字符串实在常量池中\n *  String与其他数据类型之间的转换\n *      String --> 基本数据类型变量: 调用基本数据类型的包装类.parseXxx(String string);\n *      基本数据类型变量 --> String: 调用String.valueOf(Xxx xx);\n *      String --> char[]: 使用\"变量名.toCharArray()\"转换成char数组\n *      char[] --> String: 调用String的构造器\n *      编码：String --> byte[]: 调用String的getBytes()\n *      解码：byte[] -->String: 调用String的构造器\n *          注意：解码时，字符集的解码方式要和编码方式一致\n *  String与StringBuffer，StringBuilder的区别\n *      String:\n *          不可变的字符序列(final char[]),\n *          底层使用char[]存储\n *          可以通过字面量的方式赋值，因此这个类型的字符串可能在堆中，也可能在字符串常量池中\n *      StringBuffer:\n *          可变的字符序列(transient char[])；\n *          线程安全的(大部分的方法都用synchronized修饰)，效率低；\n *          底层使用char[]存储\n *          不能通过字面量的方式赋值，也意味着这个类型的字符串只能在堆空间中\n *      StringBuilder:\n *          可变的字符序列(transient char[])；\n *          线程不安全的(方法不都用synchronized修饰)，效率高；\n *          底层使用char[]存储\n *          不能通过字面量的方式赋值，也意味着这个类型的字符串只能在堆空间中\n *\n *          StringBuffer和StringBuilder的方法大致相同，不同的是StringBuffer的方法被synchronized修饰，\n *          StringBuffer str1 = new StringBuffer(); --> char[] = new char[16];\n *          StringBuffer str2 = new StringBuffer(\"abc\"); --> char[] = new char[3+16];\n *          str1.length() --> 返回0\n *          str2.length() --> 返回3\n *          扩容问题：如果要添加的数据底层数组盛不下了，那么就需要扩容底层的数组。\n *              默认情况下，扩容为原来容量的2倍+2，同时将原有数组中的元素复制到新的数组中\n *          StringBuffer和StringBuilder中都有一个可一个可以指明初始数组大小的构造器\n *      实际工作中建议使用StringBuffer()和StringBuilder()\n *      StringBuffer和StringBuilder比String多出的几个常用的方法\n *          增：append(xxx);\n *          删：delete(int start,int end);\n *          改：setCharAt(int n,char ch);/replace(int start,int end,String str)\n *          查：charAt(int n)\n *          插：insert(int offset,xxx)\n *          长度：length()\n *  String与StringBuffer，StringBuilder的效率的差别\n *      String <<< StringBuffer < StringBuilder\n *      实际的一次记录：StringBuffer的执行时间：4\n *                   StringBuilder的执行时间：1\n *                   String的执行时间：1057\n * 时间日期的常用类\n *  System.currentTimeMillis()：返回从1970年1月1日到现在过去了多少毫秒，类型为long。\n *      这个毫秒数一般成为时间戳\n *\n *  java.util.Date类\n *      |--java.sql.Date类\n *  关系：java.sql.Date类是java.util.Date类的子类\n *  java.util.Date类\n *      1.两个构造器的使用：\n *          Date():创建一个对应当前时间的Date对象\n *          Date(long time):创建指定毫秒数的Date对象\n *      2.两个方法的使用\n *          toString():显示对象的年，月，日，时，分，秒，星期\n *          getTime():返回对象对应的毫秒数\n *   java.sql.Date类\n *      1.它对应者数据库中的日期类型\n *      2.构造方法只有一个\n *          Date(long time):创建指定毫秒数的Date对象\n *      3.toString()方法：只返回年，月，日\n *      4.如何将java.util.Date类的对象转换成java.sql.Date类的对象\n *          先调用java.util.Date类的对象的getTime()获取时间戳\n *          然后根据java.sql.Date类的构造器创建对象\n *  SimpleDateFormat类：常用于对Date的格式化和解析\n *      格式化：日期 --->字符串\n *             通过format(date)方法。\n *      解析：字符串 --->日期。\n *             通过parse(string)方法。\n *          注意：要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现)，否则抛异常\n *  Calendar类：日历类(抽象类)的使用\n *      实例化方法：\n *          创建其子类 GregorianCalendar 的对象\n *          调用Calendar类的静态方法getInstance()   //常用这个方法\n *      常用方法\n *              field可以传Calendar.DAY_OF_MONTH等等\n *          set(field,value):设置field的值为value,\n *          get(field)：获取field的值。\n *          add(field,value)：将field的值加上value\n *          setTime(Date): Date --> 日历类\n *          Date getTime(): 日历类 --> Date\n *       注意：\n *          获取月份时：一月是0，二月是1，三月是2.。。。12月是11\n *          获取星期时：周日是1，周一是2，。。。周六是7\n *  LocalDate,LocalTime和LocalDateTime的使用\n *      1.实例化方法\n *          now()：获取当前的日期，时间，日期+时间\n *              例如：LocalDateTime.now();\n *      2.of():设置指定的年，月，日，时，分，秒。\n *          例如：LocalDateTime of = LocalDateTime.of(2020, 11, 1, 10, 5, 20);\n *      3.getXxx()：获取一些时间的信息\n *          例如：localDateTime.getDayOfMonth()\n *      4.withXxx()：设置一些时间的信息，返回新的对象\n *          例如：LocalDateTime localDateTime1 = localDateTime.withDayOfMonth(22);\n *      5.plusXxx():加时间操作\n *          例如：LocalDateTime localDateTime2 = localDateTime.plusDays(5);\n *      6.minusXxx():减时间操作\n *          例如：LocalDateTime localDateTime3 = localDateTime.minusDays(6);\n *    说明\n *      1.LocalDateTime较于LocalDate,LocalTime更常用\n *      2.类似于Calendar\n *  Instant类的应用\n *      Instant：瞬时\n *      1.now():获取基于本初子午线对应的标准时间\n *           Instant instant = Instant.now();\n *      2.atOffset()：添加事件的偏移量\n *           OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8));\n *      3.toEpochMilli()：获取自1970-1-1开始的毫秒数。\n *           long milli = instant.toEpochMilli();\n *      4.ofEpochMilli(long time)：通过指定的毫秒数创建Instant对象\n *           Instant instant1 = Instant.ofEpochMilli(1604662722362L);\n *  DateTimeFormatter类的应用\n *      类似于SimpleDateFormat。\n *      有三种类别的创建实例的方法\n *      常用自己指定格式的的方法来创建实例：ofPattern(String);\n * 比较器的应用\n *  一，Java中的对象，正常情况下只能进行地址的比较：== 或 !=。不能使用 >或 <。\n *  但是在实际开发过程中，我们需要对多个对象进行排序，言外之意就是比较对象的大小。\n *  如何实现? 答：使用两个接口中的一个：Comparable接口 或 Comparator接口\n *  二，Comparable的使用  自然排序\n *      1.像String,包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式\n *      2.像String,包装类等重写了compareTo(obj)方法以后，进行了从小到大的排列\n *      3.重写compareTo(obj)方法的规则\n *          如果当前对象this大于形参对象obj,则返回正整数；\n *          如果当前对象this小于形参对象obj,则返回负整数；\n *          如果当前对象this等于形参对象obj,则返回零；\n *      4.使用步骤\n *          ① 将对象实现Comparable接口，然后重写compareTo(obj)方法，在方法中编写排序的规则\n *          ② 创建对象的数组，调用Arrays.sort(对象数组)方法。然后就排好了。\n *  三，Comparator的使用 定制排序\n *      1.当对象没有实现Comparable接口而又不方便修改代码\n *         或已经实现了Comparable接口而又像采用其他的排序方式\n *         那么可以考虑使用Comparator接口的对象来排序\n *      2. 重写compare(Object o1,Object o2)方法，比较o1,o2的大小\n *          如果o1在o2前面则返回值正整数\n *          如果o1在o2后面则返回值负整数\n *          如果o1在o2相同则返回值零\n *  四，Comparable接口 和 Comparator接口 的区别\n *      1. 对象实现了Comparable接口后，其排序的方式也就确认了。\n *          Comparator接口不需要对象实现，因此用匿名对象的方式来确定排序的方法\n *      2.Comparable接口中的比较方法是当前对象this和形参的比较\n *          Comparator接口中的比较方法是两个形参之间的比较\n * 其他常用类的使用\n * 一，System类\n *      系统的类，可以获取系统的信息，或者让系统做一些操作\n * 二，Math类\n *      对数据的操作的类，包含所有对数进行操作的方法，包括一些公式\n * 三，BigInteger类\n *      整数类型int无法表示太大的数，因此可以使用BigInteger来表示。\n *      BigInteger可以定义一些不可改变的无限大小的整数\n *      实例化方法 BigInteger(String val)\n * 四，BigDecimal类\n *      小数类型double,float无法表示太精确的小数，因此可以使用BigDecimal来表示。\n *       BigInteger可以定义一些不可改变的不限精度的小数\n *      实例化方法 BigDecimal(String val)\n *      注意：当输出的小数是无限小数时，需要给出要保留的小数位\n```","categories":["Java学习","Java高级语法"]},{"title":"IO流","url":"/2020/12/07/尚硅谷说Java/Java高级语法/6-IO流/","content":"\nJava对文件的读写操作，包含节点流，缓冲流，标准输入输出流以及对象流等等\n\n<!--more-->\n# File类的使用\n\n* java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关\n\n* File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。 \n\n* 想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对 象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。 \n\n* File对象可以作为参数传递给流的构造器\n\n* 常用构造器\n\n  |                 构造器                  |                     作用                      |\n  | :-------------------------------------: | :-------------------------------------------: |\n  |      public File(String pathname)       |         以pathname为路径创建File对象          |\n  | public File(String parent,String child) | 以parent为父路径，child为子路径创建File对象。 |\n  |  public File(File parent,String child)  |  根据一个父File对象和子文件路径创建File对象   |\n\n  * pathname可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。\n  * 绝对路径：是一个固定的路径,从盘符开始\n  * 相对路径：是相对于某个位置开始\n\n* 路径分隔符\n\n  * 路径中的每级目录之间用一个路径分隔符隔开。\n  * 路径分隔符和系统有关：\n    * windows和DOS系统默认使用“\\”来表示\n    * UNIX和URL使用“/”来表示\n  * Java程序支持跨平台运行，因此路径分隔符要慎用。\n  * 为了解决这个隐患，File类提供了一个常量：\n    * public static final String separator。根据操作系统，动态的提供分隔符。\n  * 举例：\n\n  ```java\n  File file1 = new File(\"d:\\\\atguigu\\\\info.txt\");\n  File file2 = new File(\"d:\" + File.separator + \"atguigu\" + File.separator + \"info.txt\");\n  File file3 = new File(\"d:/atguigu\");\n  ```\n\n* 常用方法\n\n  |                             方法                             |                             作用                             |\n  | :----------------------------------------------------------: | :----------------------------------------------------------: |\n  | <font color = \"red\" >public String getAbsolutePath()</font>  |           <font color = \"red\" >获取绝对路径</font>           |\n  |     <font color = \"red\" >public String getPath()</font>      |             <font color = \"red\" >获取路径</font>             |\n  |     <font color = \"red\" >public String getName()</font>      |             <font color = \"red\" >获取名称</font>             |\n  |    <font color = \"red\" >public String getParent()</font>     | <font color = \"red\" >获取上层文件目录路径。若无，返回null</font> |\n  |       <font color = \"red\" >public long length()</font>       | <font color = \"red\" >获取文件长度（即：字节数）。不能获取目录的长度。</font> |\n  |    <font color = \"red\" >public long lastModified()</font>    |  <font color = \"red\" >获取最后一次的修改时间，毫秒值</font>  |\n  |      <font color = \"red\" >public String[] list()</font>      | <font color = \"red\" >获取指定目录下的所有文件或者文件目录的名称数组</font> |\n  |    <font color = \"red\" >public File[] listFiles()</font>     | <font color = \"red\" >获取指定目录下的所有文件或者文件目录的File数组</font> |\n  | <font color = \"blue\" >public boolean renameTo(File dest)</font> | <font color = \"blue\" >把文件重命名为指定的文件路径。注意用法：见代码</font> |\n  | <font color = \"purple\" >public boolean isDirectory()</font>  |      <font color = \"purple\" >判断是否是文件目录</font>       |\n  |    <font color = \"purple\" >public boolean isFile()</font>    |        <font color = \"purple\" >判断是否是文件</font>         |\n  |    <font color = \"purple\" >public boolean exists()</font>    |         <font color = \"purple\" >判断是否存在</font>          |\n  |   <font color = \"purple\" >public boolean canRead()</font>    |         <font color = \"purple\" >判断是否可读</font>          |\n  |   <font color = \"purple\" >public boolean canWrite()</font>   |         <font color = \"purple\" >判断是否可写</font>          |\n  |   <font color = \"purple\" >public boolean isHidden()</font>   |         <font color = \"purple\" >判断是否隐藏</font>          |\n  | <font color = \"darkgreen\" >public boolean createNewFile()</font> | <font color = \"darkgreen\" >创建文件。若文件存在，则不创建，返回false</font> |\n  |   <font color = \"darkgreen\" >public boolean mkdir()</font>   | <font color = \"darkgreen\" >创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。 </font> |\n  |  <font color = \"darkgreen\" >public boolean mkdirs()</font>   | <font color = \"darkgreen\" >创建文件目录。如果上层文件目录不存在，一并创建</font> |\n  |  <font color = \"0xB0DE8A0D\" >public boolean delete()</font>  |    <font color = \"0xB0DE8A0D\" >删除文件或者文件夹</font>     |\n\n  * 创建注意事项：如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目路径下。\n  * 删除注意事项：\n    * Java中的删除不走回收站。 \n    * 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录\n\n```java\n//构造器一\nFile file1 = new File(\"hello.txt\");\nFile file2 = new File(\"E:\\\\IDEAworkspace\\\\JavaAtguigu\\\\he.txt\");\nSystem.out.println(file1);\nSystem.out.println(file2);\n//构造器二\nFile file3 = new File(\"E:\\\\IDEAworkspace\\\\JavaAtguigu\", \"javafile\");\nSystem.out.println(file3);\n//构造器三\nFile file4 = new File(file3, \"hi.txt\");\nSystem.out.println(file4);\nFile file1 = new File(\"hello.txt\");\nFile file2 = new File(\"F:\\\\io\\\\he.txt\");\n\nSystem.out.println(file1.getAbsolutePath());\nSystem.out.println(file1.getPath());\nSystem.out.println(file1.getName());\nSystem.out.println(file1.getParent());\nSystem.out.println(file1.length());\nSystem.out.println(file1.lastModified());\n\nSystem.out.println(file2.getAbsolutePath());\nSystem.out.println(file2.getPath());\nSystem.out.println(file2.getName());\nSystem.out.println(file2.getParent());\nSystem.out.println(file2.length());\nSystem.out.println(file2.lastModified());\n\nFile file3 = new File(\"E:\\\\IDEAworkspace\\\\JavaAtguigu\");\nString[] list = file3.list();\nfor (String string : list) {\n    System.out.println(string);\n}\nSystem.out.println(\"**********************\");\nFile[] files = file3.listFiles();\nfor (File file : files) {\n    System.out.println(file);\n}\nSystem.out.println(\"**********************\");\n//要想保证是成功的，需要file4在盘中是存在的，且file5不能存在硬盘中\nFile file4 = new File(\"hello.txt\");\nFile file5 = new File(\"F:\\\\io\\\\he.txt\");\nboolean b = file4.renameTo(file5);\nSystem.out.println(b);\nSystem.out.println(\"*******************\");\nFile file6 = new File(\"hello.txt\");\nFile file7 = new File(\"F:\\\\io\\\\he.txt\");\nSystem.out.println(file6.isDirectory());\nSystem.out.println(file6.isFile());\nSystem.out.println(file6.exists());\nSystem.out.println(file6.canRead());\nSystem.out.println(file6.canWrite());\nSystem.out.println(file6.isHidden());\nSystem.out.println(\"*******************\");\nSystem.out.println(file7.isDirectory());\nSystem.out.println(file7.isFile());\nSystem.out.println(file7.exists());\nSystem.out.println(file7.canRead());\nSystem.out.println(file7.canWrite());\nSystem.out.println(file7.isHidden());\nSystem.out.println(\"*******************\");\n//文件的创建\nFile file8 = new File(\"hi.txt\");\nif(!file8.exists()){\n    file8.createNewFile();\n    System.out.println(\"创建成功\");\n}else{\n    file8.delete();\n    System.out.println(\"删除成功\");\n}\n//文件目录的创建\nFile file9 = new File(\"F:\\\\io\\\\io1\\\\io4\");\nboolean mkdir = file9.mkdir();\nif (mkdir){\n    System.out.println(\"mkdir: 创建成功\");\n}\nFile file10 = new File(\"F:\\\\io\\\\io2\\\\io4\");\nboolean mkdir1 = file10.mkdirs();\nif (mkdir1){\n    System.out.println(\"mkdir1: 创建成功\");\n}\n```\n\n# IO流的原理及流的分类\n\n* I/O是Input/Output的缩写， I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。\n\n* Java程序中，对于数据的输入/输出操作以“流(stream)” 的方式进行。\n\n* java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。\n\n* 输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。\n\n* 输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。\n\n* 流的分类\n\n  * 按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit)\n  * 按数据流的流向不同分为：输入流，输出流\n  * 按流的角色的不同分为：节点流，处理流\n\n  | 抽象基类 |    字节流    | 字符流 |\n  | :------: | :----------: | :----: |\n  |  输入流  | InputStream  | Reader |\n  |  输出流  | OutputStream | Writer |\n\n  * Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。\n  * 由这四个类派生出来的子类名称都是以其父类名作为子类名后缀\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184420.png)\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184421.png)\n\n* 节点流和处理流\n\n  * 节点流：直接从数据源或目的地读写数据\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184422.png)\n\n  * 处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184423.png)\n\n## InputStream 和 Reader\n\n* InputStream 和 Reader 是所有输入流的基类。\n\n* InputStream（典型实现：FileInputStream） \n\n  * int read()\n  * int read(byte[] b)\n  * int read(byte[] b, int off, int len) \n\n* Reader（典型实现：FileReader） \n\n  * int read()\n  * int read(char [] c)\n  * int read(char [] c, int off, int len) \n\n* 程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件 IO 资源。 \n\n* FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream 用于读取非文本数据之类的原始字节流。要读取字符流，需要使用 FileReader\n\n* InputStream\n\n  * int read()\n    * 从输入流中读取数据的下一个字节。返回 0 到 255 范围内的 int 字节值。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。 \n  * int read(byte[] b)\n    * 从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。否则以整数形式返回实际读取的字节数。 \n  * int read(byte[] b, int off,int len)\n    * 将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len 个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值 -1。 \n  * public void close() throws IOException\n    * 关闭此输入流并释放与该流关联的所有系统资源。\n\n  ```java\n  FileInputStream inputStream = null;\n  try {\n      //1.指明要操作的文件\n      File file = new File(\"hello.txt\");\n      //2.创建流\n      inputStream = new FileInputStream(file);\n      //3.操作流\n      byte[] bytes = new byte[5];\n      int read;\n      while ((read = inputStream.read(bytes)) != -1){\n          System.out.println(new String(bytes,0,read));\n      }\n  } catch (IOException e) {\n      e.printStackTrace();\n  } finally {\n      if (inputStream != null){\n          try {\n              //4.关闭流\n              inputStream.close();\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n  }\n  ```\n\n* Reader\n\n  * int read()\n    * 读取单个字符。作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)（2个字节的Unicode码），如果已到达流的末尾，则返回 -1 \n  * int read(char[] cbuf)\n    * 将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 \n  * int read(char[] cbuf,int off,int len)\n    * 将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 \n  * public void close() throws IOException\n    * 关闭此输入流并释放与该流关联的所有系统资源。\n\n  ```java\n  FileReader fileReader = null;\n  try {\n      //1.实例化File类的对象，指明要操作的文件\n      File file = new File(\"hello.txt\");\n      //2.提供具体的流\n      fileReader = new FileReader(file);\n      //3.数据的读出\n      //read():返回读入的一个字符，如果达到文件末尾，返回-1。\n      //方式一\n      //        int read = fileReader.read();\n      //        while (read != -1){\n      //            System.out.println((char) read);\n      //            read = fileReader.read();\n      //        }\n      //方式二\n      int data;\n      while ((data = fileReader.read()) != -1){\n          System.out.println((char)data);\n      }\n  } catch (IOException e) {\n      e.printStackTrace();\n  } finally {\n      //4.关闭流\n      try {\n          if (fileReader != null){\n              fileReader.close();\n          }\n      } catch (IOException e) {\n          e.printStackTrace();\n      }\n  }\n  FileReader fileReader1 = null;\n  try {\n      File file = new File(\"hello.txt\");\n      fileReader1 = new FileReader(file);\n      //read(char cbuf[]):读取到的内容放到数组中。\n      // 返回每次读入cbuf数组中的字符的个数，如果达到文件末尾则返回-1。\n      //细节：每次读取的字符会依次添加到数组中，如果读取的字符数小于数组的长度，则对于数组后面的字符不做改变\n      char[] cbuf = new char[5];\n      int read;\n      while((read= fileReader1.read(cbuf))!=-1){\n  //错误的写法\n  //                for (int i = 0; i < cbuf.length; i++) {\n  //                    System.out.print(cbuf[i]);\n  //                }\n          //正确的写法\n          for (int i = 0; i < read; i++) {\n              System.out.print(cbuf[i]);\n          }\n          System.out.println();\n      }\n  \n  } catch (IOException e) {\n      e.printStackTrace();\n  } finally {\n      try {\n          fileReader1.close();\n      } catch (IOException e) {\n          e.printStackTrace();\n      }\n  }\n  ```\n\n## OutputStream 和 Writer\n\n* OutputStream 和 Writer 也非常相似：\n\n  * void write(int b/int c);\n  * void write(byte[] b/char[] cbuf);\n  * void write(byte[] b/char[] buff, int off, int len);\n  * void flush();\n  * void close(); 需要先刷新，再关闭此流\n\n* 因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组，即以 String 对象作为参数\n\n  * void write(String str);\n  * void write(String str, int off, int len);\n\n* FileOutputStream 从文件系统中的某个文件中获得输出字节。FileOutputStream 用于写出非文本数据之类的原始字节流。要写出字符流，需要使用 FileWriter\n\n* OutputStream\n\n  * void write(int b)\n    * 将指定的字节写入此输出流。write 的常规协定是：向输出流写入一个字节。要写入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。 即写入0~255范围的。 \n  * void write(byte[] b)\n    * 将 b.length 个字节从指定的 byte 数组写入此输出流。write(b) 的常规协定是：应该与调用 write(b, 0, b.length) 的效果完全相同。 \n  * void write(byte[] b,int off,int len)\n    * 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。 \n  * public void flush()throws IOException\n    * 刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。 \n  * public void close() throws IOException\n    * 关闭此输出流并释放与该流关联的所有系统资源。\n\n  ```java\n  FileInputStream inputStream = null;\n  FileOutputStream outputStream = null;\n  try {\n      //1.指明文件路径\n      File file1 = new File(\"F:\\\\1.png\");\n      File file2 = new File(\"F:\\\\2.png\");\n      //创建流\n      inputStream = new FileInputStream(file1);\n      outputStream = new FileOutputStream(file2);\n      //3.操作流\n      byte[] bytes = new byte[1024];\n      int len;\n      while ((len = inputStream.read(bytes)) != -1){\n          outputStream.write(bytes,0,len);\n      }\n  } catch (IOException e) {\n      e.printStackTrace();\n  } finally {\n      //4.关闭流\n      if (inputStream != null){\n          try {\n              inputStream.close();\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n      if (outputStream != null){\n          try {\n              outputStream.close();\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n  }\n  ```\n\n* Writer\n\n  * void write(int c)\n    * 写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入0 到 65535 之间的Unicode码。 \n  * void write(char[] cbuf)\n    * 写入字符数组。 \n  * void write(char[] cbuf,int off,int len)\n    * 写入字符数组的某一部分。从off开始，写入len个字符\n  * void write(String str)\n    * 写入字符串。 \n  * void write(String str,int off,int len)\n    * 写入字符串的某一部分。 \n  * void flush()\n    * 刷新该流的缓冲，则立即将它们写入预期目标。 \n  * public void close() throws IOException\n    * 关闭此输出流并释放与该流关联的所有系统资源\n\n  ```java\n  FileWriter writer = null;\n  try {\n      //1.实例化File类的对象，指明要操作的文件\n      File file = new File(\"hello1.txt\");\n      //2.提供具体的流\n      writer = new FileWriter(file,true);\n      //3.数据的写入\n      writer.write(\"I have a dream\\n\");\n      writer.write(\"you have a dream\");\n  } catch (IOException e) {\n      e.printStackTrace();\n  } finally {\n      //4.关闭流\n      try {\n          if (writer!=null){\n              writer.close();\n          }\n      } catch (IOException e) {\n          e.printStackTrace();\n      }\n  }\n  ```\n\n# 节点流(或文件流)\n\n* 读取文件\n  1. 建立一个流对象，将已存在的一个文件加载进流。\n     * FileReader fr = new FileReader(new File(“Test.txt”));\n  2. 创建一个临时存放数据的数组。\n     * char[] ch = new char[1024];\n  3. 调用流对象的读取方法将流中的数据读入到数组中。\n     * fr.read(ch);\n  4. 关闭资源。\n     * fr.close();\n* 写入文件\n  1. 创建流对象，建立数据存放文件\n     * FileWriter fw = new FileWriter(new File(“Test.txt”));\n  2. 调用流对象的写入方法，将数据写入流\n     * fw.write(“atguigu-songhongkang”);\n  3. 关闭流资源，并将流中的数据清空到文件中。\n     * fw.close();\n* 定义文件路径时，注意：可以用“/”或者“\\\\”。 \n* 在写入一个文件时，如果使用构造器FileOutputStream(file)，则目录下有同名文件将被覆盖。\n* 如果使用构造器FileOutputStream(file,true)，则目录下的同名文件不会被覆盖，在文件内容末尾追加内容。\n* 在读取文件时，必须保证该文件已存在，否则报异常。 \n* 字节流操作字节，比如：.mp3，.avi，.rmvb，mp4，.jpg，.doc，.ppt\n* 字符流操作字符，只能操作普通文本文件。最常见的文本文件：.txt，.java，.c，.cpp 等语言的源代码。尤其注意.doc,excel,ppt这些不是文本文件。\n\n# 处理流之一：缓冲流\n\n* 为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字节(8Kb)的缓冲区。\t\n\n  ```java\n  private static int defaultCharBufferSize = 8192;\n  ```\n\n* 缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为：\n\n  * BufferedInputStream 和 BufferedOutputStream\n  * BufferedReader 和 BufferedWriter\n\n* 当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区\n\n* 当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。 \n\n* 向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法flush()可以强制将缓冲区的内容全部写入输出流\n\n* 关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流\n\n* flush()方法的使用：手动将buffer中内容写入文件\n\n* 如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184424.png)\n\n* 字符缓冲流的使用\n\n```java\nBufferedReader br = null;\nBufferedWriter bw = null;\ntry {\n    br = new BufferedReader(new FileReader(new File(\"hello.txt\")));\n    bw = new BufferedWriter(new FileWriter(new File(\"hello3.txt\")));\n\n    //方式一\n    //            char[] chars = new char[1024];\n    //            int len ;\n    //            while ((len = br.read(chars)) != -1){\n    //                bw.write(chars,0,len);\n    //            }\n    //方式二\n    String data;\n    while ((data = br.readLine()) != null){\n        //方式一\n        //                bw.write(data+\"\\n\");\n        //方式二\n        bw.write(data);\n        bw.newLine();\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (br != null){\n        try {\n            br.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    if (bw != null){\n        try {\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n* 字节缓冲流的使用\n\n```java\nBufferedInputStream bis = null;\nBufferedOutputStream bos = null;\ntry {\n    //1.造文件\n    File file1 = new File(\"F:\\\\1.png\");\n    File file2 = new File(\"F:\\\\3.png\");\n    //2.造流\n    //2.1造节点流\n    FileInputStream fis = new FileInputStream(file1);\n    FileOutputStream fos = new FileOutputStream(file2);\n    //2.2造缓冲流\n    bis = new BufferedInputStream(fis);\n    bos = new BufferedOutputStream(fos);\n    //3.操作流\n    byte[] bytes = new byte[1024];\n    int len;\n    while ((len = bis.read(bytes)) != -1){\n        bos.write(bytes,0,len);\n\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    //4.关闭流\n    if (bis != null){\n        try {\n            bis.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    if (bos != null){\n        try {\n            bos.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n# 处理流之一：转换流\n\n* 转换流提供了在字节流和字符流之间的转换\n\n* Java API提供了两个转换流：\n\n  * InputStreamReader：将InputStream转换为Reader\n  * OutputStreamWriter：将Writer转换为OutputStream\n\n* 字节流中的数据都是字符时，转成字符流操作更高效。 \n\n* 很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184425.png)\n\n* InputStreamReader\n\n  * 实现将字节的输入流按指定字符集转换为字符的输入流。\n  * 需要和InputStream“套接”。\n  * 构造器\n    * public InputStreamReader(InputStream in)\n    * public InputSreamReader(InputStream in,String charsetName)\n  * 如： Reader isr = new InputStreamReader(System.in,”gbk”); gbk为指定的字符集\n\n* OutputStreamWriter\n\n  * 实现将字符的输出流按指定字符集转换为字节的输出流。\n  * 需要和OutputStream“套接”。\n  * 构造器 \n    * public OutputStreamWriter(OutputStream out)\n    * public OutputSreamWriter(OutputStream out,String charsetName)\n\n```java\nFileInputStream fis = new FileInputStream(\"hello.txt\");\nFileOutputStream fos = new FileOutputStream(\"hello6.txt\");\n//使用系统默认的字符集格式\n//InputStreamReader isr = new InputStreamReader(fis);\n//以UTF-8的格式将字节转换成字符\nInputStreamReader isr = new InputStreamReader(fis,\"UTF-8\");\n//输出乱码\n//InputStreamReader isr = new InputStreamReader(fis,\"GBK\");\n//以GBK的格式将字符转换成字节,\nOutputStreamWriter osw = new OutputStreamWriter(fos,\"gbk\");\n//此时由于输入时是UTF-8格式，此时的输出是gbk格式，因此写出的文件会乱码\n\nchar[] chars = new char[1024];\nint len;\nwhile ((len = isr.read(chars)) != -1){\n    osw.write(chars,0,len);\n    System.out.println(new String(chars,0,len));\n}\nisr.close();\nosw.close();\n```\n\n## 字符编码\n\n* 编码表的由来\n  * 计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表。这就是编码表。\n* 常见的编码表\n  * ASCII：美国标准信息交换码。\n    * 用一个字节的7位可以表示。\n  * ISO8859-1：拉丁码表。欧洲码表\n    * 用一个字节的8位表示。\n  * GB2312：中国的中文编码表。\n    * 最多两个字节编码所有字符\n  * GBK：中国的中文编码表升级，融合了更多的中文文字符号。\n    * 最多两个字节编码\n  * Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。\n    * 所有的文字都用两个字节来表示。\n  * UTF-8：变长的编码方式，\n    * 可用1-4个字节来表示一个字符。\n* 在Unicode出现之前，所有的字符集都是和具体编码方案绑定在一起的（即字符集≈编码方式），都是直接将字符和最终字节流绑定死了。 \n* GBK等双字节编码方式，用最高位是1或0表示两个字节和一个字节。\n* Unicode不完美，这里就有三个问题，一个是，我们已经知道，英文字母只用一个字节表示就够了，第二个问题是如何才能区别Unicode和ASCII？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？第三个，如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，不够表示所有字符。Unicode在很长一段时间内无法推广，直到互联网的出现。  \n* 面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF- 8就是每次8个位传输数据，而UTF-16就是每次16个位。这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。 \n* Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16。\n* ANSI编码，通常指的是平台的默认编码，例如英文操作系统中是ISO-8859-1，中文系统是GBK\n* 编码：字符串 --> 字节数组\n* 解码：字节数组 --> 字符串\n* 转换流的编码应用\n  * 可以将字符按指定编码格式存储\n  * 可以对文本数据按指定编码格式来解读\n  * 指定编码表的动作由构造器完成\n\n# 处理流之一：标准输入，输出流\n\n* System.in和System.out分别代表了系统标准的输入和输出设备\n* 默认输入设备是：键盘，输出设备是：显示器\n* System.in的类型是InputStream\n* System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类\n* 重定向：通过System类的setIn，setOut方法对默认设备进行改变。\n  * public static void setIn(InputStream in)\n  * public static void setOut(PrintStream out)\n\n```java\n//实现将键盘输入的字符串转换成大写输出，知道读取到e或exit退出。\nBufferedReader br = null;\ntry {\n    InputStreamReader isr = new InputStreamReader(System.in);\n    br = new BufferedReader(isr);\n    while (true){\n        System.out.println(\"请输入字符串：\");\n        String data = br.readLine();\n        if (\"e\".equals(data) || \"exit\".equals(data)){\n            break;\n        }\n        String string = data.toUpperCase();\n        System.out.println(string);\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (br != null){\n        try {\n            br.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n# 处理流之一：打印流\n\n* 实现将基本数据类型的数据格式转化为字符串输出\n* 打印流：PrintStream和PrintWriter\n  * 提供了一系列重载的print()和println()方法，用于多种数据类型的输出\n  * PrintStream和PrintWriter的输出不会抛出IOException异常\n  * PrintStream和PrintWriter有自动flush功能\n  * PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。\n  * 在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。 \n  * System.out返回的是PrintStream的实例\n\n```java\nPrintStream ps = null;\ntry {\n    //将输出的数据打印在一个文件中，而不是输出到控制台里\n    FileOutputStream fos = new FileOutputStream(\"log.txt\");\n    //true：表示设置为自动刷新(写入换行字符或字节'\\n'时都会刷新输出缓冲区)\n    ps = new PrintStream(fos,true);\n    if (ps != null){\n        System.setOut(ps);\n    }\n    for (int i = 0; i < 500; i++) {\n        System.out.print(i);\n        if (i % 50 == 0){\n            System.out.println();\n        }\n    }\n} catch (FileNotFoundException e) {\n    e.printStackTrace();\n} finally {\n    if (ps != null){\n        ps.close();\n    }\n}\n```\n\n# 处理流之一：数据流\n\n* 为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流。\n* 数据流有两个类：(用于读取和写出基本数据类型、String类的数据）\n  * DataInputStream “套接”在 InputStream 子类的流上\n  * DataOutputStream “套接”在 OutputStream 子类的流上 \n* DataInputStream中的方法：\n  * boolean readBoolean() \n  * byte readByte()\n  * char readChar() \n  * float readFloat()\n  * double readDouble() \n  * short readShort()\n  * long readLong() \n  * int readInt()\n  * String readUTF() \n  * void readFully(byte[] b)\n* DataOutputStream中的方法：将上述的方法的read改为相应的write即可。\n\n```java\nDataOutputStream dos = null;\ntry {\n    dos = new DataOutputStream(new FileOutputStream(\"data.txt\"));\n\n    dos.writeUTF(\"林妹妹\");\n    dos.flush();\n    dos.writeInt(18);\n    dos.flush();\n    dos.writeBoolean(true);\n    dos.flush();\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (dos != null){\n        try {\n            dos.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nDataInputStream dis = null;\ntry {\n    dis = new DataInputStream(new FileInputStream(\"data.txt\"));\n    String name = dis.readUTF();\n    int age = dis.readInt();\n    boolean flag = dis.readBoolean();\n    System.out.println(\"name: \" + name);\n    System.out.println(\"age: \" + age);\n    System.out.println(\"flag: \" + flag);\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (dis != null){\n        try {\n            dis.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n# 处理流之一：对象流\n\n* ObjectInputStream类和OjbectOutputSteam类\n  * 用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。\n* 序列化：用ObjectOutputStream类保存基本类型数据或对象的机制\n* 反序列化：用ObjectInputStream类读取基本类型数据或对象的机制\n* ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量\n\n## 对象的序列化\n\n* 对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象\n* 序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原\n* 序列化是 RMI（Remote Method Invoke – 远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是JavaEE 平台的基础\n* 如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出NotSerializableException异常\n  * Serializable\n  * Externalizable\n* 凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：\n  * private static final long serialVersionUID;\n  * serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。\n  * 如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议，显式声明。\n* 简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)\n* 使用对象流序列化对象\n  * 若某个类实现了 Serializable 接口，该类的对象就是可序列化的：\n  * 创建一个 ObjectOutputStream\n  * 调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象\n  * 注意写出一次，操作flush()一次\n* 反序列化\n  * 创建一个 ObjectInputStream\n  * 调用 readObject() 方法读取流中的对象\n  * 强调：如果某个类的属性不是基本数据类型或 String 类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field 的类也不能序列化\n\n```java\n//序列化\nObjectOutputStream oos = null;\ntry {\n    oos = new ObjectOutputStream(new FileOutputStream(\"object.dat\"));\n    oos.writeObject(new String(\"hello world\"));\n    oos.flush();\n    //序列化自定义的对象\n    oos.writeObject(new Person(\"林妹妹\",18));\n    oos.flush();\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (oos != null){\n        try {\n            oos.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n//反序列化\nObjectInputStream ois = null;\ntry {\n    ois = new ObjectInputStream(new FileInputStream(\"object.dat\"));\n    Object object = ois.readObject();\n    System.out.println(object.toString());\n    Object object2 = ois.readObject();\n    System.out.println(object2.toString());\n} catch (IOException | ClassNotFoundException e) {\n    e.printStackTrace();\n} finally {\n    if (ois != null){\n        try {\n            ois.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n//////////////////////////////////////////////\npublic class Person implements Serializable{\n    private static final long serialVersionUID = -7213561420926919071L;\n    private String name;\n    private int age;\n\n    public Person() {\n    }\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n}\n```\n\n* 谈谈你对java.io.Serializable接口的理解，我们知道它用于序列化，是空方法接口，还有其它认识吗？\n  * 实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。\n  * 换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节。\n  * 由于大部分作为参数的类如String、Integer等都实现了java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更灵活。\n\n# 处理流之一：随机存取文件流\n\n* RandomAccessFile类 声明在java.io包下，但直接继承于java.lang.Object类。并且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写。\n* RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件\n  * 支持只访问文件的部分内容\n  * 可以向已存在的文件后追加内容\n* RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。\n* RandomAccessFile 类对象可以自由移动记录指针：\n  * long getFilePointer()：获取文件记录指针的当前位置\n  * void seek(long pos)：将文件记录指针定位到 pos 位置\n* 构造器\n  * public RandomAccessFile(File file, String mode) \n  * public RandomAccessFile(String name, String mode) \n* 创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式：\n  * r: 以只读方式打开\n  * rw：打开以便读取和写入\n  * rwd:打开以便读取和写入；同步文件内容的更新\n  * rws:打开以便读取和写入；同步文件内容和元数据的更新\n* 如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 \n* 如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建。\n\n```java\nRandomAccessFile raf1 = null;\nRandomAccessFile raf2 = null;\ntry {\n    raf1 = new RandomAccessFile(new File(\"hello.txt\"), \"r\");\n    raf2 = new RandomAccessFile(new File(\"hello1.txt\"), \"rw\");\n    byte[] bytes = new byte[1024];\n    int len;\n    while ((len = raf1.read(bytes)) != -1){\n        raf2.seek(12);\n        raf2.write(bytes,0,len);\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (raf1 != null){\n        try {\n            raf1.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    if (raf2 != null){\n        try {\n            raf2.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n# 流的基本应用小节\n\n* 流是用来处理数据的。\n* 处理数据时，一定要先明确数据源，与数据目的地\n  * 数据源可以是文件，可以是键盘。\n  * 数据目的地可以是文件、显示器或者其他设备。\n* 而流只是在帮助数据进行传输,并对传输的数据进行处理，比如过滤处理、转换处理等。\n\n# NIO2中Path,Paths,Files类的使用\n\n## Java NIO 概述\n\n* Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新 的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。\n* Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。 \n  * |-----java.nio.channels.Channel\n    * |-----FileChannel:处理本地文件\n    * |-----SocketChannel：TCP网络编程的客户端的Channel\n    * |-----ServerSocketChannel:TCP网络编程的服务器端的Channel\n    * |-----DatagramChannel：UDP网络编程中发送端和接收端的Channel\n\n## Java NIO2 概述\n\n* 早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。\n\n* NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path可以看成是File类的升级版本，实际引用的资源也可以不存在。\n\n* 在以前IO操作都是这样写的:\n\n  ```java\n  import java.io.File;\n  File file = new File(\"index.html\");\n  ```\n\n* 但在Java7 中，我们可以这样写：\n\n  ```java\n  import java.nio.file.Path; \n  import java.nio.file.Paths; \n  Path path = Paths.get(\"index.html\");\n  ```\n\n* 同时，NIO.2在java.nio.file包下还提供了Files、Paths工具类，Files包含了大量静态的工具方法来操作文件；Paths则包含了两个返回Path的静态工厂方法。\n\n* Paths 类提供的静态 get() 方法用来获取 Path 对象：\n\n  * static Path get(String first, String … more) : 用于将多个字符串串连成路径\n  * static Path get(URI uri): 返回指定uri对应的Path路径\n\n* Path 常用方法：\n\n  |              方法               |                           作用                           |\n  | :-----------------------------: | :------------------------------------------------------: |\n  |        String toString()        |            返回调用 Path 对象的字符串表示形式            |\n  | boolean startsWith(String path) |                 判断是否以 path 路径开始                 |\n  |  boolean endsWith(String path)  |                 判断是否以 path 路径结束                 |\n  |      boolean isAbsolute()       |                    判断是否是绝对路径                    |\n  |        Path getParent()         | 返回Path对象包含整个路径，不包含 Path 对象指定的文件路径 |\n  |         Path getRoot()          |                返回调用 Path 对象的根路径                |\n  |       Path getFileName()        |             返回与调用 Path 对象关联的文件名             |\n  |       int getNameCount()        |              返回Path 根目录后面元素的数量               |\n  |      Path getName(int idx)      |             返回指定索引位置 idx 的路径名称              |\n  |      Path toAbsolutePath()      |              作为绝对路径返回调用 Path 对象              |\n  |      Path resolve(Path p)       |       合并两个路径，返回合并后的路径对应的Path对象       |\n  |          File toFile()          |                 将Path转化为File类的对象                 |\n\n* java.nio.file.Files 用于操作文件或目录的工具类。\n\n* Files常用方法：\n\n  |                             方法                             |                             作用                             |\n  | :----------------------------------------------------------: | :----------------------------------------------------------: |\n  |       Path copy(Path src, Path dest, CopyOption … how)       |                          文件的复制                          |\n  |   Path createDirectory(Path path, FileAttribute<?> … attr)   |                         创建一个目录                         |\n  |      Path createFile(Path path, FileAttribute<?> … arr)      |                         创建一个文件                         |\n  |                    void delete(Path path)                    |           删除一个文件/目录，如果不存在，执行报错            |\n  |                void deleteIfExists(Path path)                |            Path对应的文件/目录如果存在，执行删除             |\n  |        Path move(Path src, Path dest, CopyOption…how)        |                   将 src 移动到 dest 位置                    |\n  |                     long size(Path path)                     |                   返回 path 指定文件的大小                   |\n  | <font color=\"red\">boolean exists(Path path, LinkOption … opts)</font> |          <font color=\"red\">判断文件是否存在</font>           |\n  | <font color=\"red\">boolean isDirectory(Path path, LinkOption … opts)</font> |           <font color=\"red\">判断是否是目录</font>            |\n  | <font color=\"red\">boolean isRegularFile(Path path, LinkOption … opts)</font> |           <font color=\"red\">判断是否是文件</font>            |\n  |     <font color=\"red\">boolean isHidden(Path path)</font>     |         <font color=\"red\">判断是否是隐藏文件</font>          |\n  |    <font color=\"red\">boolean isReadable(Path path)</font>    |          <font color=\"red\">判断文件是否可读</font>           |\n  |    <font color=\"red\">boolean isWritable(Path path)</font>    |          <font color=\"red\">判断文件是否可写</font>           |\n  | <font color=\"red\">boolean  notExists(Path path, LinkOption … opts)</font> |         <font color=\"red\">判断文件是否不存在</font>          |\n  | <font color=\"blue\">SeekableByteChannel  newByteChannel(Path path, OpenOption…how)</font> | <font color=\"blue\">获取与指定文件的连接，how 指定打开方式。</font> |\n  | <font color=\"blue\">DirectoryStream<Path>  newDirectoryStream(Path path)</font> |        <font color=\"blue\">打开 path 指定的目录</font>        |\n  | <font color=\"blue\">InputStream  newInputStream(Path path, OpenOption…how)</font> |       <font color=\"blue\">获取 InputStream 对象</font>        |\n  | <font color=\"blue\">OutputStream  newOutputStream(Path path, OpenOption…how)</font> |       <font color=\"blue\">获取 OutputStream 对象</font>       |\n\n# 总结\n\n```java\n *  File类的使用\n *      1.File类的一个对象，代表一个文件或一个文件目录(俗称文件夹)\n *      2.File类声明在java.io包下\n *      3.File类中涉及到关于文件或文件目录的创建，删除，重命名，修改时间，文件大小等。\n *          并未涉及到写入或读取文件内容的操作，如需要读取或写入文件内容，必须使用IO流\n *      4.后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的终点\n *   一，如何创建File类的实例\n *      File(String pathname)\n *      File(String parent, String child)\n *      File(File parent, String child)\n *   二，路径的区别\n *      相对路径：相较于某个路径下，指明的路径\n *      绝对路径：包含盘符在内的文件或文件目录的路径\n *   三，路径分隔符\n *      Windows下：\\\\\n *      UNIX下：/\n *      File带有动态的路径分隔符：File.separator\n *   四，File类的方法\n *      getAbsolutePath()：获取绝对路径\n *      getPath()：获取路径\n *      getName()：获取名称\n *      getParent()：获取上层文件目录路径，若无，返回null\n *      length()：获取文件长度(即：字节数)\n *      lastModified()：获取最后一次的修改时间，毫秒值\n *      下面两个方法适用于以目录创建的file对象\n *      String[] list()：获取指定目录下的所有文件或者文件目录的名称\n *      File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组\n *      boolean renameTo(dest)：将对象对应的文件移动到dest代表的路径上，并将文件名改成dest对应的文件名\n *          要想保证是成功的，需要对象在盘中是存在的，且dest不能存在硬盘中\n *      boolean isDirectory()：判断是否是文件目录\n *      boolean isFile() ：判断是否是文件\n *      boolean exists() ：判断是否存在\n *      boolean canRead() ：判断是否可读\n *      boolean canWrite() ：判断是否可写\n *      boolean isHidden() ：判断是否隐藏\n *      boolean createNewFile() ：创建文件。若文件存在，则不创建，返回false\n *      boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。\n *      boolean mkdirs() ：创建文件目录。如果上层文件目录不存在，一并创建\n *      boolean delete()：删除文件或者文件夹。当删除文件夹时需保证此文件夹下没有文件和子文件夹。\n *  IO流的使用\n *   一，流的分类\n *      1.操作数据单位：字节流，字符流\n *      2.数据的流向：输入流，输出流\n *          输入：将文件中的内容传到程序中\n *          输出：将程序中的内容传到文件中\n *      3.流的角色：节点流，处理流\n *          处理流：套接在已有流的上的流\n *   二，流的体系结构\n *      抽象基类            节点流(或文件流)           缓冲流(处理流的一种)\n *      InputStream        FileInputStream         BufferedInputStream\n *      OutputStream       FileOutputStream        BufferedOutputStream\n *      Reader             FileReader              BufferedReader\n *      Writer             FileWriter              BufferedWriter\n *   三，流的使用\n *      1.节点流的使用\n *          1.FileReader：字符输入流\n *              ① read()的理解：返回读入的一个字符。如果到达文件末尾返回-1。\n *              ② 异常的处理：为了保证流资源一定可以执行关闭操作。想要使用try-catch-finally处理\n *              ③ 读入的文件一定要存在，否则就会报FileNotFoundException\n *              ④ read(char cbuf[]):读取到的内容放到数组中。\n *                  返回每次读入cbuf数组中的字符的个数，如果达到文件末尾则返回-1。\n *                  细节：每次读取的字符会依次添加到数组中，如果读取的字符数小于数组的长度，则对于数组后面的字符不做改变\n *          2.FileWriter：字符输出流\n *              ① 输入操作，对应的File可以不存在，不会报异常\n *              ② File对应的文件如果不存在，在输入的过程中，会自动的创建此文件\n *              ③ 输入的方法如果是: FileWriter(file,true)/FileWriter(file);则在写入时会覆盖原有的文件\n *                      如果是: FileWriter(file,false);则在写入时不会覆盖原有的文件\n *              ④ write(string)：将数据写入文件中\n *          3.FileInputStream：字节输入流\n *          4.FileOutputStream：字节输出流\n *      2.处理流之一：缓冲流的使用\n *          ① 先关闭外面的流(缓冲流)，再关闭内部的流(节点流)\n *              实际上：在关闭外层流时会自动关闭内层流\n *          ② 相比节点流，字符流能够更快的读取写入文件\n *              原因：缓冲流内部提供了一个缓冲区\n *          1.BufferedInputStream：字节输入缓冲流\n *\n *          2.BufferedOutputStream：字节输出缓冲流\n *              ① flush()：刷新缓冲区\n *          3.BufferedReader：字符输入缓冲流\n *              ① readLine()：一次读取一行数据，不包括换行符。读取到文件结尾时返回null\n *          4.BufferedWriter：字符输出缓冲流\n *              ① newLine()：写入一个换行符\n *      3.处理流之一：转换流的使用\n *          1.InputStreamReader：字符流。将字节输入流转换成字符输入流。字节 --> 字符\n *\n *          2.OutputStreamWriter：字符流。将字符输出流转换成字节输出流。字符 --> 字节\n *      4.处理流之一：标准的输入，输出流的使用\n *          1.System.in：标准的输入流，默认从键盘输入\n *          2.System.out：标准的输出流，默认输出到控制台\n *        使用：\n *          ① System类的setIn()/setOut()方式从新指定输入/输出的方式\n *          ② 两个流都是字节流.\n *      5.处理流之一：打印流\n *          1.PrintStream：字节打印流\n *\n *          2.PrintWriter：字符打印流\n *\n *      6.处理流之一：数据流\n *          1.DataInputStream\n *          2.DataOutputStream\n *        使用：\n *         ① 都是字节流\n *         ② 用于读取或写出基本数据类型的变量或字符串\n *         ③ 读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致\n *      7.处理流之一：对象流\n *          1.ObjectInputStream\n *              反序列化：将磁盘中的对象或网络接收的对象转换成内存层面的Java对象。\n *          2.ObjectOutputStream\n *              序列化：将内存中的Java对象保存到磁盘中或通过网络传输过去。\n *         使用：\n *          ① 用于存储和读取基本数据类型数据或对象的数据流。\n *          ② 自定义的类需要实现Serializable接口才能被序列化.并且要指明其serialVersionUID\n *          ③ 除了自定义的类是序列化的，还要保证其内部的属性也都是可序列化的\n *          ④ 不能序列化和反序列化static和transient修饰的属性\n *     8.随机存取文件类的使用：RandomAccessFile\n *          1.RandomAccessFile直接继承于java.lang.Object类，实现了DataOutput，DataInput接口\n *          2.RandomAccessFile既可以作为一个字节输入流，又可以作为一个字节输出流,\n *          3.构造方法的mode的值：\n *              “r\" ：表示文件以只读的方式打开\n *              \"rw\" ：表示文件以读写的方式打开\n *          4.写入时，如果文件有内容，默认从文件开头开始写，以覆盖的方式写\n *          5.seek(long pos)：将指针指向下标为pos的地方，此时的读写都会从pos的位置开始读写\n *   四，结论\n *      1.对于文本文件，使用字符流处理。对于非文本文件，使用字节流处理。\n *        当使用字符流处理非文本文件时，会损坏文件。当使用字节流处理文本文件时可能会出现乱码。\n```\n\n\n\n","categories":["Java学习","Java高级语法"]},{"title":"集合","url":"/2020/12/07/尚硅谷说Java/Java高级语法/4-集合/","content":"\nCollection接口和list链表，map，以及set\n\n<!--more-->\n# Java集合框架概述\n\n* 一方面， 面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。另一方面，使用Array存储对象方面具有一些弊端，而Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中。\n\n* 数组在内存存储方面的特点：\n\n  * 数组初始化以后，长度就确定了。\n  * 数组声明的类型，就决定了进行元素初始化时的类型\n\n* 数组在存储数据方面的弊端：\n\n  * 数组初始化以后，长度就不可变了，不便于扩展\n  * 数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。同时无法直接获取存储元素的个数\n  * 数组存储的数据是有序的、可以重复的。---->存储数据的特点单一\n\n* Java 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。\n\n* Java 集合可分为 Collection 和 Map 两种体系\n\n  * Collection接口：单列数据，定义了存取一组对象的方法的集合\n    * List：元素有序、可重复的集合\n    * Set：元素无序、不可重复的集合\n  * Map接口：双列数据，保存具有映射关系“key-value对”的集合\n\n* Collection接口继承树\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184400.png)\n\n* Map接口继承树\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184401.png)\n\n# Collection接口方法\n\n* Collection 接口是 List、Set 和 Queue 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。 \n\n* JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。 \n\n* 在 Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object 类型处理；从 JDK 5.0 增加了泛型以后，Java 集合可以记住容器中对象的数据类型。\n\n* 接口的方法\n\n  |                方法                |                             作用                             |\n  | :--------------------------------: | :----------------------------------------------------------: |\n  |          add(Object obj)           |                     添加元素obj到集合中                      |\n  |      addAll(Collection coll)       |              将coll集合中的元素添加到当前集合中              |\n  |             int size()             |                      获取有效元素的个数                      |\n  |            void clear()            |                           清空集合                           |\n  |         boolean isEmpty()          |                         是否是空集合                         |\n  |    boolean contains(Object obj)    | 是否包含某个元素：是通过元素的equals方法来判断是否是同一个对象 |\n  | boolean containsAll(Collection c)  | 是否包含某个元素：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。 |\n  |     boolean remove(Object obj)     | 通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素 |\n  | boolean removeAll(Collection coll) |                       取当前集合的差集                       |\n  |  boolean retainAll(Collection c)   |             把交集的结果存在当前集合中，不影响c              |\n  |     boolean equals(Object obj)     |                         集合是否相等                         |\n  |         Object[] toArray()         |                      集合转成成对象数组                      |\n  |             hashCode()             |                     获取集合对象的哈希值                     |\n  |             iterator()             |                 返回迭代器对象，用于集合遍历                 |\n\n```java\nCollection collection = new ArrayList();\n//add(Object obj):将元素obj添加到集合中\ncollection.add(\"aa\");\ncollection.add(\"bb\");\ncollection.add(123);\ncollection.add(new Date());\ncollection.add(new String(\"asd\"));\n//size():获取集合中元素的个数\nSystem.out.println(collection.size());\n//addAll(Collection coll1):将coll1集合中的元素添加到当前集合中\nCollection coll1 = new ArrayList();\ncoll1.add(\"a\");\ncoll1.add(\"b\");\ncollection.addAll(coll1);\nSystem.out.println(collection.size());\nSystem.out.println(collection);\n//clear():清空集合中的元素\ncollection.clear();\n//isEmpty():判断当前集合是否为空\nSystem.out.println(collection.isEmpty());\n\nCollection coll = new ArrayList();\ncoll.add(\"aa\");\ncoll.add(\"aa\");\ncoll.add(\"bb\");\ncoll.add(123);\ncoll.add(123);\ncoll.add(123);\ncoll.add(123);\ncoll.add(new Date());\ncoll.add(new String(\"asd\"));\ncoll.add(new Person(\"lc\",18));\n//contains(Object obj):判断当前集合中是否包含obj\n//在判断时，会调用obj的equals方法，因此对于自定义的类要重写equals方法\nSystem.out.println(coll.contains(\"aa\"));\nSystem.out.println(coll.contains(new String(\"asd\")));\nSystem.out.println(coll.contains(new Person(\"lc\",18)));\n//containsAll(Collection coll2):判断coll2中的元素是否都位于当前集合中\nCollection coll2 = new ArrayList();\ncoll2.add(\"aa\");\ncoll2.add(\"bb\");\nSystem.out.println(coll.containsAll(coll2));\n//remove(Object obj):移除当前集合中和obj相同的一个元素\nSystem.out.println(coll);\nSystem.out.println(coll.remove(123));\nSystem.out.println(coll);\n//removeAll(Collection coll3):移除当前集合与coll3中重复的元素,如果重复的元素则全部被移除\nCollection coll3 = new ArrayList();\ncoll3.add(\"aa\");\ncoll3.add(\"bb\");\nSystem.out.println(coll);\nSystem.out.println(coll.removeAll(coll3));\nSystem.out.println(coll);\n//retainAll(Collection coll4):保留当前集合与coll4中相同的元素，其他的都移除。如果有重复元素则都保留\nCollection coll4 = new ArrayList();\ncoll4.add(123);\ncoll4.add(345);\ncoll4.add(new Person(\"lc\",18));\nSystem.out.println(coll);\nSystem.out.println(coll.retainAll(coll4));\nSystem.out.println(coll);\n//equals(Object obj)：当前集合和obj集合中的元素都相同则返回true,如果两个集合的顺序不同则看具体的集合种类。\nCollection coll5 = new ArrayList();\ncoll5.add(\"aa\");\ncoll5.add(\"bb\");\nSystem.out.println(coll3.equals(coll5));\n//hashCode()：返回当前对象的哈希值\nSystem.out.println(coll.hashCode());\n//toArray():集合 --> 数组\nObject[] objects = coll.toArray();\nSystem.out.println(Arrays.toString(objects));\n//Arrays.asList(数组):数组 --> 集合 ; 注意基本数据类型数组的声明要用包装类\nList strings = Arrays.asList(new String[]{\"asd\",\"qwe\"});\nSystem.out.println(strings);\n```\n\n# Iterator迭代器接口\n\n* Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。\n\n* GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。 \n\n* Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。 \n\n* Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。\n\n* 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。\n\n* 迭代器接口中的方法\n\n  |   方法    |               作用               |\n  | :-------: | :------------------------------: |\n  | hasNext() |    当前指向的集合是否有下一个    |\n  |  next()   | 指向下移，然后返回当前指向的数据 |\n  | remove()  |        移除当前指向的数据        |\n\n  * 在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。\n  * 迭代器的执行原理\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184402.png)\n\n  * Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方 法，不是集合对象的remove方法。 \n  * 如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。\n\n```java\nCollection coll = new ArrayList();\ncoll.add(\"aa\");\ncoll.add(\"bb\");\ncoll.add(123);\ncoll.add(new Date());\ncoll.add(new String(\"asd\"));\ncoll.add(new Person(\"lc\",18));\n//集合元素的遍历\nIterator iterator = coll.iterator();\n//hasNext()：判断iterator指向的容器中是否有下一个对象\nwhile (iterator.hasNext()){\n    //next()：返回迭代器的下一个元素\n    System.out.println(iterator.next());\n}\n\nCollection coll2 = new ArrayList();\ncoll2.add(\"aa\");\ncoll2.add(\"bb\");\ncoll2.add(123);\ncoll2.add(new Date());\ncoll2.add(new String(\"asd\"));\ncoll2.add(new Person(\"lc\",18));\nIterator iterator2 = coll2.iterator();\nwhile (iterator2.hasNext()){\n    Object object = iterator2.next();\n    if(\"asd\".equals(object)){\n        //remove():删除迭代器返回的最后一个元素，即next()指向的元素\n        iterator2.remove();\n    }\n}\nSystem.out.println(coll2);\n```\n\n## 增强for循环：foreach()\n\n* Java 5.0 提供了 foreach 循环迭代访问 Collection和数组。\n\n* 遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。\n\n* 遍历集合的底层调用Iterator完成操作。\n\n* foreach还可以用来遍历数组。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184403.png)\n\n```java\nCollection coll = new ArrayList();\ncoll.add(\"aa\");\ncoll.add(\"bb\");\ncoll.add(123);\ncoll.add(new Date());\ncoll.add(new String(\"asd\"));\ncoll.add(new Person(\"lc\",18));\n//for(元素的类型 局部变量:遍历对象)\n//内部实质还是使用iterator来遍历元素\nfor (Object obj : coll) {\n    System.out.println(obj);\n}\n```\n\n# Collection子接口一：List\n\n* 鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组\n\n* List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。\n\n* List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。\n\n* JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。\n\n* List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。 \n\n  |                    方法                    |                   作用                    |\n  | :----------------------------------------: | :---------------------------------------: |\n  |      void add(int index, Object ele)       |          在index位置插入ele元素           |\n  | boolean addAll(int index, Collection eles) | 从index位置开始将eles中的所有元素添加进来 |\n  |           Object get(int index)            |          获取指定index位置的元素          |\n  |          int indexOf(Object obj)           |       返回obj在集合中首次出现的位置       |\n  |        int lastIndexOf(Object obj)         |     返回obj在当前集合中末次出现的位置     |\n  |          Object remove(int index)          |   移除指定index位置的元素，并返回此元素   |\n  |     Object set(int index, Object ele)      |       设置指定index位置的元素为ele        |\n  |  List subList(int fromIndex, int toIndex)  |   返回从fromIndex到toIndex位置的子集合    |\n\n```java\nList  list1 = new ArrayList();\nlist1.add(123);\nlist1.add(\"asd\");\nlist1.add(\"asd\");\nlist1.add(\"asd\");\nlist1.add(true);\nlist1.add(12.54);\nlist1.add(new String(\"qwe\"));\nlist1.add(new Person(\"lc\",18));\nSystem.out.println(list1.toString());\n//void add(int index, Object element)：在index位置插入element元素\nlist1.add(1, 456);\nSystem.out.println(list1.toString());\n//void addAll(int index, Collection c)：从index位置开始将list2中的所有元素插入到当前list中\nList list2 = new ArrayList();\nlist2.add(67);\nlist2.add(67);\nlist2.add(7);\nlist2.add(8);\nlist1.addAll(3, list2);\nSystem.out.println(list1.toString());\n//Object get(int index);获取位于index位置的元素。越界则返回-1\nSystem.out.println(list1.get(3));\n//int indexOf(Object o);返回元素o在集合中首次出现的位置\nSystem.out.println(list1.indexOf(\"asd\"));\n//int lastIndexOf(Object o);返回元素o在集合中最后一次出现的位置\nSystem.out.println(list1.lastIndexOf(\"asd\"));\n//Object remove(int index);移除集合中位于index位置的元素并返回这个元素\nSystem.out.println(list1.remove(2));\nSystem.out.println(list1.toString());\n//Object set(int index, Object element);设置集合的index位置的元素为element\nlist1.set(0, \"asd\");\nSystem.out.println(list1.toString());\n//List subList(int fromIndex, int toIndex);将当前集合的从fromIndex到toIndex位置的元素复制到一个子集和中，并返回这个子集和\n//范围：前闭后开。不会对当前集合的元素造成影响\nList list3 = list1.subList(2, 5);\nSystem.out.println(list1.toString());\nSystem.out.println(list3.toString());\n//boolean remove(Object o);删除集合中和o相等的元素，如果有多个则只删除第一个\nSystem.out.println(list1.remove(new Integer(\"67\")));\nSystem.out.println(list1.toString());\n```\n\n## List的实现类一：ArrayList\n\n* ArrayList 是 List 接口的典型实现类、主要实现类\n* 本质上，ArrayList是对象引用的一个”变长”数组\n* ArrayList的JDK1.8之前与之后的实现区别？\n  * JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组\n  * JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组\n* Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合\n\n## List的实现类二：LinkedList\n\n* 对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高\n\n* LinkedList：双向链表，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。\n  同时，定义内部类Node，作为LinkedList中保存数据的基本结构。Node除了保存数据，还定义了两个变量：\n\n  * prev变量记录前一个元素的位置\n  * next变量记录下一个元素的位置\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184404.png)\n\n* 新增方法：\n\n  |           方法            |           作用           |\n  | :-----------------------: | :----------------------: |\n  | void addFirst(Object obj) |  将一个元素添加在第一位  |\n  | void addLast(Object obj)  | 将一个元素添加在最后一位 |\n  |     Object getFirst()     |    获取第一位上的元素    |\n  |     Object getLast()      |   获取最后一位上的元素   |\n  |   Object removeFirst()    |    移除第一位上的元素    |\n  |    Object removeLast()    |   移除最后一位上的元素   |\n\n## List的实现类三：Vector\n\n* Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。\n\n* 在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。\n\n* 新增方法：\n\n  |                    方法                    |             作用             |\n  | :----------------------------------------: | :--------------------------: |\n  |        void addElement(Object obj)         |   往集合中添加一个元素obj    |\n  | void insertElementAt(Object obj,int index) | 在index位置上插入一个元素obj |\n  |  void setElementAt(Object obj,int index)   | 把index位置上的元素设置为obj |\n  |       void removeElement(Object obj)       |         移除元素obj          |\n  |          void removeAllElements()          |    移除集合中所有 的元素     |\n\n```\n面试题：\n请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别? \n\n1.ArrayList和LinkedList的异同\n \t二者都线程不安全，相对线程安全的Vector，执行效率高。此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链\n表的数据结构。对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指\n插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。\n2.ArrayList和Vector的区别\n \tVector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比\nArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。\nVector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。\n```\n\n# Collection子接口二：Set\n\n* Set接口是Collection的子接口，set接口没有提供额外的方法\n* Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败。\n* Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法\n\n## Set的实现类一：HashSet\n\n* HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。\n\n* HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。 \n\n* HashSet 具有以下特点：\n\n  * 不能保证元素的排列顺序\n  * HashSet 不是线程安全的\n  * 集合元素可以是 null\n\n* HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。 \n\n* 对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。\n\n* 向HashSet中添加元素的过程：\n\n  * 当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好） \n  * 如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过链表的方式继续链接。 \n  * 如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。\n\n* 图解添加过程\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184405.png)\n\n* 重写 hashCode() 方法的基本原则\n\n  * 在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值。\n  * 当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode() 方法的返回值也应相等。\n  * 对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。\n\n* 重写 equals() 方法的基本原则\n\n  * 当一个类有自己特有的“逻辑相等”概念,当改写equals()的时候，总是要改写hashCode()，根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法，它们仅仅是两个对象。\n  * 因此，违反了“相等的对象必须具有相等的散列码”。\n  * 结论：复写equals方法的时候一般都需要同时复写hashCode方法。通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算\n\n* 以Eclipse/IDEA为例，在自定义类中可以调用工具自动重写equals和hashCode。\n\n  * 问题：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？\n  * 原因：选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）\n  * 并且31只占用5bits,相乘造成数据溢出的概率较小。\n  * 31可以 由i*31== (i<<5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）\n  * 31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突)\n\n```java\nSet set = new HashSet();\nset.add(123);\nset.add(13);\nset.add(12);\nset.add(new Person(\"lc\",18));\nset.add(new Person(\"lc\",18));\nIterator iterator = set.iterator();\nwhile (iterator.hasNext()){\n    System.out.println(iterator.next());\n}\n//输出\n123\n12\n13\nPerson{name='lc', age=18}\n```\n\n## Set的实现类二：LinkedHashSet\n\n* LinkedHashSet 是 HashSet 的子类\n\n* LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。\n\n* LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。\n\n* LinkedHashSet 不允许集合元素重复。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184406.png)\n\n```java\nSet set = new LinkedHashSet();\nset.add(123);\nset.add(13);\nset.add(new Person(\"lc\",18));\nset.add(new Person(\"lc\",18));\nset.add(12);\nIterator iterator = set.iterator();\nwhile (iterator.hasNext()){\n    System.out.println(iterator.next());\n}\n//输出\n123\n13\nPerson{name='lc', age=18}\n12\n```\n\n## Set的实现类三：TreeSet\n\n* TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。\n\n* TreeSet底层使用红黑树结构存储数据\n\n* 新增的方法如下： (了解) \n\n  |                   方法                   | 作用 |\n  | :--------------------------------------: | :--: |\n  |         Comparator comparator()          |      |\n  |              Object first()              |      |\n  |              Object last()               |      |\n  |          Object lower(Object e)          |      |\n  |         Object higher(Object e)          |      |\n  | SortedSet subSet(fromElement, toElement) |      |\n  |       SortedSet headSet(toElement)       |      |\n  |      SortedSet tailSet(fromElement)      |      |\n\n* TreeSet 两种排序方法：自然排序和定制排序。默认情况下，TreeSet 采用自然排序。\n\n* 特点：有序，查询速度比List快\n\n```java\nSet set1 = new TreeSet();\nset1.add(123);\nset1.add(13);\nset1.add(13);\nset1.add(12);\nset1.add(12);\nIterator iterator3 = set1.iterator();\nwhile (iterator3.hasNext()){\n    System.out.println(iterator3.next());\n}\n//输出\n12\n13\n123\n```\n\n### 自然排序：\n\n* TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列\n* 如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。\n  * 实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。 \n* Comparable 的典型实现：\n  * BigDecimal、BigInteger 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较\n  * Character：按字符的 unicode值来进行比较\n  * Boolean：true 对应的包装类实例大于 false 对应的包装类实例\n  * String：按字符串中字符的 unicode 值进行比较\n  * Date、Time：后边的时间、日期比前面的时间、日期大\n* 向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。\n* 因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是同一个类的对象。\n* 对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值。\n* 当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保证该方法与 compareTo(Object obj) 方法有一致的结果：如果两个对象通过equals() 方法比较返回 true，则通过 compareTo(Object obj) 方法比较应返回 0。否则，让人难以理解。\n\n```java\nSet set = new TreeSet();\nset.add(new Person(\"lc\",18));\nset.add(new Person(\"lsc\",14));\nset.add(new Person(\"ldc\",19));\nset.add(new Person(\"ldc\",18));\nset.add(new Person(\"lfc\",10));\nset.add(new Person(\"lfc\",15));\nIterator iterator = set.iterator();\nwhile (iterator.hasNext()){\n    System.out.println(iterator.next());\n}\n//输出\nPerson{name='lc', age=18}\nPerson{name='ldc', age=18}\nPerson{name='ldc', age=19}\nPerson{name='lfc', age=10}\nPerson{name='lfc', age=15}\nPerson{name='lsc', age=14}\n```\n\n### 定制排序\n\n* TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来实现。需要重写compare(T o1,T o2)方法。 \n* 利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。 \n* 要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。\n* 此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常。\n* 使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。\n\n```java\nSet set2 = new TreeSet(new Comparator() {\n    @Override\n    public int compare(Object o1, Object o2) {\n        if (o1 instanceof Person && o2 instanceof Person){\n            return Integer.compare(((Person) o1).getAge(), ((Person) o2).getAge());\n        }else{\n            throw new RuntimeException(\"传入的数据类型不一致\");\n        }\n    }\n});\nset2.add(new Person(\"lc\",18));\nset2.add(new Person(\"lsc\",14));\nset2.add(new Person(\"ldc\",19));\nset2.add(new Person(\"ldc\",17));\nset2.add(new Person(\"lfc\",10));\nset2.add(new Person(\"lfc\",15));\nIterator iterator2 = set2.iterator();\nwhile (iterator2.hasNext()){\n    System.out.println(iterator2.next());\n}\n//输出\nPerson{name='lfc', age=10}\nPerson{name='lsc', age=14}\nPerson{name='lfc', age=15}\nPerson{name='ldc', age=17}\nPerson{name='lc', age=18}\nPerson{name='ldc', age=19}\n```\n\n# Map接口\n\n* Map与Collection并列存在。用于保存具有映射关系的数据:key-value\n\n* Map 中的 key 和 value 都可以是任何引用类型的数据\n\n* Map 中的 key 用Set来存放，不允许重复，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法\n\n* 常用String类作为Map的“键”\n\n* key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value\n\n* Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是 Map 接口使用频率最高的实现类\n\n* 常用方法：\n\n  |                方法                 |                    作用                    |\n  | :---------------------------------: | :----------------------------------------: |\n  | Object put(Object key,Object value) | 将指定key-value添加到(或修改)当前map对象中 |\n  |         void putAll(Map m)          |   将m中的所有key-value对存放到当前map中    |\n  |      Object remove(Object key)      |   移除指定key的key-value对，并返回value    |\n  |            void clear()             |          清空当前map中的所有数据           |\n  |       Object get(Object key)        |           获取指定key对应的value           |\n  |   boolean containsKey(Object key)   |             是否包含指定的key              |\n  | boolean containsValue(Object value) |            是否包含指定的value             |\n  |             int size()              |         返回map中key-value对的个数         |\n  |          boolean isEmpty()          |            判断当前map是否为空             |\n  |     boolean equals(Object obj)      |      判断当前map和参数对象obj是否相等      |\n  |            Set keySet()             |          返回所有key构成的Set集合          |\n  |         Collection values()         |     返回所有value构成的Collection集合      |\n  |           Set entrySet()            |      返回所有key-value对构成的Set集合      |\n\n```java\nMap map = new HashMap();\n//添加Object put(K key, V value);\nmap.put(\"aa\", \"aa\");\nmap.put(23, new Person(\"lc\",18));\nmap.put(\"bb\", 45);\nmap.put(\"cc\", 15.5);\n//修改Object put(K key, V value);\nmap.put(\"cc\", 18.5);\nSystem.out.println(map.toString());\nSystem.out.println(\"************************\");\nMap map2 = new HashMap();\nmap2.put(\"cc\", 49);\nmap2.put(\"dd\", 5);\n//putAll(Map m);\nmap.putAll(map2);\nSystem.out.println(map.toString());\nSystem.out.println(map2.toString());\nSystem.out.println(\"*************************\");\n//Object remove(Object key)\nObject bb = map.remove(\"bb\");\nSystem.out.println(bb);\nSystem.out.println(map.toString());\nSystem.out.println(\"************************\");\n//void clear() :\nmap.clear();\nSystem.out.println(map.size());\nSystem.out.println(map.toString());\n\n//\nHashMap map3 = new HashMap();\nmap3.put(\"aa\", 1);\nmap3.put(\"bb\", 2);\nmap3.put(\"cc\", 3);\nmap3.put(\"dd\", 4);\nSystem.out.println(map3.get(\"bb\"));\nSystem.out.println(map3.containsKey(\"bb\"));\nSystem.out.println(map3.containsValue(4));\nSystem.out.println(map3.size());\nSystem.out.println(map3.isEmpty());\nSystem.out.println(map3.equals(map));\n\n//\nSet set = map3.keySet();\nIterator iterator = set.iterator();\nwhile (iterator.hasNext()){\n    System.out.println(iterator.next());\n}\nSystem.out.println(\"***********************\");\nCollection collection = map3.values();\nIterator iterator1 = collection.iterator();\nwhile (iterator1.hasNext()){\n    System.out.println(iterator1.next());\n}\nSystem.out.println(\"*********************\");\nSet set1 = map3.entrySet();\nIterator iterator2 = set1.iterator();\nwhile (iterator2.hasNext()){\n    System.out.println(iterator2.next());\n}\nMap map = new HashMap();\n//map.put(..,..)省略\nSystem.out.println(\"map的所有key:\");\nSet keys = map.keySet();// HashSet\nfor (Object key : keys) {\n    System.out.println(key + \"->\" + map.get(key));\n}\nSystem.out.println(\"map的所有的value：\");\nCollection values = map.values();\nIterator iter = values.iterator();\nwhile (iter.hasNext()) {\n    System.out.println(iter.next());\n}\nSystem.out.println(\"map所有的映射关系：\");\n// 映射关系的类型是Map.Entry类型，它是Map接口的内部接口\nSet mappings = map.entrySet();\nfor (Object mapping : mappings) {\n    Map.Entry entry = (Map.Entry) mapping;\n    System.out.println(\"key是：\" + entry.getKey() + \"，value是：\" + entry.getValue());\n}\n```\n\n## Map的实现类一：HashMap\n\n* HashMap是 Map 接口使用频率最高的实现类。\n\n* 允许使用null键和null值，与HashSet一样，不保证映射的顺序。\n\n* 所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写：equals()和hashCode()\n\n* 所有的value构成的集合是Collection:无序的、可以重复的。所以，value所在的类要重写：equals()\n\n* 一个key-value构成一个entry\n\n* 所有的entry构成的集合是Set:无序的、不可重复的\n\n* HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true，hashCode 值也相等。\n\n* HashMap 判断两个 value相等的标准是：两个 value 通过 equals() 方法返回 true\n\n* HashMap的存储结构\n\n  * JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法)\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184407.png)\n\n  * JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184408.png)\n\n* HashMap源码中的重要常量\n\n  |          常量名          |                       作用                       |\n  | :----------------------: | :----------------------------------------------: |\n  | DEFAULT_INITIAL_CAPACITY |              HashMap的默认容量，16               |\n  |     MAXIMUM_CAPACITY     |           HashMap的最大支持容量，2^30            |\n  |   DEFAULT_LOAD_FACTOR    |              HashMap的默认加载因子               |\n  |    TREEIFY_THRESHOLD     |    Bucket中链表长度大于该默认值，转化为红黑树    |\n  |   UNTREEIFY_THRESHOLD    | Bucket中红黑树存储的Node小于该默认值，转化为链表 |\n  |   MIN_TREEIFY_CAPACITY   |       桶中的Node被树化时最小的hash表容量。       |\n  |          table           |           存储元素的数组，总是2的n次幂           |\n  |         entrySet         |                 存储具体元素的集                 |\n  |           size           |           HashMap中存储的键值对的数量            |\n  |         modCount         |          HashMap扩容和结构改变的次数。           |\n  |        threshold         |           扩容的临界值，=容量*填充因子           |\n  |        loadFactor        |                     填充因子                     |\n\n  * 当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。\n\n* JDK 7之前\n\n  * HashMap的内部存储结构其实是数组和链表的结合。当实例化一个HashMap时，系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。 \n  * 每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head。\n  * 添加元素的过程：\n\n  ```java\n  向HashMap中添加entry1(key，value)，需要首先计算entry1中key的哈希值(根据\n  key所在类的hashCode()计算得到)，此哈希值经过处理以后，得到在底层Entry[]数\n  组中要存储的位置i。如果位置i上没有元素，则entry1直接添加成功。如果位置i上\n  已经存在entry2(或还有链表存在的entry3，entry4)，则需要通过循环的方法，依次\n  比较entry1中key和其他的entry。如果彼此hash值不同，则直接添加成功。如果\n  hash值不同，继续比较二者是否equals。如果返回值为true，则使用entry1的value\n  去替换equals为true的entry的value。如果遍历一遍以后，发现所有的equals返回都\n  为false,则entry1仍可添加成功。entry1指向原有的entry元素。\n  ```\n\n  * HashMap的扩容\n\n  ```java\n  当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的\n  长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，而在\n  HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算\n  其在新数组中的位置，并放进去，这就是resize。\n  ```\n\n  * 那么HashMap什么时候进行扩容呢？\n\n  ```java\n  当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数\n  size)*loadFactor 时 ， 就 会 进 行 数 组 扩 容 ，loadFactor的默认值 (DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况\n  下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数\n  超过16*0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把\n  数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，\n  而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，\n  那么预设元素的个数能够有效的提高HashMap的性能。\n  ```\n\n* JDK 8时\n\n  * HashMap的内部存储结构其实是数组+链表+树的结合。当实例化一个HashMap时，会初始化initialCapacity和loadFactor，在put第一对映射关系时，系统会创建一个长度为initialCapacity的Node数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。 \n  * 每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带一个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，每一个TreeNode对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last，或树的叶子结点。\n  * 那么HashMap什么时候进行扩容和树形化呢？\n\n  ```java\n  当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数\n  size)*loadFactor 时 ， 就会进行数组扩容 ， loadFactor 的默认 值 (DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认\n  情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中\n  元素个数超过16*0.75=12（这个值就是代码中的threshold值，也叫做临界值）\n  的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元\n  素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知\n  HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。\n      \n  当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有\n  达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成\n  树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，\n  下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。\n  ```\n\n  * 关于映射关系的key是否可以修改？answer：不要修改\n\n  ```java\n  映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算\n  每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的映射关\n  系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。\n  ```\n\n* 总结：JDK1.8相较于之前的变化：\n\n  * HashMap map = new HashMap();//默认情况下，先不创建长度为16的数组\n  * 当首次调用map.put()时，再创建长度为16的数组\n  * 数组为Node类型，在jdk7中称为Entry类型\n  * 形成链表结构时，新添加的key-value对在链表的尾部（七上八下）\n  * 当数组指定索引位置的链表长度>8时，且map中的数组的长度> 64时，此索引位置上的所有key-value对使用红黑树进行存储。\n\n* 面试题：负载因子值的大小，对HashMap有什么影响?\n\n  ```java\n  1.负载因子的大小决定了HashMap的数据密度。\n  2.负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长,\n  造成查询或插入时的比较次数增多，性能会下降。\n  3.负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的\n  几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性\n  能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建\n  议初始化预设大一点的空间。\n  4.按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此\n  时平均检索长度接近于常数。\n  ```\n\n## Map的实现类二：LinkedHashMap\n\n* LinkedHashMap 是 HashMap 的子类\n\n* 在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的顺序\n\n* 与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致\n\n* LinkedHashMap和 HashMap 的区别\n\n  * HashMap中的内部类：Node\n\n  ```java\n  static class Node<K,V> implements Map.Entry<K,V> {\n  \tfinal int hash;\n  \tfinal K key;\n  \tV value;\n  \tNode<K,V> next; \n  }\n  ```\n\n  * LinkedHashMap中的内部类：Entry\n\n  ```java\n  static class Entry<K,V> extends HashMap.Node<K,V> {\n  \tEntry<K,V> before, after;\n  \tEntry(int hash, K key, V value, Node<K,V> next) {\n  \t\tsuper(hash, key, value, next);\n  \t} \n  }\n  ```\n\n* 使用\n\n  ```java\n  Map map = new LinkedHashMap();\n  map.put(\"aa\", 12);\n  map.put(\"bb\", 12);\n  map.put(\"cc\", 12);\n  map.put(\"dd\", 12);\n  System.out.println(map.toString());\n  ```\n\n## Map实现类之三：TreeMap\n\n* TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。\n\n* TreeMap 可以保证所有的 Key-Value 对处于有序状态。 \n\n* TreeSet底层使用红黑树结构存储数据。\n\n* TreeMap 的 Key 的排序：\n\n  * 自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException\n  * 定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现Comparable 接口\n\n* TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0。\n\n  ```java\n  //自然排序：key对象对应类继承Comparable接口实现compareTo()方法\n  Map map = new TreeMap();\n  map.put(new Person(\"lc\",18), 45);\n  map.put(new Person(\"qw\",26), 85);\n  map.put(new Person(\"as\",52), 60);\n  map.put(new Person(\"zx\",45), 98);\n  //key类型不一致会报ClassCastException异常\n  //map.put(\"as\", 45);\n  System.out.println(map);\n  System.out.println(\"******************************\");\n  //定制排序\n  Map map1 = new TreeMap(new Comparator() {\n      @Override\n      public int compare(Object o1, Object o2) {\n          if (o1 instanceof Person && o2 instanceof Person){\n              return Integer.compare(((Person) o1).getAge(), ((Person) o2).getAge());\n          }else{\n              throw new RuntimeException(\"传入的数据类型不一致\");\n          }\n      }\n  });\n  map1.put(new Person(\"lc\",18), 45);\n  map1.put(new Person(\"qw\",26), 85);\n  map1.put(new Person(\"as\",52), 60);\n  map1.put(new Person(\"zx\",45), 98);\n  System.out.println(map1);\n  ```\n\n## Map实现类之四：Hashtable\n\n* Hashtable是个古老的 Map 实现类，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的。\n* Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。 \n* 与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value\n* 与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序\n* Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。\n\n## Map实现类之五：Properties\n\n* Properties 类是 Hashtable 的子类，该对象用于处理属性文件\n\n* 由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型\n\n* 存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法\n\n  ```java\n  try {\n      Properties properties = new Properties();\n      FileInputStream stream = new FileInputStream(\"jdbc.properties\");\n      properties.load(stream);\n      String name = properties.getProperty(\"name\");\n      String password = properties.getProperty(\"password\");\n      String account = properties.getProperty(\"account\");\n      System.out.println(name + \" \" + password + \" \"+ account);\n      stream.close();\n  } catch (IOException e) {\n      e.printStackTrace();\n  }\n  \n  /**\n   * Properties的使用：用来读取配置文件\n   */\n  @Test\n  public void test5() throws IOException {\n      Properties properties = new Properties();\n      //方式一：默认加载文件在当前module下\n      //        FileInputStream fis = new FileInputStream(\"jdbc.properties\");\n      //        properties.load(fis);\n      //方式二：默认加载文件在当前module的src下\n      ClassLoader classLoader = Person.class.getClassLoader();\n      InputStream is = classLoader.getResourceAsStream(\"jdbc.properties\");\n      properties.load(is);\n  \n      String name = properties.getProperty(\"name\");\n      String password = properties.getProperty(\"password\");\n      String account = properties.getProperty(\"account\");\n      System.out.println(\"name: \" + name +\n                         \"\\npassword: \" + password +\n                         \"\\naccount: \" + account);\n  }\n  ```\n\n# Collections工具类\n\n* Collections 是一个操作 Set、List 和 Map 等集合的工具类\n  Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法\n\n* 常用方法\n\n  | 方法                                                        | 作用                                                     |\n  | ----------------------------------------------------------- | -------------------------------------------------------- |\n  | reverse(List)                                               | 反转 List 中元素的顺序                                   |\n  | shuffle(List)                                               | 对 List 集合元素进行随机排序                             |\n  | sort(List)                                                  | 根据元素的自然顺序对指定 List 集合元素按升序排序         |\n  | sort(List，Comparator)                                      | 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 |\n  | swap(List，int i， int j)                                   | 将指定 list 集合中的 i 处元素和 j 处元素进行交换         |\n  | Object max(Collection)                                      | 根据元素的自然顺序，返回给定集合中的最大元素             |\n  | Object max(Collection，Comparator)                          | 根据 Comparator 指定的顺序，返回给定集合中的最大元素     |\n  | Object min(Collection)                                      | 根据元素的自然顺序，返回给定集合中的最大元小             |\n  | Object min(Collection，Comparator)                          | 根据 Comparator 指定的顺序，返回给定集合中的最小元素     |\n  | int frequency(Collection，Object)                           | 返回指定集合中指定元素的出现次数                         |\n  | void copy(List dest,List src)                               | 将src中的内容复制到dest中                                |\n  | boolean replaceAll(List list，Object oldVal，Object newVal) | 使用新值替换List 对象的所有旧值                          |\n\n* Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题\n\n  ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184409.png)\n\n# 补充：Enumeration\n\n* Enumeration 接口是 Iterator 迭代器的 “古老版本“\n* ![](https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184410.png)\n\n```java\nEnumeration stringEnum = new StringTokenizer(\"a-b*c-d-e-g\", \"-\");\nwhile(stringEnum.hasMoreElements()){\n\tObject obj = stringEnum.nextElement();\n\tSystem.out.println(obj); \n}\n```\n\n# 总结\n\n```java\n * 一，集合框架的概述\n *  1.集合，数组都是对多个数据进行存储操作的结构，简称Java容器。\n *      说明：此时的存储器，主要指的是内存层面的存储，不涉及到持久化的存储\n *  2.1数组在存储多个数据方面的特点\n *      >一旦初始化后，其长度就确定了\n *      >数组一旦定义好后，其元素的类型也就确定了，我们也就只能操作指定类型的数据\n *      例如：String[] strslObject[] objs;\n *  2.2数组在存储多个数据方面的缺点：\n *      >一旦初始化后，其长度就不可修改\n *      >数组中提供的方法非常有限，对于添加，删除，插入数据等操作，非常不便，同时效率不高。\n *      >获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用\n *      >数组存储数据的特点：有序，可重复。对于无序不可重复的需求，不能满足；\n * 二，集合框架\n *  |---- Collection接口：单列集合，用来存储一个一个的对象\n *      |---- List接口：存储有序的，可重复的数据\n *          |---- ArrayList,LinkedList,Vector\n *\n *      |---- Set接口：存放无序的，不可重复的数据\n *          |---- HashSet,LinkedHashSet,ThreeSet\n *\n *  |---- Map接口：双列集合，用来存储一对(key - value)一对的数据\n *      |---- HashMap,LinkedHashMap,TreeMap,Hashtable,Properties\n * 三，Collection接口中方法的使用\n *      add(Object obj):将元素obj添加到集合中\n *      addAll(Collection coll1):将coll1集合中的元素添加到当前集合中\n *      size():获取集合中元素的个数\n *      clear():清空集合中的元素\n *      isEmpty():判断当前集合是否为空\n *      contains(Object obj):判断当前集合中是否包含obj。在判断时，会调用obj的equals方法，因此对于自定义的类要重写   \n *                           equals方法\n *      containsAll(Collection coll2):判断coll2中的元素是否都位于当前集合中\n *      remove(Object obj):移除当前集合中和obj相同的一个元素\n *      removeAll(Collection coll3):移除当前集合与coll3中重复的元素,如果重复的元素则全部被移除\n *      retainAll(Collection coll4):保留当前集合与coll4中相同的元素，其他的都移除。如果有重复元素则都保留\n *      equals(Object obj)：当前集合和obj集合中的元素都相同则返回true,如果两个集合的顺序不同则看具体的集合种类。\n *      hashCode()：返回当前对象的哈希值\n *      toArray():集合 --> 数组\n *      Arrays.asList(数组):数组 --> 集合 ; 注意基本数据类型数组的声明要用包装类\n *      iterator()：返回迭代器对象，用于集合遍历，此时返回的iterator指向的时集合的第一个元素的前面\n * 四，Iterator接口的使用：只用来遍历集合，不能遍历Map\n *      Iterator：迭代器\n *      当访问越界时报NoSuchElementException异常\n *    常用方法：\n *      hasNext()：判断iterator指向的容器中是否有下一个对象\n *      next()：返回集合的下一个元素\n *          工作原理：①将iterator指向下一个，②输出iterator指向的值\n *      remove():删除迭代器返回的最后一个元素，即next()指向的元素\n *          注意：①remove()在使用前必须先使用next()。②remove()方法不能连续使用两次\n * 五，增强for循环foreach的使用\n *      格式：for(元素的类型 局部变量:遍历对象){\n *          输出 --> 局部变量\n *      }\n *      原理：内部实质还是使用iterator来遍历元素\n *      注意：foreach循环中，对局部变量的更改不会影响到遍历对象\n * 六，List接口实现类的使用\n *      |---- ArrayList：作为List接口的主要实现类；1.2版本开始；线程不安全的，效率高；底层使用Object[] elementData\n *    \t\t\t\t\t存储\n *      |---- LinkedList：底层使用双向链表存储。对于频繁的插入，删除操作，使用此类的效率比ArrayList高。\n *      |---- Vector：作为List接口的古老实现类，1.0版本就有了；线程安全的，效率底；底层使用Object[] elementData存储\n *   三者的异同？\n *    同：三个类都实现了List接口，存储数据的特点相同：存储有序的，可重复的数据\n *  ArrayList源码分析：\n *    jdk 7情况下\n *      ArrayList list = new ArrayList();//底层创建了一个长度是10的Object[]数组elementData\n *      liat.add(123) //elementData[0] = new Integer(123)\n *      ...\n *      list.add(456) //当此次添加导致底层elementData数组容量不够，则扩容。\n *      默认情况下，扩容为原来容量的1.5倍，同时将原有数组复制到新数组中。容量最大为int所能表示的最大数\n *    结论：建议开发中使用带参的构造器： ArrayList(int initialCapacity)\n *    jdk 8情况下\n *      ArrayList list = new ArrayList();//底层Object[] elementData = {}，并没有创建带长度的数组\n *      liat.add(123) //第一次调用add()时，底层才创建了长度10的数组，并将数组添加到elementData数组中\n *      ...\n *      后续的添加和扩容操作与jdk 7无异\n *   小结：jdk7中的ArrayList的对象的创建类似与单例的饿汉式，而jdk8的ArrayList的对象的创建类似于\n *          单例的懒汉式，延迟了数组的创建，节省内存。\n *  LinkedList源码分析\n *      LinkedList list = new LinkedList() //内部声明了Node类型的first和last属性，默认值为null\n *      list.add(123) //将123封装到Node中，创建一个Node对象，并将这个对象链接在LinkedList对象中\n *\n *      其中，Node定义为：\n *          private static class Node<E> {\n *              E item;\n *              Node<E> next;\n *              Node<E> prev;\n *\n *              Node(Node<E> prev, E element, Node<E> next) {\n *                  this.item = element;\n *                  this.next = next;\n *                  this.prev = prev;\n *               }\n *           }\n *          体现了LinkedList双向链表的说法\n *  Vector源码分析\n *      和ArrayList的JDK 7以前相类似,在创建时对象时都是长度为10的数组，\n *      不同在于每次扩容为原来的2倍\n * 七，List接口的使用\n *      1.有序性：集合中元素的顺序是按照添加的顺序一个一个排列在底层数组中的\n *      2.可重复性：集合中可以存放相同的元素\n *    常用的方法\n *      void add(int index, Object element)：在index位置插入element元素\n *      void addAll(int index, Collection c)：从index位置开始将list2中的所有元素插入到当前list中\n *      Object get(int index);获取位于index位置的元素。越界则返回-1\n *      int indexOf(Object o);返回元素o在集合中首次出现的位置\n *      int lastIndexOf(Object o);返回元素o在集合中最后一次出现的位置\n *      Object remove(int index);移除集合中位于index位置的元素并返回这个元素\n *      boolean remove(Object o);删除集合中和o相等的元素，如果有多个则只删除第一个\n *      List subList(int fromIndex, int toIndex);将当前集合的从fromIndex到toIndex位置的元素\n *          复制到一个子集和中，并返回这个子集和。  范围：前闭后开。不会对当前集合的元素造成影响\n * 八，常用方法总结\n *      增：add(Object o)\n *      删：remove(int index) / remove(Object o)\n *      改：set(int index,Object o)\n *      查：get(int index)\n *      插入：add(int index,Object o)\n *      长度：size()\n *      遍历：① Iterator迭代器方式\n *           ② 增强for循环\n *           ③ 普通的for循环\n * 九，Set接口实现类的使用\n *      |--- HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值\n *          |--- LinkedHashSet：作为HashSet的子类；遍历内部数据时，可以按照添加的顺序遍历\n *      |--- TreeSet：可以按照添加对象的指定属性，进行排序；集合中元素的类型必须一致\n *      Set接口中没有额外定义新的方法，使用的都是Collection中声明的方法\n *   HashSet源码分析：\n *          创建时，底层创建了一个HashMap\n *      1.底层以数组+链表的方式存储。存储一个数组，数组的每一个元素相当于是一个链表\n *      2.要求①：向set中添加的数据其所在类一定要重写hashCode()和equals()方法。\n *        要求②：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的哈希值\n *   LinkedHashSet源码分析：\n *          创建时，底层创建了带有LinkedHashMap类部分属性的的HashMap\n *      作为HashSet的子类，在添加数据的同时还维护了两个引用head和tail，这两个引用记录了此数据的前一个数据和后一个数据\n *          优点：对于频繁的遍历操作，效率比HashSet要高\n *   TreeSet源码分析：\n *      1.向TreeSet中添加数据时，要求数据是相同类的对象；\n *      2.TreeSet中存放的数据会自动排列，因此要求有排列的方法\n *          2.1 让存放的数据的类实现Comparable接口(自然排序)。\n *          2.2 在创建TreeSet对象时传入一个实现Comparable接口(定制排序)的对象。\n *      3. TreeSet中添加时不再是根据equals()方法进行判断，而是根据比较方法进行判断\n *          3.1 自然排序中。比较两个对象是否相同的标准为：caopareTo()放回0，不再是equals()\n *          3.2 定制排序中。比较两个对象是否相同的标准为：caopare()放回0，不再是equals()\n * 十，Set接口的使用\n *      以HashSet为例\n *      1.无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值有关\n *\n *      2.不可重复性：保证添加的元素按照equals()判断时，不能返回true。即相同的元素只能添加一次。\n *\n *      添加元素的过程：以HashSet为例 当向HashSet添加元素a时。\n *          首先调用元素a所在类的hashCode()方法，计算a的哈希值。\n *          然后此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置(即：索引位置)。判断此位置上是否有元素？\n *              当此位置上没有元素，则元素a添加成功。 --> 情况1\n *              当此位置上有元素(或一链表形式存在的多个元素)，则比较元素a与此位置上元素的哈希值？\n *                  如果哈希值不相同，则元素a添加成功  --> 情况2\n *                  如果哈希值相同，则调用元素a所在类的equals()方法与此位置上的元素进行比较？\n *                      如果equals()返回true,元素a添加失败\n *                      如果equals()返回false,则元素a添加成功 --> 情况3\n *          对于添加成功的情况2和3而言：元素a与已经存在指定索引位置上数据以链表的方式存储。\n *              JDK 7 ：元素a放在数组中，指向原来的元素\n *              JDK 8 ：原来的元素在数组中，指向元素a      总结：七上八下\n * 十一，Map接口实现类的使用\n *      |--- HashMap：作为Map的主要实现类；线程不安全的，效率高；可以存储null的key和value。\n *          |--- LinkedHashMap：保证在遍历map元素时，可以按照添加的顺序进行遍历。\n *                          原因：在原有的HashMap底层结构上，添加了一对指针，指向前一个元素和后一个元素。\n *                          对于频繁的遍历操作，此类执行效率高于HashMap。\n *      |--- TreeMap：保证按照添加的key-value进行排序。排序的依据是根据key的自然排序或定制排序。底层使用红黑树结构\n *      |--- Hashtable：作为古老的实现类；线程安全的，效率低；不能存储null的key和value\n *          |--- Properties：常用来处理配置文件。key和value都是String类型的\n *      DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16\n *      DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75\n *      TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树：8\n *      MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量。：64\n *      threshold：扩容的临界值，=容量*填充因子：16 * 0.75 = 12\n *\n *      HashMap的底层：数组+链表 （JDK 7 以前）\n *                    数组+链表+红黑树 （JDK 8以后）\n *      实现原理：以JDK 7为例：\n *      HashMap map = new HashMap();\n *          在实例化后，底层创建了长度为16的一维数组Entry[] table;\n *      ...\n *      map.put(key1,value1);\n *          首先：调用key1所在的hashCode()计算哈希值，此哈希值经过某种算法后，得到此键值对在Entry数组中存放的位置。先\n *    \t\t\t\t判断此位置是否为空？\n *              如果此位置上为空，则将此键值对添加至此位置上，添加成功。  -->情况2\n *              如果此位置上的数据不为空(即及位置上存在一个或多个以链表形式存在的数据).比较key1和此位置上所有数据的哈希\n *     \t\t\t值？\n *                  如果key1的哈希值与已存在数据的都不一样，此时key1-value1添加成功。 -->情况2\n *                  如果key1的哈希值与已存在数据中的某一个key2-value2的哈希值有一个一样，则调用key1所在类的\n *    \t\t\t\tequals(key2)方法进行比较\n *                      如果equals返回false,此时key1-value1添加成功。 -->情况3\n *                      如果equals返回true,此时用value1替换value2\n *          补充：关于情况2和情况3，此时的key1-value1和原来的数据一链表的方式存储。\n *          在不断添加的过程中，会涉及到扩容问题，默认扩容方式为：扩容为原来的2倍，并将原来的数据复制过来\n *          如果给定初始化的容量1，实际上创建的是比给定的数大且是2的次幂的容量的数组，例如给定15，实际创建的容量是16\n *          扩容时，如果当前容量为16，当添加的元素超过临界值且要添加的位置非空时就会扩容，而不是等到满时才扩容。\n *        JDK 8 较于7的不同之处\n *           1.new HashMap():实例化时底层就没有创建数组\n *           2.JDK 8的底层数组是：Node[]，而非Entry[]\n *           3.首次调用put()方法时，底层创建了长度为16的数组\n *           4.JDK 7的底层结构是：数组+链表。JDK 8的底层结构：数组+链表+红黑树\n *           红黑树的体现：当数组的某一位置上存在的链表的元素的个数 > 8且当前数组的长度 > 64时，此位置上的所有元素改用\n *\t\t     红黑树实现。\n *      LinkedHashMap底层结构\n *          完全继承HashMap中的方法，\n *          不同之处： static class Entry<K,V> extends HashMap.Node<K,V> {\n *                          Entry<K,V> before, after;\n *                          Entry(int hash, K key, V value, Node<K,V> next) {\n *                               super(hash, key, value, next);\n *                           }\n *                    }\n *          与HashMap相比，元素添加了before，after用来记录上一个添加的和下一个添加的元素\n *      TreeMap的使用\n *          1.像TreeMap中添加key-value,要求key必须是由同一个类创建的对象\n *              因为要按照key进行排序：自然排序，定制排序。\n *          2.不能按照value排序。\n *      Properties的使用：\n *          1.常用来处理配置文件。key和value都是String类型的\n *          2.\n * 十二，Map接口的底层结构\n *      Map中的key：无序的，不可重复的，使用Set存储所有的Key -->key所在的类要重写equals()和hashCode()方法\n *      Map中的value：无序的，可重复的，使用Collection存储所有的value -->value所在的类要重写equals()方法\n *      一个键值对：key-value构成了一个Entry对象。\n *      Map中的entry：无序的，不可重复的，使用Set存储所有的entry.\n *     添加、删除、修改操作：\n *          Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中\n *          void putAll(Map m):将m中的所有key-value对存放到当前map中\n *          Object remove(Object key)：移除指定key的key-value对，并返回value\n *          void clear()：清空当前map中的所有数据\n *     元素查询的操作：\n *          Object get(Object key)：获取指定key对应的value\n *          boolean containsKey(Object key)：是否包含指定的key\n *          boolean containsValue(Object value)：是否包含指定的value\n *          int size()：返回map中key-value对的个数\n *          boolean isEmpty()：判断当前map是否为空\n *          boolean equals(Object obj)：判断当前map和参数对象obj是否相等\n *     元视图操作的方法：\n *          Set keySet()：返回所有key构成的Set集合\n *          Collection values()：返回所有value构成的Collection集合\n *          Set entrySet()：返回所有key-value对构成的Set集合\n *     总结：常用方法\n *          增：put()\n *          删：remove()\n *          改：put()\n *          查：get()\n *          长度：size()\n *          遍历：keySet()/values()/entrySet()\n * 十三，Collections工具类的使用\n *      作用：操作Collection,Map的工具类\n *      方法：\n *          reverse(list):翻转list中的元素\n *          Collections.reverse(list);\n *          shuffle(list)：对list集合的元素随机排序\n *          Collections.shuffle(list);\n *          sort(list):根据元素的自然顺序对元素进行排序，要求集合中的元素一致\n *          swap(list, i, j)：将list中的第i个和第j个元素进行交换\n *          max(list)：返回list自然排序后最后一个位置上的值\n *          min(list)：返回list自然排序后第一个位置上的值\n *          int frequency(list, Object o):返回list中元素o出现的次数\n *          boolean replaceAll(list,oldVal,newVal)：将list集合中的oldVal变成newVal,如果有多个oldVal，则全部替\n *\t\t\t\t\t\t\t\t\t\t\t\t     换\n *          copy(dest,src):将src的内容复制到dest中。\n *              注意：dest创建的方式：List dest = Arrays.asList(new Object[src.size()]);\n *          List synchronizedList(List<T> list)返回的list1既是线程安全的\n```\n\n","categories":["Java学习","Java高级语法"]},{"title":"变量与标识符","url":"/2020/10/27/尚硅谷说Java/Java基础语法/1-变量与标识符/","content":"\nJava中变量的基本格式和标识符的格式\n\n<!--more-->\n\n# 变量\n\n* 变量的概念\n\n  * 内存中的一个存储区域\n  * 该区域的数据可以在同一类型范围内不断变化\n  * 变量是程序中最基本的存储单位。包含变量类型，变量名和存储的值\n\n* 变量的作用\n\n  * 用于在内存中保存数据\n\n* 变量的使用\n\n  * Java定义变量的格式：数据类型 变量名 = 变量值\n\n  ```java\n  //变量的定义\n  int age = 12;\n  //变量的使用\n  System.out.println(age);\n  //编译错误：使用number之前未被定义过number\n  System.out.println(number);\n  //变量的声明\n  int number;\n  //编译错误：使用number之前未被赋值过number\n  System.out.println(number);\n  //变量的赋值\n  number = 100;\n  ```\n\n* 使用变量注意\n\n  * Java中每个变量必须先声明，后使用\n  * 使用变量名来访问这块区域的数据\n  * 变量的作用域：其定义所在的一对{}内\n  * 变量只有在其作用域内才有效\n  * 同一个作用域内，不能定义重名的变量\n\n# 标识符\n\n* 定义\n  * Java对各种变量，方法和类等要素命名时使用的字符序列称为标识符\n  * 技巧：凡是自己可以起名字的地方都叫标识符\n  * 比如：类名，变量名，方法名，接口名，包名···\n* 定义合法标识符规则：不遵守时会使编译不通过\n  * 由26个英文字母大小写，0-9,_或&组成\n  * 数字不可以开头\n  * 不可以使用关键字和保留字，但能包含关键字和保留字\n  * Java中严格区分大小写，长度无限制\n  * 标识符不能包含空格\n* Java中的名称命名规范：不遵守时编译会通过。但这是程序员之间的一个约定，建议遵守\n  * 包名：多单词组成时所有字母都小写：xxxyyyzzz\n  * 类名，接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz\n  * 变量名，方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz\n  * 常量名：所有字母大写。多单词时每个单词用下划线来连接：XXX_YYY_ZZZ\n* 注意\n  * 在起名字时，为了提高代码阅读性，要尽量有意义，见名知意\n  * Java采用Unicode字符集，因此标识符也可以采用汉字声明，但是不建议使用","categories":["Java学习","Java基础语法"]},{"title":"常用快捷键","url":"/2020/10/12/工具的使用/eclipse/常用快捷键/","content":"eclipse的常用快捷键说明\n<!--more-->\n1. 补全代码的声明：<font color = \"red\">alt + /</font>\n2. 快速修复: <font color = \"red\">ctrl + 1</font>\n3. 批量导包: <font color = \"red\">ctrl + shift + o</font>\n4. 使用单行注释: <font color = \"red\">ctrl + /</font>\n5. 使用多行注释: <font color = \"red\">ctrl + shift + /</font>\n6. 取消多行注释: <font color = \"red\">ctrl + shift + \\\\</font>\n7. 复制指定行的代码: <font color = \"red\">ctrl + alt + down 或 ctrl + alt + up</font>\n8. 删除指定行的代码: <font color = \"red\">ctrl + d</font>\n9. 上下移动代码: <font color = \"red\">alt + up 或 alt + down</font>\n10. 切换到下一行代码空位: <font color = \"red\">shift + enter</font>\n11. 切换到上一行代码空位: <font color = \"red\">ctrl + shift + enter</font>\n12. 查看源码: <font color = \"red\">ctrl + 选中的结构 或 ctrl + shift + t</font>\n13. 退回到前一个编辑的页面: <font color = \"red\">alt + left</font>\n14. 进入到下一个编辑的页面: <font color = \"red\">alt + right</font>\n15. 光标选中指定的类，查看继承树结构: <font color = \"red\">ctrl + t</font>\n16. 复制代码: <font color = \"red\">ctrl + c</font>\n17. 撤销: <font color = \"red\">ctrl + z</font>\n18. 反撤销: <font color = \"red\">ctrl + y</font>\n19. 剪切: <font color = \"red\">ctrl + x</font>\n20. 粘贴: <font color = \"red\">ctrl + v</font>\n21. 保存: <font color = \"red\">ctrl + s</font>\n22. 全选: <font color = \"red\">ctrl + a</font>\n23. 格式化代码: <font color = \"red\">ctrl + shift + f</font>\n24. 选中数行，整体往后移动: <font color = \"red\">tab</font>\n25. 选中数行，整体往前移动: <font color = \"red\">shift + tab</font>\n26. 在当前类中，显示类结构，并支持搜索指定的方法，属性等: <font color = \"red\">ctrl + o</font>\n27. 批量修改指定的变量名，方法名，类名等: <font color = \"red\">alt + shift + r</font>\n28. 选中的结构大小写切换：变成大写： <font color = \"red\">ctrl + shift + x</font>\n29. 选中的结构大小写切换：变成小写: <font color = \"red\">xtrl + shift + y</font>\n30. 调出生成getter/setter/构造器等快捷方式：<font color = \"red\">alt + shift + s</font>\n31. 显示当前选择资源的属性：<font color = \"red\">alt + enter</font>\n32. 快速查找：参照选中的word快速定位到下一个：<font color = \"red\">ctrl + k</font>\n33. 关闭当前窗口：<font color = \"red\">ctrl + w</font>\n34. 关闭所有的窗口：<font color = \"red\">ctrl + shift + w</font>\n35. 查看指定的结构使用过的地方：<font color = \"red\">ctlr + alt + g</font>\n36. 查找与替换：<font color = \"red\">ctrl + f</font>\n37. 最大化当前的View：<font color = \"red\">ctrl + f</font>\n38. 直接定位到当前行的首位：<font color = \"red\">home</font>\n39. 直接定位到当前行的末尾：<font color = \"red\">end</font>\n\n","categories":["工具的使用","eclipse"]},{"title":"正则表达式学习","url":"/2020/10/10/尚硅谷说Java/正则表达式/正则表达式/","content":"正则表达式学习\n<!--more-->\n# 普通字符\n\n* 字母、数字、汉字、下划线、以及没有特殊定义的标点符 号，都是“普通字符”。表达式中的普通字符，在匹配一 个字符串的时候，匹配与之相同的一个字符。\n\n* 简单的转义字符\n\n  |                             字符                             |       作用       |\n  | :----------------------------------------------------------: | :--------------: |\n  |                              \\n                              |    代表换行符    |\n  |                              \\t                              |      制表符      |\n  |                             \\\\\\                              |    代表\\本身     |\n  | \\\\^ ，\\\\$,\\\\.，\\\\(，\\ \\) ，\\ \\{，\\ \\} ， \\? ，\\ \\+ ， \\\\* ， \\\\|，，\\\\[， \\\\] | 匹配这些字符本身 |\n\n# 标准字符集合\n\n* 能够与 ‘多种字符’ 匹配的表达式 。\n\n* 注意区分大小写，大写是相反的意思。\n\n  | 字符 |                             作用                             |\n  | :--: | :----------------------------------------------------------: |\n  | \\\\d  |                任意一个数字，0~9 中的任意一个                |\n  | \\\\w  | 任意一个字母或数字或下划线，也就是 A~Z,a~z,0~9,_ 中任意一个  |\n  | \\\\s  |       包括空格、制表符、换行符等空白字符的其中任意一个       |\n  | \\\\.  | 小数点可以匹配任意一个字符(除了换行符) 如果要匹配包括“\\n”在内的所有字符，一般用[\\s\\S] |\n\n# 自定义字符集合\n\n* [ ]方括号匹配方式，能够匹配方括号中任意一个字符\n\n  |  表达式   |                  作用                   |\n  | :-------: | :-------------------------------------: |\n  |  [ab5@]   |      匹配 \"a\" 或 \"b\" 或 \"5\" 或 \"@\"      |\n  |  [^abc]   |   匹配 \"a\",\"b\",\"c\" 之外的任意一个字符   |\n  |   [f-k]   |     匹配 \"f\"~\"k\" 之间的任意一个字母     |\n  | [^A-F0-3] | 匹配 \"A\"~\"F\",\"0\"~\"3\" 之外的任意一个字符 |\n\n* 正则表达式的特殊符号，被包含到中括号中，则失去特殊意义，除了 ^,-之外。\n\n* 标准字符集合，除小数点外，如果被包含于中括号，自定义字符集合 将包含该集合。\n\n  * 比如：[\\d.\\\\-+]将匹配：数字、小数点、+、-\n\n#  量词\n\n* 修饰匹配次数的特殊符号\n\n  |       |                 作用                  |\n  | :---: | :-----------------------------------: |\n  |  {n}  |             表达式重复n次             |\n  | {m,n} |    表达式至少重复m次，最多重复n次     |\n  | {m,}  |           表达式至少重复m次           |\n  |   ?   |  匹配表达式0次或者1次，相当于 {0,1}   |\n  |   +   |    表达式至少出现1次，相当于 {1,}     |\n  |   *   | 表达式不出现或出现任意次，相当于 {0,} |\n\n  * 例如：\\d{6}表示匹配六位数。\n  * \\d{3,6}表示匹配3位数，四位数，五位数，六位数。优先匹配六位数(然后递减)\n  * \\d{3,6}?表示匹配3位数，四位数，五位数，六位数。优先匹配三位数(然后递增)\n\n* 匹配次数中的贪婪模式(匹配字符越多越好，默认！) 。如\\d{3,6}\n\n* 匹配次数中的非贪婪模式（匹配字符越少越好，修饰匹配次数 的特殊符号后再加上一个 \"?\" 号）。如\\d{3,6}?\n\n# 字符边界\n\n* (本组标记匹配的不是字符而是位置，符合某种条件的位置)\n\n  |      |          作用          |\n  | :--: | :--------------------: |\n  |  ^   | 与字符串开始的地方匹配 |\n  |  $   | 与字符串结束的地方匹配 |\n  |  \\b  |    匹配一个单词边界    |\n\n* \\b匹配这样一个位置：前面的字符和后面的字符不全是\\w\n\n","categories":["Java学习","正则表达式"]}]