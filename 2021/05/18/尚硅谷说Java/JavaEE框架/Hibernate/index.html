<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"plumv.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="Hibernate官网：http:&#x2F;&#x2F;hibernate.org&#x2F; 基于Hibernate4版本学习。工具为Eclipse">
<meta property="og:type" content="article">
<meta property="og:title" content="Hibernate的学习">
<meta property="og:url" content="https://plumv.github.io/2021/05/18/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/JavaEE%E6%A1%86%E6%9E%B6/Hibernate/index.html">
<meta property="og:site_name" content="李川的个人博客">
<meta property="og:description" content="Hibernate官网：http:&#x2F;&#x2F;hibernate.org&#x2F; 基于Hibernate4版本学习。工具为Eclipse">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-1.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-2.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-3.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-4.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-5.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-6.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-7.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-8.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-9.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210515152901.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-10.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-11.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-12.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-13.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-14.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-15.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-16.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-17.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-18.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517135139.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-19.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-20.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-1.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-2.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-3.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-4.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-5.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-6.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-7.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-8.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-9.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-10.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-11.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-12.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-13.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-14.png">
<meta property="article:published_time" content="2021-05-17T16:00:00.000Z">
<meta property="article:modified_time" content="2021-05-18T11:37:43.913Z">
<meta property="article:author" content="Plum Reiver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710.png">

<link rel="canonical" href="https://plumv.github.io/2021/05/18/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/JavaEE%E6%A1%86%E6%9E%B6/Hibernate/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Hibernate的学习 | 李川的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李川的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>日志</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://plumv.github.io/2021/05/18/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/JavaEE%E6%A1%86%E6%9E%B6/Hibernate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plum Reiver">
      <meta itemprop="description" content="技术，日常，笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李川的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Hibernate的学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-18 00:00:00 / 修改时间：19:37:43" itemprop="dateCreated datePublished" datetime="2021-05-18T00:00:00+08:00">2021-05-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0/JavaEE%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">JavaEE框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <ul>
<li>Hibernate官网：<a target="_blank" rel="noopener" href="http://hibernate.org/">http://hibernate.org/</a></li>
<li>基于Hibernate4版本学习。工具为Eclipse</li>
</ul>
<span id="more"></span>

<h1 id="Hibernate入门"><a href="#Hibernate入门" class="headerlink" title="Hibernate入门"></a>Hibernate入门</h1><ul>
<li><p>Hibernate是一个开放源代码的<strong>对象关系映射</strong>框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个<strong>全自动的orm框架</strong>，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。</p>
</li>
<li><p>对象的持久化：</p>
<ul>
<li>狭义的理解，“持久化”仅仅指把对象永久保存到数据库中。</li>
<li>广义的理解，“持久化”包括和数据库相关的各种操作：<ul>
<li>保存：把对象永久保存到数据库中。</li>
<li>更新：更新数据库中对象(记录)的状态。</li>
<li>删除：从数据库中删除一个对象。</li>
<li>查询：根据特定的查询条件，把符合查询条件的一个或多个对象从数据库加载到内存中。</li>
<li>加载：根据<strong>特定的OID</strong>，把一个对象从数据库加载到内存中。</li>
</ul>
</li>
<li>为了在系统中能够找到所需对象，需要为每一个对象分配一个唯一的标识号。在关系数据库中称之为主键，而在对象术语中，则叫做对象标识(Object identifier-OID).</li>
</ul>
</li>
<li><p>ORM：</p>
<ul>
<li>ORM(Object/Relation Mapping): 对象/关系映射。</li>
<li>ORM 主要解决对象-关系的映射</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710.png"></p>
<ul>
<li>ORM的思想：将关系数据库中表中的记录映射成为对象，以对象的形式展现，程序员可以把对数据库的操作转化为对对象的操作。</li>
<li>ORM 采用元数据来描述对象-关系映射细节, 元数据通常采用 XML 格式, 并且存放在专门的对象-关系映射文件中。</li>
<li>结构图：</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-1.png"></p>
<ul>
<li>流行的ORM框架：<ul>
<li>Hibernate:<ul>
<li>非常优秀、成熟的 ORM 框架。</li>
<li>完成对象的持久化操作。</li>
<li>Hibernate 允许开发者采用面向对象的方式来操作关系数据库。</li>
<li>消除那些针对特定数据库厂商的 SQL 代码。</li>
</ul>
</li>
<li>myBatis：<ul>
<li>相比 Hibernate 灵活高，运行速度快。</li>
<li>开发速度慢，不支持纯粹的面向对象操作，需熟悉sql语句，并且熟练使用sql语句优化功能。</li>
</ul>
</li>
<li>TopLink</li>
<li>OJB</li>
</ul>
</li>
</ul>
</li>
<li><p>Hibernate与JDBC的代码比较：完成添加数据的操作：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-2.png"></p>
</li>
<li><p>eclipse安装Hibernate插件。为了方便开发。</p>
<ul>
<li>1.点击Help –&gt; 选择Install New Software…</li>
<li>2.输入：<a target="_blank" rel="noopener" href="https://download.jboss.org/jbosstools/photon/stable/updates/%E3%80%82%E7%84%B6%E5%90%8E%E6%8C%89%E5%9B%9E%E8%BD%A6%E3%80%82">https://download.jboss.org/jbosstools/photon/stable/updates/。然后按回车。</a><ul>
<li>此网址可以在hibernate官网上的工具下载里面找。</li>
</ul>
</li>
<li>3.选中hibernate tools。如下图。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-3.png"></p>
<ul>
<li>4.一直点击下一步即可。</li>
<li>5.重启eclipse即可。</li>
</ul>
</li>
<li><p>使用IDEA搭建Hibernate</p>
<ul>
<li>第一步：创建Java Enterprise项目。导入jar包。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">所有jar包下载地址：https:&#x2F;&#x2F;plumriver.lanzoui.com&#x2F;inBJCp536ji</span><br><span class="line">antlr-2.7.7.jar</span><br><span class="line">c3p0-0.9.2.1.jar</span><br><span class="line">dom4j-1.6.1.jar</span><br><span class="line">hibernate-c3p0-4.2.4.Final.jar</span><br><span class="line">hibernate-commons-annotations-4.0.2.Final.jar</span><br><span class="line">hibernate-core-4.2.4.Final.jar</span><br><span class="line">lib\hibernate-jpa-2.0-api-1.0.1.Final.jar</span><br><span class="line">javassist-3.15.0-GA.jar</span><br><span class="line">jboss-logging-3.1.0.GA.jar</span><br><span class="line">jboss-transaction-api_1.1_spec-1.0.1.Final.jar</span><br><span class="line">mchange-commons-java-0.2.3.4.jar</span><br><span class="line">mysql-connector-java-5.1.7-bin.jar</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第二步：配置Hibernate配置文件。文件名为：hibernate.xfg.xml。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-configuration</span> <span class="meta-keyword">SYSTEM</span></span></span><br><span class="line"><span class="meta">    <span class="meta-string">&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置链接数据库的基本信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.username&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.password&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.driver_class&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.url&quot;</span>&gt;</span>jdbc:mysql:///hibernate<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置hibernate的基本信息--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.指定使用的数据库方言。此方言根据数据库不同，版本不同，驱动不同。则方言也不同--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQL5InnoDBDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2.指定操作数据库时，是否在控制台打印SQL语句--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3.是否对SLQ进行格式化--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;format_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--4.指定自动生成数据表的策略--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定关联的hbm.xml文件以及对应的实体类对象。在IDEA中这个信息可以自动生成--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">&quot;com/lc/bean/News.hbm.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">&quot;com.lc.bean.News&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>第三步：创建持久化类。即实体类。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新闻实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">News</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  <span class="keyword">private</span> String author;</span><br><span class="line">  <span class="keyword">private</span> Date date;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 无参构造方法，有参构造方法，</span></span><br><span class="line"><span class="comment">   * 所有属性的get，set方法</span></span><br><span class="line"><span class="comment">   * 重写equals方法和hashcode方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第四步：创建对象-关系映射文件</p>
<ul>
<li>IDEA使用根据数据库的方式创建。即先有数据库中的表，然后自动生成实体类以及映射文件。</li>
<li>首先使用IDEA的Database功能连接mysql数据库。</li>
<li>IDEA左下角点击persistence。右击hibernate，选中最下方的genreate mapping。</li>
<li>然后点击by database，然后填写信息即可。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-4.png"></p>
<ul>
<li>对应的配置文件信息：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">    <span class="meta-string">&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">    <span class="meta-string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;com.lc.bean.News&quot;</span> <span class="attr">table</span>=<span class="string">&quot;news&quot;</span> <span class="attr">schema</span>=<span class="string">&quot;hibernate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ID&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--指定主键的生成方式。native表示使用数据库本地的方式--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;TITLE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">column</span>=<span class="string">&quot;AUTHOR&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;date&quot;</span> <span class="attr">column</span>=<span class="string">&quot;DATE&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>第五步：编写测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建SessionFactory对象</span></span><br><span class="line">  <span class="comment">// 1.1 创建Configuration对象：对应hibernate的基本配置信息，以及对象映射信息</span></span><br><span class="line">  <span class="comment">// configure()方法可以指明配置文件信息。默认加载名为“hibernate.cfg.xml”的配置文件</span></span><br><span class="line">  Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">  <span class="comment">// 1.2 创建ServiceRegistry对象：在4.0以后开始出现此对象。</span></span><br><span class="line">  <span class="comment">//   功能：hibernate 的任何配置和服务都需要在该对象中注册后才能有效.</span></span><br><span class="line">  ServiceRegistry serviceRegistry =</span><br><span class="line">    <span class="keyword">new</span> ServiceRegistryBuilder().applySettings(configuration.getProperties())</span><br><span class="line">    .buildServiceRegistry();</span><br><span class="line">  <span class="comment">// 1.3 创建SessionFactory对象</span></span><br><span class="line">  SessionFactory sessionFactory = configuration.buildSessionFactory(serviceRegistry);</span><br><span class="line">  <span class="comment">// 2.创建Session对象</span></span><br><span class="line">  Session session = sessionFactory.openSession();</span><br><span class="line">  <span class="comment">// 3.开启事务</span></span><br><span class="line">  Transaction transaction = session.beginTransaction();</span><br><span class="line">  <span class="comment">// 4.执行保存操作</span></span><br><span class="line">  News news = <span class="keyword">new</span> News(<span class="string">&quot;hibernate测试&quot;</span>,<span class="string">&quot;hibernate&quot;</span> , <span class="keyword">new</span> Date());</span><br><span class="line">  session.save(news);</span><br><span class="line">  <span class="comment">// 5.提交事务</span></span><br><span class="line">  transaction.commit();</span><br><span class="line">  <span class="comment">// 6.关闭Session对象</span></span><br><span class="line">  session.clear();</span><br><span class="line">  <span class="comment">// 7.关闭SessionFactory对象</span></span><br><span class="line">  sessionFactory.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>说明：</p>
<ul>
<li>持久化类的说明：<ul>
<li>提供一个无参的构造器:使Hibernate可以使用Constructor.newInstance() 来实例化持久化类。</li>
<li>提供一个标识属性(identifier property): <strong>通常映射为数据库表的主键字段</strong>. 如果没有该属性，一些功能将不起作用，如：Session.saveOrUpdate()</li>
<li>为类的持久化类字段声明访问方法(get/set): Hibernate对JavaBeans 风格的属性实行持久化。</li>
<li>使用非 final 类: 在运行时<strong>生成代理</strong>是 Hibernate 的一个重要的功能. 如果持久化类没有实现任何接口, Hibnernate 使用 CGLIB 生成代理. 如果使用的是 final 类, 则无法生成 CGLIB 代理。</li>
<li><strong>重写 eqauls 和 hashCode 方法</strong>: 如果需要把持久化类的实例放到 Set 中(当需要进行关联映射时), 则应该重写这两个方法。</li>
</ul>
</li>
<li>对象-关系映射文件说明：<ul>
<li>Hibernate 采用 XML 格式的文件来指定对象和关系数据之间的映射. 在运行时 Hibernate 将根据这个映射文件来生成各种 SQL 语句。</li>
<li>映射文件的扩展名为 .hbm.xml。</li>
</ul>
</li>
<li>配置文件说明：<ul>
<li>Hibernate 从其配置文件中读取和数据库连接的有关信息, 这个文件应该位于应用的 classpath 下。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用 Hibernate 进行数据持久化操作，通常有如下步骤：</p>
<ul>
<li>编写持久化类： POJO + 映射文件</li>
<li>获取 Configuration 对象。</li>
<li>获取 SessionFactory 对象。</li>
<li>获取 Session，打开事务。</li>
<li>用面向对象的方式操作数据库。</li>
<li>关闭事务，关闭 Session。</li>
</ul>
</li>
<li><p>Configuration 类：</p>
<ul>
<li>Configuration 类负责管理 Hibernate 的配置信息。包括如下内容：<ul>
<li>Hibernate 运行的底层信息：数据库的URL、用户名、密码、JDBC驱动类，数据库Dialect,数据库连接池等（对应 hibernate.cfg.xml 文件）。</li>
<li>持久化类与数据表的映射关系（*.hbm.xml 文件）。</li>
</ul>
</li>
<li>创建 Configuration 的两种方式：<ul>
<li>属性文件（hibernate.properties）:<ul>
<li>Configuration cfg = new Configuration();</li>
</ul>
</li>
<li>Xml文件（hibernate.cfg.xml）<ul>
<li>Configuration cfg = new Configuration().configure();</li>
</ul>
</li>
<li>Configuration 的 configure 方法还支持带参数的访问：<ul>
<li>File file = new File(“simpleit.xml”);</li>
<li>Configuration cfg = new Configuration().configure(file);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>SessionFactory 接口：</p>
<ul>
<li>针对单个数据库映射关系经过编译后的内存镜像，是线程安全的。 </li>
<li>SessionFactory 对象一旦构造完毕，即被赋予特定的配置信息</li>
<li>SessionFactory是生成Session的工厂</li>
<li>构造 SessionFactory 很消耗资源，一般情况下一个应用中只初始化一个 SessionFactory 对象。</li>
<li>Hibernate4 新增了一个 ServiceRegistry 接口，所有基于 Hibernate 的配置或者服务都必须统一向这个 ServiceRegistry  注册后才能生效。</li>
</ul>
</li>
<li><p>Session 接口：</p>
<ul>
<li>Session 是应用程序与数据库之间交互操作的一个单线程对象，是 Hibernate 运作的中心，所有持久化对象必须在 session 的管理下才可以进行持久化操作。此对象的生命周期很短。</li>
<li>Session 对象有一个一级缓存，显式执行 flush 之前，所有的持久层操作的数据都缓存在 session 对象处。相当于 JDBC 中的 Connection。</li>
<li>持久化类与 Session 关联起来后就具有了持久化的能力。</li>
<li>Session 类的方法：<ul>
<li>取得持久化对象的方法： get() load()</li>
<li>持久化对象都得保存，更新和删除：save(),update(),saveOrUpdate(),delete()</li>
<li>开启事务: beginTransaction().</li>
<li>管理 Session 的方法：isOpen(),flush(), clear(), evict(), close()等</li>
</ul>
</li>
</ul>
</li>
<li><p>Transaction(事务)：</p>
<ul>
<li>代表一次原子操作，它具有数据库事务的概念。所有持久层都应该在事务管理下进行，即使是只读操作。 <ul>
<li>Transaction tx = session.beginTransaction();</li>
</ul>
</li>
<li>常用方法:<ul>
<li>commit():提交相关联的session实例。</li>
<li>rollback():撤销事务操作。</li>
<li>wasCommitted():检查事务是否提交。</li>
</ul>
</li>
</ul>
</li>
<li><p>Hibernate 配置文件的两个配置项：</p>
<ul>
<li>hbm2ddl.auto：该属性可帮助程序员实现正向工程, 即由 java 代码生成数据库脚本, 进而生成具体的表结构. 。取值 create | update | create-drop | validate。<ul>
<li>create : 会根据 .hbm.xml  文件来生成数据表, 但是每次运行都会<strong>删除上一次的表</strong> ,重新生成表, 哪怕二次没有任何改变 。</li>
<li>create-drop : 会根据 .hbm.xml 文件生成表,但是SessionFactory一关闭, <strong>表就自动删除</strong> 。</li>
<li>update : <strong>最常用的属性值</strong>，也会根据 .hbm.xml 文件生成表, 但若 .hbm.xml  文件和数据库中对应的数据表的表结构不同, Hiberante  将更新数据表结构，但<strong>不会删除已有的行和列</strong> 。</li>
<li>validate : 会和数据库中的表进行比较, 若 .hbm.xml 文件中的列在数据表中不存在，则抛出异常。</li>
</ul>
</li>
<li>format_sql：是否将 SQL 转化为格式良好的 SQL . 取值 true | false</li>
</ul>
</li>
</ul>
<h1 id="Session概述"><a href="#Session概述" class="headerlink" title="Session概述"></a>Session概述</h1><ul>
<li><p>Session 接口是 Hibernate 向应用程序提供的操纵数据库的最主要的接口, 它提供了基本的<strong>保存, 更新, 删除和加载 Java 对象</strong>的方法。</p>
</li>
<li><p>Session 具有一个缓存空间, 位于<strong>缓存中的对象</strong>称为持久化对象, 它和数据库中的相关记录对应. Session 能够在某些时间点, 按照缓存中对象的变化来执行相关的 SQL 语句, 来同步更新数据库, 这一过程被称为刷新缓存(flush)。</p>
</li>
<li><p>站在持久化的角度, Hibernate 把对象分为 4 种状态: 持久化状态, 临时状态, 游离状态, 删除状态. Session 的特定方法能使对象从一个状态转换到另一个状态.。</p>
</li>
<li><p><strong>Session 缓存</strong></p>
<ul>
<li>在 Session 接口的实现中包含一系列的 Java 集合, 这些 Java 集合构成了 Session 缓存. 只要 Session 实例没有结束生命周期, 且没有清理缓存，则存放在它缓存中的对象也不会结束生命周期。</li>
<li>Session缓存也被称为一级缓存。</li>
<li>Session 缓存可减少 Hibernate 应用程序访问数据库的频率。</li>
<li>例如下面代码：在同一个Session中查询了两次数据，但实际上Session只发送了一条查询语句。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionCacheTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> SessionFactory sessionFactory;</span><br><span class="line">  <span class="keyword">private</span> Session session;</span><br><span class="line">  <span class="keyword">private</span> Transaction transaction;</span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">befor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">    ServiceRegistry serviceRegistry = <span class="keyword">new</span> ServiceRegistryBuilder()</span><br><span class="line">        .applySettings(configuration.getProperties())</span><br><span class="line">        .buildServiceRegistry();</span><br><span class="line">    <span class="keyword">this</span>.sessionFactory = configuration.buildSessionFactory(serviceRegistry);</span><br><span class="line">    <span class="keyword">this</span>.session = sessionFactory.openSession();</span><br><span class="line">    <span class="keyword">this</span>.transaction = <span class="keyword">this</span>.session.beginTransaction();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@After</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">    transaction.commit();</span><br><span class="line">    session.close();</span><br><span class="line">    sessionFactory.close();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//get方法获取的是缓存中数据的引用，当对对象进行修改时，相当于修改缓存中的数据，</span></span><br><span class="line">    News news1 = (News) session.get(News.class,<span class="number">1</span>);</span><br><span class="line">    System.out.println(news1);</span><br><span class="line">    News news2 = (News) session.get(News.class,<span class="number">1</span>);</span><br><span class="line">    System.out.println(news2);</span><br><span class="line">    System.out.println(news1 == news2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果为：</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-5.png"></p>
</li>
<li><p>Session缓存的操作;</p>
<ul>
<li>Hibernate提供了三个操作Session缓存的方式。分别是flush(),reflush(),clear()。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-6.png"></p>
</li>
<li><p>flush()方法;</p>
<ul>
<li>flush：Session 按照缓存中对象的属性变化来同步更新数据库。</li>
<li>默认情况下 Session 在以下时间点刷新缓存：<ul>
<li>显式调用 Session 的 flush() 方法。</li>
<li>当应用程序调用 Transaction 的 <strong>commit（）</strong>方法的时, 该方法<strong>先 flush</strong> ，然后在向数据库提交事务。</li>
<li>当应用程序执行一些<strong>查询(HQL, Criteria)操作</strong>时，如果缓存中持久化对象的属性已经发生了变化，会先 flush 缓存，以保证查询结果能够反映持久化对象的<strong>最新状态</strong>。</li>
</ul>
</li>
<li>flush 缓存的<strong>例外情况</strong>: 如果对象使用 <strong>native 生成器</strong>生成 OID, 那么当调用 Session 的 save() 方法保存对象时, 会立即执行向数据库插入该实体的 insert 语句。</li>
<li>commit() 和 flush() 方法的区别：flush 执行一系列 sql 语句，<strong>但不提交事务</strong>；commit 方法先调用flush() 方法，然后提交事务. 意味着提交事务意味着对数据库操作永久保存下来。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFlush</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//get方法获取的是缓存中数据的引用，当对对象进行修改时，相当于修改缓存中的数据，</span></span><br><span class="line">  News news = (News)session.get(News.class, <span class="number">1</span>);</span><br><span class="line">  System.out.println(news.toString());</span><br><span class="line">  news.setAuthor(<span class="string">&quot;asd&quot;</span>);</span><br><span class="line">  <span class="comment">//QBC查询案例</span></span><br><span class="line">  News news1 = (News) session.createCriteria(News.class).uniqueResult();</span><br><span class="line">  System.out.println(news1.toString());</span><br><span class="line">  <span class="comment">//session.flush();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>reflush()方法：</p>
<ul>
<li>reflush：执行此方法时，会强制发送一条查询语句，以看缓存中的数据和数据库的数据是否一致。如果不一致则会更新缓存中的数据。</li>
<li>注意：此方法的执行成功想要设置数据库的隔离级别在READ COMMITED。</li>
<li>在 Hibernate 的配置文件中可以显式的设置隔离级别. 每一个隔离级别都对应一个整数:<ul>
<li>READ UNCOMMITED：1</li>
<li>READ COMMITED：2</li>
<li>REPEATABLE READ：4</li>
<li>SERIALIZEABLE：8</li>
</ul>
</li>
<li>Hibernate 通过为 Hibernate 映射文件指定 hibernate.connection.isolation 属性来设置事务的隔离级别。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改配置</span></span><br><span class="line"><span class="comment">//&lt;property name=&quot;connection.isolation&quot;&gt;2&lt;/property&gt;</span></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReflush</span><span class="params">()</span></span>&#123;</span><br><span class="line">  News news = (News)session.get(News.class, <span class="number">1</span>);</span><br><span class="line">  System.out.println(news.toString());</span><br><span class="line">  <span class="comment">//如果此时修改了数据库中的数据。这样数据库数据和缓存数据就会不同。</span></span><br><span class="line">  <span class="comment">//使用reflush()方法强制更新缓存中的哪一条数据</span></span><br><span class="line">  session.refresh(news);</span><br><span class="line">  System.out.println(news.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>clear()：清除缓存中的数据。</p>
</li>
</ul>
<h1 id="持久化对象的四种状态"><a href="#持久化对象的四种状态" class="headerlink" title="持久化对象的四种状态"></a>持久化对象的四种状态</h1><ul>
<li><p>站在持久化的角度, Hibernate 把对象分为 4 种状态: 持久化状态, 临时状态, 游离状态, 删除状态. Session 的特定方法能使对象从一个状态转换到另一个状态。</p>
</li>
<li><p>临时对象（Transient）: </p>
<ul>
<li>在使用代理主键的情况下, OID 通常为 null。</li>
<li>不处于 Session 的缓存中。</li>
<li>在数据库中没有对应的记录。</li>
</ul>
</li>
<li><p>持久化对象(也叫”托管”)（Persist）：</p>
<ul>
<li>OID 不为 null。</li>
<li>位于 Session 缓存中。</li>
<li>若在数据库中已经有和其对应的记录, 持久化对象和数据库中的相关记录对应。</li>
<li>Session 在 flush 缓存时, 会根据持久化对象的属性变化, 来同步更新数据库。</li>
<li>在同一个 Session 实例的缓存中, 数据库表中的每条记录只对应唯一的持久化对象。</li>
</ul>
</li>
<li><p>删除对象(Removed)</p>
<ul>
<li>在数据库中没有和其 OID 对应的记录</li>
<li>不再处于 Session 缓存中。</li>
<li>一般情况下, 应用程序不该再使用被删除的对象。</li>
</ul>
</li>
<li><p>游离对象(也叫”脱管”) （Detached）：</p>
<ul>
<li>OID 不为 null。</li>
<li>不再处于 Session 缓存中。</li>
<li>一般情况需下, 游离对象是由持久化对象转变过来的, 因此在数据库中可能还存在与它对应的记录。</li>
</ul>
</li>
<li><p>四种状态的改变：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-7.png"></p>
</li>
<li><p>临时状态 –&gt; 持久化状态：</p>
<ul>
<li>Session 的 save() 方法使一个临时对象转变为持久化对象</li>
<li>Session 的 save() 方法完成以下操作:<ul>
<li>把 News 对象加入到 Session 缓存中, 使它进入持久化状态</li>
<li>选用映射文件指定的标识符生成器, 为持久化对象分配<strong>唯一的 OID</strong>。</li>
<li>在<strong>使用代理主键</strong>的情况下, setId() 方法为 News 对象设置 OID 使无效的。</li>
<li>计划执行一条 insert 语句：在 flush 缓存的时候</li>
</ul>
</li>
<li>Hibernate 通过持久化对象的 OID 来维持它和数据库相关记录的对应关系. 当 News 对象处于持久化状态时, 不允许程序随意修改它的 ID</li>
<li>persist() 和 save() 区别：<ul>
<li>当对一个 OID 不为 Null 的对象执行 save() 方法时, 会把该对象以一个新的 oid 保存到数据库中;  但执行 persist() 方法时会抛出一个PersistentObjectException异常。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TransientToPersist</span><span class="params">()</span></span>&#123;</span><br><span class="line">  News news = <span class="keyword">new</span> News(<span class="string">&quot;c++&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">  news.setId(<span class="number">100</span>);</span><br><span class="line">  session.persist(news); <span class="comment">//此时会报错，因为设置的id。</span></span><br><span class="line">  <span class="comment">//    session.save(news);</span></span><br><span class="line">  <span class="comment">//    System.out.println(news); //由于设置的ID策略为native,此时输出的数据中id对应的是数据库的id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>直接变成持久化状态：</p>
<ul>
<li>get()和load()方法：都可以根据跟定的 OID 从数据库中加载一个持久化对象。</li>
<li>区别：<ul>
<li>当数据库中不存在与 OID 对应的记录时, load() 方法抛出 ObjectNotFoundException 异常, 而 get() 方法返回 null。</li>
<li>两者采用不同的延迟检索策略：load 方法支持延迟加载策略。而 get 不支持。<ul>
<li>因为load()方法执行后并不执行sql语句，而且返回的是一个代理对象。当代理对象被使用到时才会执行sql语句。</li>
</ul>
</li>
<li>当执行完get()或load()方法后，关闭session对象，此时再使用获得的数据。get可以正常使用。load汇报LazyInitializationException异常。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ToPersist</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">/*    News news1 = (News) session.get(News.class, 1);</span></span><br><span class="line"><span class="comment">    session.close();</span></span><br><span class="line"><span class="comment">    System.out.println(news1);*/</span></span><br><span class="line"></span><br><span class="line">  News news2 = (News) session.load(News.class, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//session.close();</span></span><br><span class="line">  <span class="comment">//此时汇报LazyInitializationException异常</span></span><br><span class="line">  System.out.println(news2.getClass().getName());</span><br><span class="line">  System.out.println(news2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>游离态 –&gt; 持久态</p>
<ul>
<li><p>update()方法：</p>
<ul>
<li><p>当更新一个持久化对象时，不需要显示的写出update()方法。</p>
</li>
<li><p>Session 的 update() 方法使一个游离对象转变为持久化对象, 并且计划执行一条 update 语句。</p>
</li>
<li><p>若希望 Session 仅当修改了 News 对象的属性时, 才执行 update() 语句, 可以把映射文件中 &lt;class&gt; 元素的 select-before-update 设为 true. 该属性的默认值为 false。</p>
<ul>
<li>即希望再更新前先查一遍，如果数据相同则不更新。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;com.lc.bean.News&quot;</span> <span class="attr">table</span>=<span class="string">&quot;news&quot;</span> <span class="attr">schema</span>=<span class="string">&quot;hibernate&quot;</span> <span class="attr">select-before-update</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>当 update() 方法关联一个游离对象时, 如果在 Session 的缓存中已经存在相同 OID 的持久化对象, 会抛出NonUniqueObjectException异常。</p>
</li>
<li><p>当 update() 方法关联一个游离对象时, 如果在数据库中不存在相应的记录, 也会抛出StaleStateException异常。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DetachedToPersist</span><span class="params">()</span></span>&#123;</span><br><span class="line">  News news1 = (News) session.get(News.class, <span class="number">1</span>);</span><br><span class="line">  transaction.commit();</span><br><span class="line">  session.close();</span><br><span class="line">  <span class="comment">//此时开启的session已经是一个新的session了。此时的news1对象就是一个游离状态。</span></span><br><span class="line">  session = sessionFactory.openSession();</span><br><span class="line">  transaction = session.beginTransaction();</span><br><span class="line">  <span class="comment">//1.此时会发送更新语句，将此对象由游离状态变成持久状态</span></span><br><span class="line">  <span class="comment">//session.update(news1);</span></span><br><span class="line">  <span class="comment">//2.此时会抛出StaleStateException异常，因为数据库中不存在此对象。</span></span><br><span class="line">  <span class="comment">//news1.setId(100);</span></span><br><span class="line">  <span class="comment">//session.update(news1);</span></span><br><span class="line">  <span class="comment">//3.此时会抛出NonUniqueObjectException异常，因为缓存中不能存在两个相同QID的对象。news1和news2的QID相同</span></span><br><span class="line">  News news2 = (News) session.get(News.class, <span class="number">1</span>);</span><br><span class="line">  session.update(news1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>saveOrUpdate() 方法：</p>
<ul>
<li><p>Session 的 saveOrUpdate() 方法同时包含了 save() 与 update() 方法的功能。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-8.png"></p>
</li>
<li><p>判定对象为临时对象的标准</p>
<ul>
<li>Java 对象的 OID 为 null。</li>
<li>映射文件中为 &lt;id&gt; 设置了 unsaved-value  属性, 并且 Java 对象的 OID 取值与这个 unsaved-value 属性值匹配。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ID&quot;</span> <span class="attr">unsaved-value</span>=<span class="string">&quot;-1&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--指定主键的生成方式。native表示使用数据库本地的方式--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DetachedToPersist2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  News news = <span class="keyword">new</span> News(<span class="string">&quot;asas&quot;</span>, <span class="string">&quot;dsds&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">  <span class="comment">//1.由于没有id,此时发送的insert语句</span></span><br><span class="line">  session.saveOrUpdate(news);</span><br><span class="line">  <span class="comment">//2.有id，且数据库中有此id，则发送update语句</span></span><br><span class="line">  news.setId(<span class="number">1</span>);</span><br><span class="line">  session.saveOrUpdate(news);</span><br><span class="line">  <span class="comment">//3.有id，但数据库中没有此id，会执行更新操作，但是没有id,则抛出异常</span></span><br><span class="line">  news.setId(<span class="number">100</span>);</span><br><span class="line">  session.saveOrUpdate(news);</span><br><span class="line">  <span class="comment">//4.有id.且id和映射文件中设置的id的unsaved-value属性值相同，则发送insert语句</span></span><br><span class="line">  news.setId(-<span class="number">1</span>);</span><br><span class="line">  session.saveOrUpdate(news);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>merge()方法：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-9.png"></p>
</li>
</ul>
</li>
<li><p>到删除状态：</p>
<ul>
<li>Session 的 delete() 方法既可以删除一个游离对象, 也可以删除一个持久化对象。</li>
<li>Session 的 delete() 方法处理过程<ul>
<li>计划执行一条 delete 语句。</li>
<li>把对象从 Session 缓存中删除, 该对象进入删除状态。</li>
<li>默认删除后对象的数据不变。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ToDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">  News news = <span class="keyword">new</span> News();</span><br><span class="line">  <span class="comment">/*    news.setId(3);</span></span><br><span class="line"><span class="comment">    session.delete(news);</span></span><br><span class="line"><span class="comment">    System.out.println(news);*/</span></span><br><span class="line">  <span class="comment">//如果删除的id不存在，则抛出StaleStateException异常</span></span><br><span class="line">  news.setId(<span class="number">100</span>);</span><br><span class="line">  session.delete(news);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果删除的对象再数据库中不存在，则抛StaleStateException异常。</p>
</li>
<li><p>Hibernate 的 cfg.xml 配置文件中有一个 hibernate.use_identifier_rollback 属性, 其默认值为 false, 若把它设为 true, 将改变 delete() 方法的运行行为: </p>
<ul>
<li>即delete() 方法会把持久化对象或游离<strong>对象的 OID 设置为 null</strong>, 使它们变为临时对象。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.use_identifier_rollback&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>持久状态 –&gt; 游离状态</p>
<ul>
<li>evict()方法：从Session缓存中把指定持久态对象移除。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PersistToDetached</span><span class="params">()</span></span>&#123;</span><br><span class="line">  News news = (News) session.get(News.class, <span class="number">4</span>);</span><br><span class="line">  news.setAuthor(<span class="string">&quot;xzczczx&quot;</span>);</span><br><span class="line">  <span class="comment">//从缓存中移除此对象后，更新操作将不再执行。</span></span><br><span class="line">  session.evict(news);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过Hibernate 调用存储过程。</p>
<ul>
<li>Work 接口: 直接通过 JDBC API 来访问数据库的操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jdbcTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Work work = <span class="keyword">new</span> Work() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">//此时就能获取到connection对象。就能编写调用存储过程的代码了</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  session.doWork(work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Session 的 doWork(Work) 方法用于执行 Work 对象指定的操作, 即调用 Work 对象的 execute() 方法。</li>
<li>Session 会把当前使用的数据库连接传递给 execute() 方法。</li>
</ul>
</li>
<li><p>Hibernate 与触发器协同工作：</p>
<ul>
<li>出现的问题：<ul>
<li>触发器使 Session 的缓存中的持久化对象与数据库中对应的<strong>数据不一致</strong>:触发器运行在数据库中, 它执行的操作对 Session 是透明的。</li>
<li>Session 的 update() 方法<strong>盲目地激发触发器</strong>: 无论游离对象的属性是否发生变化, 都会执行 update 语句, 而 update 语句会激发数据库中相应的触发器。</li>
</ul>
</li>
<li>解决方案：<ul>
<li>在执行完 Session 的相关操作后, 立即调用 Session 的 flush() 和 refresh() 方法, 迫使 Session 的缓存与数据库同步(refresh() 方法重新从数据库中加载对象)。</li>
<li>在映射文件的的 &lt;class&gt; 元素中设置 select-before-update 属性: </li>
<li>当 Session 的 update 或 saveOrUpdate() 方法更新一个游离对象时, 会先执行 Select 语句, 获得当前游离对象在数据库中的最新数据, 只有在不一致的情况下才会执行 update 语句。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h1><ul>
<li><p>Hibernate 配置文件主要用于配置数据库连接和 Hibernate 运行时所需的各种属性。</p>
</li>
<li><p>每个 Hibernate 配置文件对应一个 Configuration 对象。</p>
</li>
<li><p>Hibernate配置文件可以有两种格式:</p>
<ul>
<li>hibernate.properties</li>
<li>hibernate.cfg.xml </li>
</ul>
</li>
<li><p>JDBC 连接属性</p>
<ul>
<li>connection.url：数据库URL 。</li>
<li>connection.username：数据库用户名。</li>
<li>connection.password：数据库用户密码 。</li>
<li>connection.driver_class：数据库JDBC驱动 。</li>
<li>dialect：配置数据库的方言，根据底层的数据库不同产生不同的 sql 语句，Hibernate 会针对数据库的特性在访问时进行优化。</li>
</ul>
</li>
<li><p>C3P0 数据库连接池属性</p>
<ul>
<li>hibernate.c3p0.max_size: 数据库连接池的最大连接数。</li>
<li>hibernate.c3p0.min_size: 数据库连接池的最小连接数。</li>
<li>hibernate.c3p0.timeout:   数据库连接池中连接对象在多长时间没有使用过后，就应该被销毁。</li>
<li>hibernate.c3p0.max_statements:  缓存 Statement 对象的数量。</li>
<li>hibernate.c3p0.idle_test_period:  表示连接池检测线程多长时间检测一次池内的所有链接对象是否超时. 连接池本身不会把自己从连接池中移除，而是专门有一个线程按照一定的时间间隔来做这件事，这个线程通过比较连接对象最后一次被使用时间和当前时间的时间差来和 timeout 做对比，进而决定是否销毁这个连接对象。 </li>
<li>hibernate.c3p0.acquire_increment: 当数据库连接池中的连接耗尽时, 同一时刻获取多少个数据库连接。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--c3p0连接池配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;c3p0.max_size&quot;</span>&gt;</span>32<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;c3p0.min_size&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;c3p0.timeout&quot;</span>&gt;</span>2000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;c3p0.max_statements&quot;</span>&gt;</span>32<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;c3p0.acquire_increment&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;c3p0.idle_test_period&quot;</span>&gt;</span>2000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>show_sql：是否将运行期生成的SQL输出到日志以供调试。取值 true | false </p>
</li>
<li><p>format_sql：是否将 SQL 转化为格式良好的 SQL . 取值 true | false</p>
</li>
<li><p>hbm2ddl.auto：在启动和停止时自动地创建，更新或删除数据库模式。取值 create | update | create-drop | validate</p>
</li>
<li><p>hibernate.jdbc.fetch_size：实质是调用 Statement.setFetchSize() 方法设定 JDBC 的 Statement 读取数据的时候每次从数据库中取出的记录条数。</p>
<ul>
<li>例如一次查询1万条记录，对于Oracle的JDBC驱动来说，是不会 1 次性把1万条取出来的，而只会取出 fetchSize 条数，当结果集遍历完了这些记录以后，再去数据库取 fetchSize 条数据。因此大大节省了无谓的内存消耗。</li>
<li>Fetch Size设的越大，读数据库的次数越少，速度越快；Fetch Size越小，读数据库的次数越多，速度越慢。Oracle数据库的JDBC驱动默认的Fetch Size = 10，是一个保守的设定，根据测试，当Fetch Size=50时，性能会提升1倍之多，当 fetchSize=100，性能还能继续提升20%，Fetch Size继续增大，性能提升的就不显著了。</li>
<li>并不是所有的数据库都支持Fetch Size特性，例如<strong>MySQL就不支持</strong>。</li>
</ul>
</li>
<li><p>hibernate.jdbc.batch_size：设定对数据库进行批量删除，批量更新和批量插入的时候的批次大小，类似于设置缓冲区大小的意思。batchSize 越大，批量操作时向数据库发送sql的次数越少，速度就越快。</p>
<ul>
<li>测试结果是当Batch Size=0的时候，使用Hibernate对Oracle数据库删除1万条记录需要25秒，Batch Size = 50的时候，删除仅仅需要5秒！Oracle数据库 batchSize=30 的时候比较合适。</li>
</ul>
</li>
<li></li>
</ul>
<h1 id="映射文件详解"><a href="#映射文件详解" class="headerlink" title="映射文件详解"></a>映射文件详解</h1><ul>
<li><p>POJO 类和关系数据库之间的映射可以用一个XML文档来定义。</p>
</li>
<li><p>通过 POJO 类的数据库映射文件，Hibernate可以理解持久化类和数据表之间的对应关系，也可以理解持久化。</p>
</li>
<li><p>类属性与数据库表列之间的对应关系。</p>
</li>
<li><p>在运行时 Hibernate 将根据这个映射文件来生成各种 SQL 语句。</p>
</li>
<li><p>映射文件的扩展名为 .hbm.xml。</p>
</li>
<li><p>映射文件的标签层次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hibernate-mapping</span><br><span class="line"> 类层次：class</span><br><span class="line">    主键：id</span><br><span class="line">    基本类型:property</span><br><span class="line">    实体引用类: many-to-one  |  one-to-one</span><br><span class="line">    集合:set | list | map | array</span><br><span class="line">      one-to-many</span><br><span class="line">      many-to-many</span><br><span class="line">    子类:subclass | joined-subclass</span><br><span class="line">    其它:component | any 等</span><br><span class="line">  查询语句:query（用来放置查询语句，便于对数据库查询的统一管理和优化）</span><br></pre></td></tr></table></figure></li>
<li><p>每个Hibernate-mapping中可以同时定义多个类. 但更推荐为每个类都创建一个单独的映射文件。</p>
</li>
<li><p>hibernate-mapping标签属性说明：hibernate-mapping 是 hibernate 映射文件的根元素。</p>
<ul>
<li>schema：指定所映射的数据库schema的名称。若指定该属性, 则表明会自动添加该 schema 前缀</li>
<li>catalog：指定所映射的数据库catalog的名称。  </li>
<li><em>default-cascade</em>(默认为 none)：设置hibernate默认的级联风格. 若配置 Java 属性, 集合映射时没有指定 cascade 属性, 则 Hibernate 将采用此处指定的级联风格.   </li>
<li><em>default-access</em> (默认为 property)：指定 Hibernate 的默认的属性访问策略。默认值为 property, 即使用 getter, setter 方法来访问属性. 若指定 access, 则 Hibernate 会忽略 getter/setter 方法, 而通过反射访问成员变量.</li>
<li><em>default-lazy</em>(默认为 true)：设置 Hibernat morning的延迟加载策略. 该属性的默认值为 true, 即启用延迟加载策略. 若配置 Java 属性映射, 集合映射时没有指定 lazy 属性, 则 Hibernate 将采用此处指定的延迟加载策略 </li>
<li>auto-import (默认为 true)：指定是否可以在查询语言中使用非全限定的类名（仅限于本映射文件中的类）。 </li>
<li>**package (可选)**：指定一个包前缀，如果在映射文档中没有指定全限定的类名， 就使用这个作为包名。 </li>
</ul>
</li>
<li><p>class标签属性说明：class 元素用于指定类和表的映射。</p>
<ul>
<li><strong>name</strong>：指定该持久化类映射的持久化类的类名。</li>
<li><strong>table</strong>：指定该持久化类映射的表名, Hibernate 默认以持久化类的类名作为表名。</li>
<li><strong>dynamic-inser</strong>t：若设置为 true, 表示当保存一个对象时, 会动态生成 insert 语句, insert 语句中仅包含所有取值不为 null 的字段. 默认值为 false。</li>
<li><strong>dynamic-update</strong>：若设置为 true, 表示当更新一个对象时, 会动态生成 update 语句, update 语句中仅包含所有取值需要更新的字段. 默认值为 false。</li>
<li><strong>select-before-update</strong>：设置 Hibernate 在更新某个持久化对象之前是否需要先执行一次查询. 默认值为 false。</li>
<li><em>batch-size</em>：指定根据 OID 来抓取实例时每批抓取的实例数。</li>
<li><em>lazy</em>：指定是否使用延迟加载。</li>
<li><em>mutable</em>：若设置为 true, 等价于所有的 &lt;property&gt; 元素的 update 属性为 false, 表示整个实例不能被更新. 默认为 true。</li>
<li><em>discriminator-value</em>：指定区分不同子类的值. 当使用 &lt;subclass/&gt; 元素来定义持久化类的继承关系时需要使用该属性。</li>
</ul>
</li>
<li><p>id标签属性说明：设定持久化类的 OID 和表的主键的映射</p>
<ul>
<li>Hibernate 使用对象标识符(OID) 来建立内存中的对象和数据库表中记录的对应关系. 对象的 OID 和数据表的主键对应. <strong>Hibernate 通过标识符生成器来为主键赋值</strong>。</li>
<li>Hibernate 推荐在数据表中使用<strong>代理主键</strong>, 即<strong>不具备业务含义</strong>的字段. 代理主键通常为<strong>整数类型</strong>, 因为整数类型比字符串类型要节省更多的数据库空间.</li>
<li>在对象-关系映射文件中,&lt;id&gt; 元素用来设置对象标识符. &lt;generator&gt; 子元素用来设定标识符生成器。</li>
<li>Hibernate 提供了<strong>标识符生成器接口</strong>: <em>IdentifierGenerator</em>, 并提供了各种内置实现。</li>
<li><strong>name</strong>：标识持久化类 OID 的属性名。</li>
<li><strong>column</strong>：设置标识属性所映射的数据表的列名(主键字段的名字)。</li>
<li><strong>unsaved-value</strong>：若设定了该属性, Hibernate 会通过比较持久化类的 OID 值和该属性值来区分当前持久化类的对象是否为临时对象。</li>
<li><strong>type</strong>：指定 Hibernate 映射类型. Hibernate 映射类型是 Java 类型与 SQL 类型的桥梁. 如果没有为某个属性显式设定映射类型, Hibernate 会运用反射机制先识别出持久化类的特定属性的 Java 类型, 然后自动使用与之对应的默认的 Hibernate 映射类型。</li>
<li>Java 的基本数据类型和包装类型对应相同的 Hibernate 映射类型. 基本数据类型无法表达 null, 所以对于持久化类的 OID 推荐使用包装类型。</li>
</ul>
</li>
<li><p>generator标签属性说明：设定持久化类设定标识符生成器。</p>
<ul>
<li>class: 指定使用的标识符生成器全限定类名或其缩写名。</li>
</ul>
</li>
<li><p>Property标签属性说明：property 元素用于指定类的属性和表的字段的映射。</p>
<ul>
<li><strong>name</strong>：指定该持久化类的属性的名字</li>
<li><strong>column</strong>：指定与类的属性映射的表的字段名. 如果没有设置该属性, Hibernate 将直接使用类的属性名作为字段名. </li>
<li><strong>type</strong>：指定 Hibernate 映射类型. Hibernate 映射类型是 Java 类型与 SQL 类型的桥梁. 如果没有为某个属性显式设定映射类型, Hibernate 会运用反射机制先识别出持久化类的特定属性的 Java 类型, 然后自动使用与之对应的默认的 Hibernate 映射类型.</li>
<li><strong>not-null</strong>：若该属性值为 true, 表明不允许为 null, 默认为 false</li>
<li><strong>access</strong>：指定 Hibernate 的默认的属性访问策略。默认值为 property, 即使用 getter, setter 方法来访问属性. 若指定 field, 则 Hibernate 会忽略 getter/setter 方法, 而通过反射访问成员变量</li>
<li><strong>unique</strong>：设置是否为该属性所映射的数据列添加唯一约束. </li>
<li><strong>index</strong>：指定一个字符串的索引名称. 当系统需要 Hibernate 自动建表时, 用于为该属性所映射的数据列创建索引, 从而加快该数据列的查询.</li>
<li><strong>length</strong>：指定该属性所映射数据列的字段的长度</li>
<li><strong>scale</strong>：指定该属性所映射数据列的小数位数, 对 double, float, decimal 等类型的数据列有效.</li>
<li><strong>formula</strong>：设置一个 SQL 表达式, Hibernate 将根据它来计算出派生属性的值. </li>
<li><strong>派生属性</strong>：并不是持久化类的所有属性都直接和表的字段匹配, 持久化类的有些属性的值必须在运行时通过计算才能得出来, 这种属性称为派生属性。</li>
</ul>
</li>
<li><p><strong>派生属性</strong>：并不是持久化类的所有属性都直接和表的字段匹配, 持久化类的有些属性的值必须在运行时通过计算才能得出来, 这种属性称为派生属性。</p>
<ul>
<li>使用 formula 属性时：<ul>
<li>formula=“(sql)” 的英文括号不能少。</li>
<li>Sql 表达式中的列名和表名都应该和数据库对应, 而不是和持久化对象的属性对应。</li>
<li>如果需要在 formula 属性中使用参数, 这直接使用 where cur.id=id 形式, 其中 id 就是参数，表示外表的id字段的值, 和当前持久化对象的 id 属性对应的列的 id 值将作为参数传入。</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--映射派生属性：nums属性的值为表中数据的数量--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;nums&quot;</span> <span class="attr">formula</span>=<span class="string">&quot;(select count(*))&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="标识符生成器详解"><a href="#标识符生成器详解" class="headerlink" title="标识符生成器详解"></a>标识符生成器详解</h1><ul>
<li><p>Hibernate提供的内置标识符生成器：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210515152901.png"></p>
</li>
<li><p>increment 标识符生成器：</p>
<ul>
<li>increment 标识符生成器由 Hibernate 以递增的方式为代理主键赋值。</li>
<li>Hibernate 会先读取 NEWS 表中的主键的最大值, 而接下来向 NEWS 表中插入记录时, 就在 max(id) 的基础上递增, 增量为 1。</li>
<li>适用范围:<ul>
<li>由于 increment 生存标识符机制不依赖于底层数据库系统, 因此它<strong>适合所有的数据库系统</strong>。</li>
<li>适用于只有<strong>单个 Hibernate 应用进程</strong>访问同一个数据库的场合, 在集群环境下不推荐使用它。</li>
<li>OID 必须为 long, int 或 short 类型, 如果把 OID 定义为 byte 类型, 在运行时会抛出异常。</li>
</ul>
</li>
</ul>
</li>
<li><p>identity 标识符生成器：</p>
<ul>
<li>identity 标识符生成器由底层数据库来负责生成标识符, 它要求底层数据库把主键定义为自动增长字段类型</li>
<li>适用范围:<ul>
<li>由于 identity 生成标识符的机制依赖于底层数据库系统, 因此, 要求底层数据库系统必须<strong>支持自动增长字段类型</strong>. 支持自动增长字段类型的数据库包括: DB2, Mysql, MSSQLServer, Sybase 等</li>
<li>OID 必须为 long, int 或 short 类型, 如果把 OID 定义为 byte 类型, 在运行时会抛出异常</li>
</ul>
</li>
</ul>
</li>
<li><p>sequence 标识符生成器：</p>
<ul>
<li>sequence  标识符生成器利用底层数据库提供的序列来生成标识符。</li>
<li>Hibernate 在持久化一个 News 对象时, 先从底层数据库的 news_seq 序列中获得一个唯一的标识号, 再把它作为主键值。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ID&quot;</span> <span class="attr">unsaved-value</span>=<span class="string">&quot;-1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;sequence&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;sequence&quot;</span>&gt;</span>news_seq<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>适用范围:<ul>
<li>由于 sequence 生成标识符的机制依赖于底层数据库系统的序列, 因此, 要求底层数据库系统<strong>必须支持序列</strong>. 支持序列的数据库包括: DB2, Oracle 等。</li>
<li>OID 必须为 long, int 或 short 类型, 如果把 OID 定义为 byte 类型, 在运行时会抛出异常。</li>
</ul>
</li>
</ul>
</li>
<li><p>hilo 标识符生成器：</p>
<ul>
<li>hilo 标识符生成器由 Hibernate 按照一种 high/low 算法生成标识符, 它从数据库的特定表的字段中获取 high 值。</li>
<li>Hibernate 在持久化一个 News 对象时, 由 Hibernate 负责生成主键值. hilo 标识符生成器在生成标识符时, <strong>需要读取并修改 HI_TABLE 表中的 NEXT_VALUE 值</strong>。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ID&quot;</span> <span class="attr">unsaved-value</span>=<span class="string">&quot;-1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;hilo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;table&quot;</span>&gt;</span>Hi_Table<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;column&quot;</span>&gt;</span>next_value<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;max_lo&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>适用范围:<ul>
<li>由于 hilo 生存标识符机制不依赖于底层数据库系统, 因此它适合所有的数据库系统。</li>
<li>OID 必须为 long, int 或 short 类型, 如果把 OID 定义为 byte 类型, 在运行时会抛出异常。</li>
</ul>
</li>
</ul>
</li>
<li><p>native 标识符生成器：</p>
<ul>
<li>native 标识符生成器依据底层数据库对自动生成标识符的支持能力, 来选择使用 identity, sequence 或 hilo 标识符生成器。</li>
<li>当数据库支持底层生成标识符时，由数据库生成。不支持时使用hilo生成器。</li>
<li>适用范围:<ul>
<li>由于 native 能根据底层数据库系统的类型, 自动选择合适的标识符生成器, 因此很<strong>适合于跨数据库平台开发。</strong></li>
<li>OID 必须为 long, int 或 short 类型, 如果把 OID 定义为 byte 类型, 在运行时会抛出异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="类型之间的映射关系"><a href="#类型之间的映射关系" class="headerlink" title="类型之间的映射关系"></a>类型之间的映射关系</h1><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-10.png"></p>
<ul>
<li>以下情况下必须显式指定 Hibernate 映射类型:<ul>
<li>一个 Java 类型可能对应多个 Hibernate 映射类型. 例如: 如果持久化类的属性为 java.util.Date 类型, 对应的 Hibernate 映射类型可以是 date, time 或 timestamp. 此时必须根据对应的数据表的字段的 SQL 类型, 来确定 Hibernate 映射类型. 如果字段为 DATE 类型, 那么 Hibernate 映射类型为 date; 如果字段为 TIME 类型, 那么 Hibernate 映射类型为 time; 如果字段为 TIMESTATMP 类型, 那么 Hibernate 映射类型为timestamp。</li>
</ul>
</li>
</ul>
<h2 id="日期类型的映射"><a href="#日期类型的映射" class="headerlink" title="日期类型的映射"></a>日期类型的映射</h2><ul>
<li><p>在 Java 中, 代表时间和日期的类型包括: java.util.Date 和 java.util.Calendar。</p>
</li>
<li><p>此外, 在 JDBC API 中还提供了 3 个扩展了 java.util.Date 类的子类: java.sql.Date, java.sql.Time 和 java.sql.Timestamp, 这三个类分别和标准 SQL 类型中的 DATE, TIME 和 TIMESTAMP 类型对应。</p>
</li>
<li><p>在标准 SQL 中, DATE 类型表示日期, TIME  类型表示时间, TIMESTAMP 类型表示时间戳, 同时包含日期和时间信息。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-11.png"></p>
</li>
<li><p>总结：</p>
<ul>
<li>在Java类当中，对于日期类型的数据，建议选用java.util.Date类型。因为它能兼容sql的三种类型。</li>
<li>在数据库中，日期类型可以自由选择。</li>
<li>在对象-数据映射文件中。设置的type属性。需要按照上表中的映射类型进行区分。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--对应对象类型为util.date。字段类型为DATE--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;date&quot;</span> <span class="attr">column</span>=<span class="string">&quot;date&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--对应对象类型为util.date。字段类型为TIME--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;date&quot;</span> <span class="attr">column</span>=<span class="string">&quot;time&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--对应对象类型为util.date。字段类型为TIMESTAMP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;date&quot;</span> <span class="attr">column</span>=<span class="string">&quot;timestamp&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="大对象类型映射"><a href="#大对象类型映射" class="headerlink" title="大对象类型映射"></a>大对象类型映射</h2><ul>
<li><p>在 Java 中, java.lang.String 可用于表示长字符串(长度超过 255), 字节数组 byte[] 可用于存放图片或文件的二进制数据. 此外, 在 JDBC API 中还提供了 java.sql.Clob 和 java.sql.Blob 类型, 它们分别和标准 SQL 中的 CLOB 和 BLOB 类型对应. CLOB 表示字符串大对象(Character Large Object), BLOB表示二进制对象(Binary Large Object)。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-12.png"></p>
</li>
<li><p>Mysql 不支持标准 SQL 的 CLOB 类型, 在 Mysql 中, 用 TEXT, MEDIUMTEXT 及 LONGTEXT 类型来表示长度操作 255 的长文本数据。</p>
</li>
<li><p>在持久化类中, 二进制大对象可以声明为 byte[] 或 java.sql.Blob 类型; 字符串可以声明为 java.lang.String 或 java.sql.Clob。</p>
</li>
<li><p>实际上在 Java 应用程序中处理长度超过 255 的字符串, 使用 java.lang.String 比 java.sql.Clob 更方便。</p>
</li>
<li><p>若希望精确映射到数据库的类型。则可以使用sql-type属性。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--映射大对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--此处精确映射数据库中context属性为mediumtext--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">&quot;context&quot;</span> <span class="attr">sql-type</span>=<span class="string">&quot;mediumtext&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="组成关系映射"><a href="#组成关系映射" class="headerlink" title="组成关系映射"></a>组成关系映射</h2><ul>
<li><p>当有两个类，一个类聚合另一个类时。在数据库表的设计上偏向于只设计成一张表即可。</p>
<ul>
<li>例如如下图：有两个类Worker,Pay。但在表中只存在一张表。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-13.png"></p>
</li>
<li><p>域模型就是描述这种关系的模型： 由程序代码组成, 通过细化持久化类的的粒度可提高代码的可重用性, 简化编程。</p>
</li>
<li><p>从数据库方向看：在没有数据冗余的情况下, 应该尽可能<strong>减少表的数目</strong>, 简化表之间的参照关系, 以便提高数据的访问速度。</p>
</li>
<li><p>Hibernate 把持久化类的属性分为两种: </p>
<ul>
<li>值(value)类型: 没有 OID, 不能被单独持久化, 生命周期依赖于所属的持久化类的对象的生命周期。比如上面的Pay类。</li>
<li>实体(entity)类型: 有 OID, 可以被单独持久化, 有独立的生命周期。比如上面的Worker类。</li>
</ul>
</li>
<li><p>此时在对象映射文件中无法使用property标签来正常的映射属性和字段。</p>
</li>
<li><p>Hibernate 使用 &lt;component&gt; 元素来映射<strong>组成关系</strong>, 该元素表名 pay 属性是 Worker 类一个组成部分, 在 Hibernate 中称之为组件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--组件映射关系--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--说明：有两个类，worker和pay。worker类中有pay类型的属性。这两个类的数据在数据库中只对应一张表--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Worker&quot;</span> <span class="attr">table</span>=<span class="string">&quot;worker&quot;</span> <span class="attr">schema</span>=<span class="string">&quot;hibernate&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--对于组件的映射。name：组件的属性名。class：组件的类型--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">&quot;pay&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Pay&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monthlyPay&quot;</span> <span class="attr">column</span>=<span class="string">&quot;monthly_pay&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;yearPay&quot;</span> <span class="attr">column</span>=<span class="string">&quot;year_pay&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;vocationWithPay&quot;</span> <span class="attr">column</span>=<span class="string">&quot;vocation_with_pay&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>component组件的说明：</p>
<ul>
<li>&lt;component&gt; 元素来映射组成关系<ul>
<li>class：设定组成关系属性的类型, 此处表明 pay 属性为 Pay 类型</li>
</ul>
</li>
<li>&lt;parent&gt; 元素指定组件属性所属的整体类<ul>
<li>name：整体类在组件类中的属性名</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h1><ul>
<li><p>在领域模型中, 类与类之间最普遍的关系就是关联关系.</p>
</li>
<li><p>在 UML 中, 关联是有方向的.</p>
<ul>
<li>以 Customer 和 Order 为例： 一个用户能发出多个订单, 而一个订单只能属于一个客户. 从 Order 到 Customer 的关联是多对一关联; 而从 Customer 到 Order 是一对多关联。</li>
</ul>
</li>
<li><p>单向关联</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-14.png"></p>
</li>
<li><p>双向关联</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-15.png"></p>
</li>
</ul>
<h2 id="单向n对1"><a href="#单向n对1" class="headerlink" title="单向n对1"></a>单向n对1</h2><ul>
<li><p>单向 n-1 关联只需从 n 的一端可以访问 1 的一端。</p>
</li>
<li><p>域模型: 从 Order 到 Customer 的多对一单向关联需要在Order 类中定义一个 Customer 属性, 而在 Customer 类中无需定义存放 Order 对象的集合属性。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-16.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1的一端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer customerId;</span><br><span class="line">  <span class="keyword">private</span> String customerName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//n的一端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer orderId;</span><br><span class="line">  <span class="keyword">private</span> String orderNumber;</span><br><span class="line">  <span class="comment">//保证可以从n访问到1</span></span><br><span class="line">  <span class="keyword">private</span> Customer customer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>关系数据模型:ORDERS 表中的 CUSTOMER_ID 参照 CUSTOMER 表的主键。即设计外键。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-17.png"></p>
</li>
<li><p>映射文件的编写：</p>
<ul>
<li>显然无法直接用 property 映射 customer 属性。</li>
<li>Hibernate 使用 &lt;many-to-one&gt; 元素来映射多对一关联关系。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Order&quot;</span> <span class="attr">table</span>=<span class="string">&quot;order&quot;</span> <span class="attr">schema</span>=<span class="string">&quot;hibernate&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;orderNumber&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_number&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--对于多以一关联映射。需要在多的一方。类中添加属性。且用many-to-one表示映射--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Customer&quot;</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p> &lt;many-to-one&gt; 元素说明：元素来映射组成关系。</p>
</li>
<li><p>name：设定待映射的持久化类的属性的名字。</p>
</li>
<li><p>column：设定和持久化类的属性对应的表的外键。</p>
</li>
<li><p>class：设定待映射的持久化类的属性的类型。</p>
</li>
<li><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">n21Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">/*    Customer customer = new Customer();</span></span><br><span class="line"><span class="comment">    customer.setCustomerName(&quot;12&quot;);</span></span><br><span class="line"><span class="comment">    Order order = new Order();</span></span><br><span class="line"><span class="comment">    order.setOrderNumber(&quot;a1&quot;);</span></span><br><span class="line"><span class="comment">    order.setCustomer(customer);</span></span><br><span class="line"><span class="comment">    //当先插入1的一端，在插入n的一端。总共是2条插入语句。</span></span><br><span class="line"><span class="comment">    //当先插入n的一端，在插入1的一端时。会有2条插入语句，外加一条更新语句。</span></span><br><span class="line"><span class="comment">    //因为在插入多的一端时，无法得知外键的值，因此在少的一端插入后再更新多的一端的数据。</span></span><br><span class="line"><span class="comment">    session.save(customer);</span></span><br><span class="line"><span class="comment">    session.save(order);*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*    //此时的查询只查询了Order的数据，而对于Customer的数据采用的但是懒加载查询</span></span><br><span class="line"><span class="comment">    Order order1 = (Order) session.get(Order.class, 1);</span></span><br><span class="line"><span class="comment">    System.out.println(order1);</span></span><br><span class="line"><span class="comment">    //当使用到customer数据时，才发送查询语句。此时要注意懒加载的异常情况</span></span><br><span class="line"><span class="comment">    System.out.println(order1.getCustomer().toString());*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//在不设定级联关系时，当n的一端对1的一端有引用时，删除1的一端的数据会抛出ConstraintViolationException异常</span></span><br><span class="line">  Customer customer = (Customer) session.get(Customer.class,<span class="number">1</span>);</span><br><span class="line">  session.delete(customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="双向1对n"><a href="#双向1对n" class="headerlink" title="双向1对n"></a>双向1对n</h2><ul>
<li><p>双向 1-n 与 双向 n-1 是完全相同的两种情形</p>
</li>
<li><p>双向 1-n 需要在 1 的一端可以访问 n 的一端, 反之依然</p>
</li>
<li><p>域模型:从 Order 到 Customer 的多对一双向关联需要在Order 类中定义一个 Customer 属性, 而在 Customer 类中需定义存放 Order 对象的集合属性。</p>
<ul>
<li>只是在1的那端多了个集合。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-18.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1的一端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer customerId;</span><br><span class="line">  <span class="keyword">private</span> String customerName;</span><br><span class="line">  <span class="comment">//在1的一端设定一个集合。集合属性建议使用接口类型。集合可以设定一个空实现。</span></span><br><span class="line">  <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//n的一端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer orderId;</span><br><span class="line">  <span class="keyword">private</span> String orderNumber;</span><br><span class="line">  <span class="keyword">private</span> Customer customer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>关系数据模型:ORDERS 表中的 CUSTOMER_ID 参照 CUSTOMER 表的主键。和单向一对多的相同。</p>
</li>
<li><p>类中集合属性的说明：</p>
<ul>
<li>当 Session 从数据库中加载 Java 集合时, 创建的是 Hibernate 内置集合类的实例, 因此在持久化类中定义集合属性时必须把属性声明为 <strong>Java 接口类型</strong>。<ul>
<li>Hibernate 的内置集合类具有集合代理功能, <strong>支持延迟检索策略</strong>。</li>
<li>事实上, Hibernate 的内置集合类封装了 JDK 中的集合类, 这使得 Hibernate 能够对缓存中的集合对象进行脏检查, 按照集合对象的状态来同步更新数据库。</li>
</ul>
</li>
<li>在定义集合属性时, 通常把它<strong>初始化为集合实现类</strong>的一个实例. 这样可以提高程序的<strong>健壮性</strong>, <strong>避免应用程序访问取值为 null 的集合的方法抛出 NullPointerException</strong>。</li>
</ul>
</li>
<li><p>映射文件的编写：</p>
<ul>
<li>Hibernate 使用 &lt;set&gt; 元素来映射 set 类型的属性。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Customer&quot;</span> <span class="attr">table</span>=<span class="string">&quot;customers&quot;</span> <span class="attr">schema</span>=<span class="string">&quot;hibernate&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;customerId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;customerName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;customer_name&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--集合属性的映射。首先order需要有多对一的映射。--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- inverse=&quot;false&quot;：表示customer为被动方，所以由Order来维护数据 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">table</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">inverse</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这个键是Order表中的哪个外键的字段名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--从customer端来看，是1到多的方向，因此要指定多的类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">&quot;Order&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">one-to-many</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Order&quot;</span> <span class="attr">table</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">schema</span>=<span class="string">&quot;hibernate&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;orderId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;orderNumber&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_number&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--对于多以一关联映射。需要在多的一方。类中添加属性。且用many-to-one表示映射--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Customer&quot;</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>标签说明：</p>
<ul>
<li>&lt;set&gt; 元素来映射持久化类的 set 类型的属性<ul>
<li>name: 设定待映射的持久化类的属性的</li>
</ul>
</li>
<li>&lt;key&gt; 元素设定与所关联的持久化类对应的表的外键<ul>
<li>column: 指定关联表的外键名</li>
</ul>
</li>
<li>&lt;one-to-many&gt; 元素设定集合属性中所关联的持久化类<ul>
<li>class: 指定关联的持久化类的类名</li>
</ul>
</li>
</ul>
</li>
<li><p>&lt;set&gt;元素的inverse属性：</p>
<ul>
<li>在hibernate中通过对 inverse 属性的来决定是由双向关联的哪一方来维护表和表之间的关系。<ul>
<li>设置inverse = false 的为主动方，设置inverse = true 的为被动方。</li>
<li>最后是由主动方负责维护关联关系。</li>
</ul>
</li>
<li>在<strong>没有设置 inverse的情况</strong>下，父子两边都维护父子关系 。</li>
<li>在 1-n 关系中，将 n 方设为主控方将有助于性能改善(如果要国家元首记住全国人民的名字，不是太可能，但要让全国人民知道国家元首，就容易的多)</li>
<li>在 1-N 关系中，若将 1 方设为主控方<ul>
<li>会额外多出 update 语句。</li>
<li>插入数据时无法同时插入外键列，因而无法为外键列添加非空约束。</li>
</ul>
</li>
</ul>
</li>
<li><p>&lt;set&gt;元素的cascade属性：</p>
<ul>
<li>cascade：意为级联。</li>
<li>在对象 – 关系映射文件中, 用于映射持久化类之间关联关系的元素, &lt;set&gt;, &lt;many-to-one&gt; 和 &lt;one-to-one&gt; 都有一个 cascade 属性, 它用于指定如何操纵与当前对象关联的其他对象。</li>
<li>举例：设定属性为delete时，删除一个customer对象，这个对象中还含有两个order属性。则在删除customer对象的数据时，也会删除对应的order对象的数据。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517135139.png"></p>
</li>
<li><p>在数据库中对集合排序：</p>
<ul>
<li>&lt;set&gt; 元素有一个 <strong>order-by 属性</strong>, 如果设置了该属性, 当 Hibernate 通过 select 语句到数据库中检索集合对象时, 利用 order by 子句进行排序。</li>
<li>order-by 属性中还可以加入 SQL 函数。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--集合属性的映射。首先order需要有多对一的映射。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- inverse=&quot;false&quot;：表示customer为被动方，所以由Order来维护数据 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--cascade=&quot;delete&quot;：表示删除当前对象时，和当前对象相关的数据对象也会被删除。即级联删除--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--order-by=&quot;order_number&quot;：表示根据order_number排序。注意order_number是表的字段名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">table</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">inverse</span>=<span class="string">&quot;false&quot;</span> <span class="attr">cascade</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">order-by</span>=<span class="string">&quot;order_number&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--这个键是Order表中的哪个外键的字段名--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--从customer端来看，是1到多的方向，因此要指定多的类型--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">&quot;Order&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">one-to-many</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="一对一关系"><a href="#一对一关系" class="headerlink" title="一对一关系"></a>一对一关系</h1><ul>
<li><p>域模型：一个部门对应一个经理，一个经理对应一个部门。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-19.png"></p>
</li>
<li><p>关系数据模型：有两种方式</p>
<ul>
<li>按照外键映射：通过外键设置关联，但设定外键为唯一约束。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210517210710-20.png"></p>
<ul>
<li>按照主键映射：</li>
</ul>
<p><img src=""></p>
</li>
<li><p>按照外键映射：</p>
<ul>
<li>对于基于外键的1-1关联，其外键可以存放在<strong>任意一边</strong>，在需要<strong>存放外键一端</strong>，增加<strong>many-to-one元素</strong>。为many-to-one元素增加<strong>unique=“true”</strong> 属性来表示为1-1关联。</li>
<li>另一端需要使用<strong>one-to-one元素</strong>，该元素使用 <strong>property-ref 属性指定使用被关联实体主键以外的字段作为关联字段</strong>。</li>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oneToOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">/*    Department department = new Department();</span></span><br><span class="line"><span class="comment">    department.setDepName(&quot;dep-A&quot;);</span></span><br><span class="line"><span class="comment">    Manager manager = new Manager();</span></span><br><span class="line"><span class="comment">    manager.setManName(&quot;man-A&quot;);</span></span><br><span class="line"><span class="comment">    manager.setManAge(12);</span></span><br><span class="line"><span class="comment">    manager.setDepartment(department);</span></span><br><span class="line"><span class="comment">    department.setManager(manager);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //建议先保存没有外键列的数据对象。这样可以减少sql语句的发送</span></span><br><span class="line"><span class="comment">    session.save(manager);</span></span><br><span class="line"><span class="comment">    session.save(department);*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*    //查询时，对于关联属性会使用懒加载机制。</span></span><br><span class="line"><span class="comment">    Department department = (Department) session.get(Department.class, 1);</span></span><br><span class="line"><span class="comment">    System.out.println(department.getDepName());</span></span><br><span class="line"><span class="comment">    //懒加载的查询语句有问题：</span></span><br><span class="line"><span class="comment">      //首先懒加载使用是左外连接。问题是做连接条件是dep的id和man的id进行连接。这是错误的。</span></span><br><span class="line"><span class="comment">    //解决方法是，在one-to-one链接时，添加property-ref属性</span></span><br><span class="line"><span class="comment">    Manager manager = department.getManager();</span></span><br><span class="line"><span class="comment">    System.out.println(manager.getManName());*/</span></span><br><span class="line">  <span class="comment">//在查询没有外键的对象时，如何获取到关联对象的数据呢？</span></span><br><span class="line">  <span class="comment">//答案：在查询时直接使用左外连接查询关联对象数据。而不使用懒加载机制</span></span><br><span class="line">  Manager manager = (Manager) session.get(Manager.class, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Department&quot;</span> <span class="attr">table</span>=<span class="string">&quot;departments&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;depId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;DEP_ID&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;depName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;DEP_NAME&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--1对1的关联映射：首先使用many-to-one在一个表中设定一个外键。外键unique属性为true--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">column</span>=<span class="string">&quot;MANAGER_ID&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Manager&quot;</span> <span class="attr">unique</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Manager&quot;</span> <span class="attr">table</span>=<span class="string">&quot;MANAGERS&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;manId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;MAN_ID&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;manAge&quot;</span> <span class="attr">column</span>=<span class="string">&quot;MAN_AGE&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;manName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;MAN_NAME&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--1对1映射：由于已经设置外键了，因此此处只需使用one-to-one关联即可--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--property-ref=&quot;manager&quot;：该属性指定使用哪个字段进行关联字段。--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">&quot;department&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Department&quot;</span> <span class="attr">property-ref</span>=<span class="string">&quot;manager&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>按照主键映射：</p>
<ul>
<li>基于主键的映射策略:指一端的<strong>主键生成器使用 foreign 策略</strong>,表明根据”对方”的主键来生成自己的主键，自己并不能独立生成主键. <strong>&lt;param&gt; 子元素</strong>指定使用当前持久化类的哪个属性作为 “对方”。</li>
<li>采用foreign主键生成器策略的一端增加 one-to-one 元素映射关联属性，其one-to-one属性还应增加 <strong>constrained=“true” 属性</strong>；另一端增加one-to-one元素映射关联属性。</li>
<li>constrained(约束)：指定为当前持久化类对应的数据库表的<strong>主键添加一个外键约束</strong>，引用被关联的对象(“对方”)所对应的数据库表主键。</li>
<li>测试代码：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Department&quot;</span> <span class="attr">table</span>=<span class="string">&quot;departments&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;depId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;DEP_ID&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注意此处--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;foreign&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;property&quot;</span>&gt;</span>manager<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;depName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;DEP_NAME&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--1对1映射。不设中主键。注意主键生成策略。和constrained属性--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Manager&quot;</span> <span class="attr">constrained</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Manager&quot;</span> <span class="attr">table</span>=<span class="string">&quot;MANAGERS&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;manId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;MAN_ID&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;manAge&quot;</span> <span class="attr">column</span>=<span class="string">&quot;MAN_AGE&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;manName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;MAN_NAME&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--1对1映射。不设中主键--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">&quot;department&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Department&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="多对多关系"><a href="#多对多关系" class="headerlink" title="多对多关系"></a>多对多关系</h1><h2 id="单向n对n"><a href="#单向n对n" class="headerlink" title="单向n对n"></a>单向n对n</h2><ul>
<li><p>域模型：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655.png"></p>
</li>
<li><p>关系数据模型：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-1.png"></p>
</li>
<li><p>映射文件配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Category&quot;</span> <span class="attr">table</span>=<span class="string">&quot;categorys&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;cgyId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;cgy_id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cgyName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;cgy_name&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--对集合属性进行映射。映射多对多关系--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--table：指定中间表的表名--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;items&quot;</span> <span class="attr">table</span>=<span class="string">&quot;categorys_items&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定一个字段作为主键。这个字段默认对应当前类的id--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;category_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定集合的属性，以及在中间表对应的字段名。字段值对应集合的id值--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定集合中的持久化类在中间表的外键列的名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">&quot;Item&quot;</span> <span class="attr">column</span>=<span class="string">&quot;item_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-many</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Item&quot;</span> <span class="attr">table</span>=<span class="string">&quot;items&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;itId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;it_id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;itName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;it_name&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>说明：</p>
<ul>
<li>n-n 的关联必须使用<strong>连接表</strong>。一个类设定集合即可。</li>
<li>与 1-n 映射类似，必须为 set 集合元素添加 key 子元素，指定 CATEGORIES_ITEMS 表(中间表)中参照 CATEGORIES 表的外键为 CATEGORIY_ID。</li>
<li>与 1-n 关联映射不同的是，建立 n-n 关联时, 集合中的元素使用 many-to-many. many-to-many 子元素的 class 属性指定 items 集合中存放的是 Item 对象, column 属性指定  CATEGORIES_ITEMS 表中参照 ITEMS 表的外键为 ITEM_ID。</li>
</ul>
</li>
<li><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nToNTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">/*    Category category1 = new Category();</span></span><br><span class="line"><span class="comment">    Category category2 = new Category();</span></span><br><span class="line"><span class="comment">    category1.setCgyName(&quot;cat-A&quot;);</span></span><br><span class="line"><span class="comment">    category2.setCgyName(&quot;cat-B&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Item item1 = new Item();</span></span><br><span class="line"><span class="comment">    Item item2 = new Item();</span></span><br><span class="line"><span class="comment">    item1.setItName(&quot;it-A&quot;);</span></span><br><span class="line"><span class="comment">    item2.setItName(&quot;it-B&quot;);</span></span><br><span class="line"><span class="comment">    //设定关联关系</span></span><br><span class="line"><span class="comment">    category1.getItems().add(item1);</span></span><br><span class="line"><span class="comment">    category1.getItems().add(item2);</span></span><br><span class="line"><span class="comment">    category2.getItems().add(item1);</span></span><br><span class="line"><span class="comment">    category2.getItems().add(item2);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //执行了8条插入语句，categorys表两条，items表两条，中间表4条</span></span><br><span class="line"><span class="comment">    session.save(category1);</span></span><br><span class="line"><span class="comment">    session.save(category2);</span></span><br><span class="line"><span class="comment">    session.save(item1);</span></span><br><span class="line"><span class="comment">    session.save(item2);*/</span></span><br><span class="line"></span><br><span class="line">  Category category = (Category) session.get(Category.class,<span class="number">1</span>);</span><br><span class="line">  System.out.println(category.getCgyName());</span><br><span class="line">  <span class="comment">//对于集合属性的数据采用了懒加载机制。在查询时使用inner join连接查询</span></span><br><span class="line">  Set&lt;Item&gt; items = category.getItems();</span><br><span class="line">  System.out.println(items.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="双向n对n"><a href="#双向n对n" class="headerlink" title="双向n对n"></a>双向n对n</h2><ul>
<li><p>域模型和关系数据模型与单向的n对n的基本相同。不同在于Item类中有一个set集合。</p>
</li>
<li><p>映射文件配置：不同之处：Category映射文件一模一样。Item映射文件加了一些。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Item&quot;</span> <span class="attr">table</span>=<span class="string">&quot;items&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;itId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;it_id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;itName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;it_name&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--注意table的值要和另一个映射文件的值相同。即使用同一个中间表。--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--inverse=&quot;true&quot;属性必须写。只能是一个持久化类维护中间表--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;categories&quot;</span> <span class="attr">table</span>=<span class="string">&quot;categorys_items&quot;</span> <span class="attr">inverse</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里的字段名也要和另一个映射文件的字段名一一对应。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;item_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">column</span>=<span class="string">&quot;category_id&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Category&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>说明：</p>
<ul>
<li>双向 n-n 关联需要<strong>两端都使用集合属性</strong>。双向n-n关联必须使<strong>用连接表</strong>。</li>
<li>集合属性应增加 key 子元素用以映射外键列, 集合元素里还应增加many-to-many子元素关联实体类。</li>
<li>在双向 n-n 关联的两边<strong>都需指定连接表的表名及外键列的列名</strong>。两个集合元素 set 的 table 元素的值必须指定，而且<strong>必须相同</strong>。</li>
<li>set元素的两个子元素：key 和 many-to-many 都必须指定 column 属性，其中，key 和 many-to-many 分别指定本持久化类和关联类在连接表中的外键列名，因此两边的 key 与 many-to-many 的<strong>column属性交叉相同</strong>。</li>
<li>也就是说，一边的set元素的key的 cloumn值为a,many-to-many 的 column 为b；则另一边的 set 元素的 key 的 column 值 b,many-to-many的 column 值为 a。</li>
<li>对于双向 n-n 关联, 必须把其中一端的 <strong>inverse 设置为 true</strong>, 否则两端都维护关联关系可能<strong>会造成主键冲突</strong>。</li>
</ul>
</li>
</ul>
<h1 id="对象继承关系映射"><a href="#对象继承关系映射" class="headerlink" title="对象继承关系映射"></a>对象继承关系映射</h1><ul>
<li><p>对于面向对象的程序设计语言而言，继承和多态是两个最基本的概念。</p>
</li>
<li><p>Hibernate 的继承映射可以理解持久化类之间的继承关系。</p>
</li>
<li><p>例如：人和学生之间的关系。学生继承了人，可以认为学生是一个特殊的人，如果对人进行查询，学生的实例也将被得到。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-2.png"></p>
</li>
<li><p>Hibernate支持三种继承映射策略：</p>
<ul>
<li>使用 <strong>subclass</strong> 进行映射：将域模型中的每一个实体对象映射到一个独立的表中，也就是说不用在关系数据模型中考虑域模型中的继承关系和多态。 </li>
<li>使用 <strong>joined-subclass</strong> 进行映射： 对于继承关系中的子类使用同一个表，这就需要在数据库表中增加额外的区分子类类型的字段。 </li>
<li>使用  <strong>union-subclass</strong> 进行映射：域模型中的每个类映射到一个表，通过关系数据模型中的外键来描述表之间的继承关系。这也就相当于按照域模型的结构来建立数据库中的表，并通过外键来建立表之间的继承关系。</li>
</ul>
</li>
</ul>
<h2 id="subclass-进行映射"><a href="#subclass-进行映射" class="headerlink" title="subclass 进行映射"></a>subclass 进行映射</h2><ul>
<li><p>采用 subclass 的继承映射可以实现对于继承关系中<strong>父类和子类使用同一张表</strong>。</p>
</li>
<li><p>因为父类和子类的实例全部保存在同一个表中，因此需要在该表内增加一列，使用该列来<strong>区分每行记录到低是哪个类的实例</strong>—-这个列被称为辨别者列(discriminator)。</p>
</li>
<li><p>在这种映射策略下，使用 subclass 来映射子类，使用 class 或 subclass 的 <strong>discriminator-value 属性指定辨别者列的值</strong>。</p>
</li>
<li><p><strong>所有子类定义的字段都不能有非空约束</strong>。如果为那些字段添加非空约束，那么父类的实例在那些列其实并没有值，这将引起数据库完整性冲突，导致父类的实例无法保存到数据库中。</p>
</li>
<li><p>关系数据模型：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-3.png"></p>
</li>
<li><p>映射文件：只需要父类一个映射文件即可。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span> <span class="attr">table</span>=<span class="string">&quot;persons&quot;</span> <span class="attr">discriminator-value</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;perId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;per_id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--添加辨别者列字段。并设定两个类的辨别者标识--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">column</span>=<span class="string">&quot;type&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;perName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;per_name&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;perAge&quot;</span> <span class="attr">column</span>=<span class="string">&quot;per_age&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--使用映射继承关系--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">subclass</span> <span class="attr">name</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">discriminator-value</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;school&quot;</span> <span class="attr">column</span>=<span class="string">&quot;school&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">subclass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subclassTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">/*    Person person = new Person();</span></span><br><span class="line"><span class="comment">    person.setPerName(&quot;per-A&quot;);</span></span><br><span class="line"><span class="comment">    person.setPerAge(10);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Student student = new Student();</span></span><br><span class="line"><span class="comment">    student.setPerName(&quot;stu-A&quot;);</span></span><br><span class="line"><span class="comment">    student.setPerAge(18);</span></span><br><span class="line"><span class="comment">    student.setSchool(&quot;请阿虎&quot;);</span></span><br><span class="line"><span class="comment">    //SQL语句：insert into persons (per_name, per_age, type) values (?, ?, &#x27;person&#x27;)</span></span><br><span class="line"><span class="comment">    session.save(person);</span></span><br><span class="line"><span class="comment">    //SQL语句：insert into persons (per_name, per_age, school, type) values (?, ?, ?, &#x27;student&#x27;)</span></span><br><span class="line"><span class="comment">    session.save(student);*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//from Peoson：表示查询Person类型数据。</span></span><br><span class="line">  List&lt;Person&gt; persons = session.createQuery(<span class="string">&quot;FROM Person&quot;</span>).list();</span><br><span class="line">  System.out.println(persons.size());</span><br><span class="line">  <span class="comment">//from Student：表示查询Student类型数据。</span></span><br><span class="line">  List&lt;Student&gt; students = session.createQuery(<span class="string">&quot;FROM Student&quot;</span>).list();</span><br><span class="line">  System.out.println(students.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>总结：</p>
<ul>
<li>对于父类记录，插入只需要插入一张表中，查询也只需要查询一张表。</li>
<li>对于子类记录，插入只需要插入一张表中，查询也只需要查询一张表。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>需要添加辨别者列。</li>
<li>子类的数据可以设置为空。</li>
<li>若几继承关系很深的话，表的字段数量会变很大。</li>
</ul>
</li>
</ul>
<h2 id="joined-subclass-进行映射"><a href="#joined-subclass-进行映射" class="headerlink" title="joined-subclass 进行映射"></a>joined-subclass 进行映射</h2><ul>
<li><p>采用 joined-subclass 元素的继承映射可以实现<strong>每个子类一张表</strong>.</p>
</li>
<li><p>采用这种映射策略时，父类实例保存在父类表中，<strong>子类实例由父类表和子类表共同存储</strong>。因为子类实例也是一个特殊的父类实例，因此必然也包含了父类实例的属性。于是将子类和父类共有的属性保存在父类表中，子类增加的属性，则保存在子类表中。</p>
</li>
<li><p>在这种映射策略下，无须使用鉴别者列，但需要为<strong>每个子类使用 key 元素映射共有主键</strong>。</p>
</li>
<li><p><strong>子类增加的属性可以添加非空约束</strong>。因为子类的属性和父类的属性没有保存在同一个表中</p>
</li>
<li><p>关系数据模型:</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-4.png"></p>
</li>
<li><p>映射文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span> <span class="attr">table</span>=<span class="string">&quot;persons&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;perId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;per_id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;perName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;per_name&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;perAge&quot;</span> <span class="attr">column</span>=<span class="string">&quot;per_age&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--使用joined-subclass映射继承关系--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">joined-subclass</span> <span class="attr">name</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">table</span>=<span class="string">&quot;students&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--column对应的字段值是父类的主键的值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;person_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;school&quot;</span> <span class="attr">column</span>=<span class="string">&quot;school&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">joined-subclass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">joinedSubclassTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">/*    Person person = new Person();</span></span><br><span class="line"><span class="comment">    person.setPerName(&quot;per-A&quot;);</span></span><br><span class="line"><span class="comment">    person.setPerAge(10);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Student student = new Student();</span></span><br><span class="line"><span class="comment">    student.setPerName(&quot;stu-A&quot;);</span></span><br><span class="line"><span class="comment">    student.setPerAge(18);</span></span><br><span class="line"><span class="comment">    student.setSchool(&quot;请阿虎&quot;);</span></span><br><span class="line"><span class="comment">    //执行一条insert语句</span></span><br><span class="line"><span class="comment">    session.save(person);</span></span><br><span class="line"><span class="comment">    //执行两条insert语句</span></span><br><span class="line"><span class="comment">    session.save(student);*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//查询两张表。使用左外连接</span></span><br><span class="line">  List&lt;Person&gt; persons = session.createQuery(<span class="string">&quot;FROM Person&quot;</span>).list();</span><br><span class="line">  System.out.println(persons.size());</span><br><span class="line">  <span class="comment">//查询两张表。使用内连接</span></span><br><span class="line">  List&lt;Student&gt; students = session.createQuery(<span class="string">&quot;FROM Student&quot;</span>).list();</span><br><span class="line">  System.out.println(students.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>总结：</p>
<ul>
<li>查询时：父类使用左外连接查询两张表，子类使用内连接查询两张表。</li>
<li>插入时：父类只插入一张表中，子类需要插入两张表。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>不需要使用辨别者字段。</li>
<li>子类可以添加非空约束。</li>
<li>每个类一个表，没有冗余的字段。</li>
</ul>
</li>
</ul>
<h2 id="union-subclass-进行映射"><a href="#union-subclass-进行映射" class="headerlink" title="union-subclass 进行映射"></a>union-subclass 进行映射</h2><ul>
<li><p>采用 union-subclass 元素可以实现将<strong>每一个实体对象映射到一个独立的表中</strong>。</p>
</li>
<li><p><strong>子类增加的属性可以有非空约束</strong> — 即父类实例的数据保存在父表中，而子类实例的数据保存在子类表中。</p>
</li>
<li><p>子类实例的数据<strong>仅保存在子类表中</strong>, 而在父类表中没有任何记录。</p>
</li>
<li><p>在这种映射策略下，<strong>子类表的字段会比父类表的映射字段要多</strong>,因为子类表的字段等于父类表的字段、加子类增加属性的总和。</p>
</li>
<li><p>在这种映射策略下，既不需要使用鉴别者列，也无须使用 key 元素来映射共有主键。</p>
</li>
<li><p>使用 union-subclass 映射策略是<strong>不可使用 identity 的主键生成策略</strong>, 因为同一类继承层次中所有实体类都需要使用同一个主键种子, 即多个持久化实体对应的记录的<strong>主键应该是连续的</strong>. 受此影响, <strong>也不该使用 native 主键生成策略</strong>, 因为 native 会根据数据库来选择使用 identity 或 sequence。</p>
</li>
<li><p>关系数据模型：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-5.png"></p>
</li>
<li><p>映射文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span> <span class="attr">table</span>=<span class="string">&quot;persons&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;perId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;per_id&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注意这里的主键生成策略--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;increment&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;perName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;per_name&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;perAge&quot;</span> <span class="attr">column</span>=<span class="string">&quot;per_age&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--使用union-subclass映射继承关系--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">union-subclass</span> <span class="attr">name</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">table</span>=<span class="string">&quot;students&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;school&quot;</span> <span class="attr">column</span>=<span class="string">&quot;school&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">union-subclass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionSubclassTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">/*    Person person = new Person();</span></span><br><span class="line"><span class="comment">    person.setPerName(&quot;per-A&quot;);</span></span><br><span class="line"><span class="comment">    person.setPerAge(10);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Student student = new Student();</span></span><br><span class="line"><span class="comment">    student.setPerName(&quot;stu-A&quot;);</span></span><br><span class="line"><span class="comment">    student.setPerAge(18);</span></span><br><span class="line"><span class="comment">    student.setSchool(&quot;请阿虎&quot;);</span></span><br><span class="line"><span class="comment">    //会先执行一条查询最大id的语句</span></span><br><span class="line"><span class="comment">    //执行一条insert语句</span></span><br><span class="line"><span class="comment">    session.save(person);</span></span><br><span class="line"><span class="comment">    //执行一条insert语句</span></span><br><span class="line"><span class="comment">    session.save(student);*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*    //查询两张表。先内连接查询两张表，然后在查询连接后的表</span></span><br><span class="line"><span class="comment">    List&lt;Person&gt; persons = session.createQuery(&quot;FROM Person&quot;).list();</span></span><br><span class="line"><span class="comment">    System.out.println(persons.size());</span></span><br><span class="line"><span class="comment">    //查询一张表。</span></span><br><span class="line"><span class="comment">    List&lt;Student&gt; students = session.createQuery(&quot;FROM Student&quot;).list();</span></span><br><span class="line"><span class="comment">    System.out.println(students.size());*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//更新父类的数据时。会先查询所有的父类信息，然后依次更新。</span></span><br><span class="line">  <span class="comment">//更新语句是针对数据对象的更新。是HQL语句</span></span><br><span class="line">  String hql = <span class="string">&quot;update Person p set p.perAge = 20&quot;</span>;</span><br><span class="line">  session.createQuery(hql).executeUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>总结：</p>
<ul>
<li>插入时：首先会查询最大的id。然后父类只会插入一张表，子类也是。</li>
<li>查询时：父类会进行内连接查询然后再查询。子类只会查询一张表。</li>
<li>更新时：父类会先查询对象数据，然后再依次更新。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>没有辨别者字段。</li>
<li>子类可以添加非空约束。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>存在冗余的字段。因为子类的表和父类的表存在相同的字段。</li>
<li>更新的效率较低。</li>
</ul>
</li>
</ul>
<h2 id="三种继承映射方式的比较"><a href="#三种继承映射方式的比较" class="headerlink" title="三种继承映射方式的比较"></a>三种继承映射方式的比较</h2><ul>
<li>推荐使用joined-subclass和union-class的方式。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-6.png"></p>
<h1 id="检索策略"><a href="#检索策略" class="headerlink" title="检索策略"></a>检索策略</h1><ul>
<li>检索数据时的 2 个问题：<ul>
<li><strong>不浪费内存</strong>：当 Hibernate 从数据库中加载 Customer 对象时, 如果同时加载所有关联的 Order 对象, 而程序实际上仅仅需要访问 Customer 对象, 那么这些关联的 Order 对象就白白浪费了许多内存。</li>
<li><strong>更高的查询效率</strong>：发送尽可能少的 SQL 语句。</li>
</ul>
</li>
</ul>
<h2 id="类级别的检索策略"><a href="#类级别的检索策略" class="headerlink" title="类级别的检索策略"></a>类级别的检索策略</h2><ul>
<li>类级别可选的检索策略包括立即检索和延迟检索, 默认为延迟检索<ul>
<li>立即检索: 立即加载检索方法指定的对象。</li>
<li>延迟检索: 延迟加载检索方法指定的对象。在使用具体的属性时，再进行加载。</li>
</ul>
</li>
<li>类级别的检索策略可以通过 &lt;class&gt; 元素的 lazy 属性进行设置</li>
<li>如果程序加载一个对象的目的是为了访问它的属性, 可以采取立即检索. </li>
<li>如果程序加载一个持久化对象的目的是仅仅为了获得它的引用, 可以采用延迟检索。<strong>注意出现懒加载异常！</strong></li>
<li>无论 &lt;class&gt; 元素的 lazy 属性是 true 还是 false, Session 的 get() 方法及 Query 的 list() 方法在<strong>类级别总是使用立即检索策略</strong>。</li>
<li>若 &lt;class&gt; 元素的 lazy 属性为 true 或取默认值, Session 的 <strong>load() 方法</strong>不会执行查询数据表的 SELECT 语句, 仅返回代理类对象的实例, 该代理类实例有如下特征:<ul>
<li>由 Hibernate 在运行时采用 CGLIB 工具动态生成。</li>
<li>Hibernate 创建代理类实例时, 仅初始化<strong>其 OID 属性</strong>。</li>
<li>在应用程序第一次访问代理类实例的非 OID 属性时, Hibernate 会初始化代理类实例。</li>
</ul>
</li>
</ul>
<h2 id="一对多和多对多的检索策略"><a href="#一对多和多对多的检索策略" class="headerlink" title="一对多和多对多的检索策略"></a>一对多和多对多的检索策略</h2><ul>
<li><p>在映射文件中, 用 &lt;set&gt; 元素来配置一对多关联及多对多关联关系. &lt;set&gt; 元素有 lazy 和 fetch 属性</p>
<ul>
<li>lazy: 主要决定 orders 集合被<strong>初始化的时机</strong>。 即到底是在加载 Customer 对象时就被初始化, 还是在程序访问 orders 集合时被初始化。</li>
<li>fetch: 取值为 “select” 或 “subselect” 时, 决定<strong>初始化 orders 的查询语句的形式</strong>;  若取值为”join”, 则决定 orders 集合被初始化的时机。</li>
<li>若把 fetch 设置为 “join”, lazy 属性将被忽略。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-7.png"></p>
</li>
<li><p>&lt;set&gt; 元素的 batch-size 属性：用来为延迟检索策略或立即检索策略<strong>设定批量检索的数量</strong>. 批量检索能减少 SELECT 语句的数目, 提高延迟检索或立即检索的运行性能。</p>
<ul>
<li>batch-size 属性也可以设定在&lt;class&gt;元素中。不过要设置在1的那一端。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--batch-size=&quot;5&quot;：表示初始化集合的数据时，一次性初始5条数据--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;items&quot;</span> <span class="attr">table</span>=<span class="string">&quot;categorys_items&quot;</span> <span class="attr">batch-size</span>=<span class="string">&quot;5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在延迟检索(<strong>lazy 属性值为 true</strong>) 集合属性时, Hibernate 在以下情况下<strong>初始化集合代理类实例</strong> </p>
<ul>
<li>应用程序第一次访问集合属性: iterator(), size(), isEmpty(), contains() 等方法。</li>
<li>通过 Hibernate.initialize() 静态方法显式初始化。</li>
</ul>
</li>
<li><p>增强延迟检索(<strong>lazy 属性为 extra</strong>): 与 lazy=“true” 类似. 主要区别是增强延迟检索策略能进一步延迟 Customer 对象的 orders 集合代理实例的初始化时机：</p>
<ul>
<li>当程序第一次访问 orders 属性的 iterator() 方法时, 会导致 orders 集合代理类实例的初始化</li>
<li>当程序第一次访问 order 属性的 size(), contains() 和 isEmpty() 方法时, Hibernate 不会初始化 orders 集合类的实例, 仅<strong>通过特定的 select 语句查询必要的信息</strong>, 不会检索所有的 Order 对象。</li>
</ul>
</li>
<li><p>当 fetch 属性为 “<strong>select</strong>” 时：</p>
<ul>
<li>集合的数据是使用一个初始化一个。</li>
</ul>
</li>
<li><p>当 fetch 属性为 “<strong>subselect</strong>” 时：</p>
<ul>
<li>假定 Session 缓存中有 n 个 orders 集合代理类实例没有被初始化, Hibernate 能够通过带子查询的 select 语句, 来<strong>批量初始化 n 个 orders 集合代理类实例</strong>。</li>
<li><strong>batch-size 属性将被忽略</strong>。</li>
<li>子查询中的 select 语句为通过查询CUSTOMERS 表 OID进而查询集合数据的 SELECT 语句。</li>
</ul>
</li>
<li><p>当 fetch 属性为 “<strong>join</strong>” 时：</p>
<ul>
<li>检索 Customer 对象时, 会<strong>采用迫切左外连接</strong>(通过左外连接加载与检索指定的对象关联的对象)<strong>策略来检索所有关联的 Order 对象</strong>。</li>
<li><strong>lazy 属性将被忽略</strong>。</li>
<li><font color="red">但是当使用Query 的list() 方法会忽略映射文件中配置的迫切左外连接检索策略, 而依旧采用延迟加载策略。</font></li>
</ul>
</li>
</ul>
<h2 id="多对一和一对一的检索策略"><a href="#多对一和一对一的检索策略" class="headerlink" title="多对一和一对一的检索策略"></a>多对一和一对一的检索策略</h2><ul>
<li><p>和 &lt;set&gt; 一样, &lt;many-to-one&gt; 元素也有一个 lazy 属性和 fetch 属性。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-8.png"></p>
<ul>
<li>若 fetch 属性设为 join, 那么 lazy 属性被忽略。</li>
<li>迫切左外连接检索策略的优点在于比立即检索策略使用的 SELECT 语句更少。</li>
<li>无代理延迟检索需要增强持久化类的字节码才能实现。</li>
</ul>
</li>
<li><p>Query 的 <strong>list 方法会忽略</strong>映射文件配置的<strong>迫切左外连接</strong>检索策略, 而采用延迟检索策略。</p>
</li>
<li><p>如果在关联级别使用了延迟加载或立即加载检索策略, 可以<strong>设定批量检索的大小</strong>, 以帮助提高延迟检索或立即检索的运行性能。</p>
</li>
<li><p>Hibernate 允许在应用程序中覆盖映射文件中设定的检索策略。</p>
</li>
</ul>
<h2 id="检索策略总结"><a href="#检索策略总结" class="headerlink" title="检索策略总结"></a>检索策略总结</h2><ul>
<li><p>类级别和关联级别可选的检索策略及默认的检索策略：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-9.png"></p>
</li>
<li><p>3 种检索策略的运行机制：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-10.png"></p>
</li>
<li><p>映射文件中用于设定检索策略的几个属性：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-11.png"></p>
</li>
<li><p>比较 Hibernate 的三种检索策略：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-12.png"></p>
</li>
</ul>
<h1 id="检索方式"><a href="#检索方式" class="headerlink" title="检索方式"></a>检索方式</h1><ul>
<li>Hibernate 提供了以下几种检索对象的方式：<ul>
<li>导航对象图检索方式:  根据已经加载的对象导航到其他对象。</li>
<li>OID 检索方式:  按照对象的 OID 来检索对象。</li>
<li><strong>HQL 检索方式</strong>: 使用<strong>面向对象</strong>的 HQL 查询语言。</li>
<li><strong>QBC 检索方式</strong>: 使用 QBC(Query By Criteria) API 来检索对象. 这种 API 封装了<strong>基于字符串形式的查询语句</strong>, 提供了更加面向对象的查询接口。</li>
<li>本地 SQL 检索方式: 使用本地数据库的 SQL 查询语句。</li>
</ul>
</li>
</ul>
<h2 id="HQL检索方式"><a href="#HQL检索方式" class="headerlink" title="HQL检索方式"></a>HQL检索方式</h2><ul>
<li><p>HQL(Hibernate Query Language) 是<strong>面向对象的查询语言</strong>, 它和 SQL 查询语言有些相似。</p>
</li>
<li><p>在Hibernate 提供的各种检索方式中, HQL 是使用最广的一种检索方式. 它有如下功能:</p>
<ul>
<li>在查询语句中设定各种查询条件</li>
<li>支持投影查询, 即仅检索出对象的部分属性。</li>
<li>支持分页查询。</li>
<li>支持连接查询。</li>
<li>支持分组查询, 允许使用 HAVING 和 GROUP BY 关键字。</li>
<li>提供内置聚集函数, 如 sum(), min() 和 max()。</li>
<li>支持子查询。</li>
<li>支持动态绑定参数。</li>
<li>能够调用用户定义的 SQL 函数或标准的 SQL 函数。</li>
</ul>
</li>
<li><p>HQL 检索方式包括以下步骤:</p>
<ul>
<li>通过 Session 的 createQuery() 方法创建一个 Query 对象, 它包括一个 HQL 查询语句。HQL 查询语句中可以包含命名参数。</li>
<li>动态绑定参数。</li>
<li>调用 Query 相关方法执行查询语句。</li>
</ul>
</li>
<li><p>Qurey 接口<strong>支持方法链编程风格</strong>, 它的 setXxx() 方法返回自身实例, 而不是 void 类型。</p>
</li>
<li><p>HQL vs SQL：</p>
<ul>
<li>HQL 查询语句是面向对象的, <strong>Hibernate 负责解析 HQL 查询语句</strong>, 然后根据对象-关系映射文件中的映射信息, <strong>把 HQL 查询语句翻译成相应的 SQL 语句</strong>. HQL 查询语句中的<strong>主体是域模型中的类及类的属性</strong>。</li>
<li>SQL 查询语句是与关系数据库绑定在一起的. SQL 查询语句中的主体是数据库表及表的字段。</li>
</ul>
</li>
<li><p>绑定参数：</p>
<ul>
<li><p>Hibernate 的参数绑定机制<strong>依赖于 JDBC API 中的 PreparedStatement 的预定义 SQL</strong> 语句功能。</p>
</li>
<li><p>HQL 的参数绑定由两种形式:</p>
<ul>
<li>按<strong>参数名字</strong>绑定: 在 HQL 查询语句中定义命名参数, 命名参数以 “:” 开头。</li>
<li>按<strong>参数位置</strong>绑定: 在 HQL 查询语句中用 “?” 来定义参数位置</li>
</ul>
</li>
<li><p>相关方法:</p>
<ul>
<li>setEntity(): 把参数与一个持久化类绑定。</li>
<li>setParameter(): 绑定任意类型的参数. 该方法的第三个参数显式指定 Hibernate 映射类型。</li>
</ul>
</li>
<li><p>参数的类型：</p>
<ul>
<li>基本数据类型。</li>
<li>自定义类型的对象。</li>
</ul>
</li>
<li><p>实例：</p>
<ul>
<li>按<strong>参数名字</strong>绑定</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHQL2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//1.创建Query对象</span></span><br><span class="line">  <span class="comment">//设定了两个参数名sal和eml</span></span><br><span class="line">  String sql = <span class="string">&quot;from Employee e where e.salary &gt; :sal and e.email LIKE :eml&quot;</span>;</span><br><span class="line">  Query query = session.createQuery(sql);</span><br><span class="line">  <span class="comment">//2.绑定参数</span></span><br><span class="line">  <span class="comment">//通过链式操作绑定参数。</span></span><br><span class="line">  query.setFloat(<span class="string">&quot;sal&quot;</span>,<span class="number">6000</span>)</span><br><span class="line">    .setString(<span class="string">&quot;eml&quot;</span>,<span class="string">&quot;%qq%&quot;</span>);</span><br><span class="line">  <span class="comment">//3.执行查询</span></span><br><span class="line">  List&lt;Employee&gt; employees = query.list();</span><br><span class="line">  System.out.println(employees.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>按<strong>参数位置</strong>绑定</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHQL1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//1.创建Query对象</span></span><br><span class="line">  <span class="comment">//说明：查询Employee类的数据对象，当salary属性大于?且email像?并且dept等于?时。结果按照salary排序。</span></span><br><span class="line">  String sql = <span class="string">&quot;from Employee e where e.salary &gt; ? and e.email LIKE ? AND e.dept = ?&quot;</span> +</span><br><span class="line">    <span class="string">&quot;ORDER BY e.salary&quot;</span>;</span><br><span class="line">  Query query = session.createQuery(sql);</span><br><span class="line">  <span class="comment">//2.绑定参数</span></span><br><span class="line">  Department dep =  <span class="keyword">new</span> Department();</span><br><span class="line">  dep.setId(<span class="number">10</span>);</span><br><span class="line">  <span class="comment">//通过链式操作绑定参数。第三个绑定的是对象类型的参数</span></span><br><span class="line">  query.setFloat(<span class="number">0</span>,<span class="number">6000</span>)</span><br><span class="line">    .setString(<span class="number">1</span>,<span class="string">&quot;%qq%&quot;</span>)</span><br><span class="line">    .setEntity(<span class="number">2</span>,dep);</span><br><span class="line">  <span class="comment">//3.执行查询</span></span><br><span class="line">  List&lt;Employee&gt; employees = query.list();</span><br><span class="line">  System.out.println(employees.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>HQL 采用 ORDER BY 关键字对查询结果排序。</p>
</li>
</ul>
<h2 id="HQL检索的其他方式"><a href="#HQL检索的其他方式" class="headerlink" title="HQL检索的其他方式"></a>HQL检索的其他方式</h2><ul>
<li><p>分页查询：</p>
<ul>
<li>setFirstResult(int firstResult): 设定<strong>从哪一个对象开始检索</strong>, 参数 firstResult 表示这个对象在查询结果中的索引位置。<ul>
<li>索引位置的起始值为 0。默认情况下, Query 从查询结果中的第一个对象开始检索。</li>
</ul>
</li>
<li>setMaxResults(int maxResults): 设定一次<strong>最多检索出的对象的数目</strong>。<ul>
<li>在默认情况下, Query 和 Criteria 接口检索出查询结果中所有的对象。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPaging</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String hql = <span class="string">&quot;FROM Employee&quot;</span>;</span><br><span class="line">  Query query = session.createQuery(hql);</span><br><span class="line">  <span class="comment">//pageNo：第几页。pageSize：一页多少条数据</span></span><br><span class="line">  <span class="keyword">int</span> pageNo = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> pageSize = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  List&lt;Employee&gt; emps =</span><br><span class="line">    query.setFirstResult((pageNo - <span class="number">1</span>) * pageSize)</span><br><span class="line">    .setMaxResults(pageSize)</span><br><span class="line">    .list();</span><br><span class="line">  System.out.println(emps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>命名查询语句：</p>
<ul>
<li>Hibernate 允许在映射文件中定义字符串形式的查询语句。</li>
<li>&lt;query&gt; 元素用于定义一个 HQL 查询语句, 它和 &lt;class&gt; 元素并列。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--自定义查询语句。CDATA格式可以转义特殊符号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">query</span> <span class="attr">name</span>=<span class="string">&quot;salaryEmps&quot;</span>&gt;</span>&lt;![CDATA[FROM Employee e WHERE e.salary &gt; :minSal AND e.salary &lt; :maxSal]]&gt;<span class="tag">&lt;/<span class="name">query</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在程序中通过 Session 的 getNamedQuery() 方法获取查询语句对应的 Query 对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNameQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//获取映射文件中的sql元素的查询语句</span></span><br><span class="line">  Query query = session.getNamedQuery(<span class="string">&quot;salaryEmps&quot;</span>);</span><br><span class="line"></span><br><span class="line">  List&lt;Employee&gt; emps = query.setFloat(<span class="string">&quot;minSal&quot;</span>, <span class="number">5000</span>)</span><br><span class="line">    .setFloat(<span class="string">&quot;maxSal&quot;</span>, <span class="number">10000</span>)</span><br><span class="line">    .list();</span><br><span class="line"></span><br><span class="line">  System.out.println(emps.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>投影查询：</p>
<ul>
<li>投影查询: 查询结果仅包含实体的部分属性. 通过 SELECT 关键字实现。</li>
<li>Query 的 list() 方法返回的集合中包含的是数组类型的元素, 每个对象数组代表查询结果的一条记录。</li>
<li>可以在持久化类中定义一个对象的构造器来包装投影查询返回的记录, 使程序代码能完全运用面向对象的语义来访问查询结果集。</li>
<li>可以通过 DISTINCT 关键字来保证查询结果不会返回重复元素。</li>
<li>默认情况查询返回数组：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFieldQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String hql = <span class="string">&quot;SELECT e.email, e.salary, e.dept FROM Employee e WHERE e.dept = :dept&quot;</span>;</span><br><span class="line">  Query query = session.createQuery(hql);</span><br><span class="line"></span><br><span class="line">  Department dept = <span class="keyword">new</span> Department();</span><br><span class="line">  dept.setId(<span class="number">80</span>);</span><br><span class="line">  <span class="comment">//默认情况下list()方法返回的集合中的数据是数组类型的。但是我们可以封装成对象类型</span></span><br><span class="line">  List&lt;Object[]&gt; result = query.setEntity(<span class="string">&quot;dept&quot;</span>, dept)</span><br><span class="line">    .list();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(Object [] objs: result)&#123;</span><br><span class="line">    System.out.println(Arrays.asList(objs));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过构造器让数组转换成对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFieldQuery2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//此时需要保证Employee类中有此构造器的情况下才行</span></span><br><span class="line">  String hql = <span class="string">&quot;SELECT new Employee(e.email, e.salary, e.dept) &quot;</span></span><br><span class="line">    + <span class="string">&quot;FROM Employee e &quot;</span></span><br><span class="line">    + <span class="string">&quot;WHERE e.dept = :dept&quot;</span>;</span><br><span class="line">  Query query = session.createQuery(hql);</span><br><span class="line"></span><br><span class="line">  Department dept = <span class="keyword">new</span> Department();</span><br><span class="line">  dept.setId(<span class="number">80</span>);</span><br><span class="line">  <span class="comment">//查询语句通过构造器进行了封装</span></span><br><span class="line">  List&lt;Employee&gt; result = query.setEntity(<span class="string">&quot;dept&quot;</span>, dept)</span><br><span class="line">    .list();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(Employee emp: result)&#123;</span><br><span class="line">    System.out.println(emp.getId() + <span class="string">&quot;, &quot;</span> + emp.getEmail()</span><br><span class="line">                       + <span class="string">&quot;, &quot;</span> + emp.getSalary() + <span class="string">&quot;, &quot;</span> + emp.getDept());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>报表查询：</p>
<ul>
<li>报表查询用于对数据分组和统计, 与 SQL 一样, HQL 利用 GROUP BY 关键字对数据分组, 用 HAVING 关键字对分组数据设定约束条件。</li>
<li>在 HQL 查询语句中可以调用以下聚集函数：<ul>
<li>count()；min()；max()；sum()；avg()。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGroupBy</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String hql = <span class="string">&quot;SELECT min(e.salary), max(e.salary) &quot;</span></span><br><span class="line">    + <span class="string">&quot;FROM Employee e &quot;</span></span><br><span class="line">    + <span class="string">&quot;GROUP BY e.dept &quot;</span></span><br><span class="line">    + <span class="string">&quot;HAVING min(salary) &gt; :minSal&quot;</span>;</span><br><span class="line"></span><br><span class="line">  Query query = session.createQuery(hql)</span><br><span class="line">    .setFloat(<span class="string">&quot;minSal&quot;</span>, <span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">  List&lt;Object []&gt; result = query.list();</span><br><span class="line">  <span class="keyword">for</span>(Object [] objs: result)&#123;</span><br><span class="line">    System.out.println(Arrays.asList(objs));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>左外连接：</p>
<ul>
<li><p>迫切左外连接:</p>
<ul>
<li>LEFT JOIN <strong>FETCH 关键字</strong>表示迫切左外连接检索策略。</li>
<li>list() 方法返回的集合中存放<strong>实体对象的引用</strong>, 每个 Department 对象关联的 Employee  集合都被初始化, 存放所有关联的 Employee 的实体对象。</li>
<li>查询结果中<strong>可能会包含重复元素</strong>, 可以通过一个 HashSet 来过滤重复元素。</li>
<li>去重可以使用DISTINCT关键字。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLeftJoinFetch</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//		String hql = &quot;SELECT DISTINCT d FROM Department d LEFT JOIN FETCH d.emps&quot;;</span></span><br><span class="line">  String hql = <span class="string">&quot;FROM Department d INNER JOIN FETCH d.emps&quot;</span>;</span><br><span class="line">  Query query = session.createQuery(hql);</span><br><span class="line"></span><br><span class="line">  List&lt;Department&gt; depts = query.list();</span><br><span class="line">  depts = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">new</span> LinkedHashSet(depts));</span><br><span class="line">  System.out.println(depts.size());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(Department dept: depts)&#123;</span><br><span class="line">    System.out.println(dept.getName() + <span class="string">&quot;-&quot;</span> + dept.getEmps().size());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>左外连接:</p>
<ul>
<li>LEFT JOIN 关键字表示左外连接查询。</li>
<li>list() 方法返回的集合中存放的是<strong>对象数组类型</strong>。</li>
<li>此时<strong>根据配置文件来决定 Employee 集合的检索策略</strong>。</li>
<li>如果希望 list() 方法返回的集合中仅包含 Department 对象, 可以在HQL 查询语句中使用 SELECT 关键字。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLeftJoin</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String hql = <span class="string">&quot;SELECT DISTINCT d FROM Department d LEFT JOIN d.emps&quot;</span>;</span><br><span class="line">  Query query = session.createQuery(hql);</span><br><span class="line"></span><br><span class="line">  List&lt;Department&gt; depts = query.list();</span><br><span class="line">  System.out.println(depts.size());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(Department dept: depts)&#123;</span><br><span class="line">    <span class="comment">//此时的dept对象的Employee数据是根据配置文件的设定初始化的。默认懒加载</span></span><br><span class="line">    System.out.println(dept.getName() + <span class="string">&quot;, &quot;</span> + dept.getEmps().size());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//		List&lt;Object []&gt; result = query.list();</span></span><br><span class="line">  <span class="comment">//		result = new ArrayList&lt;&gt;(new LinkedHashSet&lt;&gt;(result));</span></span><br><span class="line">  <span class="comment">//		System.out.println(result);</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//		for(Object [] objs: result)&#123;</span></span><br><span class="line">  <span class="comment">//			System.out.println(Arrays.asList(objs));</span></span><br><span class="line">  <span class="comment">//		&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>内连接：</p>
<ul>
<li><p>与左外连接的区别：不返回左表不符合的记录</p>
</li>
<li><p>迫切内连接:</p>
<ul>
<li>INNER JOIN <strong>FETCH 关键</strong>字表示迫切内连接, 也可以省略 INNER 关键字。</li>
<li>list() 方法返回的集合中<strong>存放 Department 对象的引用</strong>, 每个 Department 对象的 Employee 集合都被初始化, 存放所有关联的 Employee 对象。</li>
</ul>
</li>
<li><p>内连接:</p>
<ul>
<li>INNER JOIN 关键字表示内连接, 也可以省略 INNER 关键字。</li>
<li>list() 方法的集合中存放的每个元素对应查询结果的一条记录, 每个元素都是<strong>对象数组类型</strong>。</li>
<li>如果希望 list() 方法的返回的集合仅包含 Department  对象, 可以在 HQL 查询语句中使用 SELECT 关键字。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInnerJoinFetch2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String hql = <span class="string">&quot;SELECT e FROM Employee e INNER JOIN e.dept&quot;</span>;</span><br><span class="line">  Query query = session.createQuery(hql);</span><br><span class="line"></span><br><span class="line">  List&lt;Employee&gt; emps = query.list();</span><br><span class="line">  System.out.println(emps.size());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(Employee emp: emps)&#123;</span><br><span class="line">    System.out.println(emp.getName() + <span class="string">&quot;, &quot;</span> + emp.getDept().getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>关联级别运行时的检索策略：</p>
<ul>
<li>如果在 HQL 中没有显式指定检索策略, 将使用映射文件配置的检索策略。</li>
<li><strong>HQL 会忽略映射文件中设置的迫切左外连接检索策略</strong>, 如果希望 HQL 采用迫切左外连接策略, 就必须在 HQL 查询语句中<strong>显式的指定它</strong>。</li>
<li>若在 HQL 代码中显式指定了检索策略, 就会<strong>覆盖映射文件中配置的检索策略</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.setFetchSize();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="QBC检索"><a href="#QBC检索" class="headerlink" title="QBC检索"></a>QBC检索</h2><ul>
<li><p>QBC 查询就是通过使用 Hibernate 提供的 Query By <strong>Criteria</strong> API 来查询对象，这种 API 封装了 SQL 语句的动态拼装，对查询提供了更加面向对象的功能接口。</p>
</li>
<li><p>基本使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQBC</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//1. 创建一个 Criteria 对象</span></span><br><span class="line">  Criteria criteria = session.createCriteria(Employee.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2. 添加查询条件: 在 QBC 中查询条件使用 Criterion 来表示</span></span><br><span class="line">  <span class="comment">//Criterion 可以通过 Restrictions 的静态方法得到</span></span><br><span class="line">  criteria.add(Restrictions.eq(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;SKUMAR&quot;</span>));</span><br><span class="line">  criteria.add(Restrictions.gt(<span class="string">&quot;salary&quot;</span>, <span class="number">5000F</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3. 执行查询</span></span><br><span class="line">  Employee employee = (Employee) criteria.uniqueResult();</span><br><span class="line">  System.out.println(employee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>or和and的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQBC2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Criteria criteria = session.createCriteria(Employee.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1. AND: 使用 Conjunction 表示</span></span><br><span class="line">  <span class="comment">//Conjunction 本身就是一个 Criterion 对象</span></span><br><span class="line">  <span class="comment">//且其中还可以添加 Criterion 对象</span></span><br><span class="line">  Conjunction conjunction = Restrictions.conjunction();</span><br><span class="line">  conjunction.add(Restrictions.like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>, MatchMode.ANYWHERE));</span><br><span class="line">  Department dept = <span class="keyword">new</span> Department();</span><br><span class="line">  dept.setId(<span class="number">80</span>);</span><br><span class="line">  conjunction.add(Restrictions.eq(<span class="string">&quot;dept&quot;</span>, dept));</span><br><span class="line">  System.out.println(conjunction);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2. OR：使用 Disjunction 表示</span></span><br><span class="line">  <span class="comment">//Disjunction 本身也是一个 Criterion 对象</span></span><br><span class="line">  Disjunction disjunction = Restrictions.disjunction();</span><br><span class="line">  disjunction.add(Restrictions.ge(<span class="string">&quot;salary&quot;</span>, <span class="number">6000F</span>));</span><br><span class="line">  disjunction.add(Restrictions.isNull(<span class="string">&quot;email&quot;</span>));</span><br><span class="line"></span><br><span class="line">  criteria.add(disjunction);</span><br><span class="line">  criteria.add(conjunction);</span><br><span class="line"></span><br><span class="line">  criteria.list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>统计查询的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQBC3</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Criteria criteria = session.createCriteria(Employee.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//统计查询: 使用 Projection 来表示: 可以由 Projections 的静态方法得到</span></span><br><span class="line">  criteria.setProjection(Projections.max(<span class="string">&quot;salary&quot;</span>));</span><br><span class="line"></span><br><span class="line">  System.out.println(criteria.uniqueResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>排序查询的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQBC4</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Criteria criteria = session.createCriteria(Employee.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1. 添加排序：使用 Order 来表示</span></span><br><span class="line">  criteria.addOrder(Order.asc(<span class="string">&quot;salary&quot;</span>));</span><br><span class="line">  criteria.addOrder(Order.desc(<span class="string">&quot;email&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2. 添加翻页方法</span></span><br><span class="line">  <span class="keyword">int</span> pageSize = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> pageNo = <span class="number">3</span>;</span><br><span class="line">  criteria.setFirstResult((pageNo - <span class="number">1</span>) * pageSize)</span><br><span class="line">    .setMaxResults(pageSize)</span><br><span class="line">    .list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="本地检索"><a href="#本地检索" class="headerlink" title="本地检索"></a>本地检索</h2><ul>
<li><p>本地SQL查询来完善HQL不能涵盖所有的查询特性。</p>
<ul>
<li>比如复杂的添加，更新，删除操作。</li>
</ul>
</li>
<li><p>添加操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNativeSQL</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String sql = <span class="string">&quot;INSERT INTO gg_department VALUES(?, ?)&quot;</span>;</span><br><span class="line">  Query query = session.createSQLQuery(sql);</span><br><span class="line"></span><br><span class="line">  query.setInteger(<span class="number">0</span>, <span class="number">280</span>)</span><br><span class="line">      .setString(<span class="number">1</span>, <span class="string">&quot;ATGUIGU&quot;</span>)</span><br><span class="line">      .executeUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHQLUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String hql = <span class="string">&quot;DELETE FROM Department d WHERE d.id = :id&quot;</span>;</span><br><span class="line"></span><br><span class="line">  session.createQuery(hql).setInteger(<span class="string">&quot;id&quot;</span>, <span class="number">280</span>)</span><br><span class="line">      .executeUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h1><ul>
<li><p>缓存(Cache): 计算机领域非常通用的概念。它介于应用程序和永久性数据存储源(如硬盘上的文件或者数据库)之间，其作用是降低应用程序直接读写永久性数据存储源的频率，从而提高应用的运行性能。缓存中的数据是数据存储源中数据的拷贝。缓存的物理介质通常是内存。</p>
</li>
<li><p>Hibernate中提供了两个级别的缓存：</p>
<ul>
<li>第一级别的缓存是 Session 级别的缓存，它是属于<strong>事务范围的缓存</strong>。这一级别的缓存由 hibernate 管理的。</li>
<li>第二级别的缓存是 SessionFactory 级别的缓存，它是属于<strong>进程范围的缓存</strong>。</li>
</ul>
</li>
<li><p>SessionFactory 的缓存可以分为两类:</p>
<ul>
<li>内置缓存: <strong>Hibernate 自带的</strong>, 不可卸载. 通常在 <strong>Hibernate 的初始化阶段</strong>, Hibernate 会把映射元数据和预定义的 SQL 语句放到 SessionFactory 的缓存中, <ul>
<li>映射元数据是映射文件中数据（.hbm.xml 文件中的数据）的复制. 该内置缓存是<strong>只读的</strong>。</li>
</ul>
</li>
<li>外置缓存(<strong>二级缓存</strong>): <strong>一个可配置的缓存插件</strong>. 在<strong>默认情况下, SessionFactory 不会启用</strong>这个缓存插件。<ul>
<li>外置缓存中的数据是<strong>数据库数据的复制</strong>, <strong>外置缓存的物理介质可以是内存或硬盘</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>适合放入二级缓存中的数据:</p>
<ul>
<li>很少被修改。</li>
<li>不是很重要的数据, 允许出现偶尔的并发问题。</li>
</ul>
</li>
<li><p>不适合放入二级缓存中的数据:</p>
<ul>
<li>经常被修改。</li>
<li>财务数据, 绝对不允许出现并发问题。</li>
<li>与其他应用程序共享的数据。</li>
</ul>
</li>
<li><p>二级缓存架构</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-13.png"></p>
</li>
<li><p>二级缓存的并发访问策略：</p>
<ul>
<li>两个并发的事务同时访问持久层的缓存的相同数据时, 也有可能出现各类并发问题。</li>
<li>二级缓存可以设定以下 4 种类型的并发访问策略, <strong>每一种访问策略对应一种事务隔离级别</strong>。<ul>
<li>非严格读写(Nonstrict-read-write): 不保证缓存与数据库中数据的一致性. <strong>提供 Read Uncommited 事务隔离级别</strong>, 对于极少被修改, 而且允许脏读的数据, 可以采用这种策略。</li>
<li>读写型(Read-write): <strong>提供 Read Commited 数据隔离级别</strong>.对于经常读但是很少被修改的数据, 可以采用这种隔离类型, 因为它可以防止脏读。</li>
<li>事务型(Transactional): 仅在受管理环境下适用. 它<strong>提供了 Repeatable Read 事务隔离级别</strong>. 对于经常读但是很少被修改的数据, 可以采用这种隔离类型, 因为它可以防止脏读和不可重复读。</li>
<li>只读型(Read-Only):<strong>提供 Serializable 数据隔离级别</strong>, 对于从来不会被修改的数据, 可以采用这种访问策略。</li>
</ul>
</li>
</ul>
</li>
<li><p>管理 Hibernate 的二级缓存：</p>
<ul>
<li>Hibernate 的二级缓存是进程或集群范围内的缓存。</li>
<li>二级缓存是可配置的的插件, Hibernate 允许选用以下类型的缓存插件:<ul>
<li>EHCache: 可作为进程范围内的缓存, 存放数据的物理介质可以使内存或硬盘, 对 Hibernate 的查询缓存提供了支持。</li>
<li>OpenSymphony OSCache:可作为进程范围内的缓存, 存放数据的物理介质可以使内存或硬盘, 提供了丰富的缓存数据过期策略, 对 Hibernate 的查询缓存提供了支持。</li>
<li>SwarmCache: 可作为集群范围内的缓存, 但不支持 Hibernate 的查询缓存。</li>
<li>JBossCache:可作为集群范围内的缓存, 支持 Hibernate 的查询缓存。</li>
</ul>
</li>
<li>4 种缓存插件支持的并发访问策略(x 代表支持, 空白代表不支持)。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210518193655-14.png"></p>
</li>
<li><p>配置进程范围内的二级缓存：</p>
<ul>
<li><p>选择合适的缓存插件: EHCache(jar 包和 配置文件), 并编译器配置文件。</p>
<ul>
<li>jar包：<a target="_blank" rel="noopener" href="https://plumriver.lanzoui.com/iXN2sp8q5xc">https://plumriver.lanzoui.com/iXN2sp8q5xc</a></li>
</ul>
</li>
<li><p>在 Hibernate 的配置文件中启用二级缓存并指定和 EHCache 对应的缓存适配器。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--启用二级缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cache.use_second_level_cache&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置二级缓存插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.cache.region.factory_class&quot;</span>&gt;</span></span><br><span class="line">  org.hibernate.cache.ehcache.EhCacheRegionFactory</span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>选择需要使用二级缓存的持久化类, 设置它的二级缓存的并发访问策略。</p>
<ul>
<li>&lt;class&gt; 元素的 cache 子元素表明 Hibernate 会缓存对象的简单属性, 但不会缓存集合属性, 若希望缓存集合属性中的元素, 必须在&lt;set&gt; 元素中加入 &lt;cache&gt; 子元素。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式一：在具体类的映射文件中配置此类开启缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Customer&quot;</span> <span class="attr">table</span>=<span class="string">&quot;customers&quot;</span> <span class="attr">schema</span>=<span class="string">&quot;hibernate&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">usage</span>=<span class="string">&quot;read-write&quot;</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">table</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">inverse</span>=<span class="string">&quot;false&quot;</span> <span class="attr">cascade</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">order-by</span>=<span class="string">&quot;order_number&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--对集合进行缓存--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">usage</span>=<span class="string">&quot;read-write&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">&quot;Order&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">one-to-many</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 hibernate 配置文件中通过&lt;class-cache/&gt; 节点配置使用缓存。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式二：在hibernate配置文件中指明对哪个类启用二级缓存--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--class-cache：是类级别的缓存，只针对这个类缓存，对于类中的集合属性数据不进行缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class-cache</span> <span class="attr">class</span>=<span class="string">&quot;com.lc.relation.oneTon.Customer&quot;</span> <span class="attr">usage</span>=<span class="string">&quot;read-write&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--collection-cache：集合类型的缓存。会缓存这个集合的ID，但不会缓存集合的数据--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection-cache</span> <span class="attr">collection</span>=<span class="string">&quot;com.lc.relation.oneTon.Customer.orders&quot;</span> <span class="attr">usage</span>=<span class="string">&quot;read-write&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--因此对于集合，我们不仅要缓存集合，也要缓存集合元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class-cache</span> <span class="attr">class</span>=<span class="string">&quot;com.lc.relation.oneTon.Order&quot;</span> <span class="attr">usage</span>=<span class="string">&quot;read-write&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Customer customer = (Customer) session.get(Customer.class, <span class="number">1</span>);</span><br><span class="line">  System.out.println(customer.toString());</span><br><span class="line">  System.out.println(customer.getOrders().size());</span><br><span class="line">  transaction.commit();</span><br><span class="line">  session.close();</span><br><span class="line">  session = sessionFactory.openSession();</span><br><span class="line">  transaction = session.beginTransaction();</span><br><span class="line">  <span class="comment">//由于有二级缓存，因此在同一进程中，此查询的数据已经在二级缓存中存在了。</span></span><br><span class="line">  <span class="comment">//因此这次不会执行查询语句</span></span><br><span class="line">  Customer customer1 = (Customer) session.get(Customer.class, <span class="number">1</span>);</span><br><span class="line">  System.out.println(customer1.toString());</span><br><span class="line">  <span class="comment">//由于对集合和集合的元素都进行了缓存，因此这次也不会查询数据</span></span><br><span class="line">  System.out.println(customer1.getOrders().size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置缓存的文件ehcache.xml：</p>
<ul>
<li>&lt;diskStore&gt;: 指定一个目录：当 EHCache 把数据写到硬盘上时, 将把数据写到这个目录下。</li>
<li>&lt;defaultCache&gt;: 设置缓存的<strong>默认数据过期策略</strong> 。</li>
<li>&lt;cache&gt; 设定具体的<strong>命名缓存的数据过期策略</strong>。每个命名缓存代表一个缓存区域。</li>
<li>缓存区域(region)：一个具有名称的缓存块，可以给每一个缓存块设置不同的缓存策略。如果没有设置任何的缓存区域，则所有被缓存的对象，都将使用默认的缓存策略。即：&lt;defaultCache…/&gt;。</li>
<li>Hibernate在不同的缓存区域保存不同的类/集合。<ul>
<li>对于类而言，区域的名称是类名。如:com.bean.Customer。</li>
<li>对于集合而言，区域的名称是类名加属性名。如com.bean.Customer.orders。</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 你的缓存配置如下 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;com.lc.relation.oneTon.Customer&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;com.lc.relation.oneTon.Customer.orders&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>ehcache.xml文件实例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ehcache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 设置创建cache.data文件的目录的路径。</span></span><br><span class="line"><span class="comment">       如果路径是一个Java系统属性，则在运行的VM中用它的值替换它。</span></span><br><span class="line"><span class="comment">       将转换以下属性：</span></span><br><span class="line"><span class="comment">       user.home - 用户的主目录</span></span><br><span class="line"><span class="comment">       user.dir - 用户当前工作目录</span></span><br><span class="line"><span class="comment">       java.io.tmpdir - 默认临时文件路径 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--自定义缓存文件路径--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;d://chcache&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--默认缓存配置。这些将应用于通过CacheManager以编程方式创建的缓存。</span></span><br><span class="line"><span class="comment">      defaultCache需要以下属性：</span></span><br><span class="line"><span class="comment">      maxInMemory       - 设置将在内存中创建的最大对象数</span></span><br><span class="line"><span class="comment">      eternal           - 设置元素是否永恒。如果是永恒的，则会忽略超时，并且元素永远不会过期。</span></span><br><span class="line"><span class="comment">      timeToIdleSeconds - 设置元素过期前的空闲时间。仅当元素不是永恒的时才使用。空闲时间现在是-上次访问时间</span></span><br><span class="line"><span class="comment">      timeToLiveSeconds - 设置元素过期前的生存时间。仅当元素不是永恒的时才使用。TTL现在是创建时间</span></span><br><span class="line"><span class="comment">      overflowToDisk    - 设置当内存缓存达到maxInMemory限制时，元素是否可以溢出到磁盘。</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">  &lt;defaultCache</span><br><span class="line">      maxElementsInMemory=&quot;10000&quot;</span><br><span class="line">      eternal=&quot;false&quot;</span><br><span class="line">      timeToIdleSeconds=&quot;120&quot;</span><br><span class="line">      timeToLiveSeconds=&quot;120&quot;</span><br><span class="line">      overflowToDisk=&quot;true&quot;</span><br><span class="line">  /&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--自定义缓存。在此处添加缓存配置设置。如果没有自定义缓存的配置，则在启动CacheManager时使用默认缓存配置</span></span><br><span class="line"><span class="comment">      Cache需要以下属性：</span></span><br><span class="line"><span class="comment">      name              - 设置缓存的名称。这用于标识缓存。它必须是独一无二的。</span></span><br><span class="line"><span class="comment">      maxInMemory       - 设置将在内存中创建的最大对象数</span></span><br><span class="line"><span class="comment">      eternal           - 设置元素是否永恒。如果是永恒的，则会忽略超时，并且元素永远不会过期。永恒的表示在缓存中永远存在</span></span><br><span class="line"><span class="comment">      timeToIdleSeconds - 设置元素过期前的空闲时间。仅当元素不是永恒的时才使用。空闲时间指：现在时间-上次访问时间。</span></span><br><span class="line"><span class="comment">                          以秒为单位。超过空闲时间，数据将被清除。此值为0表示对象永远处于空闲时间。</span></span><br><span class="line"><span class="comment">      timeToLiveSeconds - 设置元素过期前的生存时间。仅当元素不是永恒的时才使用。生存时间指：现在时间-创建时间。</span></span><br><span class="line"><span class="comment">                          以秒为单位。超过空闲时间，数据将被清除。此值为0表示对象永远处于生存时间。</span></span><br><span class="line"><span class="comment">      overflowToDisk    - 设置当内存缓存达到maxInMemory限制时，元素是否可以溢出到磁盘。</span></span><br><span class="line"><span class="comment">           设置基于内存的缓存中的对象数目达到上限后,是否把溢出的对象写到基于硬盘的缓存中</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 名为sampleCache1的示例缓存此缓存在内存中最多包含10000个元素，</span></span><br><span class="line"><span class="comment">       如果某个元素空闲超过5分钟并且生存时间超过10分钟，则该元素将过期。</span></span><br><span class="line"><span class="comment">       如果有超过10000个元素，它将溢出到磁盘缓存，</span></span><br><span class="line"><span class="comment">       在这个配置中，磁盘缓存将到达系统上定义java.io.tmp的任何地方。在标准Linux系统上，这将是tmp“</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;sampleCache1&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;300&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;600&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 名为sampleCache2的示例缓存此缓存包含1000个元素。元素将永远保存在内存中。它们没有过期。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;sampleCache2&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">eternal</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 你的缓存配置如下 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--通常name的命名规则如下</span></span><br><span class="line"><span class="comment">  对于类而言，区域的名称是类名。</span></span><br><span class="line"><span class="comment">  对于集合而言，区域的名称是类名加属性名。</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;com.lc.relation.oneTon.Customer&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;com.lc.relation.oneTon.Customer.orders&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>查询缓存：</p>
<ul>
<li><p>对于<strong>经常使用的查询语句</strong>, 如果启用了查询缓存, 当第一次执行查询语句时, Hibernate 会把<strong>查询结果存放在查询缓存中</strong>. 以后再次执行该查询语句时, 只需从缓存中获得查询结果, 从而提高查询性能。</p>
</li>
<li><p>查询缓存使用于如下场合:</p>
<ul>
<li>应用程序运行时经常使用查询语句。</li>
<li>很少对与查询语句检索到的数据进行插入, 删除和更新操作。</li>
</ul>
</li>
<li><p>启用查询缓存的步骤</p>
<ul>
<li>配置二级缓存, 因为查询缓存依赖于二级缓存。</li>
<li>在 hibernate 配置文件中启用查询缓存。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--启用查询缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cache.use_query_cache&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于希望启用查询缓存的查询语句, 调用 Query 的 setCacheable() 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryCacheTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Query query = session.createQuery(<span class="string">&quot;from Order&quot;</span>);</span><br><span class="line">  <span class="comment">//设定此查询使用查询缓存</span></span><br><span class="line">  query.setCacheable(<span class="keyword">true</span>);</span><br><span class="line">  List&lt;Order&gt; orders = query.list();</span><br><span class="line">  System.out.println(orders.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>时间戳缓存区域：</p>
<ul>
<li>时间戳缓存区域存放了对于查询结果相关的表进行插入, 更新或删除操作的时间戳。</li>
<li>Hibernate 通过时间戳缓存区域来判断被缓存的查询结果是否过期, 其运行过程如下:</li>
<li>T1 时刻执行查询操作, 把查询结果存放在 QueryCache 区域, 记录该区域的时间戳为 T1。</li>
<li>T2 时刻对查询结果相关的表进行更新操作, Hibernate 把 T2 时刻存放在UpdateTimestampCache 区域。</li>
<li>T3 时刻执行查询结果前, 先比较 QueryCache 区域的时间戳和 UpdateTimestampCache 区域的时间戳, <ul>
<li>若 T2 &gt;T1, 那么就丢弃原先存放在 QueryCache 区域的查询结果, <strong>重新到数据库中查询数据</strong>, 再把结果存放到 QueryCache 区域。</li>
<li>若 T2 &lt; T1, <strong>直接从 QueryCache 中获得查询结果</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeCacheTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Query query = session.createQuery(<span class="string">&quot;from Order&quot;</span>);</span><br><span class="line">  <span class="comment">//设定此查询使用查询缓存</span></span><br><span class="line">  query.setCacheable(<span class="keyword">true</span>);</span><br><span class="line">  List&lt;Order&gt; orders = query.list();</span><br><span class="line">  System.out.println(orders.size());</span><br><span class="line"></span><br><span class="line">  Order order = (Order) session.get(Order.class, <span class="number">1</span>);</span><br><span class="line">  order.setOrderNumber(<span class="string">&quot;vbm&quot;</span>);</span><br><span class="line">  <span class="comment">//由于时间戳缓存的存在，导致查询缓存区域和时间戳缓存区域数据不一致。此时会再执行一次查询</span></span><br><span class="line">  orders = query.list();</span><br><span class="line">  System.out.println(orders.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Query 接口的 iterate() 方法：</p>
<ul>
<li>Query 接口的 iterator() 方法。<ul>
<li>同 list() 一样也能执行查询操作。</li>
<li>list() 方法执行的 SQL 语句包含实体类对应的数据表的所有字段。</li>
<li>Iterator() 方法执行的SQL 语句中仅包含实体类对应的数据表的 ID 字段。</li>
<li>当遍历访问结果集时, 该方法先到 Session 缓存及二级缓存中查看是否存在特定 OID 的对象。<ul>
<li> 如果存在, 就直接返回该对象。</li>
<li>如果不存在该对象就通过相应的 SQL Select 语句到数据库中加载特定的实体对象。</li>
</ul>
</li>
</ul>
</li>
<li>大多数情况下, 应考虑使用 list() 方法执行查询操作。</li>
<li>iterator() 方法仅在满足以下条件的场合, 可以<strong>稍微提高</strong>查询性能:<ul>
<li>要查询的数据表中包含大量字段。</li>
<li>启用了二级缓存, 且二级缓存中可能已经包含了待查询的对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Session管理和批量操作"><a href="#Session管理和批量操作" class="headerlink" title="Session管理和批量操作"></a>Session管理和批量操作</h1><ul>
<li><p>管理 Session</p>
<ul>
<li>Hibernate  自身提供了三种管理 Session 对象的方法<ul>
<li>Session 对象的生命周期与本地线程绑定.</li>
<li>Session 对象的生命周期与 JTA 事务绑定。</li>
<li>Hibernate 委托程序管理 Session 对象的生命周期。</li>
</ul>
</li>
<li>在 Hibernate 的配置文件中, hibernate.current_session_context_class 属性用于指定 Session 管理方式。可选值包括<ul>
<li>thread: Session 对象的生命周期与本地线程绑定。</li>
<li>jta*: Session 对象的生命周期与 JTA 事务绑定。</li>
<li>managed: Hibernate 委托程序来管理 Session 对象的生命周期。</li>
</ul>
</li>
</ul>
</li>
<li><p>Session 对象的生命周期与本地线程绑定：</p>
<ul>
<li>如果把 Hibernate 配置文件的 hibernate.current_session_context_class 属性值设为 thread, Hibernate 就会按照与本地线程绑定的方式来管理 Session。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置管理Session--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.current_session_context_class&quot;</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Hibernate 按一下规则把 Session 与本地线程绑定：</p>
<ul>
<li>当一个线程(threadA)第一次调用 SessionFactory 对象的 <strong>getCurrentSession()</strong> 方法时, 该方法会创建一个新的 Session(sessionA) 对象, 把该对象与 threadA 绑定, 并将 sessionA 返回 。</li>
<li>当 threadA 再次调用 SessionFactory 对象的 getCurrentSession() 方法时, 该方法将返回 sessionA 对象。</li>
<li>当 threadA <strong>提交 sessionA 对象关联的事务时</strong>, Hibernate 会自动flush sessionA 对象的缓存, 然后提交事务, <strong>关闭 sessionA 对象</strong>. 当 threadA 撤销 sessionA 对象关联的事务时, 也会自动关闭 sessionA 对象。</li>
<li>若 threadA 再次调用 SessionFactory 对象的 getCurrentSession() 方法时, 该方法会又创建一个新的 Session(sessionB) 对象, 把该对象与 threadA 绑定, 并将 sessionB 返回 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testManageSession</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取 Session</span></span><br><span class="line">  <span class="comment">//开启事务</span></span><br><span class="line">  Session session = HibernateUtils.getInstance().getSession();</span><br><span class="line">  System.out.println(<span class="string">&quot;--&gt;&quot;</span> + session.hashCode());</span><br><span class="line">  Transaction transaction = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">  DepartmentDao departmentDao = <span class="keyword">new</span> DepartmentDao();</span><br><span class="line"></span><br><span class="line">  Department dept = <span class="keyword">new</span> Department();</span><br><span class="line">  dept.setName(<span class="string">&quot;ATGUIGU&quot;</span>);</span><br><span class="line"></span><br><span class="line">  departmentDao.save(dept);</span><br><span class="line">  departmentDao.save(dept);</span><br><span class="line">  departmentDao.save(dept);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//若 Session 是由 thread 来管理的, 则在提交或回滚事务时, 已经关闭 Session 了. </span></span><br><span class="line">  transaction.commit();</span><br><span class="line">  System.out.println(session.isOpen()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>批量处理数据：</p>
<ul>
<li>批量处理数据是指在一个事务中处理大量数据.</li>
<li>在应用层进行批量操作, 主要有以下方式:<ul>
<li>通过 Session 。</li>
<li>通过 HQL 。</li>
<li>通过 StatelessSession 。</li>
<li>通过 JDBC API。</li>
</ul>
</li>
</ul>
</li>
<li><p>通过JDBC API进行批量操作：</p>
<ul>
<li>效率是最高的。推荐使用这种方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatch</span><span class="params">()</span></span>&#123;</span><br><span class="line">  session.doWork(<span class="keyword">new</span> Work() &#123;			</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">//通过 JDBC 原生的 API 进行操作, 效率最高, 速度最快!</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过 Session 来进行批量操作：</p>
<ul>
<li><p>Session 的 save() 及 update() 方法都会把处理的对象存放在自己的缓存中. 如果通过一个 Session 对象来处理大量持久化对象, 应该<strong>及时从缓存中清空已经处理完毕并且不会再访问的对象</strong>。</p>
</li>
<li><p>具体的做法是在<strong>处理完一个对象或小批量对象后, 立即调用 flush() 方法刷新缓存, 然后在调用 clear() 方法清空缓存</strong>。</p>
</li>
<li><p>通过 Session 来进行处理操作会受到以下约束。</p>
<ul>
<li>需要在  Hibernate 配置文件中设置 JDBC 单次批量处理的数目, 应保证每次向数据库发送的批量的 SQL 语句数目与 batch_size 属性一致。</li>
<li>若对象采用 “identity” 标识符生成器, 则 Hibernate 无法在 JDBC 层进行批量插入操作。</li>
<li>进行批量操作时, 建议关闭 Hibernate 的二级缓存。</li>
</ul>
</li>
<li><p>批量插入数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">News news = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  news = <span class="keyword">new</span> News();</span><br><span class="line">  news.setTitle(<span class="string">&quot;--&quot;</span> + i);</span><br><span class="line">  session.save(news);</span><br><span class="line">  <span class="comment">//定时清理session缓存</span></span><br><span class="line">  <span class="keyword">if</span> ((i+<span class="number">1</span>)%<span class="number">20</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    session.flush();</span><br><span class="line">    session.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>批量更新数据：</p>
<ul>
<li>批量更新: 在进行批量更新时, 如果一下子把所有对象都加载到 Session 缓存, 然后再缓存中一一更新, 显然是不可取的。</li>
<li>使用可滚动的结果集 org.hibernate.ScrollableResults, <strong>该对象中实际上并不包含任何对象, 只包含用于在线定位记录的游标</strong>. 只有当程序遍历访问 ScrollableResults 对象的特定元素时, 它才会到数据库中加载相应的对象。</li>
<li>org.hibernate.ScrollableResults 对象由 Query 的 scroll 方法返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ScrollableResults sr = session.createQuery(<span class="string">&quot;from news&quot;</span>).scroll();</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (sr.next())&#123;</span><br><span class="line">  News news1 = (News) sr.get(<span class="number">0</span>);</span><br><span class="line">  news1.setTitle(<span class="string">&quot;==&quot;</span>+count);</span><br><span class="line">  <span class="comment">//定时清理缓存</span></span><br><span class="line">  <span class="keyword">if</span> ((count+<span class="number">1</span>)%<span class="number">20</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    session.flush();</span><br><span class="line">    session.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>通过HQL进行批量操作：</p>
<ul>
<li>注意: HQL 只支持 INSERT INTO … SELECT 形式的插入语句, 但不支持 INSERT INTO … VALUES 形式的插入语句. 所以使用 HQL 不能进行批量插入操作。</li>
</ul>
</li>
<li><p>通过StatelessSession来进行批量操作:</p>
<ul>
<li>从形式上看，StatelessSession与session的用法类似。</li>
<li>StatelessSession与session相比，有以下区别:<ul>
<li>StatelessSession没有缓存，通过StatelessSession来加载、保存或更新后的对象处于游离状态。</li>
<li>StatelessSession不会与Hibernate的第二级缓存交互。</li>
<li>当调用StatelessSession的save()、update()或delete()方法时，这些方法会立即执行相应的SQL语句，而不会仅计划执行一条SQL语句</li>
<li>StatelessSession不会进行脏检查，因此修改了Customer对象属性后，还需要调用</li>
<li>StatelessSession的update()方法来更新数据库中数据。</li>
<li>StatelessSession不会对关联的对象进行任何级联操作。</li>
<li>通过同一个StatelessSession对象两次加载OID为1的Customer对象，得到的两个对象内存地址不同。</li>
<li>StatelessSession所做的操作可以被Interceptor拦截器捕获到，但是会被Hibernate的事件处理系统忽略掉。</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/14/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A1%8C%E4%B8%BA%E5%9E%8B/" rel="prev" title="设计模式之行为型">
      <i class="fa fa-chevron-left"></i> 设计模式之行为型
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/20/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/JavaEE%E6%A1%86%E6%9E%B6/JPA/" rel="next" title="JPA的学习">
      JPA的学习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Hibernate%E5%85%A5%E9%97%A8"><span class="nav-number">1.</span> <span class="nav-text">Hibernate入门</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Session%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">Session概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">3.</span> <span class="nav-text">持久化对象的四种状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="nav-number">4.</span> <span class="nav-text">配置文件详解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="nav-number">5.</span> <span class="nav-text">映射文件详解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E7%94%9F%E6%88%90%E5%99%A8%E8%AF%A6%E8%A7%A3"><span class="nav-number">6.</span> <span class="nav-text">标识符生成器详解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="nav-number">7.</span> <span class="nav-text">类型之间的映射关系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%98%A0%E5%B0%84"><span class="nav-number">7.1.</span> <span class="nav-text">日期类型的映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84"><span class="nav-number">7.2.</span> <span class="nav-text">大对象类型映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E6%88%90%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84"><span class="nav-number">7.3.</span> <span class="nav-text">组成关系映射</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB"><span class="nav-number">8.</span> <span class="nav-text">一对多关系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%90%91n%E5%AF%B91"><span class="nav-number">8.1.</span> <span class="nav-text">单向n对1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E5%90%911%E5%AF%B9n"><span class="nav-number">8.2.</span> <span class="nav-text">双向1对n</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB"><span class="nav-number">9.</span> <span class="nav-text">一对一关系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB"><span class="nav-number">10.</span> <span class="nav-text">多对多关系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%90%91n%E5%AF%B9n"><span class="nav-number">10.1.</span> <span class="nav-text">单向n对n</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E5%90%91n%E5%AF%B9n"><span class="nav-number">10.2.</span> <span class="nav-text">双向n对n</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84"><span class="nav-number">11.</span> <span class="nav-text">对象继承关系映射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#subclass-%E8%BF%9B%E8%A1%8C%E6%98%A0%E5%B0%84"><span class="nav-number">11.1.</span> <span class="nav-text">subclass 进行映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#joined-subclass-%E8%BF%9B%E8%A1%8C%E6%98%A0%E5%B0%84"><span class="nav-number">11.2.</span> <span class="nav-text">joined-subclass 进行映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#union-subclass-%E8%BF%9B%E8%A1%8C%E6%98%A0%E5%B0%84"><span class="nav-number">11.3.</span> <span class="nav-text">union-subclass 进行映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">11.4.</span> <span class="nav-text">三种继承映射方式的比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E7%AD%96%E7%95%A5"><span class="nav-number">12.</span> <span class="nav-text">检索策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E6%A3%80%E7%B4%A2%E7%AD%96%E7%95%A5"><span class="nav-number">12.1.</span> <span class="nav-text">类级别的检索策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%92%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E7%9A%84%E6%A3%80%E7%B4%A2%E7%AD%96%E7%95%A5"><span class="nav-number">12.2.</span> <span class="nav-text">一对多和多对多的检索策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%92%8C%E4%B8%80%E5%AF%B9%E4%B8%80%E7%9A%84%E6%A3%80%E7%B4%A2%E7%AD%96%E7%95%A5"><span class="nav-number">12.3.</span> <span class="nav-text">多对一和一对一的检索策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93"><span class="nav-number">12.4.</span> <span class="nav-text">检索策略总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E6%96%B9%E5%BC%8F"><span class="nav-number">13.</span> <span class="nav-text">检索方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HQL%E6%A3%80%E7%B4%A2%E6%96%B9%E5%BC%8F"><span class="nav-number">13.1.</span> <span class="nav-text">HQL检索方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HQL%E6%A3%80%E7%B4%A2%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F"><span class="nav-number">13.2.</span> <span class="nav-text">HQL检索的其他方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QBC%E6%A3%80%E7%B4%A2"><span class="nav-number">13.3.</span> <span class="nav-text">QBC检索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%A3%80%E7%B4%A2"><span class="nav-number">13.4.</span> <span class="nav-text">本地检索</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-number">14.</span> <span class="nav-text">二级缓存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Session%E7%AE%A1%E7%90%86%E5%92%8C%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">15.</span> <span class="nav-text">Session管理和批量操作</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Plum Reiver</p>
  <div class="site-description" itemprop="description">技术，日常，笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
	
  </nav>
</div>


      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plum Reiver</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
