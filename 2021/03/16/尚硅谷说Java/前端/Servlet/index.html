<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"plumv.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="Servlet学习">
<meta property="og:type" content="article">
<meta property="og:title" content="Servlet学习">
<meta property="og:url" content="https://plumv.github.io/2021/03/16/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/%E5%89%8D%E7%AB%AF/Servlet/index.html">
<meta property="og:site_name" content="李川的个人博客">
<meta property="og:description" content="Servlet学习">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210205121836.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210208112902.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210208113132.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210208143730.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210211104213.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210211143310.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210211144852.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210212193316.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210212193322.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222194719.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222194719-1.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210212204440.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210213112649.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222165817.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222194646.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222194943.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222195205.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210223084707.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210223122735.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210227185948.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210223142833.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210224093841.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210224094554.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210224124311.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210224124224.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210224124507.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210224131110.png">
<meta property="article:published_time" content="2021-03-15T16:00:00.000Z">
<meta property="article:modified_time" content="2021-04-22T12:51:13.573Z">
<meta property="article:author" content="Plum Reiver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210205121836.png">

<link rel="canonical" href="https://plumv.github.io/2021/03/16/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/%E5%89%8D%E7%AB%AF/Servlet/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Servlet学习 | 李川的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李川的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>日志</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://plumv.github.io/2021/03/16/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/%E5%89%8D%E7%AB%AF/Servlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plum Reiver">
      <meta itemprop="description" content="技术，日常，笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李川的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Servlet学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-16 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-16T00:00:00+08:00">2021-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-22 20:51:13" itemprop="dateModified" datetime="2021-04-22T20:51:13+08:00">2021-04-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Servlet学习</p>
<span id="more"></span>

<h1 id="第一章-Servlet基础"><a href="#第一章-Servlet基础" class="headerlink" title="第一章 Servlet基础"></a>第一章 Servlet基础</h1><ul>
<li><p>宏观地讲，Servlet 是连接Web服务器与服务端Java程序的协议，是一种通信规范。这个规范是以一套接口的形式体现的。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210205121836.png"></p>
</li>
<li><p>通常来说，Servlet 是宏观上Servlet规范中的一个具体的接口，Servlet 规范中包含一套接口。而Servlet接口仅仅是其中之一。 </p>
</li>
<li><p>微观地讲, Servlet是Servlet接口实现类的一个实例对象，是运行在服务器上的一段Java小程序，即Server Applet, 也就是Servlet这个单词的来历。Servlet 的主要功能是根据客户端提交的请求，调用服务器端相关代码，完成对请求的处理与运算。</p>
</li>
</ul>
<h2 id="1-1-Servlet生命周期"><a href="#1-1-Servlet生命周期" class="headerlink" title="1.1 Servlet生命周期"></a>1.1 Servlet生命周期</h2><ul>
<li><p>所谓Servlet 生命周期是指，Servlet 对象的创建、Servlet 对象的初始化、Servlet 对象服务的执行，及最终Servlet对象被销毁的整个过程。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210208112902.png"></p>
</li>
<li><p>Servlet的整个生命周期过程的执行,均由Web服务器负责管理。即Servlet从创建到服务到销毀的整个过程中方法的调用，都是由Web服务器负责调用执行，程序员无法控制其执行流程。</p>
</li>
<li><p>但程序员可以获取到Servlet 的这些生命周期时间点，并可以指定让Servlet做一些具体业务相关的事情。</p>
</li>
</ul>
<h3 id="1-1-1-生命周期方法执行流程"><a href="#1-1-1-生命周期方法执行流程" class="headerlink" title="1.1.1 生命周期方法执行流程"></a>1.1.1 生命周期方法执行流程</h3><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210208113132.png"></p>
<ul>
<li>对于以上代码的运行，注意以下几个时间点: <ul>
<li>(1)项目部署后启动服务器，发现并没有执行Servlet 的无参构造器方法，说明在Web容器启动时并没有创建Servlet对象。</li>
<li>(2)用户提交请求后，马上可以看到无参构造器、init()方法、service()方法均执行。 </li>
<li>(3)刷新页面,发现只会执行service()方法，每刷新一次，即每提交一次请求，就会执行一次service()方法。</li>
<li>(4)让另外一个浏览器也发出同样的请求,会发现只执行service()方法,而无参构造器、init()方法均未执行。</li>
<li>(5)正常关闭Tomcat (使用stop server关闭,不能使用Terminate 关闭)，发现destroy()方法也会执行</li>
</ul>
</li>
</ul>
<h3 id="1-1-2-Servlet特征"><a href="#1-1-2-Servlet特征" class="headerlink" title="1.1.2 Servlet特征"></a>1.1.2 Servlet特征</h3><ul>
<li>(1) Servlet 是单例多线程的。</li>
<li>(2)一个Servlet实例只会执行一次无参构造器与init()方法，并且是在第一次访问时执行。</li>
<li>(3)用户每提交一次对当前Servlet的请求，就会执行一次 service()方法。</li>
<li>(4)一个Servlet实例只会执行一次 destroy()方法，在应用停止时执行。</li>
<li>(5)由于Servlet是单例多线程的，所以为了保证其线程安全性，一般情况下是不为Servlet类定义可修改的成员变量的。因为每个线程均可修改这个成员变量,会出现线程安全问题。</li>
<li>(6)默认情况下，Servlet 在Web容器启动时是不会被实例化的。</li>
</ul>
<h3 id="1-1-3-Web容器启动时创建Servlet实例"><a href="#1-1-3-Web容器启动时创建Servlet实例" class="headerlink" title="1.1.3 Web容器启动时创建Servlet实例"></a>1.1.3 Web容器启动时创建Servlet实例</h3><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210208143730.png"></p>
<h3 id="1-1-4-Web容器中的两个Map"><a href="#1-1-4-Web容器中的两个Map" class="headerlink" title="1.1.4 Web容器中的两个Map"></a>1.1.4 Web容器中的两个Map</h3><ul>
<li><p>一个Map</p>
<table>
<thead>
<tr>
<th align="center">key</th>
<th align="center">value</th>
</tr>
</thead>
<tbody><tr>
<td align="center">url-patten</td>
<td align="center">Servlet实例的引用</td>
</tr>
</tbody></table>
</li>
<li><p>另一个Map</p>
<table>
<thead>
<tr>
<th align="center">key</th>
<th align="center">value</th>
</tr>
</thead>
<tbody><tr>
<td align="center">url-patten</td>
<td align="center">Servlet的类路径</td>
</tr>
</tbody></table>
</li>
<li><p>当Servlet实例被创建好后被放在了哪里? web.xml中URI与Servlet的映射关系反映到内存中是以什么形式存在呢?</p>
<ul>
<li>当Servlet实例被创建好后,会将该Serlet实例的引用存放到一个Map集合中。该Map ,集合的key为URI,而value购Servlet实例的引用，即Map&lt;String, Servlet&gt;.当Web容器从用户请求中分离出URI后,会首先到这个Map中查找是否存在其所对应的value。若存在，则直接调用其servicel(方法。若不存在，则需要创建该Servlet 实例。</li>
</ul>
</li>
<li><p>若请求的Servlet 实例不存在, Web容器又是根据什么创建这个Servlet 实例的呢?</p>
<ul>
<li>在Web容器的内存中,还存在一个Map集合。该Map集合的key为URI,而value购web.xml中配置的与之对应的Servlet的全限定性类名，即Map&lt;String, String&gt;.。</li>
</ul>
</li>
<li><p>总结：当Web容器从用户请求中分离出URI后,到第一个Map中又没有找到其所对应的Servlet实例，则会马上查找这第二个Map, 从中找到其所对应的类名,再根据反射机制，创建这个Servlet实例。然后再将这个创建好的Servlet的引用放入到第一个Map中。然后执行Servlet实例的service()方法。</p>
</li>
</ul>
<h3 id="1-1-5-关于getServletInfo-方法"><a href="#1-1-5-关于getServletInfo-方法" class="headerlink" title="1.1.5 关于getServletInfo()方法"></a>1.1.5 关于getServletInfo()方法</h3><ul>
<li>Servlet接口中的getServletInfo()方法，是由程序员自己定义的有相关当前Servlet的一些基本信息，不属于Servlet生命周期中的方法。对程序的运行没有任何影响与作用。仅仅是返回一些让他人阅读的信息。</li>
<li>比如Servlet的作者，版本等。</li>
</ul>
<h2 id="1-2-ServletConfig"><a href="#1-2-ServletConfig" class="headerlink" title="1.2 ServletConfig"></a>1.2 ServletConfig</h2><h3 id="1-2-1-什么是ServletConfig"><a href="#1-2-1-什么是ServletConfig" class="headerlink" title="1.2.1 什么是ServletConfig"></a>1.2.1 什么是ServletConfig</h3><ul>
<li>ServletConfig是一个配置接口，其实现类保存着web.xml文件中的配置信息。</li>
</ul>
<h3 id="1-2-2-获取ServletConfig对象"><a href="#1-2-2-获取ServletConfig对象" class="headerlink" title="1.2.2 获取ServletConfig对象"></a>1.2.2 获取ServletConfig对象</h3><ul>
<li>由于ServletConfig中可以获取到Servlet 的初始化参数,获取到ServletContext对象, 而这些参数与对象在进行业务逻辑处理时，即执行service()方法时需要经常访问，很重要,所以ServletConfig对象也就显得很重要了。</li>
<li>由于ServetConfig对象是Web容器通过init()方法传递给当前Servlet类的,而init()方法只会在Servlet对象初始化时调用一次。所以,需要在init()方法中将ServletConfig对象传递给Servlet的servletConfig成员变量,这样service()方法即可使用ServletConfig对象了。也就是说，我们需要在Servlet中声明一个ServletConfig 成员变量。</li>
<li>若在Servlet中声明一个ServetConfig 成员变量,是否会存在线程安全问题呢?因为Servlet是单例多线程的。只要在Servlet中不为ServletConfig 对象提供其它修改方法，其值只能由Web容器通过init()方法进行赋值,那么ServletConfig 对象就不存在线程安全问题。因为对于所有线程来说，ServletConfig 对象是只读的，不能修改。</li>
</ul>
<h3 id="1-2-3-ServletConfig中的方法"><a href="#1-2-3-ServletConfig中的方法" class="headerlink" title="1.2.3 ServletConfig中的方法"></a>1.2.3 ServletConfig中的方法</h3><ul>
<li><p>一个Servlet实例只有一个ServletConfig。</p>
</li>
<li><p>查看帮助文档可以知道ServletConfig接口中有四个方法：</p>
<ul>
<li> getServletName() ：获取Servlet名字，即在web.xml中配置的</li>
<li> getServletContext()  ：获取servlet上下文</li>
<li> getInitParameter(String name) ：获取Servlet的初始化参数的value,通过name获取，</li>
<li> getInitParameterNames() ：获取Servlet的初始化参数的所有name，</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取servlet的名称，即web.xml文件中servlet-name标签中的内容</span></span><br><span class="line">String servletName = servletConfig.getServletName();</span><br><span class="line">System.out.println(<span class="string">&quot;servletName = &quot;</span> + servletName);</span><br><span class="line"><span class="comment">//获取Servlet上下文</span></span><br><span class="line">ServletContext servletContext = servletConfig.getServletContext();</span><br><span class="line">System.out.println(<span class="string">&quot;servletContext = &quot;</span> + servletContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Servlet的初始化参数的所有name，即init-param节点里的param-name节点的内容</span></span><br><span class="line"><span class="comment">//顺序为从下往上输出</span></span><br><span class="line">Enumeration&lt;String&gt; names = servletConfig.getInitParameterNames();</span><br><span class="line"><span class="keyword">while</span> (names.hasMoreElements())&#123;</span><br><span class="line">  String name = names.nextElement();</span><br><span class="line">  <span class="comment">//获取Servlet的初始化参数的value,通过name获取，</span></span><br><span class="line">  String value = servletConfig.getInitParameter(name);</span><br><span class="line">  System.out.println(name + <span class="string">&quot; &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-3-ServletContext"><a href="#1-3-ServletContext" class="headerlink" title="1.3 ServletContext"></a>1.3 ServletContext</h2><ul>
<li>ServletContext官方叫servlet上下文。服务器会为每一个工程创建一个对象，这个对象就是ServletContext对象。</li>
<li>这个对象全局唯一，而且工程内部的所有servlet都共享这个对象。所以叫全局应用程序共享对象</li>
<li>作用：<ul>
<li>是一个域对象</li>
<li>可以读取全局配置参数。</li>
<li> 可以搜索当前工程目录下面的资源文件。</li>
<li>可以获取当前工程名字。</li>
</ul>
</li>
<li>方法：<ul>
<li>getInitParameterNames() ：获取应用所有初始化参数名。</li>
<li>getInitParameter() ：获取应用的初始化参数的value,通过name获取。</li>
<li>setAttribute(key,value) ：设置域属型，当已存在此key域属性时，会覆盖原来的域属性。</li>
<li>getAttribute(key) ：获取域属性。</li>
<li>removeAttribute(key) ：删除域属性。</li>
<li>getContextPath() ：获取项目应用名称。</li>
<li>getRealPath(string) ：获取以string为基础的绝对路径</li>
</ul>
</li>
<li>在web.xml中配置全局域属型</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- context-param：表示定义整个应用都能使用的初始化参数  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>cj<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>address<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>河南<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>servletContext的使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Servlet上下文</span></span><br><span class="line">ServletContext servletContext = servletConfig.getServletContext();</span><br><span class="line">System.out.println(<span class="string">&quot;servletContext = &quot;</span> + servletContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取应用所有初始化参数名</span></span><br><span class="line">Enumeration&lt;String&gt; initParameterNames = servletContext.getInitParameterNames();</span><br><span class="line"><span class="keyword">while</span> (initParameterNames.hasMoreElements())&#123;</span><br><span class="line">  String name = initParameterNames.nextElement();</span><br><span class="line">  String value = servletContext.getInitParameter(name);</span><br><span class="line">  System.out.println(name + <span class="string">&quot; &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置域属性。域属性是全局性的，在每个Servlet中都能访问</span></span><br><span class="line"><span class="comment">//当再次设置相同key的域属性时是重置，而不是添加</span></span><br><span class="line">servletContext.setAttribute(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;xxx@qq.com&quot;</span>);</span><br><span class="line">servletContext.setAttribute(<span class="string">&quot;mobile&quot;</span>, <span class="string">&quot;110&quot;</span>);</span><br><span class="line"><span class="comment">//获取域属性</span></span><br><span class="line">Object email = servletContext.getAttribute(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">System.out.println(email);</span><br><span class="line"><span class="comment">//删除域属性</span></span><br><span class="line">servletContext.removeAttribute(<span class="string">&quot;email&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取应用名称</span></span><br><span class="line">String contextPath = servletContext.getContextPath();</span><br><span class="line">System.out.println(<span class="string">&quot;contextPath = &quot;</span> + contextPath);</span><br><span class="line"><span class="comment">//获取基于/的绝对路径</span></span><br><span class="line">String realPath = servletContext.getRealPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;realPath = &quot;</span> + realPath);</span><br></pre></td></tr></table></figure>

<h2 id="1-4-欢迎页面设置"><a href="#1-4-欢迎页面设置" class="headerlink" title="1.4 欢迎页面设置"></a>1.4 欢迎页面设置</h2><ul>
<li><p>自定义欢迎页面</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--此处可以放多个欢迎页面，查找顺序为从上到下。默认欢迎页面都是名为index的的页面文件  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>默认的欢迎页面</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-5-url-pattern的使用"><a href="#1-5-url-pattern的使用" class="headerlink" title="1.5 url-pattern的使用"></a>1.5 url-pattern的使用</h2><ul>
<li>url路径可以写多级路径，这种方式被称为<strong>精确路径匹配</strong>。<ul>
<li>类似于/xxx/000/jjj/main。访问时url也必须是/xxx/000/jjj/main。</li>
</ul>
</li>
<li>一个servlet-mapping中可以有多个url-pattern。</li>
<li><strong>通配符路径模式</strong>：例如/aaa/*。表示匹配以/aaa/开头的所有url。</li>
<li><strong>全路径模式</strong>：<ul>
<li>例如/*。表示匹配所有的url。包括对静态资源和动态资源的请求也会拦截。</li>
<li>例如/ 。表示匹配所有的url。拦截对静态资源的请求，但不拦截动态资源的请求。</li>
</ul>
</li>
<li><strong>后缀模式</strong>：例如*.do。表示拦截所有以.do结尾的url请求。<ul>
<li>后缀模式不能和路径模式一块使用。</li>
</ul>
</li>
<li>路径匹配的优先原则：精确路径 &gt; 通配符路径 &gt; 全路径 &gt; 后缀模式。<ul>
<li>相同模式中长路径优先于短路径。</li>
</ul>
</li>
</ul>
<h1 id="第二章-Servlet核心"><a href="#第二章-Servlet核心" class="headerlink" title="第二章 Servlet核心"></a>第二章 Servlet核心</h1><h2 id="2-1-GenericServlet的定义和使用"><a href="#2-1-GenericServlet的定义和使用" class="headerlink" title="2.1 GenericServlet的定义和使用"></a>2.1 GenericServlet的定义和使用</h2><ul>
<li><p>定义一个抽象类GenericServlet。这个类的作用：实现Servlet接口的四个抽象方法，这四个方法是空实现，留一个service方法不实现。</p>
<ul>
<li>因为service方法经常被使用。</li>
<li>这种设计模式被称为缺省适配器设计模式。</li>
</ul>
</li>
<li><p>在抽象类GenericServlet，重写了父类的init()方法，但也定义了一个无参的init()方法给子类重写。</p>
<ul>
<li>模板方法设计模式：父类重写了init有参方法，定义一个无参的init方法留给子类去重写。在编译时this.init()调用的是父类的init方法，运行时调用的是子类重写的init()方法。</li>
</ul>
</li>
<li><p>抽象类GenericServlet相当于servlet接口和ServletConfig接口的子接口，供程序员只使用这两个接口的核心功能。</p>
</li>
<li><p>核心代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span>,<span class="title">ServletConfig</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ServletConfig servletConfig;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.servletConfig = servletConfig;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 该无参方法，是为了让子类重写此方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> servletConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 抽象方法必须使用抽象类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> servletRequest</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> servletResponse</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> servletConfig.getServletName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> servletConfig.getServletContext();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInitParameter</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> servletConfig.getInitParameter(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getInitParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> servletConfig.getInitParameterNames();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>子类调用代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行Servlet的service()方法&quot;</span>);</span><br><span class="line">    Enumeration&lt;String&gt; names = <span class="keyword">this</span>.getInitParameterNames();</span><br><span class="line">    <span class="keyword">while</span> (names.hasMoreElements()) &#123;</span><br><span class="line">      String name = names.nextElement();</span><br><span class="line">      String value = <span class="keyword">this</span>.getInitParameter(name);</span><br><span class="line">      System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 重写父类的无参init方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.init();</span><br><span class="line">    System.out.println(<span class="string">&quot;另外的代码&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>其实javax包中已经定义好了GenericServlet类，因此我们在使用servlet时，直接继承GenericServlet即可，不必继承Servlet。</p>
</li>
</ul>
<h2 id="2-2-HttpServlet的定义和使用"><a href="#2-2-HttpServlet的定义和使用" class="headerlink" title="2.2 HttpServlet的定义和使用"></a>2.2 HttpServlet的定义和使用</h2><ul>
<li><p>HttpServlet类主要用去处理请求的方式，比如get请求就调用doGet方法，post请求就调用doPost方法，同时隐藏了service方法。</p>
</li>
<li><p>HttpServlet类继承于GenericServlet类。</p>
</li>
<li><p>自定义的HttpServlet类核心代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HTTPServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多态的体现：分为向下转型和向上转型</span></span><br><span class="line">    <span class="comment">// 下转型：将父类引用赋值给子类引用。但Java中是不支持真正的下转型的。但若父类对象本身</span></span><br><span class="line">    <span class="comment">//        是由子类对象上转型而来的，那么可以通过强转的方式，将其赋值给子类对象。</span></span><br><span class="line">    <span class="comment">//  上转型：将子类引用赋值给父类引用。</span></span><br><span class="line">    HttpServletRequest request = (HttpServletRequest)servletRequest;</span><br><span class="line">    HttpServletResponse response = (HttpServletResponse) servletResponse;</span><br><span class="line">    String method = request.getMethod();</span><br><span class="line">    System.out.println(method);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(method))&#123;</span><br><span class="line">      doPost(request,response);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;GET&quot;</span>.equals(method))&#123;</span><br><span class="line">      doGet(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行doGET&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行doPOST&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>其实javax包中已经定义好了HttpServlet类，因此我们在使用servlet时，直接继承HttpServlet即可，不必继承Servlet和GenericServlet。</p>
</li>
</ul>
<h2 id="2-3-HttpServletRequest"><a href="#2-3-HttpServletRequest" class="headerlink" title="2.3 HttpServletRequest"></a>2.3 HttpServletRequest</h2><h3 id="2-3-1-请求的生命周期"><a href="#2-3-1-请求的生命周期" class="headerlink" title="2.3.1 请求的生命周期"></a>2.3.1 请求的生命周期</h3><ul>
<li><p>javax.servet.http.HttpServletRequest是SUN制定的Servlet规范,是一个接口,表示请求，其父接口是javax.servlet.ServletRequest。“HTTP请求协议”的完整内容都被封装到request对象中。</p>
</li>
<li><p>HttpServletRequest实例对象是什么时候创建和销毁的呢?</p>
</li>
<li><p>当客户端浏览器将请求(字符序列)发送到服务器后，服务器会根据HTTp请求协议的格式对请求进行解析。同时，服务器会创建HttpServletRequest的实现类RequestFacade的对象，即请求对象。然后再调用相应的set 方法，将解析出的数据封装到请求对象中。此时HttpServletRequest实例就创建并初始化完毕了。也就是说，请求对象是由服务器创建。</p>
</li>
<li><p>当服务器向客户端发送响应结束后，HttpServletRequest 实例对象被服务器销毁。</p>
</li>
<li><p>一次睛求对应一个请求对象,另外一次请求对应另外一个请求对象，与之前的请求对象没有任何关系。HttpServletRequest 实例的生命周期很短暂。</p>
</li>
</ul>
<h3 id="2-3-2-请求参数"><a href="#2-3-2-请求参数" class="headerlink" title="2.3.2 请求参数"></a>2.3.2 请求参数</h3><ul>
<li>HttpServletRequest对于请求中所携带的参数是以Map的形式接收的,并且该Map的key为String, value 为<strong>String数组</strong>。注意，是String数组。</li>
<li>为什么是String数组而不是string呢?因为Http请求协议允许一个请求参 数具有多个值的情况出现。例如下面表单中的复选框hobby的值就可能是多个。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.请求参数是存放在map中的</span></span><br><span class="line"><span class="comment"> * 2.map中的key为请求参数的名称，为String类型</span></span><br><span class="line"><span class="comment"> *   map中的value为请求参数的所有值，为String[]类型。</span></span><br><span class="line"><span class="comment"> * 3.使用最多的是getParameter()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">  <span class="comment">//获取请求的表单中的参数值</span></span><br><span class="line">  <span class="comment">//getParameter：本质上等同于获取getParameterValues(key)[0]。</span></span><br><span class="line">  String name = request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">  String ageStr = request.getParameter(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">  Integer age = Integer.valueOf(ageStr);</span><br><span class="line">  System.out.println(name + <span class="string">&quot; &quot;</span> + age);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取请求的表单中的所有参数名称</span></span><br><span class="line">  Enumeration&lt;String&gt; names = request.getParameterNames();</span><br><span class="line">  <span class="keyword">while</span> (names.hasMoreElements())&#123;</span><br><span class="line">    String element = names.nextElement();</span><br><span class="line">    String value = request.getParameter(element);</span><br><span class="line">    System.out.println(element + <span class="string">&quot; : &quot;</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获取请求参数的map</span></span><br><span class="line">  Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">  <span class="keyword">for</span> (String key : parameterMap.keySet()) &#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot; : &quot;</span> + request.getParameter(key));</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-域属型"><a href="#2-3-3-域属型" class="headerlink" title="2.3.3 域属型"></a>2.3.3 域属型</h3><ul>
<li>在Request中也存在域属性空间，用于存放有名称的数据。该数据只在当Request请求中可以进行访问。<ul>
<li>能够实现跨Servlet的数据传输。</li>
</ul>
</li>
<li>对域属型的访问：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置域属型</span></span><br><span class="line">request.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;cl&quot;</span>);</span><br><span class="line">request.setAttribute(<span class="string">&quot;age&quot;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="comment">//获取所有的域属性名称</span></span><br><span class="line">Enumeration&lt;String&gt; names = request.getAttributeNames();</span><br><span class="line"><span class="keyword">while</span> (names.hasMoreElements())&#123;</span><br><span class="line">  String element = names.nextElement();</span><br><span class="line">  Object value =  request.getAttribute(element);</span><br><span class="line">  System.out.println(element + <span class="string">&quot; : &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除域属型</span></span><br><span class="line">request.removeAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//将请求转发给OtherServlet</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">&quot;/other&quot;</span>).forward(request,response);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取域属性。由于是同一个request，因此能够获取到值</span></span><br><span class="line">Object name = req.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">Object age = req.getAttribute(<span class="string">&quot;age&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-3-4-服务端相关信息"><a href="#2-3-4-服务端相关信息" class="headerlink" title="2.3.4 服务端相关信息"></a>2.3.4 服务端相关信息</h3><ul>
<li>request的其他方法的使用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取请求的URL</span></span><br><span class="line">StringBuffer requestURL = request.getRequestURL();</span><br><span class="line">System.out.println(<span class="string">&quot;requestURL: &quot;</span> + requestURL);</span><br><span class="line"><span class="comment">//获取请求的URI：即url路径去掉协议和主机地址的剩下的</span></span><br><span class="line">String requestURI = request.getRequestURI();</span><br><span class="line">System.out.println(<span class="string">&quot;requestURI: &quot;</span> + requestURI);</span><br><span class="line"><span class="comment">//获取当前web应用的根名称</span></span><br><span class="line">String contextPath = request.getContextPath();</span><br><span class="line">System.out.println(<span class="string">&quot;contextPath: &quot;</span> + contextPath);</span><br><span class="line"><span class="comment">//获取客户端IP</span></span><br><span class="line">String clientIP = request.getRemoteAddr();</span><br><span class="line">System.out.println(<span class="string">&quot;clientIP: &quot;</span> + clientIP);</span><br><span class="line"><span class="comment">//获取servle与url映射中路径的精确部分</span></span><br><span class="line">String servletPath = request.getServletPath();</span><br><span class="line">System.out.println(<span class="string">&quot;servletPath: &quot;</span> + servletPath);</span><br><span class="line"><span class="comment">//获取servle与url映射中路径的非精确部分</span></span><br><span class="line">String pathInfo = request.getPathInfo();</span><br><span class="line">System.out.println(<span class="string">&quot;pathInfo: &quot;</span> + pathInfo);</span><br></pre></td></tr></table></figure>

<h2 id="2-4-关于乱码问题"><a href="#2-4-关于乱码问题" class="headerlink" title="2.4 关于乱码问题"></a>2.4 关于乱码问题</h2><ul>
<li>当在浏览器输入汉字时，服务器端接受的数据可能是乱码的现象。</li>
<li>原因：浏览器的数据是经过HTTP协议传输到服务端的，<ul>
<li>Http协议中规定,数据的传输采用字节编码方式,即无论浏览器提交的数据所包含的中文是什么字符编码格式，一旦由浏览器经过Http协议传输，则这些数据均将以字节的形式上传给服务器。因为HTTP协议的底层使用的是TCP传输协议。TCP, Transmission ControlProtocol,传输控制协议，是一种面向连接的、可靠的、基于字节流的、端对端的通信协议。</li>
<li>在请求中，这些字节均以%开头，并以十六进制形式出现。如%5A%3D等。</li>
</ul>
</li>
<li>那么，乱码是如何产生的呢?<ul>
<li>当用户通过浏览器提交一个包含UTF-8编码格式的两个字的中文请求时,浏览器会将这两个中文字符变为六个字节(-般一个UTF-8汉字占用三个字节),即形成六个类似%8E的字节表示形式，并将这六个字节。上传至Tomcat服务器。</li>
<li>例如：name=%E8%AF%95%E7%82%B9%E8%8C%83%E5%9B%B4  ==&gt;  name=试点范围</li>
<li>Tomcat服务器在接收到这六个字节后，并不知道它们原始采用的是什么字符编码。而Tomcat默认的编码格式为1SO-8859-1。所以会将这六个字节按照1SO-8859-1的格式进行编码,编码后在控制台显示，所以在控制台会显示乱码。</li>
</ul>
</li>
<li>注意：Tomcat9版本中，使用GET提交的不会出现中文乱码问题，使用POST提交的会出现中文乱码问题。<ul>
<li>只有9版本解决了GET提交方式的中文乱码，其他版本的都没有解决。</li>
</ul>
</li>
</ul>
<h3 id="2-4-1-解决POST请求的中文乱码"><a href="#2-4-1-解决POST请求的中文乱码" class="headerlink" title="2.4.1 解决POST请求的中文乱码"></a>2.4.1 解决POST请求的中文乱码</h3><ul>
<li>在接受请求后，通过request.setCharacterEncoding(“UTF-8”);设置编码格式，然后在使用request。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">  <span class="comment">//解决POST提交时的中文乱码问题</span></span><br><span class="line">  <span class="comment">//setCharacterEncoding()：设置了请求正文中的字符编码格式</span></span><br><span class="line">  request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">  String name = request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">  String ageStr = request.getParameter(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">  Integer age = Integer.valueOf(ageStr);</span><br><span class="line">  System.out.println(name + <span class="string">&quot; &quot;</span> + age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-解决GET请求的中文乱码"><a href="#2-4-2-解决GET请求的中文乱码" class="headerlink" title="2.4.2 解决GET请求的中文乱码"></a>2.4.2 解决GET请求的中文乱码</h3><ul>
<li>打开tomcat的安装路径，找到tomcat下的conf文件夹里面的server.xml文件。在server.xml文件中，将 URIEncoding=”UTF-8”添加到如下位置：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> <span class="attr">URIEncoding</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>另一种解决方式：在接受到数据后，对数据进行编码转换。<ul>
<li><font color="red">这种方案是万能方式，能够解决get和post请求的中文乱码问题。</font></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//针对tomcat9除外的其他版本的get请求。通过转换成浏览器的字节编码格式</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = name.getBytes(<span class="string">&quot;ISO8859-1&quot;</span>);</span><br><span class="line">String newName = <span class="keyword">new</span> String(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="2-5-HttpServletResponse"><a href="#2-5-HttpServletResponse" class="headerlink" title="2.5 HttpServletResponse"></a>2.5 HttpServletResponse</h2><ul>
<li>Web服务器收到一个Http请求后，会针对每个请求创建一个HttpServletRequest 对象和HttpSservletResponse对象。若需要获取客户端提交请求的相关信息，则需要从HttpServletRequest对象中获取;若需要向客户端发送数据，则需要通过HttpServletResponse对象来完成。</li>
</ul>
<h3 id="2-5-1-向客户端发送数据"><a href="#2-5-1-向客户端发送数据" class="headerlink" title="2.5.1 向客户端发送数据"></a>2.5.1 向客户端发送数据</h3><ul>
<li>SenvletResponse’接口有-一个方法getWriter()，用于获取到一个输出流对象PrintWriter,该输出流对象是专门用于向客户端浏览器中输出字符数据的，称为标准输出流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">  <span class="comment">//获取标准输出流：用于输出到浏览器中</span></span><br><span class="line">  PrintWriter writer = response.getWriter();</span><br><span class="line">  <span class="comment">//将数据传输到浏览器，浏览器会直接显示这些数据</span></span><br><span class="line">  <span class="comment">/*writer.print(&quot;asd&quot;);</span></span><br><span class="line"><span class="comment">    writer.println(&quot;acd&quot;);</span></span><br><span class="line"><span class="comment">    writer.print(&quot;zxczx&quot;);*/</span></span><br><span class="line">  <span class="comment">/*writer.write(&quot;zxc&quot;);</span></span><br><span class="line"><span class="comment">    writer.write(&quot;dfger&quot;);*/</span></span><br><span class="line">  <span class="comment">//像标准输出流中写入数据，那么客户端浏览器会直接看到这些数据</span></span><br><span class="line">  writer.append(<span class="string">&quot;ad&quot;</span>);</span><br><span class="line">  writer.append(<span class="string">&quot;zc&quot;</span>);</span><br><span class="line">  <span class="comment">//对标准输出流的关闭。注意关闭的时间。可以不用手动关闭</span></span><br><span class="line">  <span class="comment">//writer.close();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210211104213.png"></p>
<h3 id="2-5-2-响应时出现乱码"><a href="#2-5-2-响应时出现乱码" class="headerlink" title="2.5.2 响应时出现乱码"></a>2.5.2 响应时出现乱码</h3><ul>
<li>若在PrintWriter流中写入中交字符，那么，在客户端浏览器中将显示乱码。</li>
<li>只所以响应时会产生乱码，是因为HTTP 协议中规定，默认响应体的字符编码为ISO-8859-1。所以，若要解决乱码问题，就需要修改响应体的默认编码。一般情况下，有两种方式可以修改: <ul>
<li>HttpServletResponse 的setContentType(“text/html;charset=utf-8”]方法， 用于设置响应内容的MIME类型，其中可以指定MIME的字符编码。而MIME的字符编码，即响应体的字符编码。</li>
<li>HttpServletResponse 的setCharacterEncoding(“ut-8”)方法,用于修改MIME的字符编码，即修改响应体的字符编码。但使用setCharacterEncoding()方法的前提是，之前必须要通过使用方法setContentType()方法设置响应内容的MIME类型。否则setChar acterEncoding()方法不起作用。</li>
</ul>
</li>
<li>浏览器会根据响应体字符编码,自动调整其对响应体内容的解码方式;即会使用响应俸的字符编码显示响应体内容。</li>
<li>不过，需要注意一点，这些设置，必愤在PrintWriter对象产生之前先设置，否则将不起作用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="comment">//设置响应的MIME类型。例如：video/mp4,image/jpg</span></span><br><span class="line"><span class="comment">//其中可以指定MIME的字符编码，即响应体的字符编码</span></span><br><span class="line"><span class="comment">//response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//setCharacterEncoding()此方法的使用必须在getWriter()方法使用前使用</span></span><br><span class="line"><span class="comment">//这个方法的使用前提是必须先使用setContentType()方法</span></span><br><span class="line"><span class="comment">//这个方法用于修改ContentType的MIME类型字符编码</span></span><br><span class="line">response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="2-6-转发与重定向"><a href="#2-6-转发与重定向" class="headerlink" title="2.6 转发与重定向"></a>2.6 转发与重定向</h2><ul>
<li>通过HttpServletRequest获取到的RequestDispatcher对象的forward()方法，可以完成请求转发功能。而通过HttpServletResponse的sendRedirect()方法，可以完成重定向功能。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210211143310.png"></p>
<ul>
<li>图解</li>
</ul>
<img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210211144852.png"  />

<ul>
<li>请求转发：也称为服务器内跳转。重定向：也称为服务器外跳转。</li>
</ul>
<h3 id="2-6-1-请求转发"><a href="#2-6-1-请求转发" class="headerlink" title="2.6.1 请求转发"></a>2.6.1 请求转发</h3><ul>
<li>请求转发：是由请求发起的跳转操作。<ul>
<li>跳转时会携带浏览器的传参。</li>
<li>浏览器的url不会变。</li>
<li>转发前后的request和response根据转发的方式不同，也有所不同。见下面6.7</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String name = request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//请求转发操作</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">&quot;/other&quot;</span>).forward(request,response);</span><br></pre></td></tr></table></figure>

<h3 id="2-6-2-重定向"><a href="#2-6-2-重定向" class="headerlink" title="2.6.2 重定向"></a>2.6.2 重定向</h3><ul>
<li>重定向：是由响应发起的跳转操作。<ul>
<li>跳转时是浏览器默认发起的请求，不带任何参数。</li>
<li>浏览器的url会发生变化。</li>
<li>重定向之后此servlet中的request和response已经失效。</li>
<li>重定向与请求转发还有一点很重要的不同点是，重定向可以跳转到其它应用中,而请求转发只能在当前应用中跳转。也正因为如此,所以以sendRedirect()的参数中必须要添加request.getContextPath(),即当前应用的根目录，指定要跳转到哪个应用的哪个资源。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重定向：</span></span><br><span class="line">response.sendRedirect(request.getContextPath() + <span class="string">&quot;/other&quot;</span>);</span><br><span class="line"><span class="comment">//此处以下的代码仍会执行，但请求和响应已经结束。</span></span><br><span class="line">System.out.println(name);</span><br><span class="line">PrintWriter writer = response.getWriter();</span><br><span class="line">System.out.println(writer);</span><br><span class="line"><span class="comment">//此处无法向浏览器发送数据</span></span><br><span class="line">writer.append(<span class="string">&quot;asdasd&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>重定向时传输数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(request.getContextPath() + <span class="string">&quot;/other?pname=&quot;</span> + name + <span class="string">&quot;&amp;age=&quot;</span> + age);</span><br></pre></td></tr></table></figure>

<ul>
<li>此时会发现重定向后pname没有值。因为此时发生了重定向的数据乱码方式。</li>
</ul>
<h3 id="2-6-3-重定向时的乱码解决方式"><a href="#2-6-3-重定向时的乱码解决方式" class="headerlink" title="2.6.3 重定向时的乱码解决方式"></a>2.6.3 重定向时的乱码解决方式</h3><ul>
<li>首先重定向一般是在GET请求时，</li>
<li>在重定向前，需要将中文数据通过URL工具的编码方式，在接收后通过URL的解码方式。<ul>
<li>同时针对Tomcat9之外的其他版本，在解码后需要get请求的中文处理方式解决中文乱码现象。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编码：打散,使得url能够显示数据</span></span><br><span class="line">name = URLEncoder.encode(name,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//重定向：</span></span><br><span class="line">response.sendRedirect(request.getContextPath() + <span class="string">&quot;/other?pname=&quot;</span> + name + <span class="string">&quot;&amp;age=&quot;</span> + age);</span><br><span class="line"></span><br><span class="line">tring name = request.getParameter(<span class="string">&quot;pname&quot;</span>);</span><br><span class="line">System.out.println(name);</span><br><span class="line"><span class="comment">//解码：组装，将url的数据解码</span></span><br><span class="line">name = URLDecoder.decode(name,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对get请求的乱码问题的解决。当tomcat为9之外的版本</span></span><br><span class="line">String sname = <span class="keyword">new</span> String(name.getBytes(<span class="string">&quot;ISO8859-1&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Tomcat9版本的get重定向中，只需要编码和解码即可，不需要解决中文乱码的方式。</li>
</ul>
<h3 id="6-4-请求转发与重定向的对比"><a href="#6-4-请求转发与重定向的对比" class="headerlink" title=".6.4 请求转发与重定向的对比"></a>.6.4 请求转发与重定向的对比</h3><ul>
<li>请求转发<ul>
<li>浏览器只发出一次请求，收到一次响应。</li>
<li>请求所转发到的资源中可以直接获取到请求中所携带的数据。</li>
<li>浏览器地址栏显示的为用户所提交的请求路径。</li>
<li>只能跳转到当前应用的资源中。</li>
</ul>
</li>
<li>重定向<ul>
<li>浏览器发出两次请求，接收到两次响应。</li>
<li>重定向到的资源不能直接获取到用户提交请求中所携带的数据。</li>
<li>浏览器地址栏显示的为重定向的请求路径，而非用户提交请求的路径。也正因为如此，重定向的一个很重要作用是：防止表单重复提交。</li>
<li>重定向不仅可以跳转到当前应用的其它资源，也可以跳转到到其它应用中资源。</li>
</ul>
</li>
</ul>
<h3 id="2-6-5-请求转发与重定向的选择"><a href="#2-6-5-请求转发与重定向的选择" class="headerlink" title="2.6.5 请求转发与重定向的选择"></a>2.6.5 请求转发与重定向的选择</h3><ul>
<li>若需要跳转到其它应用，则使用重定向。</li>
<li>若是处理表单数据的ervlet要跳转到其它Servlet,则需要选择重定向。为了防止表单重复提交。</li>
<li>若对某一请求进行处理的Servlet的执行需要消耗大量的服务器资源(CPU、内存),此时这个Servlet执行完毕后，也需要重定向。</li>
<li>其它情况，一般使用请求转发。</li>
</ul>
<h2 id="2-7-RequestDispatcher"><a href="#2-7-RequestDispatcher" class="headerlink" title="2.7 RequestDispatcher"></a>2.7 RequestDispatcher</h2><ul>
<li>RequestDispatcher是lavax.servlet 包下的一个接口,通过HttpServletRequest可以获取到RequestDispatcher的接口对象。顾名思义，该对象就是用于完成请求转发功能的。</li>
<li>RequestDispatcher接口中只有两个方法：forward(),include()。</li>
</ul>
<h3 id="2-7-1-forward-与include"><a href="#2-7-1-forward-与include" class="headerlink" title="2.7.1 forward()与include()"></a>2.7.1 forward()与include()</h3><ul>
<li>RequestDispatcher接口中具有两个方法: forward()与include()，均可完成请求的转发。即可以将请求中所携带的参数由当前Servlet传递给下一下资源，如另一个Servlet。也就是说，这两个方法对于请求来说是相同的，都是请求转发。但它们的不同之处是响应，是标准响应输出流的开启时间不同。</li>
<li>对于forward()与include()。在请求转发后，它们的request实体都是由RequestFacade变成了ApplicationHttpRequest。而对于response实体，在使用forword()之后，没有发生变化；而使用了include()之后，实体由ResponseFacade变成了ApplicationHttpResponse。<ul>
<li>ApplicationHttpRequest和ApplicationHttpResponse分别是对HttpServletRequest和HttpServletResponse的增强类。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">request = org.apache.catalina.connector.RequestFacade@22cd7cf1</span><br><span class="line">response = org.apache.catalina.connector.ResponseFacade@67cff6cc</span><br><span class="line"><span class="comment">//使用forword后的变化  </span></span><br><span class="line">request === org.apache.catalina.core.ApplicationHttpRequest<span class="meta">@fded0ec</span></span><br><span class="line">response === org.apache.catalina.connector.ResponseFacade@67cff6cc</span><br><span class="line">  </span><br><span class="line">request = org.apache.catalina.connector.RequestFacade@780737f2</span><br><span class="line">response = org.apache.catalina.connector.ResponseFacade@3d05b696</span><br><span class="line"><span class="comment">//使用include后的变化  </span></span><br><span class="line">request === org.apache.catalina.core.ApplicationHttpRequest@1e0b2a35</span><br><span class="line">response === org.apache.catalina.core.ApplicationHttpResponse@483434df</span><br></pre></td></tr></table></figure>

<ul>
<li><p>void forward(ServletRequest request, ServletResponse response)</p>
<ul>
<li>使用该方法，则当前的servlet 中只能进行业务处理,而不能向浏览器发送要显示的数据。因为请求还未完成，需要继续向前(forward)，当请求完成后，服务器才会开启标准响应输出流，向输出流中写入数据。</li>
<li>该方法的响应对象，使用的是第二个资源的响应对象。即第二个资源向浏览器回送的响应数据。</li>
<li>不过，需要注意的是,在后面的测试代码的someServlet与otherservlet中均添加对于Response对象的输出语句，会发现这两个Servlet中所使用的Response对象为同一个ResponseFacade对象。那为什么在someServlet中向out中print()数据后，并不会显示到客户端浏览器?原因就是Response对象在SomeServlet中创建了,但标准输出流并未开启。输出流的开启是在OtherServlet中进行的。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210212193316.png"></p>
</li>
<li><p>void Include(ServletRequest request, servletResponse response)</p>
<ul>
<li>使用该方法，在将请求向后转发时，服务器会将标准响应输出流开启。当前ervlet可以向输出流中写入数据,并且服务器还会将要转向的资源的输出流中数据合并到当前的输出流中。</li>
<li>该方法的响应对象，使用的是第一个资源的响应对象，即当前servlet向浏览器回送的响应数据。</li>
<li>需要注意的是，在后面的测试代码的SomeServlet 与Otherervlet 中均添加对于Response对象的输出语句，会发现SomeSenvlet输出的是ResponseFacade 对象，而OtherServlet输出的则是_ ApplicationHttpResponse 对象。ApplicationHttpResponse 是HttpServletResponse接口的实现类ResponseFacade 的装饰者类，其增强了ResponseFacade类的功能。</li>
<li>ApplicationHttpResponse底层完成的一个工作是，将当前的OtherServlet 中的输出流中的数据合并到了SomeServlet的标准输出流中。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210212193322.png"></p>
</li>
<li><p>样例</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置响应的文本内容以text/html方式解析</span></span><br><span class="line">response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line"></span><br><span class="line">PrintWriter writer = response.getWriter();</span><br><span class="line">writer.append(<span class="string">&quot;SomeServlet:forward() before &lt;br&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * forward()与include()的区别：主要表现在标准输出流的开启时间不同。</span></span><br><span class="line"><span class="comment"> * forward(): forward单词本意为”向前“，说明当前的请求还未结束，需要继续向前，所以服务器不会</span></span><br><span class="line"><span class="comment"> *    在这里打开输出流。所以此时写入到out中的数据不会写到客户端浏览器中。</span></span><br><span class="line"><span class="comment"> * include(): include单词本意为”包含“，说明当前的请求已经结束，可以对客户端进行响应的。</span></span><br><span class="line"><span class="comment"> *    其不仅将自己的数据写入到标准输出流，还将包含的其他servlet中写入的数据包含到自己的输出流中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结：在使用forward()进行请求转发时，使用forward()的Servlet不应向Response中写入数据，</span></span><br><span class="line"><span class="comment"> *    若要写入数据，则应使用include()进行转发。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//request.getRequestDispatcher(&quot;/other&quot;).forward(request,response);</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">&quot;/other&quot;</span>).include(request,response);</span><br><span class="line"></span><br><span class="line">writer.append(<span class="string">&quot;SomeServlet:forward() after &lt;br&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当上述代码使用forward转发方式时</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222194719.png"></p>
</li>
<li><p>当上述代码使用include转发方式时。注意输出的顺序</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222194719-1.png"></p>
</li>
</ul>
<h2 id="2-8-访问路径问题"><a href="#2-8-访问路径问题" class="headerlink" title="2.8 访问路径问题"></a>2.8 访问路径问题</h2><h3 id="2-8-1-访问路径的组成"><a href="#2-8-1-访问路径的组成" class="headerlink" title="2.8.1 访问路径的组成"></a>2.8.1 访问路径的组成</h3><ul>
<li><p>URL,统一资源定位符，用于定位资源的一种方式。通常的<font color="red">URL资源访问路径由两部分构成:资源路径</font>与<font color="red">资源名称</font>。资源名称指的是要访问资源的直接名称，如show.html,或与要访问资源存在映射关系的间接名称，如show.do。而资源路径,则是通过该路径则可以定位到指定的资源，即资源路径是指在URL资源访问路径中除了资源名称以外的其它部分。</p>
</li>
<li><p>根据以上规则，URI,统一资源标识符，也可以分为资源路径与资源名称两部分。</p>
</li>
<li><p>一般情况下，在URL或URI中，最后一个斜杠后的部分为资源名称,而其它部分则为资源路径。</p>
</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210212204440.png"></p>
<ul>
<li>根据”资源路径是否可以独立完成资源准确定位“的判别标准,可以将访问路径分为绝对路径与相对路径。</li>
</ul>
<h3 id="2-8-2-绝对路径"><a href="#2-8-2-绝对路径" class="headerlink" title="2.8.2 绝对路径"></a>2.8.2 绝对路径</h3><ul>
<li>绝对路径,是指根据给出的访问路径可以准确定位到资源的路径。例如，你要告诉对方你现在的位置,你说:我现在在北京故宫游客A入口处。这就是个绝对地址,听者根据你所述地址,可以准确的找到你。</li>
<li>而对于计算机中<font color="red">Web应用的绝对路径，则是指带访问协议的路径,即URL。</font>例如下面的路径就是一个带有http 访问协议的绝对路径。<ul>
<li><a href="http://127.0.0.1:.8080/primary/index.jsp">http://127.0.0.1:.8080/primary/index.jsp</a></li>
</ul>
</li>
</ul>
<h3 id="2-8-3-相对路径"><a href="#2-8-3-相对路径" class="headerlink" title="2.8.3 相对路径"></a>2.8.3 相对路径</h3><ul>
<li>相对路径,是指仅根据访问路径无法准确定位资源的路径。<font color="red">相对路径必须要结合其参照路径才可组成可以准确定位资源的绝对路径。</font>參照路径的不同,所形成的可以准确定位资源的绝对路径也是不同的。在进行资源访问时，必须要将相对路径转换为绝对路径才可完成资源的准确定位。它们的关系如下:<ul>
<li><font color="red">绝对路径=参照路径+相对路径</font></li>
</ul>
</li>
<li>例如，你要告诉对方你现在的位置，你说:我在人民公园的正门门口。这就是个相对地址。因为很多城市都有人民公园,每个人民公园也都有正门]。当对方不知道你在哪个城市时，他是无法准确定位你的。当然，你只所以不说是哪个城市，是因为这里存在一个默认的参照路径:与听者在同一个城市。听者会将你所说的相对地址,自动转换为一个绝对地址:与听者在同一城市的人民公园正门门口。</li>
<li>在Web应用中，浏览器或服务器会自动为不同的相对路径添加不同的参照路径，将相对路径转换为绝对路径,以定位这个资源。作为程序员,必须要理解并掌握浏览器或服务器为相对路径添加参照路径的规则，这样才能在编程时更为准确地书写相对路径。</li>
<li>相对路径的写法有两种: -种是以斜杠开头的相对路径,-种是以路径名称开头的相对路径。<font color="red">根据相对路径是否以斜杠开头,且路径出现的文件的不同，其默认的参照路径是不同的。</font></li>
<li>这是我们学习的重点，是路径问题中最容易出错的地方:确定相对路径的参照路径。</li>
</ul>
<h4 id="1-以斜杠开头的相对路径"><a href="#1-以斜杠开头的相对路径" class="headerlink" title="(1) 以斜杠开头的相对路径"></a>(1) 以斜杠开头的相对路径</h4><ul>
<li>以斜杠开头的相对路径,根据路径所在文件所处位置的不同,分为两种:前台路径与后台路径。</li>
</ul>
<p><strong>前台路径</strong></p>
<ul>
<li>所谓前台路径是指，由浏览器解析执行的代码中所包含的路径。例如，html. css、 js中的路径，及jsp文件中静态部分的路径(HTML标签中的路径)。例如，html 及jsp文件中的&lt;img src-=*/&gt;、&lt;a href=””&gt;&lt;/a&gt; ,&lt;form actio=””&gt;&lt;/form&gt;等标签中的路径;再如，css 文件中的background:img(“”)等属性中的路径，js文件中的window.location.href=””等属性中的路径，都属于前台路径。</li>
<li><font color="red">前台路径的参照路径是Web服务器的根路径</font>,即<a href="http://127.0.0.1:8080。">http://127.0.0.1:8080。</a></li>
<li>将前台路径转换为绝对路径的工作,是<font color="red">由浏览器自动完成的</font>。该路径的作用是要为用户提交对某种资源的请求,是要查找并定位服务器中的某资源。简单来说，前台路径的作用是“查找”。</li>
</ul>
<p><strong>后台路径</strong></p>
<ul>
<li>所谓后台路径是指，由服务器解析执行的代码及文件中所包含的路径。例如，java 代码中的路径、jsp文件动态部分(java 代码块)中的路径、xml等配置文件中的路径(配置文件是要被java代码解析后加载到内存的，其中的路径会出现在Java代码中)等。</li>
<li><font color="red">后台路径的参照路径是Web应用的根路径</font>。如<a target="_blank" rel="noopener" href="http://127.0.0.1:8080/primary%E3%80%82">http://127.0.0.1:8080/primary。</a></li>
<li>将后台路径转换为绝对路径的工作,是<font color="red">由服务器自动完成的</font>。该路径的作用是标识出该资源在服务器中的路径，以便客户端能够按照这个设定路径来查找相应资源。简单来说，后台路径的作用是“标识”。</li>
</ul>
<p><strong>后台路径特例</strong></p>
<ul>
<li>对于后台路径的參照路径有一个特例：<font color="red">当代码中使用response 的sendRedirect()方法进行重定向时，若其参照路径是以斜杠开头,则其參照路径不是web应用的根路径,而是web服务器的根路径。</font><ul>
<li>例如，执行response.sendRedirect(“*/show.sp”);将 会报404错误。因为其参照路径是Tomcat的根，而非当前项目的根。所以若要使用重定向，就需要在路径上添加上项目名称: response.sendRedirect(request.getContextPath+“/show.jsp”);</li>
</ul>
</li>
<li>为什么这里是特例?<ul>
<li>因为sendRedirect()方法可以重定向到其它应用， 若不指定要跳转的应用，其将无法确定跳转方向。</li>
</ul>
</li>
</ul>
<h4 id="2-以路径名称开头的相对路径"><a href="#2-以路径名称开头的相对路径" class="headerlink" title="(2) 以路径名称开头的相对路径"></a>(2) 以路径名称开头的相对路径</h4><ul>
<li><font color="red">以路径名称开头的相对路径</font>，无论是出现在前台页面,还是出现在后台Java 代码或配置文件中，<font color="red">其参照路径都是当前访问路径的资源路径</font>。即使是response的sendRedirect()方法的参数路径,若不以斜杠开头，其也属于“以路径名称开头的相对路径”类,参照路径为当前访问路径的资源路径。</li>
</ul>
<h4 id="3-总结"><a href="#3-总结" class="headerlink" title="(3) 总结"></a>(3) 总结</h4><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210213112649.png"></p>
<h3 id="2-8-4-实例"><a href="#2-8-4-实例" class="headerlink" title="2.8.4 实例"></a>2.8.4 实例</h3><ul>
<li>前台路径的实例</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  以斜杠开头的前台页面的静态路径是前台路径。前台路径的参照路径是当前Web服务器的根路径，</span></span><br><span class="line"><span class="comment">  即：http://localhost:8080</span></span><br><span class="line"><span class="comment">  绝对路径 = 参照路径+相对路径。</span></span><br><span class="line"><span class="comment">  因此这个img的图片的访问路径(绝对路径)为：http://localhost:8080/images/csd.png。</span></span><br><span class="line"><span class="comment">  因为images文件不在当前服务器下，因此是访问不到的。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/csd.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  因此这个img的图片的访问路径(绝对路径)为：http://localhost:8080/JavaWeb1_war_exploded/images/csd.png。</span></span><br><span class="line"><span class="comment">  因为JavaWeb1_war_exploded文件在Web服务器下，而images文件又在此文件下，因此这个可以访问到</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/JavaWeb1_war_exploded/images/csd.png&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100px&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  这个action的访问路径(绝对路径)为：http://localhost:8080/some</span></span><br><span class="line"><span class="comment">  因为Web服务器的跟路径中不存在some，因此这个访问是不能被访问到的。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/some&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">  名字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  这个action的访问路径(绝对路径)为：http://localhost:8080/JavaWeb1_war_exploded/some</span></span><br><span class="line"><span class="comment">  因为Web服务器的跟路径存在JavaWeb1_war_exploded项目文件，项目文件中又存在some文件，</span></span><br><span class="line"><span class="comment">  因此这个访问是能被访问到的。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/JavaWeb1_war_exploded/some&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">  名字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>后台路径的实例</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  以斜杠开头的存在与xml文件或Java代码中的路径被称为后台路径。后台路径的参照路径是当前Web应用的根路径</span></span><br><span class="line"><span class="comment">  即：http://localhost:8080/JavaWeb1_war_exploded</span></span><br><span class="line"><span class="comment">  绝对路径 = 参照路径+相对路径。</span></span><br><span class="line"><span class="comment">  因此这里的url的绝对路径是：http://localhost:8080/JavaWeb1_war_exploded/other</span></span><br><span class="line"><span class="comment">  后台路径的作用是”标识“。即客户端想要访问我定义的other，那么必须提交上述的绝对路径。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>other-servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/other<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 因此这里的访问路径(绝对路径)是：http://localhost:8080/JavaWeb1_war_exploded/other</span></span><br><span class="line"><span class="comment"> * 当提出此请求路径后，即可访问到other的资源。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//request.getRequestDispatcher(&quot;/other&quot;).forward(request,response);</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 特殊的是sendRedirect()方法。此方法的参照路径是Web服务器的根路径</span></span><br><span class="line"><span class="comment"> * 即：http://localhost:8080 与后台路径的参照路径不同。</span></span><br><span class="line"><span class="comment"> * 因为此方法不仅可以跳转到当前项目的资源中，还可以跳转到其他项目的资源中</span></span><br><span class="line"><span class="comment"> * 因此在使用此方法时，需要在访问路径前加上访问资源的项目名称。</span></span><br><span class="line"><span class="comment"> * 注意：只有此方法的重定向需要加上项目名称，其他的重定向方法不需要</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//输出的是 /JavaWeb1_war_exploded</span></span><br><span class="line">System.out.println(request.getContextPath());</span><br><span class="line">response.sendRedirect(request.getContextPath() + <span class="string">&quot;/other&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>以路径名称开头的相对路径</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	这是一个”以路径名称开头的相对路径“，其参照路径是”当前访问路径的资源路径“</span></span><br><span class="line"><span class="comment">	对于初始页面index.html而言。参照路径是：http://localhost:8080/JavaWeb1_war_exploded</span></span><br><span class="line"><span class="comment">	绝对路径 = 参照路径+相对路径。</span></span><br><span class="line"><span class="comment">	此路径的访问路径(绝对路径)为:http://localhost:8080/JavaWeb1_war_exploded/images/csd.png</span></span><br><span class="line"><span class="comment">	此路径在不启动服务器时，也能访问到图片</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/csd.png&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100px&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	此处的路径的作用是标识资源的位置，因此此处的路径只能以斜杠开头，不能省略。 </span></span><br><span class="line"><span class="comment">  且当服务启动时，此处并没有参照路径的存在。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>other-servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/other<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这是一个以路径开头的访问路径，其参照路径是”当前当问路径的资源路径“。</span></span><br><span class="line"><span class="comment"> * 就本路径而言，其参照路径是：http://localhost:8080/JavaWeb1_war_exploded</span></span><br><span class="line"><span class="comment"> * 绝对路径 = 参照路径+相对路径。</span></span><br><span class="line"><span class="comment"> * 此路径的访问路径(绝对路径)为：http://localhost:8080/JavaWeb1_war_exploded/other</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">&quot;other&quot;</span>).forward(request,response);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对于sendRedirect()方法完成的重定向，若参数路径不以斜杠开头，则项目名称不用写。</span></span><br><span class="line"><span class="comment"> * 也能完成跳转。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">response.sendRedirect(<span class="string">&quot;other&quot;</span>);</span><br><span class="line"><span class="comment">// 对于可以写斜杠，和不写斜杠的效果相同时，优先推荐写斜杠。</span></span><br><span class="line"><span class="comment">//因为带斜杠的参考路径是定死的，而不写斜杠时，参考路径是变化的，可能会出错。</span></span><br></pre></td></tr></table></figure>

<h2 id="2-9-Servlet的线程安全问题"><a href="#2-9-Servlet的线程安全问题" class="headerlink" title="2.9 Servlet的线程安全问题"></a>2.9 Servlet的线程安全问题</h2><ul>
<li>Servlet是在单例多线程环境下运行的。其运行可能会出现线程安全问题。</li>
</ul>
<h3 id="2-9-1-线程安全问题"><a href="#2-9-1-线程安全问题" class="headerlink" title="2.9.1 线程安全问题"></a>2.9.1 线程安全问题</h3><p><strong>(1) 什么是线程安全问题</strong></p>
<ul>
<li>同时满足以下两个条件,则会出现线程安全问题。<ul>
<li>存在多线程并发访问。</li>
<li>存在可修改的共享数据。</li>
</ul>
</li>
<li>当多个线程同时修改同一个共享数据时,后修改的数据会将先修改的数据覆盖,对数据先进行修改的用户读取到的不是自己修改后的数据，这就是线程安全问题。</li>
</ul>
<p><strong>(2) JVM中可能存在线程安全问题的数据分析</strong></p>
<ul>
<li>栈内存数据分析。<ul>
<li>栈内存是多例的，即JVM会为每个线程创建一个栈， 所以其中的数据不是共享的。另外，方法中的局部变量存放在Stack 的栈帧中,方法执行完毕，栈帧弹栈，局部变量消失。局部变量是局部的，不是共享的。所以栈内存中的数据不存在线程安全问题。。</li>
</ul>
</li>
<li>堆内存数据分析。<ul>
<li>一个JVM中只存在一个堆内存,堆内存是共享的。被创建出的对象是存放在堆内存的，而存放在堆内存中的对象,实际就是对象成员变量的值的集合。即成员变量是存放在堆内存的。堆内存中的数据是多线程共享的，也就是说，堆内存中的数据是存在线程安全问题的。</li>
</ul>
</li>
<li>方法区数据分析。<ul>
<li>一个JVM中只存在一个方法区。静态变量与常量存放在方法区，方法区是多线程共享的。常量是不能被修改的量,所以常量不存在线程安全问题。静态变量是多线程共享的,所以静态变量存在线程安全问题。</li>
</ul>
</li>
</ul>
<p><strong>(3) 线程安全问题的解决方案</strong></p>
<ul>
<li>若要解决数据的线程安全问题，则可按照下面思路考虑:<ul>
<li>对于一般性的类,不要定义为单例的。除非项目有特殊需求,或该类对象属于重量级对象。所谓重量级对象是指，创建该类对象时需要占用较大的系统资源。</li>
<li>无论类是否为单例类，尽量不使用静态变量。</li>
<li>若需要定义为单例类,则单例类虫尽量不使用成员变量。</li>
<li>若单例类中必须要 使用成员变量,则对成员变量的操作，可以添加串行化锁synchronized,实现线程同步。不过，最好不要使用线程同步机制。因为一旦操作进入串行化的排队状态，将大大降低程序的执行效率。</li>
</ul>
</li>
</ul>
<h3 id="2-9-2-Servlet的线程安全问题"><a href="#2-9-2-Servlet的线程安全问题" class="headerlink" title="2.9.2  Servlet的线程安全问题"></a>2.9.2  Servlet的线程安全问题</h3><ul>
<li>Servlet是单例多线程并发访问的，所以其就有可能会出现线程安全问题。为了避免线程安全问题的产生，对于Servlet的使用，一般是不声明成员变量的。若项目中要求必须要声明成员变量,则只能通过线程同步机制synchronized 避免。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由于当前Servlet是单例多线程的，而且其中又存在可修改的成员变量userName</span></span><br><span class="line"><span class="comment"> * 所以，当前这个Servlet存在线程安全问题，即这个Servlet是线程不安全的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 成员变量</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//解决方法一：不定义成员变量，定义局部变量</span></span><br><span class="line">    <span class="comment">//String userName = req.getParameter(&quot;userName&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决方法二：定义成员变量，但使用串行锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">      userName = req.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">      PrintWriter writer = resp.getWriter();</span><br><span class="line">      writer.append(userName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-Cookie"><a href="#第三章-Cookie" class="headerlink" title="第三章 Cookie"></a>第三章 Cookie</h1><h2 id="3-1-Cookie简介"><a href="#3-1-Cookie简介" class="headerlink" title="3.1 Cookie简介"></a>3.1 Cookie简介</h2><ul>
<li>Cookie是1993年由网景公司(Netscape) 前雇员发明的一种进行网络会话状态跟踪的技术。</li>
<li>会话是由一组请求与响应组成,是围绕着一件相关事 情所进行的请求与响应。所以这些请求与响应之间一定是需要有数据传递的，即是需要进行会话状态跟踪的。然而HTP协议是一种无状态协议，在不同的请求间是无法进行数据传递的。此时就需要一种可以进行请求间数据传递的会话跟踪技术，而Cookie就是一种这样的技术。 </li>
<li>Cookie是由服务器生成,保存在客户端的-种信息载体。这个载体中存放着用户访问该站点的会话状态信息。只要Cookie没有被清空，或都Cookie没有失效，那么,保存在其中的会话状态就有效。</li>
<li>用户在提交第一-次请求后，由服务器生成Cookie,并将其封装到响应头中,以响应的形式发送给客户端。客户端接收到这个响应后，将Cookie 保存到客户端。当客户端再次发送同类请求后，在请求中会携带保存在客户端的Cookie 数据,发送到服务端，由服务器对会话进行跟踪。</li>
<li>Cookie技术并不是JavaWeb开发专属技术,而是属于Web开发的技术，是所有Web开发语言均支持的技术。</li>
<li>Cookie是由若干键值对构成,这里的键一般称为name,值称为value。 Cookie 中的键值对均为字符串。</li>
</ul>
<h2 id="3-2-火狐下的Cookie"><a href="#3-2-火狐下的Cookie" class="headerlink" title="3.2 火狐下的Cookie"></a>3.2 火狐下的Cookie</h2><ul>
<li>不同的浏览器，其Cookie的保存位置及查看方式是不同的。删除了某-浏览器下的Cookie,不会影响到其它浏览器中的Cookie。</li>
<li>在火狐浏览器下可以直接查看到Cookie 的信息。查看位置在:</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222165817.png"></p>
<ul>
<li>打开选项后，找到隐私然后打开，就可以找到火狐浏览器对Cookie的管理了。</li>
</ul>
<h2 id="3-3-JavaEE中的Cookie"><a href="#3-3-JavaEE中的Cookie" class="headerlink" title="3.3 JavaEE中的Cookie"></a>3.3 JavaEE中的Cookie</h2><ul>
<li>在JavaEE中的javax.servlet.http包中存在一个类Cookie ,就是用于完成会话跟踪的Cookie。其只有一个带参构造器:<ul>
<li>public Cookie(String name, String value)</li>
</ul>
</li>
<li>而HttpServletResponse中有一个方法，可以将Cookie 添加到响应头中。<ul>
<li>public void addCookie(Cookie cookie)</li>
</ul>
</li>
<li>注意，一个response中可以添加多个Cookie的键值对。</li>
</ul>
<p><strong>(1)默认绑定路径</strong></p>
<ul>
<li>访问路径由资源路径与资源名称构成。默认情况下，Cookie与访问路径中的资源路径(URi)绑定。只要用户发出带有绑定资源路径的请求,则在请求头部,将自动会携带与之绑定的Cookie数据。</li>
</ul>
<p><strong>(2)服务器生成Cookie</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建两个Cookie</span></span><br><span class="line">    Cookie cookie1 = <span class="keyword">new</span> Cookie(<span class="string">&quot;company&quot;</span>, <span class="string">&quot;北京新能源&quot;</span>);</span><br><span class="line">    Cookie cookie2 = <span class="keyword">new</span> Cookie(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;asd&quot;</span>);</span><br><span class="line">    <span class="comment">//设置Cookie绑定的访问路径。注意需要添加上项目名称</span></span><br><span class="line">    cookie1.setPath(req.getContextPath()+<span class="string">&quot;/xxx/ooo&quot;</span>);</span><br><span class="line">    cookie2.setPath(req.getContextPath()+<span class="string">&quot;/bbb&quot;</span>);</span><br><span class="line">    <span class="comment">//设置Cookie的有效期。值为整型值，单位为秒。</span></span><br><span class="line">    <span class="comment">//该值大于0，表示将Cookie存放到客户端的硬盘。</span></span><br><span class="line">    <span class="comment">//该值小于0或不设置，表示将Cookie存放到浏览器的缓存中。</span></span><br><span class="line">    <span class="comment">//该值等于0，表示Cookie一生成就马上失效。</span></span><br><span class="line">    cookie1.setMaxAge(<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    cookie2.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//向响应中添加Cookie</span></span><br><span class="line">    resp.addCookie(cookie1);</span><br><span class="line">    resp.addCookie(cookie2);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>(3)服务端获取并解析Cookie</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取请求中的Cookie</span></span><br><span class="line">    Cookie[] cookies = req.getCookies();</span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">      System.out.println(cookie.getName() + <span class="string">&quot;  &quot;</span> + cookie.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-Cookie的禁用"><a href="#3-4-Cookie的禁用" class="headerlink" title="3.4 Cookie的禁用"></a>3.4 Cookie的禁用</h2><ul>
<li>Cookie的禁用会导致很多网站都无法正常访问。</li>
</ul>
<h1 id="第四章-Session"><a href="#第四章-Session" class="headerlink" title="第四章 Session"></a>第四章 Session</h1><ul>
<li>Session,即会话,是Webj开发中的一种会话状态跟踪技术。当然,前面所讲述的Cookie也是一种会话跟踪技术。不同的是Cookie是将会话状态保存在了客户端，而Session则是将会话状态保存在了服务器端。</li>
<li>那么，到底什么是“会话”?当用户打开浏览器，从发出第一次请求开始，一 直到最终关闭浏览器，就表示一次会话的完成。</li>
<li>Session并不是JavaWeb开发所特有的,而是整个Web开发中所使用的技术。在JavaWeb开发中，Session 是以javax.servlet.http.HttpSession的接口对象的形式出现的。</li>
</ul>
<h2 id="4-1-Session的访问"><a href="#4-1-Session的访问" class="headerlink" title="4.1 Session的访问"></a>4.1 Session的访问</h2><p><strong>(1) Session对象的创建</strong></p>
<ul>
<li>若要对Session进行操作，则可以通过HttpServletRequest的getession(方法获取。该方法具有两个重载的方法。</li>
<li>public HttpSession getSession(boolean create)<ul>
<li>该方法用于创建Session。若参数create为true,则表示若当前没有Session,则新建一个Session,若当前存在Session 则使用当前的Session。若参数create为false 表示若当前没有Session,则直接返回null。</li>
</ul>
</li>
<li>public Httpsession getSession()<ul>
<li>该方法用于创建Session。相当于getSession(true), 即没有Session则创建新的Session。</li>
</ul>
</li>
<li>何时使用getsession(true),即getSession(),何时使用getSession(false)呢? </li>
<li>一般情况下， 若要向Session中存放数据，则使用getSession(true),即getSessin()。意义为:若当前存在Session,则使用当前的Session;若当前不存在Session,则创建一个新的Session。因为存放数据是必须要有Session 的。</li>
<li>若要从Session中获取数据,则一般使用getsession(fase)。意义为:若当前存在Session,则从中获取数据;若当前根本就没有Session, 那就更不可能存在Session中的数据了。无需创建一个新的Session,再从新的Session中获取数据,因为新创建的Session 中是不可能有数据的。</li>
</ul>
<p><strong>(2) Session的域属型空间</strong></p>
<ul>
<li>Session是-一个专门用于存放数据的集合,我们一般称这个用于存放数据的内存空间为域属性空间,简称域。HttpSession 中具有三个方法，是专门用于对该域属性空间中数据进行写、读操作的。</li>
<li>public void setAttribute(String name, Object value)<ul>
<li>该方法用于向Session的域属性空间中放入指定名称、指定值的域属性。</li>
</ul>
</li>
<li>public Object getAttribute(String name)<ul>
<li>该方法用于从Session的域属性空间中读取指定名称为域属性值。</li>
</ul>
</li>
<li>public void removeAttribute(String name)<ul>
<li>该方法用于从Session的域属性空间中删除指定名称的域属性。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Session</span></span><br><span class="line">HttpSession session = req.getSession();</span><br><span class="line"><span class="comment">//往Session中添加域属性</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="comment">//获取Session</span></span><br><span class="line">HttpSession session = req.getSession(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//获取Session中的域属型</span></span><br><span class="line"><span class="keyword">if</span> (session != <span class="keyword">null</span>)&#123;</span><br><span class="line">  Object name = session.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：在使用Session时，浏览器不要禁调Cookie。</li>
<li>多个用户均在自己的电脑上访问当前应用，发现不同用户从Session 中读取到的都是自己所提交的参数值,并没有读取到别人的参数，并没有发生“错乱”现象。这是为什么呢?</li>
<li>Web开发中的Session机制，为每个用户都分配了一个Session。即一个 用户-个Session,确切地说,是一次会话- -个Sesson对象。同一用户可以发出多个会话,即会产生多个Session</li>
</ul>
<h2 id="4-2-Session的工作原理"><a href="#4-2-Session的工作原理" class="headerlink" title="4.2 Session的工作原理"></a>4.2 Session的工作原理</h2><ul>
<li>在服务器中系统会为每个会话维护一个Session。 不同的会话，对应不同的Session。 那么，系统是如何识别各个Session对象的?即是如何做到在同一会话过程中，一直使用的是同一个Session对象呢?。</li>
</ul>
<p><strong>(1) 写入Session列表</strong></p>
<ul>
<li>服务器对当前应用中的Session是以Map的形式进行管理的,这个Map称为session 列表。该Map的key为一个32位长度的随机串,这个随机串称为JSessionlD , value为Session对象的引用。</li>
<li>当用户第一次提交请求时，服务端Servlet中执行到reguest.gesession()方法后，会自动生成一个Map.Entry对象，key 为一个根据某种算法新生成的JsessionID, value 则为新创建的HttpSession对象。</li>
<li>注意：是在执行到reguest.gesession()方法后才生成Session对象。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222194646.png"></p>
<p><strong>(2) 服务器生成并发送Cookie</strong></p>
<ul>
<li>在将Session信息写入Session列表后，系统还会自动将“JSESSIONID”作为name,这个32位长度的随机串作为value,以Cookie 的形式存放到响应报头中，并随着响应，将该Cookie发送到客户端。小</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222194943.png"></p>
<p><strong>(3) 客户端接受并发送Cookie</strong></p>
<ul>
<li>客户端接收到这个Cookie 后会将其存放到浏览器的缓存中。即，只要客户端浏览器不关闭，浏览器缓存中的Cookie就不会消失。</li>
<li>当用户提交第二次请求时，会将缓存中的这个Cookie,伴随着请求的头部信息，一块发送到服务端。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210222195205.png"></p>
<p><strong>(4) 从Session列表中查找</strong></p>
<ul>
<li>服务端从请求中读取到客户端发送来的Cookie, 并根据Cookie 的SSIONID的值，从Map中查找相应key对应的value,即Session对象。然后,对该Session对象的域属性进行读写操作。</li>
</ul>
<h2 id="4-3-Session的失效"><a href="#4-3-Session的失效" class="headerlink" title="4.3 Session的失效"></a>4.3 Session的失效</h2><ul>
<li>Web开发中引入的Session超时的概念，Session 的失效就是指Session的超时。若某个Session在指定的时间范围内一直未被访问，那么Session 将超时，即将失效。</li>
<li>在web.xml中可以通过&lt;session-config/&gt;标签设置Session的超时时间，单位为分钟。默认Session的超时时间为30分钟。需要再次强调的是，这个时间并不是从Session被创建开始计时的生命周期时长，而是从最后一次被访问开始计时,在指定的时长内一直未被访问的时长。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置Session失效时间。单位：分钟--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>120<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>若未到超时时限，也可通过代码提前使Session 失效。Httsession 中的方法Inalide(),使得Session失效。<ul>
<li>public void invalidate()</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使Session失效同时解绑所有的域属型。但失效的Session不为空</span></span><br><span class="line">session.invalidate();</span><br></pre></td></tr></table></figure>

<h2 id="4-4-Cookie禁用后使用Session进行会话跟踪"><a href="#4-4-Cookie禁用后使用Session进行会话跟踪" class="headerlink" title="4.4 Cookie禁用后使用Session进行会话跟踪"></a>4.4 Cookie禁用后使用Session进行会话跟踪</h2><ul>
<li>从前面Session的工作原理可知,服务器只所以可以针对不同的会话找到不同的Session,是因为Cookie完成了会话的跟踪。但是,若客户端浏览器将Cookie 禁用，那么服务器还怎样保证同一会话使用的是同一个Session 呢?</li>
<li>若客户端浏览器禁用了Cookie, 会发现向服务器所提交的每一次请求,服务器在给出的响应中都会包含名称为JSESSIONID 的Cookie, 只不过这个Cookie 的值每一次都不同。 也就是说，只要客户端刘览器所提交的请求中没有包含JSESSIONID, 服务器就会认为这是一次新的会话的开始,就会为其生成一个Map.Entry对象，key 为新的32位长度的随机串，value为新创建的Session 会话引用。这样的话,也就无法实现会话跟踪了。</li>
</ul>
<p><strong>手写重写URL</strong></p>
<ul>
<li><p>此时仍可以通过地址栏+:jsessionid=Cookie发过来的JSESSIONID 。来跟踪对应Session的状态。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210223084707.png"></p>
</li>
<li><p>此时将会出现一个问题：</p>
<ul>
<li>假设A用浏览器登录了淘宝网站。再访问一段时间后。走开了，B又过来使用此电脑记录下了A访问电脑时的Session的JSESSIONID 。</li>
<li>此时B在另一台电脑上访问淘宝，然后在地址栏中加上JSESSIONID 。即可使用A的账户了。</li>
</ul>
</li>
</ul>
<p><strong>重定向的URL重写</strong></p>
<ul>
<li>当浏览器禁掉Cookie时，重定向后的请求和重定向前的请求会是两个会话过程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String uri = req.getContextPath() + <span class="string">&quot;/otherServlet&quot;</span>;</span><br><span class="line"><span class="comment">//重新编码后的uri可以解决Cookie禁用后，Session禁用的问题。但会将JSESSIONID暴露在地址栏中</span></span><br><span class="line">uri = resp.encodeRedirectURL(uri);</span><br><span class="line">resp.sendRedirect(uri);</span><br></pre></td></tr></table></figure>

<p><strong>超链接的URL重写</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">String uri = <span class="string">&quot;otherServlet&quot;</span>;</span><br><span class="line"><span class="comment">//解决Cookie禁用后非重定向时的url</span></span><br><span class="line">uri = resp.encodeURL(uri);</span><br><span class="line">resp.getWriter().println(<span class="string">&quot;&lt;a href=&#x27;&quot;</span>+uri+<span class="string">&quot;&#x27;&gt;跳转&lt;/a&gt;到OtherServlet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="域属型空间范围对比"><a href="#域属型空间范围对比" class="headerlink" title="域属型空间范围对比"></a>域属型空间范围对比</h1><ul>
<li><p>在JavaWeb编程的API中,存在三个可以存放域属性的空间范围对象,这三个对象中所存储的域属性作用范围，由大到小分别为:</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210223122735.png"></p>
</li>
<li><p>ServletContext,即aplication,置入其中的域属性是整个应用范围的，可以完成跨会话共享数据。</p>
</li>
<li><p>HttpSession,置入其中的域属性是会话范围的，可以完成跨请求共享数据。</p>
</li>
<li><p>HttpServletRequest,置入其中的域属性是请求范围的，可以完成跨Servlet 共享数据。但这些Serlet必须在同一请求中。</p>
</li>
<li><p>对于这三个域属性空间对象的使用原则是,在可以保证功能需求的前提下,优先使用小范围的。这样不仅可以节省服务器内存，还可以保证数据的安全性。</p>
</li>
</ul>
<h1 id="第五章-监听器"><a href="#第五章-监听器" class="headerlink" title="第五章 监听器"></a>第五章 监听器</h1><ul>
<li>在Servlet规范中存在三大组件: Servlet 接口、Listener 接口、Filter 接口。这里要学习监听器接口Listener。 监听器是一种设计模式，是观察者设计模式的一种实现。</li>
</ul>
<h2 id="5-1-设计模式"><a href="#5-1-设计模式" class="headerlink" title="5.1 设计模式"></a>5.1 设计模式</h2><p><strong>(1) 创建型</strong></p>
<ul>
<li>通过特定方式创建特定对象的设计模式。例如，工厂方法模式、单例模式等。</li>
</ul>
<p><strong>(2) 结构型</strong></p>
<ul>
<li>为了解决某-特定问题所搭建的特定代码结构的设计模式。例如,适配器模式、代理模式等。</li>
</ul>
<p><strong>(3) 行为型</strong></p>
<ul>
<li>通过构建不同的角色来完成某一特定 功能的设计模式。例如，模板方法模式、观察者摸式等。</li>
</ul>
<h3 id="5-1-1-观察者设计模式"><a href="#5-1-1-观察者设计模式" class="headerlink" title="5.1.1 观察者设计模式"></a>5.1.1 观察者设计模式</h3><ul>
<li>从现实角度来说，我们每一个人都是一个观察者,同时也是一个被观察者。作为被观察者，我们会发出一些信息,观察者在接收到这些信息后,会做出相应的反映;而作为观察者，我们是可以被“被观察者”所发出的信息影响的一个被观察者，可能存在多个观察者。也就是说，一个被观察者所发出的信息，可能会影响到多个观察者。</li>
<li>观察者设计模式，定义了一种一对多的关联关系。一个对象A与多个对象B、C. D之间建立“被观察与观察关系”。当对象A的状态发生改变时，通知所有观察者对象B、C. D，当观察者对象B、C、D在接收到A的通知后，根据自身实际情况，做出相应改变。</li>
<li>当然，观察者与被观察者指的都是具有某一类功能的对象,所以这里的观察者与被观察者都是指的接口，而真正的观察者对象与被观察者对象，是指实现了这些接口的类的对象。</li>
</ul>
<p><strong>定义观察者接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObServer</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 处理被观察者发送来的信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleNotify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义被观察者接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObServerable</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加观察者</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> obServer</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addObServer</span><span class="params">(ObServer obServer)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除观察者</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> obServer</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">removeObServer</span><span class="params">(ObServer obServer)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 向观察者发送信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notifyObServers</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义观察者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一号观察者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstObServer</span> <span class="keyword">implements</span> <span class="title">ObServer</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNotify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;一号观察者接受到 &quot;</span> + message + <span class="string">&quot;信息&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二号观察者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondObServer</span> <span class="keyword">implements</span> <span class="title">ObServer</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNotify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;二号观察者接受到 &quot;</span> + message + <span class="string">&quot;信息&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义被观察者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Some</span> <span class="keyword">implements</span> <span class="title">ObServerable</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;ObServer&gt; observers;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Some</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObServer</span><span class="params">(ObServer obServer)</span> </span>&#123;</span><br><span class="line">    observers.add(obServer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObServer</span><span class="params">(ObServer obServer)</span> </span>&#123;</span><br><span class="line">    observers.remove(obServer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObServers</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通知每一个观察者</span></span><br><span class="line">    <span class="keyword">for</span> (ObServer observer : observers) &#123;</span><br><span class="line">      observer.handleNotify(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建多个观察者</span></span><br><span class="line">  ObServer first = <span class="keyword">new</span> FirstObServer();</span><br><span class="line">  ObServer second = <span class="keyword">new</span> SecondObServer();</span><br><span class="line">  <span class="comment">//创建被观察者</span></span><br><span class="line">  ObServerable some = <span class="keyword">new</span> Some();</span><br><span class="line">  <span class="comment">//被观察者添加观察者</span></span><br><span class="line">  some.addObServer(first);</span><br><span class="line">  some.addObServer(second);</span><br><span class="line">  <span class="comment">//被观察者向所有观察者发送消息</span></span><br><span class="line">  some.notifyObServers(<span class="string">&quot;全体起立&quot;</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">  <span class="comment">//被观察者删除观察者</span></span><br><span class="line">  some.removeObServer(first);</span><br><span class="line">  <span class="comment">//被观察者向所有观察者发送消息</span></span><br><span class="line">  some.notifyObServers(<span class="string">&quot;全体起立&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210227185948.png"></p>
<h3 id="5-1-2-监听器设计模式"><a href="#5-1-2-监听器设计模式" class="headerlink" title="5.1.2 监听器设计模式"></a>5.1.2 监听器设计模式</h3><ul>
<li>监听器设计模式，是观察者设计模式的一种实现，它并不是23种设计模式之一。</li>
<li>这里的监听器实际对应的就是观察者,而被监听对象，则是指被观察者。当被监听对象的状态发生改变时，也需要通知监听器，监听器在收到通知后会做出相应改变。</li>
<li>与观察者设计模式不同的是，被监听者的状态改变,被定义为了一个对象，称为事件;被监听对象有了个新的名子,称为事件源;对监听器的通知，称为触发监听器。其实质与观察者设计模式是相同的。</li>
<li>下面以对被监听者所执行的增删改查CURD操作进行监听为例,来演示监听器设计模式的用法。</li>
</ul>
<p><strong>定义事件接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义增删改查事件接口</span></span><br><span class="line"><span class="comment"> * C:Create 增加</span></span><br><span class="line"><span class="comment"> * U:Update 修改</span></span><br><span class="line"><span class="comment"> * R:Retrieve 检索</span></span><br><span class="line"><span class="comment"> * D:Delete 删除</span></span><br><span class="line"><span class="comment"> * 通过，对于事件对象，一般是可以事件对象中获取到事件源对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICurdEvent</span> </span>&#123;</span><br><span class="line">  <span class="comment">//声明事件类型</span></span><br><span class="line">  String CRE_EVENT = <span class="string">&quot;creat event&quot;</span>;</span><br><span class="line">  String UPD_EVENT = <span class="string">&quot;update event&quot;</span>;</span><br><span class="line">  String RET_EVENT = <span class="string">&quot;retrieve event&quot;</span>;</span><br><span class="line">  String DEL_EVENT = <span class="string">&quot;delete event&quot;</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *获取事件源对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">IListenerable <span class="title">getEventSource</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取事件类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">getEventType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义监听器接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IListener</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 处理事件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(ICurdEvent event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义事件源接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IListenerable</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 为事件源注册监听器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setListener</span><span class="params">(IListener listener)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 触发监听器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">triggerListener</span><span class="params">(ICurdEvent event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义事件类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurdEvent</span> <span class="keyword">implements</span> <span class="title">ICurdEvent</span> </span>&#123;</span><br><span class="line">  <span class="comment">//事件源</span></span><br><span class="line">  <span class="keyword">private</span> IListenerable eventSource;</span><br><span class="line">  <span class="comment">//事件源执行的方法名称</span></span><br><span class="line">  <span class="keyword">private</span> String methodName;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CurdEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CurdEvent</span><span class="params">(IListenerable eventSource, String methodName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.eventSource = eventSource;</span><br><span class="line">    <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IListenerable <span class="title">getEventSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> eventSource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getEventType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据事件源所执行的不同的方法，返回不同的事件</span></span><br><span class="line">    String eventType = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (methodName.startsWith(<span class="string">&quot;save&quot;</span>))&#123;</span><br><span class="line">      eventType = CRE_EVENT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.startsWith(<span class="string">&quot;remove&quot;</span>))&#123;</span><br><span class="line">      eventType = DEL_EVENT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.startsWith(<span class="string">&quot;modify&quot;</span>))&#123;</span><br><span class="line">      eventType = UPD_EVENT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.startsWith(<span class="string">&quot;find&quot;</span>))&#123;</span><br><span class="line">      eventType = RET_EVENT;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      eventType = <span class="string">&quot;have not this event type&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eventType;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义监听器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurdListener</span> <span class="keyword">implements</span> <span class="title">IListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ICurdEvent event)</span> </span>&#123;</span><br><span class="line">    String eventType = event.getEventType();</span><br><span class="line">    IListenerable eventSource = event.getEventSource();</span><br><span class="line"></span><br><span class="line">    System.out.print(eventSource + <span class="string">&quot;事件源执行了&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ICurdEvent.CRE_EVENT.equals(eventType))&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;添加操作&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ICurdEvent.DEL_EVENT.equals(eventType))&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;删除操作&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ICurdEvent.RET_EVENT.equals(eventType))&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;查询操作&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ICurdEvent.UPD_EVENT.equals(eventType))&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;修改操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义事件源</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Some</span> <span class="keyword">implements</span> <span class="title">IListenerable</span> </span>&#123;</span><br><span class="line">  <span class="comment">//声明一个监听器</span></span><br><span class="line">  <span class="keyword">private</span> IListener listener;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setListener</span><span class="params">(IListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listener = listener;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">triggerListener</span><span class="params">(ICurdEvent event)</span> </span>&#123;</span><br><span class="line">    listener.handle(event);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//下面的方法就是事件源的业务方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;向DB中插入一条数据&quot;</span>);</span><br><span class="line">    ICurdEvent event = <span class="keyword">new</span> CurdEvent(<span class="keyword">this</span>,<span class="string">&quot;saveStudent&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.triggerListener(event);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;查找DB中的数据&quot;</span>);</span><br><span class="line">    ICurdEvent event = <span class="keyword">new</span> CurdEvent(<span class="keyword">this</span>,<span class="string">&quot;findStudent&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.triggerListener(event);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;移除了DB中的一条数据&quot;</span>);</span><br><span class="line">    ICurdEvent event = <span class="keyword">new</span> CurdEvent(<span class="keyword">this</span>,<span class="string">&quot;removeStudent&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.triggerListener(event);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;修改了DB的一条数据&quot;</span>);</span><br><span class="line">    ICurdEvent event = <span class="keyword">new</span> CurdEvent(<span class="keyword">this</span>,<span class="string">&quot;modifyStudent&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.triggerListener(event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//定义监听器</span></span><br><span class="line">  IListener listener = <span class="keyword">new</span> CurdListener();</span><br><span class="line">  <span class="comment">//定义事件源</span></span><br><span class="line">  Some some = <span class="keyword">new</span> Some();</span><br><span class="line">  <span class="comment">//事件源注册监听器</span></span><br><span class="line">  some.setListener(listener);</span><br><span class="line">  <span class="comment">//事件源执行业务方法</span></span><br><span class="line">  some.saveStudent();</span><br><span class="line">  some.findStudent();</span><br><span class="line">  some.removeStudent();</span><br><span class="line">  some.modifyStudent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210223142833.png"></p>
<h2 id="5-2-监听器Listener"><a href="#5-2-监听器Listener" class="headerlink" title="5.2 监听器Listener"></a>5.2 监听器Listener</h2><h3 id="5-2-1-Servlet中的监听器"><a href="#5-2-1-Servlet中的监听器" class="headerlink" title="5.2.1 Servlet中的监听器"></a>5.2.1 Servlet中的监听器</h3><ul>
<li><p>Servlet规范中已经定义好了八个监听器接口,它们要监听的对象分别是request、session、servletContext对象，触发监听器的事件是这三个对象的创建与销毁，它们的域属性空间中属性的添加、删除、修改，及session的钝化与活化操作。</p>
</li>
<li><p>在JavaWeb项目中使用监听器，需要在web.xml文件中对监听器进行注册。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.lc.Listener.MyListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>(1) ServletRequestListener</strong></p>
<ul>
<li>此监听器用于监听request请求的创建和销毁。内部有两个方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRequestListener</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请求对象被销毁&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请求对象被创建&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2) ServletRequestAttributeListener</strong></p>
<ul>
<li>此监听器用于监听request域中的域属型的添加，修改和删除。内部包含三个方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRequestAttributeListener</span> <span class="keyword">implements</span> <span class="title">ServletRequestAttributeListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletRequestAttributeEvent srae)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;向request域中添加属性：&quot;</span>+srae.getName() + <span class="string">&quot;=&quot;</span> + srae.getValue());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletRequestAttributeEvent srae)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;向request域中删除属性&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletRequestAttributeEvent srae)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;替换request域中的属性&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(3) HttpSessionListener</strong></p>
<ul>
<li>此监听器用于监听创建的创建和销毁。内部有两个方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySessionListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Session正被创建&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Session正被销毁&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(4) HttpSessionAttributeListener</strong></p>
<ul>
<li>此监听器用于监听Session域中的域属型的添加，修改和删除。内部包含三个方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySessionAttributeListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionAttributeListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(HttpSessionBindingEvent se)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;正在往Session中添加域属型&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(HttpSessionBindingEvent se)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;正在删除Session中的域属型&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(HttpSessionBindingEvent se)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;正在修改Session中的域属型&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(5) ServletContextListener</strong></p>
<ul>
<li>该监听器用于完成对ServletContext 对象的创建及销毁的监听。不过需要注意，由于ServletContext在一个应用中只有一个，且是在服务器启动时创建。另外，ServletConetxt 的生命周期与整个应用的相同，所以当项目重新部署，或Tomcat正常关闭(通过stop service关闭，不能是terminate关闭)时，可以销ServletContext。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletContextListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ServletContext被创建&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ServletContext被销毁。服务器正在关闭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(6) ServletContextAttributeListener</strong></p>
<ul>
<li>该监听器用于完成对ServletContext 域中属性的添加，重置，删除的监听。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletContextAttributeListener</span>  <span class="keyword">implements</span> <span class="title">ServletContextAttributeListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletContextAttributeEvent scae)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;往ServletContext中添加域属型&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletContextAttributeEvent scae)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;删除ServletContext中的域属型&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletContextAttributeEvent scae)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;重置ServletContext中的域属型&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(7) HttpSessionBindingListener</strong></p>
<ul>
<li>该监听器用于完成对实现类绑定到Session域中和解绑的监听。</li>
<li>注意：<ul>
<li>该监听器接口需要被实体类实现。即Student ,User等实体类。</li>
<li>该监听器不需要注册。即不需要在web.xml中配置。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">HttpSessionBindingListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//当当前类的对象绑定到Session时会触发该方法的执行</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">valueBound</span><span class="params">(HttpSessionBindingEvent event)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Student对象放入到了Session域中&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//当当前类的对象与Session解绑时会触发该方法的执行</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">valueUnbound</span><span class="params">(HttpSessionBindingEvent event)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Student对象从Session域中删除&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Student student = new Student();</span></span><br><span class="line"><span class="comment">student.setName(&quot;asd&quot;);</span></span><br><span class="line"><span class="comment">student.setAge(18);</span></span><br><span class="line"><span class="comment">//Session绑定</span></span><br><span class="line"><span class="comment">session.setAttribute(&quot;student&quot;, student);</span></span><br><span class="line"><span class="comment">//Session解绑</span></span><br><span class="line"><span class="comment">session.removeAttribute(&quot;student&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>(8) HttpSessionActivationListener</strong></p>
<ul>
<li>该监听器用于监听在Session中存放的指定类型对象的钝化与活化。</li>
<li>钝化是指将内存中的数据写入到硬盘中，而话化是指将硬盘中的数据恢复到内存。当用户正在访问的应用或该应用所在的服务器由于种种原因被停掉,然后在短时间内又重启，此时用户在访问时session中的数据是不能丢掉的,在应用关闭之前,需要将数据写入到硬盘,在重启后应可以立即重新恢复Session中的数据。这就称为Session的钝化与活化。</li>
<li>那么Session中的哪些数据能够钝化呢?只有存放在JVM堆内存中的实现了Serializable类的对象能够被钝化。也就是说，对于字符串常量、基本数据类型常量等存放在JVM方法区中常量池中的常量，是无法被钝化的。</li>
<li>对干监听Session中对象数据的钝化与活化，需要注意以下几点:<ul>
<li>该接口需要由实体类实现。即Student,User等类似的类。</li>
<li>实体类实现该接口时还要实现Serializable序列化接口。</li>
<li>该监听器不需要注册。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">HttpSessionActivationListener</span>,<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//当当前类的对象被钝化(内存中的数据写入到硬盘)时会触发该方法的执行</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionWillPassivate</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Student对象将要被钝化&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//当当前类的对象被活化(硬盘中的数据回复到内存中)时会触发该方法的执行</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDidActivate</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Student对象以经被活化&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-2-监听器应用举例"><a href="#5-2-2-监听器应用举例" class="headerlink" title="5.2.2 监听器应用举例"></a>5.2.2 监听器应用举例</h3><p><strong>客户端数量统计</strong></p>
<ul>
<li>要求：统计在线客户端的数量。</li>
<li>解决方案：</li>
<li>第一步：在服务器的全局域中创建一个Map的域属型。map中key为ip,用于区分客户端。map中value为List&lt;HttpSession&gt;,用于保存一个客户端发送的所有会话。这一步是在ServletContextListener监听器中完成的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletContextListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个map。map的key为ip,value为该ip上发送出的所有会话对象</span></span><br><span class="line">    Map&lt;String,List&lt;HttpSession&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    ServletContext context = sce.getServletContext();</span><br><span class="line">    context.setAttribute(<span class="string">&quot;map&quot;</span>, map);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二步：针对请求的处理。找出当前请求的Session和IP，判断其是否要放入到全局域中的map中。这一步是在ServletRequestListener监听器中完成的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRequestListener</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前request</span></span><br><span class="line">    HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();</span><br><span class="line">    <span class="comment">//获取当前ip</span></span><br><span class="line">    String IP = request.getRemoteAddr();</span><br><span class="line">    System.out.println(<span class="string">&quot;ip = &quot;</span> + IP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前session</span></span><br><span class="line">    HttpSession session = request.getSession();</span><br><span class="line">    <span class="comment">//获取全局域</span></span><br><span class="line">    ServletContext context = sre.getServletContext();</span><br><span class="line">    <span class="comment">//从全局域中获取map</span></span><br><span class="line">    Map&lt;String, List&lt;HttpSession&gt;&gt; map = (Map&lt;String, List&lt;HttpSession&gt;&gt;) context.getAttribute(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">    <span class="comment">//从map中获取由当前ip发出的所有Session组成的list。</span></span><br><span class="line">    List&lt;HttpSession&gt; sessions = map.get(IP);</span><br><span class="line">    <span class="comment">//判断list是否为空。</span></span><br><span class="line">    <span class="keyword">if</span> (sessions == <span class="keyword">null</span>)&#123;</span><br><span class="line">      sessions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历list是否已存在这个会话</span></span><br><span class="line">    <span class="keyword">for</span> (HttpSession httpSession : sessions) &#123;</span><br><span class="line">      <span class="keyword">if</span> (httpSession == session)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sessions.add(session);</span><br><span class="line">    <span class="comment">//将变化后的list放回map中</span></span><br><span class="line">    map.put(IP,sessions);</span><br><span class="line">    <span class="comment">//将变化后的map放回域中</span></span><br><span class="line">    context.setAttribute(<span class="string">&quot;map&quot;</span>,map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将当前IP放入到当前Session中。方便session结束时判断是否在线客户端是否改变</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;ip&quot;</span>, IP);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第三步：对于每一次的会话结束(即关闭浏览器)，需要判断此次会话的客户端ip是否已经全部关闭。这一步是在HttpSessionListener监听器中完成的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySessionListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前sessiona</span></span><br><span class="line">    HttpSession session = se.getSession();</span><br><span class="line">    <span class="comment">//获取当前ip</span></span><br><span class="line">    String ip = (String) session.getAttribute(<span class="string">&quot;ip&quot;</span>);</span><br><span class="line">    <span class="comment">//获取全局域</span></span><br><span class="line">    ServletContext context = session.getServletContext();</span><br><span class="line">    <span class="comment">//获取map</span></span><br><span class="line">    Map&lt;String, List&lt;HttpSession&gt;&gt; map = (Map&lt;String, List&lt;HttpSession&gt;&gt;) context.getAttribute(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">    <span class="comment">//获取list</span></span><br><span class="line">    List&lt;HttpSession&gt; sessions = map.get(ip);</span><br><span class="line">    <span class="comment">//从list中删除当前session</span></span><br><span class="line">    sessions.remove(session);</span><br><span class="line">    <span class="comment">//对当前ip包含的session列表进行判空处理</span></span><br><span class="line">    <span class="keyword">if</span> (sessions.size() == <span class="number">0</span>)&#123;</span><br><span class="line">      map.remove(ip);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map.put(ip,sessions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将变化后的map放到全局域中</span></span><br><span class="line">    context.setAttribute(<span class="string">&quot;map&quot;</span>,map);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>第四步：页面的显示，及会话结束的方式。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogoutServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    request.getSession().invalidate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  在线用户已有$&#123;applicationScope.map.size()&#125;人数&lt;br&gt;</span><br><span class="line">  安全&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/logout&quot;&gt;退出&lt;/a&gt;&lt;br&gt;</span><br><span class="line">  &lt;c:forEach items=<span class="string">&quot;$&#123;applicationScope.map&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;entry&quot;</span>&gt;</span><br><span class="line">    $&#123;entry.key&#125; = $&#123;entry.value.size()&#125;&lt;br&gt;</span><br><span class="line">  &lt;/c:forEach&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p><strong>管理员踢出用户</strong></p>
<ul>
<li></li>
<li></li>
</ul>
<h1 id="第六章-过滤器"><a href="#第六章-过滤器" class="headerlink" title="第六章 过滤器"></a>第六章 过滤器</h1><ul>
<li>Filter是Servlet规范的三大组件之一。顾名思义，就是过滤。可以在请求到达目标资源之前先对请求进行拦截过滤，即对请求进行一些处理 ;也可以在响应到达客户端之前先对响应进行拦截过滤，即对响应进行一些处理。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210224093841.png"></p>
<h2 id="6-1-Filter的生命周期"><a href="#6-1-Filter的生命周期" class="headerlink" title="6.1 Filter的生命周期"></a>6.1 Filter的生命周期</h2><ul>
<li>Filter的生命周期与Servlet的生命周期类似，其主要生命周期阶段有四个:Filter对象的创建、Filter 对象的初始化、Filter 执行doFilter()方法，及最终Filter 对象被销毁。</li>
<li>Filter的整个生命周期过程的执行，均由Web服务器负责管理。即Filter从创建到销毁的整个过程中方法的调用，都是由Web服务器负责调用执行，程序员无法控制其执行流程。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210224094554.png"></p>
<p><strong>1.Filter的简单使用</strong></p>
<ul>
<li>定义Filter</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SomeFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;创建SomeFilter&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;初始化SomeFilter&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了SomeFilter --before--&quot;</span>);</span><br><span class="line">    <span class="comment">//下面代码的作用：将请求放行到下一个资源</span></span><br><span class="line">    filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了SomeFilter --after--&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;销毁SomeFilter&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注册Filter</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>some-fliter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>fliters.SomeFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>some-fliter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--配置Filter的要过滤的请求路径--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.Filter的特征</strong></p>
<ul>
<li>(1) Filter 是单例多线程的。</li>
<li>(2 )Filter是在应用被加载时创建并初始化,这是与Servlet不同的地方。Servlet是在该Servlet被第一次访问时创建。Filter与Servlet的共同点是,其无参构造器与init()方法只会执行- -次。</li>
<li>(3)用户每提交- -次该Filter 可以过滤的请求，服务器就会执行一次doFilter()方法， 即doFilter()方法是可以被多次执行的。</li>
<li>(4)当应用被停止时执行destroy()方法，Filter 被销毁，即destroy()方法只会执行一次。</li>
<li>(5) 由于Filter是单例多线程的，所以为了保证其线程安全性，一般情况下是不为Filter类定义可修改的成员变量的。因为每个线程均可修改这个成员变量，会出现线程安全问题。</li>
</ul>
<h2 id="6-2-FilterConfig"><a href="#6-2-FilterConfig" class="headerlink" title="6.2 FilterConfig"></a>6.2 FilterConfig</h2><ul>
<li>FilterConfig是Filter在web.xml中的配置信息。</li>
<li>FilterConfig中有四个方法。使用方式如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> FilterConfig config;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    config = filterConfig;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">//获取Filter名字</span></span><br><span class="line">    String filterName = config.getFilterName();</span><br><span class="line">    System.out.println(<span class="string">&quot;filterName = &quot;</span> + filterName);</span><br><span class="line">    <span class="comment">//获取Filter所有的初始化参数名</span></span><br><span class="line">    Enumeration&lt;String&gt; names = config.getInitParameterNames();</span><br><span class="line">    <span class="keyword">while</span> (names.hasMoreElements()) &#123;</span><br><span class="line">      String name = names.nextElement();</span><br><span class="line">      <span class="comment">//获取name对应的初始化参数值</span></span><br><span class="line">      String value = config.getInitParameter(name);</span><br><span class="line">      System.out.println(<span class="string">&quot;initName = &quot;</span> + name);</span><br><span class="line">      System.out.println(<span class="string">&quot;initValue = &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取应用全局域</span></span><br><span class="line">    ServletContext context = config.getServletContext();</span><br><span class="line">    System.out.println(context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>web.xml中的配置信息如下</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>second-fliter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>fliters.SecondFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--放置Filte的初始化参数--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>lisi<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>age<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>18<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>second-fliter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--配置Filter的要过滤的请求路径--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-3-Filter的-lt-url-pattern-gt"><a href="#6-3-Filter的-lt-url-pattern-gt" class="headerlink" title="6.3 Filter的&lt;url-pattern/&gt;"></a>6.3 Filter的&lt;url-pattern/&gt;</h2><ul>
<li>注意事项：<ul>
<li>若Filter的url-pattern为全路径匹配方式，那么url-pattern只能写为/*，而不能写为/</li>
<li>当filter-mapping中不写url-pattern时，必须写Servlet-Name。此时表示的是。当访问该Servlet-Name时。过滤这个访问的请求。</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>second-fliter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--若Filter为全路径匹配方式，那么url-pattern只能写为/*，而不能写为/--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;url-pattern&gt;/&lt;/url-pattern&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   当filter-mapping中不写url-pattern时，必须写servlet-name。</span></span><br><span class="line"><span class="comment">   此时表示的是。当访问该servlet-name时。过滤这个访问的请求。</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>some-servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>some-servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   对于Servlet来说：</span></span><br><span class="line"><span class="comment">   /*表示拦截所有资源请求。包括动态资源和静态资源。</span></span><br><span class="line"><span class="comment">   /表示拦截所有资源请求。但不包括动态资源。</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/someServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-4-lt-dispatcher-gt-标签"><a href="#6-4-lt-dispatcher-gt-标签" class="headerlink" title="6.4 &lt;dispatcher/&gt;标签"></a>6.4 &lt;dispatcher/&gt;标签</h2><ul>
<li><p>该标签位于filter-mapping标签下。用于对拦截的请求进行进一步的约束。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>second-fliter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>这个标签的取值由五个。分别是： FORWARD, REQUEST(默认值),INCLUDE, ASYNC, and ERROR。</p>
</li>
<li><p>FORWARD：当前Filter只会拦截由RequestDispatcher 的forward()方法所转发的请求。其它请求均不拦截。</p>
</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210224124311.png"></p>
<ul>
<li>INCLUDE：当前Filter只会拦截由RequestDispatcher 的include()方法所转发的请求。其它请求均不拦截。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210224124224.png"></p>
<ul>
<li>REQUEST：当前Filter会拦截所有的请求。但不拦截forward()方法和include()方法转发的请求。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210224124507.png"></p>
<ul>
<li>ERROR：在web.xml中可以配置错误页面&lt;error-page&gt;。当发生指定错误会跳转到错误页面。而这个跳转同样是发出的请求。若dispatcher标签设置为ERROR，则只会拦截这样的请求。</li>
</ul>
<h2 id="6-5-Filter的使用"><a href="#6-5-Filter的使用" class="headerlink" title="6.5 Filter的使用"></a>6.5 Filter的使用</h2><ul>
<li>Filter可以在doFilter()方法中修改，拦截的请求和响应的数据。</li>
<li>多个Filter同时存在时。其执行顺序与其注册的先后顺序有关。执行过程如下：</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210224131110.png"></p>
<h2 id="6-6-Filter的执行原理"><a href="#6-6-Filter的执行原理" class="headerlink" title="6.6 Filter的执行原理"></a>6.6 Filter的执行原理</h2><ul>
<li>一个数组与一个Map:<ul>
<li>一个Map: Map的key为&lt;url-pattern/&gt;的值, value为Filter实例对象的引用</li>
<li>一个数组:存放着与请求相匹配的所有Filter</li>
</ul>
</li>
<li>执行原理:</li>
<li>当对某资源的请求到达Web容器时，会先对请求进行解析,使用解析出的URI作为比较对象,Map中查找是否存在相匹配的key。<ul>
<li>若存在，那么读取其value,即Filter对象的引用，将该引用存入到数组中。然后继续向后查找，直到将该Map查找完毕。这样在数组中就会存在按照查找顺序排好序的Filter引用。</li>
<li>数组初始化完毕后,开始按照数组元素顺序进行执行。所有数组中的Filter全部执行完毕后，再跳转到请求的目标资源。</li>
</ul>
</li>
</ul>
<h2 id="6-7-Filter的应用举例"><a href="#6-7-Filter的应用举例" class="headerlink" title="6.7 Filter的应用举例"></a>6.7 Filter的应用举例</h2><h3 id="6-7-1-装饰者设计模式"><a href="#6-7-1-装饰者设计模式" class="headerlink" title="6.7.1 装饰者设计模式"></a>6.7.1 装饰者设计模式</h3><ul>
<li>Decorator Pattefn, 能够在不修改目标类也不使用继承的情况下，动态地扩展一个类的功能。它是通过创建于个包装对象，也就是装饰者来达到增强目标类的目的的。</li>
<li>装饰者设计模式的实现有两个要求:<ul>
<li>装饰者类与目标类要实现相同的接口，或继承自相同的抽象类。</li>
<li>装饰者类中要有目标类的引用作为成员变量，而具体的赋值一般通过带参构造器完成。</li>
</ul>
</li>
<li>这两个要求的目的是，在装饰者类中的方法可以调用目标类的方法，以增强这个方法。而增强的这个方法是通过重写的方式进行的增强,所以要求实现相同的接口或继承相同的抽象类。</li>
<li>在装饰者设计模式中,装饰者类一般是不对目标类进行增强的。装饰者类作为一个基类，具体的装饰者继承自这个基类，对目标类进行具体的、单功能的增强。这样做的好处是，在很方便的情况下实现多重地，组合式地增强。</li>
</ul>
<h3 id="6-7-2-应用举例"><a href="#6-7-2-应用举例" class="headerlink" title="6.7.2 应用举例"></a>6.7.2 应用举例</h3><ul>
<li>对于请求和响应中的中文乱码问题的解决方案：<ul>
<li>自定义一个请求的装饰者，装饰者继承装饰者基类。在装饰者中解决中文乱码的问题，并替换request请求的具体实现类为自定的装饰者类。</li>
</ul>
</li>
<li>装饰者类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRequest</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String oldCharsetName = <span class="string">&quot;ISO8859-1&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String newCharsetName = <span class="string">&quot;utf-8&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CustomRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(request);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将原始的map替换为新的map。</span></span><br><span class="line"><span class="comment">   * 原因：原始map中的中文数据是乱码的。在解决中文乱码后放到新map中。</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Map&lt;String, String[]&gt; getParameterMap() &#123;</span><br><span class="line">    <span class="comment">//新建一个新map</span></span><br><span class="line">    Map&lt;String, String[]&gt; newMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//获取原始的map</span></span><br><span class="line">    Map&lt;String, String[]&gt; oldMap = <span class="keyword">super</span>.getParameterMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*   解决原始Map中的中文乱码问题    */</span></span><br><span class="line">    <span class="comment">//遍历原始的map</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (String key : oldMap.keySet()) &#123;</span><br><span class="line">        <span class="comment">//获取当前遍历key的所有值</span></span><br><span class="line">        String[] values = oldMap.get(key);</span><br><span class="line">        <span class="comment">//遍历values，对每一个值的中文乱码问题解决</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">          <span class="comment">//按当前编码将数据打散成二进制流。</span></span><br><span class="line">          <span class="keyword">byte</span>[] bytes = values[i].getBytes(oldCharsetName);</span><br><span class="line">          <span class="comment">//将二进制流按照目标编码方式进行组装</span></span><br><span class="line">          values[i] = <span class="keyword">new</span> String(bytes,newCharsetName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将解决了乱码问题的数据放入到新map中</span></span><br><span class="line">        newMap.put(key,values);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newMap;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getParameterNames();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">    Map&lt;String, String[]&gt; parameterMap = <span class="keyword">this</span>.getParameterMap();</span><br><span class="line">    <span class="keyword">return</span> parameterMap.get(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getParameterValues(name)[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>过滤器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">  <span class="comment">//当只想解决post请求的中文乱码问题时</span></span><br><span class="line">  <span class="comment">//req.setCharacterEncoding(&quot;UTF-8&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//解决get和post请求的中文乱码问题</span></span><br><span class="line">  req = <span class="keyword">new</span> CustomRequest((HttpServletRequest) req);</span><br><span class="line">  <span class="comment">//解决get和post响应时的中文乱码问题</span></span><br><span class="line">  resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">  chain.doFilter(req, resp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第七章-文件上传下载"><a href="#第七章-文件上传下载" class="headerlink" title="第七章 文件上传下载"></a>第七章 文件上传下载</h1><h2 id="7-1什么是上传与下载"><a href="#7-1什么是上传与下载" class="headerlink" title="7.1什么是上传与下载"></a>7.1什么是上传与下载</h2><ul>
<li>数据上传是指客户端向服务器上传数据,客户端向服务器发送的所有请求都属于数据上传。文件上传是数据上传的一种特例，指客户端向服务器上传文件。即将保存在客户端的文件上传至服务器中一个副本，保存到服务器中。</li>
<li>数据下载是指客户端从服务器上获取数据的过程。文件下载是数据下载的一种特例，指客户端从服务器下载文件,即将原本保存在服务器中的文件下载到到客户端中一个副本保存</li>
<li>通常我们对服务器所发出的请求,大多是文件下载请求,从服务器中下载文本、图片、声音、视频等文件，然后由客户端浏览器对这些文件进行解析后，才可能看到这些多媒体信息。</li>
<li>但我们这里所说的文件下载，指的是文件从服务器下载到浏览器后,浏览器并不直接解析，而是以附件的形式保存到客户端。</li>
<li>上传与下载的文件可以是文本文件、图片、声音、视频等各种类型。</li>
</ul>
<h2 id="7-2-文件的上传"><a href="#7-2-文件的上传" class="headerlink" title="7.2 文件的上传"></a>7.2 文件的上传</h2><h3 id="7-2-1-上传表单的要求"><a href="#7-2-1-上传表单的要求" class="headerlink" title="7.2.1 上传表单的要求"></a>7.2.1 上传表单的要求</h3><ul>
<li><p>文件上传要求客户端表单提交特殊的请求— multipart请求,即包含多部分数据的请求。所以文件上传表单对于表单数据的编码类型要求,必须为mutipart/form-data 。即要为&lt;fom/&gt;标签指定enctype属性值为“mutipart/form-data”。enctype,即encoding type : 编码类型。</p>
</li>
<li><p>由于客户端上传文件的大小是不确定的，所以HTTP协议规定，文件上传的数据要存放于请求正文中，而不能出现在URL的地址栏中，因为地址栏中可以存放的数据量太小。也就是说，文件上传的表单，必须提交POST请求，而不能提交GET请求。        </p>
</li>
<li><p>multipart请求和普通请求的请求正文有些不一样</p>
<ul>
<li>multipart请求.其中—————————–22445177718463892833146896101为分隔符。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------22445177718463892833146896101</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;name&quot;</span><br><span class="line"></span><br><span class="line">as</span><br><span class="line">-----------------------------22445177718463892833146896101</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;age&quot;</span><br><span class="line"></span><br><span class="line">12</span><br><span class="line">-----------------------------22445177718463892833146896101</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;photo&quot;; filename&#x3D;&quot;新建文本文档.txt&quot;</span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line"></span><br><span class="line">添加新的别名</span><br><span class="line">-----------------------------22445177718463892833146896101--</span><br></pre></td></tr></table></figure>

<ul>
<li>普通请求</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name&#x3D;as&amp;age&#x3D;12</span><br></pre></td></tr></table></figure></li>
<li><p>multipart请求样式</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--    文件上传表单--%&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/submit&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">  姓名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">  年龄：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">  照片：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;photo&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-3-使用第三方工具解析上传的文件"><a href="#7-2-3-使用第三方工具解析上传的文件" class="headerlink" title="7.2.3 使用第三方工具解析上传的文件"></a>7.2.3 使用第三方工具解析上传的文件</h3><ul>
<li>需要两个jar包。两个jar包要一起使用。将压缩包导入到web项目下的lib文件中。<ul>
<li><a target="_blank" rel="noopener" href="https://plumriver.lanzous.com/iK0wcm3uhob">fileupload</a></li>
<li><a target="_blank" rel="noopener" href="https://plumriver.lanzous.com/isPGVm3uqkb">io</a></li>
</ul>
</li>
</ul>
<p><strong>基础的代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> isMultipart = ServletFileUpload.isMultipartContent(request);</span><br><span class="line">  <span class="comment">//判断请求是否是Multipart请求</span></span><br><span class="line">  <span class="keyword">if</span> (!isMultipart)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;当前请求不支持文件上传&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个FileItem工厂</span></span><br><span class="line">    DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">    <span class="comment">//创建一个文件上传的核心组件</span></span><br><span class="line">    ServletFileUpload upload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line">    <span class="comment">//获取请求的正文信息的文件项</span></span><br><span class="line">    List&lt;FileItem&gt; items = upload.parseRequest(request);</span><br><span class="line">    <span class="comment">//遍历文件项</span></span><br><span class="line">    <span class="keyword">for</span> (FileItem item : items) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.isFormField()) &#123;</span><br><span class="line">        <span class="comment">//若文件为普通表单项。例如name=xx</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取表单项名称。即name</span></span><br><span class="line">        String fieldName = item.getFieldName();</span><br><span class="line">        <span class="comment">//获取表单项的值。即xx</span></span><br><span class="line">        String value = item.getString();</span><br><span class="line">        System.out.println(fieldName + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//若item为文件表单项</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取上传的文件名</span></span><br><span class="line">        String fileName = item.getName();</span><br><span class="line">        <span class="comment">//获取上传文件的输入流</span></span><br><span class="line">        InputStream is = item.getInputStream();</span><br><span class="line">        <span class="comment">//定义服务器接收文件的路径</span></span><br><span class="line">        String path = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">&quot;/file&quot;</span>);</span><br><span class="line">        <span class="comment">//创建文件路径</span></span><br><span class="line">        File fileDirectory = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span> (!fileDirectory.exists())&#123;</span><br><span class="line">          fileDirectory.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建接收文件的对象</span></span><br><span class="line">        File descFile = <span class="keyword">new</span> File(path,fileName);</span><br><span class="line">        <span class="comment">//创建接收文件的输出流</span></span><br><span class="line">        FileOutputStream os = <span class="keyword">new</span> FileOutputStream(descFile);</span><br><span class="line">        <span class="comment">//将上传的文件写道服务器中</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">          os.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭输入输出流</span></span><br><span class="line">        os.close();</span><br><span class="line">        is.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FileUploadException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决上传缓冲文件</strong></p>
<ul>
<li>在创建一个FileItem工厂后添加下面代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.设置临时文件的边界值.</span></span><br><span class="line"><span class="comment">//大于该值，上传文件会先保存在临时文件中，否则直接保存在服务器中。单位：字节。</span></span><br><span class="line">factory.setSizeThreshold(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1</span>);</span><br><span class="line"><span class="comment">//3.设置临时文件路径</span></span><br><span class="line">String tempPath = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">&quot;/temp&quot;</span>);</span><br><span class="line">File tempFile = <span class="keyword">new</span> File(tempPath);</span><br><span class="line"><span class="keyword">if</span> (!tempFile.exists())&#123;</span><br><span class="line">  tempFile.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">factory.setRepository(tempFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在关闭流操作添加下面代码</span></span><br><span class="line"><span class="comment">//8.删除临时文件</span></span><br><span class="line">item.delete()</span><br></pre></td></tr></table></figure>

<p><strong>解决上传时的中文乱码</strong></p>
<ul>
<li>在基础代码上修改为下面代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置每一个item的头部字符编码，其可以解决文件名的中文乱码问题。</span></span><br><span class="line">upload.setHeaderEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//获取表单项的值,以指定的字符串编码。即xx</span></span><br><span class="line">String value = item.getString(<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>解决上传多个文件，对单个文件和总量的限制</strong></p>
<ul>
<li>在创建文件上传的核心组件后添加如下代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置上传单个文件的最大边界值为2M</span></span><br><span class="line">upload.setFileSizeMax(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">2</span>);</span><br><span class="line"><span class="comment">//设置多个文件上传时的总和最大值为5M(只对上传多个文件时起效)</span></span><br><span class="line"><span class="comment">//注意此时</span></span><br><span class="line">upload.setSizeMax(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p><strong>解决上传文件存放的目录管理问题</strong></p>
<ul>
<li>以年月日分级存放文件。在定义服务器接收文件的路径后添加如下代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前系统时间</span></span><br><span class="line">Calendar now = Calendar.getInstance();</span><br><span class="line"><span class="comment">//获取年月日</span></span><br><span class="line"><span class="keyword">int</span> year = now.get(Calendar.YEAR);</span><br><span class="line"><span class="keyword">int</span> month = now.get(Calendar.MONTH)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> day = now.get(Calendar.DAY_OF_MONTH);</span><br><span class="line"></span><br><span class="line">path = path + <span class="string">&quot;/&quot;</span> + year + <span class="string">&quot;/&quot;</span> + month + <span class="string">&quot;/&quot;</span> + day;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-文件的下载"><a href="#7-3-文件的下载" class="headerlink" title="7.3 文件的下载"></a>7.3 文件的下载</h2><p><strong>超链接方式的文件下载</strong></p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--超链接方式的文件下载--%&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/resources/aaa.jpg&quot;</span>/&gt;&lt;br&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/resources/bbb.jar&quot;</span>/&gt;&lt;br&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/resources/ccc.zip&quot;</span>/&gt;&lt;br&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/resources/ddd.exe&quot;</span>/&gt;&lt;br&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/resources/eee.txt&quot;</span>/&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>缺点：<ul>
<li>下载文件的打开方式由浏览器决定。和服务器无关。(一般来说浏览器能解析的会在浏览器直接打开，浏览器无法解析的会另存为本地磁盘中)</li>
</ul>
</li>
</ul>
<p><strong>正常的文件下载</strong></p>
<ul>
<li>实现下载的文件都以附件的方式保存在磁盘中<ul>
<li>以get提交。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">  <span class="comment">//防止文件名出现中文乱码问题</span></span><br><span class="line">  String filename = <span class="string">&quot;车.jpg&quot;</span>;</span><br><span class="line">  <span class="comment">//打散</span></span><br><span class="line">  <span class="keyword">byte</span>[] filenameBytes = filename.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">  <span class="comment">//组装</span></span><br><span class="line">  filename = <span class="keyword">new</span> String(filenameBytes,<span class="string">&quot;ISO8859-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//修改响应的头部属性content-disposition值为attachment</span></span><br><span class="line">  <span class="comment">//同时设置文件名。</span></span><br><span class="line">  response.setHeader(<span class="string">&quot;content-disposition&quot;</span>,<span class="string">&quot;attachment;filename=&quot;</span> + filename);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取服务端资源文件的输入流</span></span><br><span class="line">  InputStream is = <span class="keyword">this</span>.getServletContext().getResourceAsStream(<span class="string">&quot;/resources/aaa.jpg&quot;</span>);</span><br><span class="line">  <span class="comment">//获取输出流</span></span><br><span class="line">  ServletOutputStream os = response.getOutputStream();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    os.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">  &#125;java</span><br><span class="line"></span><br><span class="line">    os.close();</span><br><span class="line">  is.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第八章-Servlet3-0"><a href="#第八章-Servlet3-0" class="headerlink" title="第八章 Servlet3.0"></a>第八章 Servlet3.0</h1><ul>
<li>往前的Servlet版本为Servlet2.5</li>
<li>Servlet3.0规范是JavaEE6.0规范中的子规范。其要求运行环境最低是JDK6.0, Tomcat7.0</li>
<li>而之前学习的是Servlet2.5版本的规范，其是JavaEE5.0规范的子规范。其要求运行环境最低是JDK5.0, Tomcat5.0</li>
</ul>
<h2 id="8-1-Servlet3-0的注解"><a href="#8-1-Servlet3-0的注解" class="headerlink" title="8.1 Servlet3.0的注解"></a>8.1 Servlet3.0的注解</h2><ul>
<li>   Servlet3.0规范中允许在定义Serf/let、 Filter 与Listener 三大组件时使用注解，而不用在Web.xml进行注册了。Servlet3.0规范允许项目没有web.xml配置文件。</li>
</ul>
<h3 id="8-1-1-Servlet注解"><a href="#8-1-1-Servlet注解" class="headerlink" title="8.1.1 Servlet注解"></a>8.1.1 Servlet注解</h3><ul>
<li>   Servlet3.0规范中使用@WebServlet()注解来注册当前的Servlet类。该注解具有多个属性,常用属性的类型与意义如下表所示:</li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">类型</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">name</td>
<td align="center">String</td>
<td align="center">表示Servlet的名字name。相当于&lt;servlet-name&gt;标签</td>
</tr>
<tr>
<td align="center">value/urlPatterns</td>
<td align="center">String[]</td>
<td align="center">表示此Servlet要匹配的请求路径。相当于&lt;url-pattern&gt;标签</td>
</tr>
<tr>
<td align="center">loadOnStartup</td>
<td align="center">int</td>
<td align="center">表示此Servlet创建的级别。相当于&lt;load-on-startup&gt;标签</td>
</tr>
<tr>
<td align="center">initParams</td>
<td align="center">WebInitParam[]</td>
<td align="center">表示此Servlet的初始化参数。注意值为注解数组。相当于&lt;init-param&gt;标签</td>
</tr>
</tbody></table>
<ul>
<li>对应的使用方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(value = &#123;&quot;/someServlet&quot;,&quot;/xxx&quot;&#125;,</span></span><br><span class="line"><span class="meta">            name = &quot;some-servlet&quot;,</span></span><br><span class="line"><span class="meta">            initParams = &#123;@WebInitParam(name = &quot;name&quot;,value = &quot;cl&quot;),</span></span><br><span class="line"><span class="meta">                          @WebInitParam(name = &quot;age&quot;,value = &quot;18&quot;)&#125;,</span></span><br><span class="line"><span class="meta">            loadOnStartup = 1</span></span><br><span class="line"><span class="meta">           )</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SomeServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;创建SomeServlet&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    PrintWriter writer = response.getWriter();</span><br><span class="line">    <span class="comment">//获取servletName</span></span><br><span class="line">    String servletName = <span class="keyword">this</span>.getServletName();</span><br><span class="line">    writer.println(servletName);</span><br><span class="line">    <span class="comment">//获取初始化参数</span></span><br><span class="line">    Enumeration&lt;String&gt; names = <span class="keyword">this</span>.getInitParameterNames();</span><br><span class="line">    <span class="keyword">while</span> (names.hasMoreElements()) &#123;</span><br><span class="line">      String name = names.nextElement();</span><br><span class="line">      String value = <span class="keyword">this</span>.getInitParameter(name);</span><br><span class="line">      writer.println(name + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-1-2-Filter注解"><a href="#8-1-2-Filter注解" class="headerlink" title="8.1.2 Filter注解"></a>8.1.2 Filter注解</h3><ul>
<li>Servlet3.0规范中使用@WebFilter()注解来注册当前的Filter类。该注解具有多个属性,常用属性的类型与意义如下表所示:</li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">类型</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">filterName</td>
<td align="center">String</td>
<td align="center">表示Filter的名字name。相当于&lt;filter-name&gt;标签</td>
</tr>
<tr>
<td align="center">initParams</td>
<td align="center">WebInitParam[]</td>
<td align="center">表示Filter的初始化参数。相当于&lt;init-param&gt;标签</td>
</tr>
<tr>
<td align="center">servletNames</td>
<td align="center">String[]</td>
<td align="center">表示Filter的过滤的Servlet。相当于&lt;servlet-name&gt;标签</td>
</tr>
<tr>
<td align="center">value/urlPatterns</td>
<td align="center">String[]</td>
<td align="center">表示Filter的过滤请求路径。相当于&lt;url-pattern&gt;标签</td>
</tr>
<tr>
<td align="center">dispatcherTypes</td>
<td align="center">DispatcherType[]</td>
<td align="center">表示Filter的过滤的请求类型。相当于&lt;dispatcher&gt;标签</td>
</tr>
</tbody></table>
<ul>
<li>使用方式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@WebFilter(servletNames = &quot;some-servlet&quot;)</span></span><br><span class="line"><span class="meta">@WebFilter(value = &quot;/*&quot;,dispatcherTypes = DispatcherType.FORWARD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;==========拦截前&quot;</span>);</span><br><span class="line">    chain.doFilter(req, resp);</span><br><span class="line">    System.out.println(<span class="string">&quot;==========拦截后&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-1-3-Listener注解"><a href="#8-1-3-Listener注解" class="headerlink" title="8.1.3 Listener注解"></a>8.1.3 Listener注解</h3><ul>
<li>Servlet3.0规范中使用@WebListener()注解来注册当前的Listener类.使用如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-1-4-Servlet3-0中的web-xml"><a href="#8-1-4-Servlet3-0中的web-xml" class="headerlink" title="8.1.4 Servlet3.0中的web.xml"></a>8.1.4 Servlet3.0中的web.xml</h3><ul>
<li>当web应用程序中即存在注解的注册，又存在web.xml中的注册。对于不同的组件会出现不同的效果。</li>
<li>若对于Servlet采用了两种方式同时进行注册，则需要注意:<ul>
<li>1.若两种方式的url-pattern值相同，则应用无法启动。</li>
<li>2.若两种方式的url-pattern值不同，那么相当于该Servlet具有两个url-pattern。</li>
</ul>
</li>
<li>若对于Filter采用了两种方式同时进行注册，则需要注意:<ul>
<li>无论url-pattern的值是否相同，其都是作为两个独立的Filter出现的。</li>
</ul>
</li>
<li>若对于Listener采用了两种方式同时进行注册，则需要注意:<ul>
<li>若对于Listener采用了两种方式同时进行注册，其仅仅是相当于一个Listener。</li>
</ul>
</li>
<li>除了上述的情况注意web.xml的头文件的属性信息。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span> <span class="attr">metadata-complete</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;web-app/&gt;中的属性metadata- complete的值</span></span><br><span class="line"><span class="comment">若为true,则表示对三大组件的注册方式，只有web.xml中的注册起作用，将忽略注解的注册。</span></span><br><span class="line"><span class="comment">若为false,则表示两种注册方式同时起作用。默认为false</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="8-2-Servlet3-0的文件上传"><a href="#8-2-Servlet3-0的文件上传" class="headerlink" title="8.2 Servlet3.0的文件上传"></a>8.2 Servlet3.0的文件上传</h2><ul>
<li>Servlet3.0提供了专门的文件上传API。HttpServletRequest中的getPart()方法可以完成单个文件上传，而getParts()方法可以完成多个文件上传。注意，这两个方法是从Servlet3.0开始定义的。</li>
<li>使用步骤：<ul>
<li>1.在页面中添加multipart上传。</li>
<li>2.在Servlet上添加MultipartConfig注解。用于表示当前Servlet可以处理Multipart请求。</li>
<li>3.创建服务器保存上传文件的目录路径</li>
<li>4.获取上传文件的数据</li>
<li>5.解析上传文件的原始名字</li>
<li>6.写入服务器</li>
</ul>
</li>
<li>上传页面代码</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--    文件上传表单--%&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/submitServlet&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">  姓名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">  年龄：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">  照片：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>处理上传请求的代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(value = &quot;/submitServlet&quot;,name = &quot;submit-servlet&quot;)</span></span><br><span class="line"><span class="meta">@MultipartConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubmitServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建服务器保存上传文件的目录路径</span></span><br><span class="line">    String path = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">&quot;/file&quot;</span>);</span><br><span class="line">    File dirFile = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="keyword">if</span> (!dirFile.exists())&#123;</span><br><span class="line">      dirFile.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取multipart请求中指定属性名字的上传文件的&quot;部分数据&quot;对象。</span></span><br><span class="line">    Part part = request.getPart(<span class="string">&quot;file&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析除原始文件名。</span></span><br><span class="line">    <span class="comment">//获取请求中的指定的头部信息</span></span><br><span class="line">    String header = part.getHeader(<span class="string">&quot;Content-Disposition&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> start = header.indexOf(<span class="string">&quot;filename=&quot;</span>);</span><br><span class="line">    String fileName = header.substring(start + <span class="number">10</span>, header.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成文件上传。将上传文件以xxx.txt的方式存放在path路径下</span></span><br><span class="line">    part.write(path+<span class="string">&quot;/&quot;</span>+fileName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-3-Servlet3-0的异步处理"><a href="#8-3-Servlet3-0的异步处理" class="headerlink" title="8.3 Servlet3.0的异步处理"></a>8.3 Servlet3.0的异步处理</h2><ul>
<li>这里的异步处理，是指服务端的异步处理，与AJAX是没有关系的。AIAX 是客户端的异步处理。</li>
</ul>
<h3 id="8-3-1-为什么使用Servlet异步"><a href="#8-3-1-为什么使用Servlet异步" class="headerlink" title="8.3.1 为什么使用Servlet异步"></a>8.3.1 为什么使用Servlet异步</h3><ul>
<li>Servlet是单例多线程的。当一个请求到达服务器后,服务器会马上为该请求创建一个相应的Servlet 线程,为该请求服务。那么,一个请求就一定会有一个Servlet线程为之服务吗?</li>
<li>答案是否定的。服务器会为每一个Servlet实例创建一个Servlet线程池,而线程池中该Servlet实例的线程对象并不是“取之不尽”的，而是有上限的。当达到该上限后，再有请求要访问该Servlet，那么该请求就只能等待了。只有当又有了空闲的Servlet线程对象后才能为该请求分配Servlet线程对象。</li>
<li>对于Servlet来说，其最典型的工作一般分为三步:<ul>
<li>接收并解析用户请求。</li>
<li>根据用户请求调用Service层代码进行计算。</li>
<li>将计算结果响应给客户端。</li>
</ul>
</li>
</ul>
<h3 id="8-3-2-Servlet异步的实现"><a href="#8-3-2-Servlet异步的实现" class="headerlink" title="8.3.2 Servlet异步的实现"></a>8.3.2 Servlet异步的实现</h3><ul>
<li>Servlet主线程代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//asyncSupported = true表示当前Servlet支持异步操作</span></span><br><span class="line"><span class="meta">@WebServlet(value = &quot;/first&quot;,asyncSupported = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">//获取异步上下文对象</span></span><br><span class="line">    AsyncContext asyncContext = request.startAsync();</span><br><span class="line">    <span class="comment">//创建耗时的子线程</span></span><br><span class="line">    FirstThread firstThread = <span class="keyword">new</span> FirstThread(asyncContext);</span><br><span class="line">    <span class="comment">//2.设置异步上下文对象的超时时限。默认的超时时限是30秒</span></span><br><span class="line">    <span class="comment">//当超时时，子线程的响应和请求将被结束。</span></span><br><span class="line">    <span class="comment">//asyncContext.setTimeout(5000);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//为异步操作添加异步监听器</span></span><br><span class="line">    asyncContext.addListener(<span class="keyword">new</span> AsyncListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异步操作完成时触发&quot;</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimeout</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异步操作超时时触发&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异步操作错误时触发&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartAsync</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异步操作启动时触发&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//开启异步上下文对象</span></span><br><span class="line">    asyncContext.start(firstThread);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>子线程代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AsyncContext asyncContext;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FirstThread</span><span class="params">(AsyncContext asyncContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.asyncContext = asyncContext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      HttpServletRequest request = (HttpServletRequest) asyncContext.getRequest();</span><br><span class="line">      HttpSession session = request.getSession();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i ======&quot;</span> + i);</span><br><span class="line">        sum = sum + i;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//将子线程的结果放到session中</span></span><br><span class="line">      session.setAttribute(<span class="string">&quot;message&quot;</span>, sum);</span><br><span class="line">      <span class="comment">//1.通知主线程：子线程执行完毕</span></span><br><span class="line">      <span class="comment">//asyncContext.complete();</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.dispatch()方法相当于请求转发的include()操作。可以结束子线程的请求与响应对象</span></span><br><span class="line">      asyncContext.dispatch(<span class="string">&quot;/show.jsp&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-3-异步的注意事项"><a href="#8-3-3-异步的注意事项" class="headerlink" title="8.3.3 异步的注意事项"></a>8.3.3 异步的注意事项</h3><ul>
<li>当Servlet接收到用户的请求后，开启了一个很耗时的子线程。<ul>
<li>再不做异步处理时，浏览器会接收到servlet线程的结果，但由于子线程很耗时。并不能接受到子线程的结果。</li>
</ul>
</li>
<li>使用异步处理的步骤<ul>
<li>1.配置Servlet的asyncSupported = true。以支持异步操作</li>
<li>2.在servlet中获取异步上下文对象。</li>
<li>2.在servlet中创建以“异步上下文对象”为参数的子线程对象。</li>
<li>3.在servlet中调用start()方法开启异步上下文。</li>
<li>4.结束子线程。</li>
</ul>
</li>
<li>在异步处理中。对异步对象ac的结束方式如下：<ul>
<li>1.在异步子线程中使用ac. complete()方法:该方法用于结束异步操作，并将与当前异步对象相关的request与response对象销毁。</li>
<li>在异步子线程中使用ac .dispatch(path)方法:该方法在结束异步操作的同时,会将参数所指定的页面内容包含到当前异步对象相关的标准输出流中。其执行效果相当于RequestDispatcher对象的include(path )方法的执行效果。</li>
<li>在异步Servlet主线程中通过ac.setTimeout()设置ac的超时时限，当超时时限到达时，异步对象及其相关的request与response对象销毁。</li>
</ul>
</li>
<li>在异步处理时，不推荐使用request和response对象。但可以使用类似session之类的对象。可以把子线程的结果放进入。能够方便用户体验。</li>
<li>对于异步操作可以添加<font color="red">监听器</font>。</li>
</ul>
<h2 id="8-4-Servlet3-0的组件可插性"><a href="#8-4-Servlet3-0的组件可插性" class="headerlink" title="8.4 Servlet3.0的组件可插性"></a>8.4 Servlet3.0的组件可插性</h2><ul>
<li>所谓组件可插性是指，JavaEE6.0 项目支持将打为Jar 包的Servlet、Filter、 Listener 直接插入到正在运行的Web项目中。当然，这些Jar包中同时包含有相应的配置文件。</li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV18z411i7gh?p=211">视频地址</a></li>
</ul>
<h2 id="8-5-Servlet3-0的三大组件动态注册"><a href="#8-5-Servlet3-0的三大组件动态注册" class="headerlink" title="8.5 Servlet3.0的三大组件动态注册"></a>8.5 Servlet3.0的三大组件动态注册</h2><ul>
<li>Servlet的三大组件的三大注册方式<ul>
<li>通过web.xml注册。</li>
<li>通过注解注册。</li>
<li>动态注册。</li>
</ul>
</li>
<li>Servlet3.0对于ServletContext进行了功能增强，可以对Servlet、Filter及Listener进行动态注册。所谓动态注册是指，Web应用在运行过程中通过代码对Servlet、 Filter 或Listener进行注册。</li>
<li>为了系统安全考虑，这个动态注册是有限制的:只能在应用启动时进行，而不能在应用运行过程中的进行注册。这个应用启动时间点，可以通过ServletContextListener监听器来把握。</li>
</ul>
<p><strong>Servlet动态注册</strong></p>
<ul>
<li>未注册的Servlet类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">    PrintWriter out = resp.getWriter();</span><br><span class="line">    out.println(<span class="string">&quot;DynamicServlet已被动态注册&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在ServletContextListener监听器的实现类中动态注册</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个servlet的名字，一个servlet的类路径。一般从配置文件中获取</span></span><br><span class="line"><span class="comment">//注意：当servletName设置为some-servlet时会注册不成功。dynamic对象为null</span></span><br><span class="line">String servletName = <span class="string">&quot;dynamicServlet&quot;</span>;</span><br><span class="line">String className = <span class="string">&quot;com.lc.mode3.DynamicServlet&quot;</span>;</span><br><span class="line"><span class="comment">//动态注册Servlet</span></span><br><span class="line">ServletRegistration.Dynamic dynamic = context.addServlet(servletName, className);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给servlet添加初始化信息</span></span><br><span class="line">dynamic.setInitParameter(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;cl&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给servlet添加url-pattern信息</span></span><br><span class="line">dynamic.addMapping(<span class="string">&quot;/dynamic&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Filter动态注册</strong></p>
<ul>
<li>未注册的Filter类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;过滤器前&quot;</span>);</span><br><span class="line">    chain.doFilter(request,response);</span><br><span class="line">    System.out.println(<span class="string">&quot;过滤器后&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在ServletContextListener监听器的实现类中动态注册</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String filterName = <span class="string">&quot;dynamicFilter&quot;</span>;</span><br><span class="line">String filterClassName = <span class="string">&quot;com.lc.mode3.DynamicFilter&quot;</span>;</span><br><span class="line">FilterRegistration.Dynamic filterDynamic = context.addFilter(filterName, filterClassName);</span><br><span class="line"><span class="comment">//配置当前filter的配置信息</span></span><br><span class="line"><span class="comment">//true表示对于相同url先执行其他filter在执行此filter.false则相反</span></span><br><span class="line">filterDynamic.addMappingForServletNames(EnumSet.of(DispatcherType.REQUEST),<span class="keyword">true</span>,<span class="string">&quot;dynamicServlet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Listener动态注册</strong></p>
<ul>
<li>未注册的Listener类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicListener</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;**********&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在ServletContextListener监听器的实现类中动态注册</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String listenerClassName = <span class="string">&quot;com.lc.mode3.DynamicListener&quot;</span>;</span><br><span class="line">context.addListener(listenerClassName);</span><br></pre></td></tr></table></figure>










    </div>

    
    
    


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/14/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/IDEA/tomcat/" rel="prev" title="tomcat配置">
      <i class="fa fa-chevron-left"></i> tomcat配置
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/18/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/JavaEE%E6%A1%86%E6%9E%B6/SpringMVC/" rel="next" title="SpringMVC的学习">
      SpringMVC的学习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-Servlet%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">第一章 Servlet基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 Servlet生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1 生命周期方法执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-Servlet%E7%89%B9%E5%BE%81"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2 Servlet特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3-Web%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E5%88%9B%E5%BB%BAServlet%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.1.3 Web容器启动时创建Servlet实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-4-Web%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AAMap"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.1.4 Web容器中的两个Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-5-%E5%85%B3%E4%BA%8EgetServletInfo-%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.1.5 关于getServletInfo()方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-ServletConfig"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 ServletConfig</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E4%BB%80%E4%B9%88%E6%98%AFServletConfig"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 什么是ServletConfig</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-%E8%8E%B7%E5%8F%96ServletConfig%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2 获取ServletConfig对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-ServletConfig%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3 ServletConfig中的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-ServletContext"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 ServletContext</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E6%AC%A2%E8%BF%8E%E9%A1%B5%E9%9D%A2%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 欢迎页面设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-url-pattern%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 url-pattern的使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-Servlet%E6%A0%B8%E5%BF%83"><span class="nav-number">2.</span> <span class="nav-text">第二章 Servlet核心</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-GenericServlet%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 GenericServlet的定义和使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-HttpServlet%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 HttpServlet的定义和使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-HttpServletRequest"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 HttpServletRequest</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-%E8%AF%B7%E6%B1%82%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1 请求的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2 请求参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-%E5%9F%9F%E5%B1%9E%E5%9E%8B"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3 域属型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="nav-number">2.3.4.</span> <span class="nav-text">2.3.4 服务端相关信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E5%85%B3%E4%BA%8E%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 关于乱码问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-%E8%A7%A3%E5%86%B3POST%E8%AF%B7%E6%B1%82%E7%9A%84%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81"><span class="nav-number">2.4.1.</span> <span class="nav-text">2.4.1 解决POST请求的中文乱码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-%E8%A7%A3%E5%86%B3GET%E8%AF%B7%E6%B1%82%E7%9A%84%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.4.2 解决GET请求的中文乱码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-HttpServletResponse"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 HttpServletResponse</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-%E5%90%91%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="nav-number">2.5.1.</span> <span class="nav-text">2.5.1 向客户端发送数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-%E5%93%8D%E5%BA%94%E6%97%B6%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.5.2 响应时出现乱码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 转发与重定向</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-1-%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91"><span class="nav-number">2.6.1.</span> <span class="nav-text">2.6.1 请求转发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-2-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">2.6.2.</span> <span class="nav-text">2.6.2 重定向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-3-%E9%87%8D%E5%AE%9A%E5%90%91%E6%97%B6%E7%9A%84%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F"><span class="nav-number">2.6.3.</span> <span class="nav-text">2.6.3 重定向时的乱码解决方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">2.6.4.</span> <span class="nav-text">.6.4 请求转发与重定向的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-5-%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">2.6.5.</span> <span class="nav-text">2.6.5 请求转发与重定向的选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-RequestDispatcher"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 RequestDispatcher</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-1-forward-%E4%B8%8Einclude"><span class="nav-number">2.7.1.</span> <span class="nav-text">2.7.1 forward()与include()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.8.</span> <span class="nav-text">2.8 访问路径问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-1-%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">2.8.1.</span> <span class="nav-text">2.8.1 访问路径的组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-2-%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="nav-number">2.8.2.</span> <span class="nav-text">2.8.2 绝对路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-3-%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="nav-number">2.8.3.</span> <span class="nav-text">2.8.3 相对路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BB%A5%E6%96%9C%E6%9D%A0%E5%BC%80%E5%A4%B4%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="nav-number">2.8.3.1.</span> <span class="nav-text">(1) 以斜杠开头的相对路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BB%A5%E8%B7%AF%E5%BE%84%E5%90%8D%E7%A7%B0%E5%BC%80%E5%A4%B4%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="nav-number">2.8.3.2.</span> <span class="nav-text">(2) 以路径名称开头的相对路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%80%BB%E7%BB%93"><span class="nav-number">2.8.3.3.</span> <span class="nav-text">(3) 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-4-%E5%AE%9E%E4%BE%8B"><span class="nav-number">2.8.4.</span> <span class="nav-text">2.8.4 实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-9-Servlet%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">2.9.</span> <span class="nav-text">2.9 Servlet的线程安全问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">2.9.1.</span> <span class="nav-text">2.9.1 线程安全问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-2-Servlet%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">2.9.2.</span> <span class="nav-text">2.9.2  Servlet的线程安全问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-Cookie"><span class="nav-number">3.</span> <span class="nav-text">第三章 Cookie</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-Cookie%E7%AE%80%E4%BB%8B"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 Cookie简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E7%81%AB%E7%8B%90%E4%B8%8B%E7%9A%84Cookie"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 火狐下的Cookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-JavaEE%E4%B8%AD%E7%9A%84Cookie"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 JavaEE中的Cookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-Cookie%E7%9A%84%E7%A6%81%E7%94%A8"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 Cookie的禁用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-Session"><span class="nav-number">4.</span> <span class="nav-text">第四章 Session</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-Session%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 Session的访问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-Session%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 Session的工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-Session%E7%9A%84%E5%A4%B1%E6%95%88"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 Session的失效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-Cookie%E7%A6%81%E7%94%A8%E5%90%8E%E4%BD%BF%E7%94%A8Session%E8%BF%9B%E8%A1%8C%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 Cookie禁用后使用Session进行会话跟踪</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%9F%E5%B1%9E%E5%9E%8B%E7%A9%BA%E9%97%B4%E8%8C%83%E5%9B%B4%E5%AF%B9%E6%AF%94"><span class="nav-number">5.</span> <span class="nav-text">域属型空间范围对比</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-number">6.</span> <span class="nav-text">第五章 监听器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.</span> <span class="nav-text">5.1 设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.1.</span> <span class="nav-text">5.1.1 观察者设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-%E7%9B%91%E5%90%AC%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.2.</span> <span class="nav-text">5.1.2 监听器设计模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E7%9B%91%E5%90%AC%E5%99%A8Listener"><span class="nav-number">6.2.</span> <span class="nav-text">5.2 监听器Listener</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-Servlet%E4%B8%AD%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-number">6.2.1.</span> <span class="nav-text">5.2.1 Servlet中的监听器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-%E7%9B%91%E5%90%AC%E5%99%A8%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">6.2.2.</span> <span class="nav-text">5.2.2 监听器应用举例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">7.</span> <span class="nav-text">第六章 过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-Filter%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">7.1.</span> <span class="nav-text">6.1 Filter的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-FilterConfig"><span class="nav-number">7.2.</span> <span class="nav-text">6.2 FilterConfig</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-Filter%E7%9A%84-lt-url-pattern-gt"><span class="nav-number">7.3.</span> <span class="nav-text">6.3 Filter的&lt;url-pattern&#x2F;&gt;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-lt-dispatcher-gt-%E6%A0%87%E7%AD%BE"><span class="nav-number">7.4.</span> <span class="nav-text">6.4 &lt;dispatcher&#x2F;&gt;标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-Filter%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.5.</span> <span class="nav-text">6.5 Filter的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-Filter%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-number">7.6.</span> <span class="nav-text">6.6 Filter的执行原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-7-Filter%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">7.7.</span> <span class="nav-text">6.7 Filter的应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-1-%E8%A3%85%E9%A5%B0%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.7.1.</span> <span class="nav-text">6.7.1 装饰者设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-2-%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">7.7.2.</span> <span class="nav-text">6.7.2 应用举例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD"><span class="nav-number">8.</span> <span class="nav-text">第七章 文件上传下载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD"><span class="nav-number">8.1.</span> <span class="nav-text">7.1什么是上传与下载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0"><span class="nav-number">8.2.</span> <span class="nav-text">7.2 文件的上传</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-%E4%B8%8A%E4%BC%A0%E8%A1%A8%E5%8D%95%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-number">8.2.1.</span> <span class="nav-text">7.2.1 上传表单的要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-3-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%A7%A3%E6%9E%90%E4%B8%8A%E4%BC%A0%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">8.2.2.</span> <span class="nav-text">7.2.3 使用第三方工具解析上传的文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8B%E8%BD%BD"><span class="nav-number">8.3.</span> <span class="nav-text">7.3 文件的下载</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-Servlet3-0"><span class="nav-number">9.</span> <span class="nav-text">第八章 Servlet3.0</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-Servlet3-0%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="nav-number">9.1.</span> <span class="nav-text">8.1 Servlet3.0的注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-1-Servlet%E6%B3%A8%E8%A7%A3"><span class="nav-number">9.1.1.</span> <span class="nav-text">8.1.1 Servlet注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-2-Filter%E6%B3%A8%E8%A7%A3"><span class="nav-number">9.1.2.</span> <span class="nav-text">8.1.2 Filter注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-3-Listener%E6%B3%A8%E8%A7%A3"><span class="nav-number">9.1.3.</span> <span class="nav-text">8.1.3 Listener注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-4-Servlet3-0%E4%B8%AD%E7%9A%84web-xml"><span class="nav-number">9.1.4.</span> <span class="nav-text">8.1.4 Servlet3.0中的web.xml</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-Servlet3-0%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="nav-number">9.2.</span> <span class="nav-text">8.2 Servlet3.0的文件上传</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-Servlet3-0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="nav-number">9.3.</span> <span class="nav-text">8.3 Servlet3.0的异步处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Servlet%E5%BC%82%E6%AD%A5"><span class="nav-number">9.3.1.</span> <span class="nav-text">8.3.1 为什么使用Servlet异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-2-Servlet%E5%BC%82%E6%AD%A5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.3.2.</span> <span class="nav-text">8.3.2 Servlet异步的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-3-%E5%BC%82%E6%AD%A5%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">9.3.3.</span> <span class="nav-text">8.3.3 异步的注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-Servlet3-0%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8F%AF%E6%8F%92%E6%80%A7"><span class="nav-number">9.4.</span> <span class="nav-text">8.4 Servlet3.0的组件可插性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-Servlet3-0%E7%9A%84%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C"><span class="nav-number">9.5.</span> <span class="nav-text">8.5 Servlet3.0的三大组件动态注册</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Plum Reiver</p>
  <div class="site-description" itemprop="description">技术，日常，笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">91</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
	
  </nav>
</div>


      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plum Reiver</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
