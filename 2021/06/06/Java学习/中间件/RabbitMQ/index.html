<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"plumv.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="sss包含RabbitMQ的基本知识，以及五种模型的使用。 与SpringBoot的集成使用。普通集群和镜像集群的搭建。">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ的学习">
<meta property="og:url" content="https://plumv.github.io/2021/06/06/Java%E5%AD%A6%E4%B9%A0/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/index.html">
<meta property="og:site_name" content="李川的个人博客">
<meta property="og:description" content="sss包含RabbitMQ的基本知识，以及五种模型的使用。 与SpringBoot的集成使用。普通集群和镜像集群的搭建。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604213434.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604225851.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605153314.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605153305.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605151200.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605151505.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605151749.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605152919.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605152847.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605153256.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605161001.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605154212.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605155800.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605154853.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605154857.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605160606.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605161107.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605163401.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605173352.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606172032.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605195821.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605204315.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605211830.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605204645.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606120304.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606140133.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606144736.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606145215.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606150232.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606151345.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606152230.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153236.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153249.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153246.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153150.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153141.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153047.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153930.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606165116.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606165129.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606154621.png">
<meta property="article:published_time" content="2021-06-05T16:00:00.000Z">
<meta property="article:modified_time" content="2021-06-06T09:20:35.382Z">
<meta property="article:author" content="Plum Reiver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604213434.png">

<link rel="canonical" href="https://plumv.github.io/2021/06/06/Java%E5%AD%A6%E4%B9%A0/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>RabbitMQ的学习 | 李川的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李川的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>日志</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://plumv.github.io/2021/06/06/Java%E5%AD%A6%E4%B9%A0/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plum Reiver">
      <meta itemprop="description" content="技术，日常，笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李川的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RabbitMQ的学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-06-06 00:00:00 / 修改时间：17:20:35" itemprop="dateCreated datePublished" datetime="2021-06-06T00:00:00+08:00">2021-06-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <ul>
<li>sss包含RabbitMQ的基本知识，以及五种模型的使用。</li>
<li>与SpringBoot的集成使用。普通集群和镜像集群的搭建。</li>
</ul>
<span id="more"></span>

<h1 id="MQ的简介"><a href="#MQ的简介" class="headerlink" title="MQ的简介"></a>MQ的简介</h1><ul>
<li>MQ (Message Queue):翻译为消息队列通过典型的<strong>生产者和消费者模型</strong>,生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是<strong>异步的</strong>，而且只关心消息的发送和接收，<strong>没有业务逻辑的侵入</strong>,轻松的实现系统间解耦。</li>
<li>别名为<strong>消息中间件</strong>通过利用高效可靠的消息传递机制进行平台无关的数据交流， 并基于数据通信来进行分布式系统的集成。</li>
<li>当今市面上有很多主流的消息中间件，如老牌的<strong>ActiveMQ</strong>、<strong>RabbitMQ</strong> , 炙手可热的<strong>Kafka</strong>，阿里巴巴自主开发<strong>RocketMQ</strong>等。</li>
<li>ActiveMQ：<ul>
<li>ActiveMQ是Apache出品， 最流行的，能力强劲的开源消息总线。它是一个完全支持JMS规范的的消息中间件。丰富的API,多种集群架构模式让ActiveMQ在业界成为老牌的消息中间件在中小型企业颇受欢迎!</li>
</ul>
</li>
<li>Kafka：<ul>
<li>Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pul1的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。</li>
</ul>
</li>
<li>RocketMQ：<ul>
<li>RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。</li>
<li>RocketMQ思路起源于Kafka,但并不是Kafka的一个Copy,它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、<em>binglog</em>分发等场景。</li>
</ul>
</li>
<li>RabbitMQ：<ul>
<li>RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于<em>AMQP</em>协议来实现。</li>
<li><em>AMQP</em>的主要特征是面向消息、队列、路由(包括点对点和发布/订阅)、可靠性、安全。<em>AMQP</em>协议更多用在企业系统内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</li>
</ul>
</li>
<li>总结：<ul>
<li>RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性(少量延迟)，可靠性(少量丢数据)要求稍低的场景使用，比如ELK日志收集。</li>
</ul>
</li>
</ul>
<h1 id="RabbitMQ的简介"><a href="#RabbitMQ的简介" class="headerlink" title="RabbitMQ的简介"></a>RabbitMQ的简介</h1><ul>
<li><p>基于AMOP协议，Erlang语言开发， 是部署最广泛的开源消息中间件,是最受欢迎的开源消息中间件之一。</p>
</li>
<li><p>特点：</p>
<ul>
<li>基于AMQP协议，此协议支持很多种消息中间件，有多种业务场景，比如点对点，发布，广播等。</li>
<li>使用Erlang语言开发。此语言作为Socket编程的性能是非常不错的。</li>
<li>RabbitMQ和Spring框架能够有很好的整合。</li>
<li>对于数据的一致性要求很多，能够达到几乎不丢失数据。能够恢复消息数据。</li>
</ul>
</li>
<li><p>官网：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></p>
</li>
<li><p>AMQP协议：</p>
<ul>
<li>AMQP (advanced message queuing prqtocol)在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。</li>
<li>顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol (链接协议)。 这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。</li>
<li>以下是AMQP协议模型:</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604213434.png"></p>
</li>
<li><p>AMQP模型说明：</p>
<ul>
<li>生产者和消费者之间没有任何通信，通过Server进行间接通信。</li>
<li>生产者先把消息发送到虚拟主机的交换机中。</li>
<li>消费者从消息队列中消费消息。</li>
<li>交换机和消费队列之间有很多种绑定形式。</li>
</ul>
</li>
</ul>
<h2 id="RabbitMQ的安装"><a href="#RabbitMQ的安装" class="headerlink" title="RabbitMQ的安装"></a>RabbitMQ的安装</h2><ul>
<li><p>虚拟机的安装</p>
</li>
<li><p>第一步：下载RabbitMQ和erlang的依赖。</p>
<ul>
<li>下载地址：<a target="_blank" rel="noopener" href="https://plumriver.lanzoui.com/b01cetjfg">https://plumriver.lanzoui.com/b01cetjfg</a> 密码:9uee</li>
</ul>
</li>
<li><p>第二步：将下载的文件传输到虚拟机上。</p>
</li>
<li><p>第三步：安装RabbitMQ和erlang。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# ls</span><br><span class="line">debug                           kernels                                  socat-1.7.3.2-2.el7.x86_64.rpm</span><br><span class="line">erlang-22.0.7-1.el7.x86_64.rpm  rabbitmq-server-3.7.18-1.el7.noarch.rpm</span><br><span class="line">[root@localhost src]# rpm -ivh erlang-22.0.7-1.el7.x86_64.rpm </span><br><span class="line">[root@localhost src]# rpm -ivh socat-1.7.3.2-2.el7.x86_64.rpm </span><br><span class="line">[root@localhost src]# rpm -ivh rabbitmq-server-3.7.18-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure>

<ul>
<li>安装后配置文件在/etc/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.exaplie目录中。</li>
<li>需要把配置文件复制到/etc/rabbitmq/目录中，把那个修改名称为rabbitmq.config</li>
</ul>
</li>
<li><p>第四步：复制配置文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# cp /usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</span><br><span class="line">[root@localhost /]# cd /etc/rabbitmq/</span><br><span class="line">[root@localhost rabbitmq]# ls</span><br><span class="line">rabbitmq.config</span><br></pre></td></tr></table></figure></li>
<li><p>第五步：修改配置文件。</p>
<ul>
<li>去掉前面的%,和后面的逗号。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;loopback_users, []&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>作用：打开后台管理页面的登录权限。</li>
</ul>
</li>
<li><p>第六步：启动RabbitMQ的插件管理。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# rabbitmq-plugins enable rabbitmq_management</span><br><span class="line">Enabling plugins on node rabbit@localhost:</span><br><span class="line">rabbitmq_management</span><br><span class="line">The following plugins have been configured:</span><br><span class="line">  rabbitmq_management</span><br><span class="line">  rabbitmq_management_agent</span><br><span class="line">  rabbitmq_web_dispatch</span><br><span class="line">Applying plugin configuration to rabbit@localhost...</span><br><span class="line">The following plugins have been enabled:</span><br><span class="line">  rabbitmq_management</span><br><span class="line">  rabbitmq_management_agent</span><br><span class="line">  rabbitmq_web_dispatch</span><br><span class="line">set 3 plugins.</span><br><span class="line">Offline change; changes will take effect at broker restart.</span><br></pre></td></tr></table></figure></li>
<li><p>第七步：启动RabbitMQ的服务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动rabbitmq服务</span></span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看rabbitmq服务的状态</span></span><br><span class="line">systemctl status rabbitmq-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启rabbitmq服务</span></span><br><span class="line">systemctl restart rabbitmq-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭rabbitmq服务</span></span><br><span class="line">systemctl stop rabbitmq-server</span><br></pre></td></tr></table></figure></li>
<li><p>第八步：关闭防火墙服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure></li>
<li><p>第九步：访问RabbitMQ的web管理界面</p>
<ul>
<li>地址：虚拟机ip+<strong>15672</strong>端口号</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210604225851.png"></p>
<ul>
<li>默认账号密码：guest</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605153314.png"></p>
</li>
</ul>
<h1 id="RabbitMQ的使用方式"><a href="#RabbitMQ的使用方式" class="headerlink" title="RabbitMQ的使用方式"></a>RabbitMQ的使用方式</h1><h2 id="以命令行的方式"><a href="#以命令行的方式" class="headerlink" title="以命令行的方式"></a>以命令行的方式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.服务启动相关。访问默认端口号为15672</span></span><br><span class="line"><span class="code">	systemctl start|restart|stop|status rabbitmq-server</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 2.管理命令行  用来在不使用web管理界面情况下命令操作RabbitMQ</span></span><br><span class="line"><span class="code">	rabbitmqctl  help  可以查看更多命令</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 3.插件管理命令行</span></span><br><span class="line"><span class="code">	rabbitmq-plugins enable|list|disable </span></span><br></pre></td></tr></table></figure>

<ul>
<li>一般情况下，很少使用命令行方式来操作RabbitMQ,一般使用后台管理界面的方式。</li>
</ul>
<h2 id="以后台管理界面的方式"><a href="#以后台管理界面的方式" class="headerlink" title="以后台管理界面的方式"></a>以后台管理界面的方式</h2><ul>
<li><p>页面介绍</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605153305.png"></p>
<ul>
<li><strong>connections</strong>：无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况。</li>
<li><strong>channels</strong>：通道，建立连接后，会形成通道，消息的投递获取依赖通道。</li>
<li><strong>Exchanges</strong>：交换机，用来实现消息的路由。</li>
<li><strong>Queues</strong>：队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列。</li>
</ul>
</li>
<li><p>Admin介绍：</p>
<ul>
<li>当点击Admin时在其右边有一列</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605151200.png"></p>
</li>
<li><p>添加用户操作：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605151505.png"></p>
<ul>
<li><p>上面的Tags选项，其实是指定用户的角色，可选的有以下几个：</p>
<ul>
<li><p><code>超级管理员(administrator)</code></p>
<p>可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p>
</li>
<li><p><code>监控者(monitoring)</code></p>
<p>可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p>
</li>
<li><p><code>策略制定者(policymaker)</code></p>
<p>可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。</p>
</li>
<li><p><code>普通管理者(management)</code></p>
<p>仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</p>
</li>
<li><p><code>其他</code></p>
<p>无法登陆管理控制台，通常就是普通的生产者和消费者。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>创建虚拟主机：</p>
<ul>
<li>为了让<strong>各个用户可以互不干扰的工作</strong>，RabbitMQ添加了虚拟主机（Virtual Hosts）的概念。其实就是一个<strong>独立的访问路径</strong>，不同用户使用不同路径，各自有自己的队列、交换机，互相不会影响。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605151749.png"></p>
<ul>
<li>添加的虚拟主机默认绑定超级管理员，想要将其与其他用户绑定，想要手动操作。</li>
</ul>
</li>
<li><p>绑定虚拟主机和用户：</p>
<ul>
<li>第一步：点击添加好的虚拟主机，进入设置页面。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605152919.png"></p>
<ul>
<li>第二步：绑定即可。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605152847.png"></p>
</li>
<li><p>交换机协议：</p>
<ul>
<li>默认支持其中交换机协议。也可以自定义交换机。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605153256.png"></p>
</li>
<li><p>端口说明：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605161001.png"></p>
</li>
</ul>
<h1 id="使用RabbitMQ"><a href="#使用RabbitMQ" class="headerlink" title="使用RabbitMQ"></a>使用RabbitMQ</h1><ul>
<li><p>AMQP协议的回顾：</p>
<ul>
<li>首先一个虚拟主机对应一个生产者。</li>
<li>生产者往虚拟主机的交换机中发送消息。</li>
<li>消费者想要获取消息，想要先绑定这个虚拟主机，然后从消息队列中获取。</li>
<li>交换机和消息队列之间的规则有很多种，称为消息模型。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605154212.png"></p>
</li>
<li><p>消息模型的种类七种：</p>
<ul>
<li>版本不同，支持的消息模型也不同。</li>
<li>具体信息可以去官网上查看：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a></li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605155800.png"></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605154853.png"></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605154857.png"></p>
</li>
<li><p>在1，2两种模型中，生产者是直接将消息发送到消息队列中的。</p>
</li>
<li><p>在3，4，5模型中，生产者是将消息发送到交换机x中的。</p>
</li>
</ul>
<h1 id="模型实例"><a href="#模型实例" class="headerlink" title="模型实例"></a>模型实例</h1><ul>
<li><p>准备工作：</p>
<ul>
<li>第一步：创建一个maven版的web工程。</li>
<li>第二步：引入下面依赖。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>第三步：在rabbitmq的管理界面创建生产者和虚拟主机。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605160606.png"></p>
</li>
</ul>
</li>
</ul>
<h2 id="直连模型"><a href="#直连模型" class="headerlink" title="直连模型"></a>直连模型</h2><ul>
<li><p>模型图：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605161107.png"></p>
</li>
<li><p>说明：</p>
<ul>
<li>P：生产者，也就是要发送消息的程序</li>
<li>C：消费者：消息的接受者，会一直等待消息到来。</li>
<li>queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</li>
</ul>
</li>
<li><p>开发生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//创建连接工厂</span></span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    <span class="comment">//设置rabbitmq的主机IP</span></span><br><span class="line">    factory.setHost(<span class="string">&quot;192.168.56.110&quot;</span>);</span><br><span class="line">    <span class="comment">//设置端口号</span></span><br><span class="line">    factory.setPort(<span class="number">5672</span>);</span><br><span class="line">    <span class="comment">//设置连接的虚拟主机</span></span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">    <span class="comment">//设置生产者用户的名字和密码</span></span><br><span class="line">    factory.setUsername(<span class="string">&quot;ems&quot;</span>);</span><br><span class="line">    factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="comment">//获取连接对象，即生产者和AMQP服务的连接</span></span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    <span class="comment">//获取连接对象的通道，通道用于传递消息。</span></span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    <span class="comment">//将通道与消息队列进行绑定</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String queue：队列名称，如果队列不存在则创建队列。</span></span><br><span class="line"><span class="comment">     * boolean durable：定义队列是否持久化。</span></span><br><span class="line"><span class="comment">     * boolean exclusive：定义队列是否为独占的，即只有当前连接使用此队列</span></span><br><span class="line"><span class="comment">     * boolean autoDelete：定义消费者在消费完队列，且与队列断开连接后 是否自动删除队列。</span></span><br><span class="line"><span class="comment">     * Map&lt;String, Object&gt; arguments：额外附加参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;directQueue&quot;</span>, <span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>, );</span><br><span class="line">    <span class="comment">//发布消息</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String exchange：交换机名称</span></span><br><span class="line"><span class="comment">     * String routingKey：消息队列名称</span></span><br><span class="line"><span class="comment">     * BasicProperties props ：额外参数设置</span></span><br><span class="line"><span class="comment">     * byte[] body：消息的具体信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>,<span class="string">&quot;directQueue&quot;</span>,<span class="keyword">null</span>,<span class="string">&quot;hello rabbitmq&quot;</span>.getBytes());</span><br><span class="line">    <span class="comment">//关闭通道和连接</span></span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行效果：在rabbitmq的管理页面的Queue中会发现出现了一个队列。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605163401.png"></p>
<ul>
<li><p>说明：</p>
<ul>
<li>durable参数：只是设置队列是否持久化，而队列中的消息是否持久化并没有设置。<ul>
<li>持久化是指在重启服务器后，这个队列还存不存在。</li>
</ul>
</li>
<li>如果要设置队列中的消息持久化，则需要在发送消息时设置。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置发送消息时的额外设置</span></span><br><span class="line"><span class="comment">// MessageProperties.PERSISTENT_TEXT_PLAIN：表示持久化此消息</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>,<span class="string">&quot;directQueue&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN,<span class="string">&quot;hello rabbitmq&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<p>* </p>
</li>
</ul>
</li>
<li><p>开发消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//创建连接工厂</span></span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">&quot;192.168.56.110&quot;</span>);</span><br><span class="line">    factory.setPort(<span class="number">5672</span>);</span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">    factory.setUsername(<span class="string">&quot;ems&quot;</span>);</span><br><span class="line">    factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    <span class="comment">// 要注意此处绑定的队列信息要和生产者绑定的队列信息相同。否则会报错</span></span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;directQueue&quot;</span>, <span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费消息</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String queue：队列的名称</span></span><br><span class="line"><span class="comment">     * boolean autoAck：是否开启消息的自动确认机制</span></span><br><span class="line"><span class="comment">     * Consumer callback：获取消息后的回调接口。即获取消息后如何处理这个消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    channel.basicConsume(<span class="string">&quot;directQueue&quot;</span>,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 输出获取到的消息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Customer --- &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭通道和连接。如果不关闭，则消费者会一直消费队列中的消息。</span></span><br><span class="line"><span class="comment">//    channel.close();</span></span><br><span class="line"><span class="comment">//    connection.close();</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于消费者会在获取消息后使用子线程来处理消息，即回调接口，而Test运行后就会关掉主线程，子线程就无法运行了。所以不适用Test注解来测试消费者。</li>
<li>一般情况下不会关闭消费者的的通道。如果关闭通道的话，回调接口可能不被调用，但信息还是被消费了。</li>
</ul>
</li>
<li><p>工具类的创建：由于生产者和消费者有大量重复的代码，因此对冗余的代码进行封装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQUtils</span> </span>&#123;</span><br><span class="line">  <span class="comment">//重量级资源，一般使用静态代码块进行初始化</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ConnectionFactory factory;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">&quot;192.168.56.110&quot;</span>);</span><br><span class="line">    factory.setPort(<span class="number">5672</span>);</span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">    factory.setUsername(<span class="string">&quot;ems&quot;</span>);</span><br><span class="line">    factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取连接</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> factory.newConnection();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//关闭资源</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeResource</span><span class="params">(Connection connection, Channel channel)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      channel.close();</span><br><span class="line">      connection.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="work模型"><a href="#work模型" class="headerlink" title="work模型"></a>work模型</h2><ul>
<li><p><code>Work queues</code>也叫<code>Task queues</code>。</p>
</li>
<li><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用此模型：<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605173352.png"></p>
</li>
<li><p>角色：</p>
<ul>
<li>P：生产者：任务的发布者</li>
<li>C1：消费者-1，领取任务并且完成任务。</li>
<li>C2：消费者-2：领取任务并完成任务。</li>
</ul>
</li>
<li><p>消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;fanoutQueue&quot;</span>, <span class="keyword">true</span>,<span class="keyword">false</span> ,<span class="keyword">false</span> ,<span class="keyword">null</span> );</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;fanoutQueue&quot;</span>,<span class="keyword">null</span>, (<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;个消息&quot;</span>).getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    RabbitMQUtils.closeResource(connection,channel);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;fanoutQueue&quot;</span>, <span class="keyword">true</span>,<span class="keyword">false</span> ,<span class="keyword">false</span> ,<span class="keyword">null</span> );</span><br><span class="line">    channel.basicConsume(<span class="string">&quot;fanoutQueue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者A消费消息：&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerB</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;fanoutQueue&quot;</span>, <span class="keyword">true</span>,<span class="keyword">false</span> ,<span class="keyword">false</span> ,<span class="keyword">null</span> );</span><br><span class="line">    channel.basicConsume(<span class="string">&quot;fanoutQueue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者B消费消息：&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试发现：两个消费者总是交替消费消息。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606172032.png"></p>
</li>
<li><p>总结：</p>
<ul>
<li>默认情况下，RabbitMQ将按顺序将每个消息发送给下一个使用者。平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式称为循环。</li>
</ul>
</li>
<li><p>情况一：</p>
<ul>
<li><p>问题：</p>
<ul>
<li>在循环的机制下，如果一个消费者的消费速度较慢，另一个消费者的消费速度较快。则可能出现快消费者消费完信息后，慢消费者还在消费从消息队列中获取到的信息。</li>
<li>并且如果满消费者宕机了，由于消息已经分发给满消费者了，此时就会造成消息的丢失。</li>
<li>对于消费队列的消息，在通道中已经把此消息分发给哪个消费者做好的标记，即使消费者消费的慢，他也会把这个消息发给这个消费者。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设B消费速度较慢</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerB</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;fanoutQueue&quot;</span>, <span class="keyword">true</span>,<span class="keyword">false</span> ,<span class="keyword">false</span> ,<span class="keyword">null</span> );</span><br><span class="line">    channel.basicConsume(<span class="string">&quot;fanoutQueue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者B消费消息：&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>解决方法：</p>
<ul>
<li>使用消费自动确认机制。</li>
</ul>
</li>
</ul>
</li>
<li><p>消费自动确认机制：</p>
<ul>
<li>即消费者消费消息时的第二个参数。boolean autoAck。</li>
<li>为true时：表示由rabbitmq自动分发消息，默认按照循环的方式分发。</li>
<li>为false时：表示由自定义的方式分发消息。</li>
</ul>
</li>
<li><p>解决循环产生的问题：</p>
<ul>
<li>让通道一次只传输一个消息，当消费者消费完这个消息时在传输下一个。</li>
<li>让快消费者消费更多的消息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：设置一次只接受一条消息</span></span><br><span class="line">channel.basicQos(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//第二步：关闭自动确认参数。即第二个参数</span></span><br><span class="line">channel.basicConsume(<span class="string">&quot;fanoutQueue&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者B消费消息：&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三步：手动确认此消息已经消费完了。</span></span><br><span class="line">    <span class="comment">//第一个参数表示这个消息的标签，第二个参数为false表示只确认当前的消息。</span></span><br><span class="line">    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="fanout模型"><a href="#fanout模型" class="headerlink" title="fanout模型"></a>fanout模型</h2><ul>
<li><p>fanout：扇出 也称为广播。</p>
</li>
<li><p>模型图：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605195821.png"></p>
</li>
<li><p>在广播模式下，消息发送流程是这样的：</p>
<ul>
<li> 可以有多个消费者</li>
<li> 每个<strong>消费者有自己的queue</strong>（队列）</li>
<li> 每个<strong>队列都要绑定到Exchange</strong>（交换机）</li>
<li> <strong>生产者发送的消息，只能发送到交换机</strong>，交换机来决定要发给哪个队列，生产者无法决定。</li>
<li> 交换机把消息发送给绑定过的所有队列</li>
<li> 队列的消费者都能拿到消息。实现<strong>一条消息被多个消费者消费</strong>。</li>
</ul>
</li>
<li><p>生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//获取通道</span></span><br><span class="line">    Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    <span class="comment">//声明交换机</span></span><br><span class="line">    <span class="comment">//第一个参数：交换机的名字。第二个参数：交换机的类型，在广播模型中交换机的类型只能是fanout</span></span><br><span class="line">    channel.exchangeDeclare(<span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    <span class="comment">// 在生产者这里，不需要绑定任何消息队列，因此第二个参数没有值即可</span></span><br><span class="line">    channel.basicPublish(<span class="string">&quot;exchange&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="keyword">null</span>,<span class="string">&quot;hello exchange&quot;</span>.getBytes());</span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    RabbitMQUtils.closeResource(connection,channel);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    <span class="comment">//绑定交换机</span></span><br><span class="line">    channel.exchangeDeclare(<span class="string">&quot;exchange&quot;</span>,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">    <span class="comment">//创建临时队列</span></span><br><span class="line">    String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">    <span class="comment">//将临时队列与交换机进行绑定</span></span><br><span class="line">    channel.queueBind(queueName,<span class="string">&quot;exchange&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//消费消息</span></span><br><span class="line">    channel.basicConsume(queueName,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消费者A：&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试结果：</p>
<ul>
<li>生产者发送消息后，消费者们都能接收到消息。</li>
<li>在rabbitmq的后台管理界面中，出现了新的交换机，但没有出现新的消息队列。</li>
</ul>
</li>
</ul>
<h2 id="Routing模型"><a href="#Routing模型" class="headerlink" title="Routing模型"></a>Routing模型</h2><ul>
<li>Routing模型有两种，一种是直连式的，一种是动态式的。</li>
</ul>
<h3 id="直连式Routing模型"><a href="#直连式Routing模型" class="headerlink" title="直连式Routing模型"></a>直连式Routing模型</h3><ul>
<li><p>出现的原因：在Fanout(广播)模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p>
</li>
<li><p>也被称为<strong>订阅模型</strong>。</p>
</li>
<li><p>在Direct模型下：</p>
<ul>
<li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li>
<li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li>
<li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息。</li>
</ul>
</li>
<li><p>与广播模型的区别在于，消息的发送和接收多了一层Routing key的加密，只有具有相同Routing key的才能完成发送接收。</p>
</li>
<li><p>模型图：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605204315.png"></p>
</li>
<li><p>说明：</p>
<ul>
<li>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</li>
<li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</li>
<li>C1：消费者，其所在队列指定了需要routing key 为 error 的消息。</li>
<li>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息。</li>
<li>图示的样例为日志的信息处理，c2相当于控制台接受全部信息。c1相当于日志的持久化操作，只持久化错误信息。</li>
<li>这样既可以看到完整的日志，又可以节省磁盘空间。</li>
</ul>
</li>
<li><p>生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    <span class="comment">//声明交换机。类型为direct</span></span><br><span class="line">    String exchange = <span class="string">&quot;directExchange&quot;</span>;</span><br><span class="line">    channel.exchangeDeclare(exchange, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    String routeKey = <span class="string">&quot;warning&quot;</span>;</span><br><span class="line">    String message = <span class="string">&quot;生产者发送key为[&quot;</span>+routeKey+<span class="string">&quot;]的消息&quot;</span>;</span><br><span class="line">    channel.basicPublish(exchange, routeKey,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    RabbitMQUtils.closeResource(connection,channel);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消费者A：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    String exchange = <span class="string">&quot;directExchange&quot;</span>;</span><br><span class="line">    channel.exchangeDeclare(exchange,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line">    String queue = channel.queueDeclare().getQueue();</span><br><span class="line">    <span class="comment">// 以key(error)绑定队列和交换机</span></span><br><span class="line">    channel.queueBind(queue,exchange,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者A：&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消费者B：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerB</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    String exchange = <span class="string">&quot;directExchange&quot;</span>;</span><br><span class="line">    channel.exchangeDeclare(exchange,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line">    String queue = channel.queueDeclare().getQueue();</span><br><span class="line">    <span class="comment">// 以key(error,info,warning)绑定队列和交换机</span></span><br><span class="line">    channel.queueBind(queue,exchange,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    channel.queueBind(queue,exchange,<span class="string">&quot;info&quot;</span>);</span><br><span class="line">    channel.queueBind(queue,exchange,<span class="string">&quot;warning&quot;</span>);</span><br><span class="line">    channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者B：&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试：</p>
<ul>
<li>发送一条error信息和一条warning信息的结果</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605211830.png"></p>
</li>
</ul>
<h3 id="动态式Routing模型"><a href="#动态式Routing模型" class="headerlink" title="动态式Routing模型"></a>动态式Routing模型</h3><ul>
<li><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候<strong>使用通配符</strong>！这种模型<code>Routingkey</code> 一般都是由一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p>
</li>
<li><p>即Routing key是模糊的，可以产生动态的效果。</p>
</li>
<li><p>模型图：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210605204645.png"></p>
</li>
<li><p>通配符的说明：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 统配符</span></span><br><span class="line"><span class="bullet">		*</span> (star) can substitute for exactly one word.    匹配不多不少恰好1个词</span><br><span class="line"><span class="code">		# (hash) can substitute for zero or more words.  匹配0或多个词</span></span><br><span class="line"><span class="code"># 如:</span></span><br><span class="line"><span class="code">		audit.#    匹配audit.irs.corporate或者 audit.irs 等</span></span><br><span class="line"><span class="code">    audit.*   只能匹配 audit.irs</span></span><br></pre></td></tr></table></figure></li>
<li><p>生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    <span class="comment">//声明交换机。类型为topic</span></span><br><span class="line">    String exchange = <span class="string">&quot;topicExchange&quot;</span>;</span><br><span class="line">    channel.exchangeDeclare(exchange, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    String routeKey = <span class="string">&quot;user.save.name&quot;</span>;</span><br><span class="line">    String message = <span class="string">&quot;生产者发送key为[&quot;</span>+routeKey+<span class="string">&quot;]的消息&quot;</span>;</span><br><span class="line">    channel.basicPublish(exchange, routeKey,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    RabbitMQUtils.closeResource(connection,channel);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消费者A：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String exchange = <span class="string">&quot;topicExchange&quot;</span>;</span><br><span class="line">channel.exchangeDeclare(exchange, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">String queue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">// 以key(user.#)绑定队列和交换机。user.#：表示接收以user.开头的所有key的消息</span></span><br><span class="line">channel.queueBind(queue, exchange, <span class="string">&quot;user.#&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>消费者B：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String exchange = <span class="string">&quot;topicExchange&quot;</span>;</span><br><span class="line">channel.exchangeDeclare(exchange,<span class="string">&quot;topic&quot;</span>);</span><br><span class="line">String queue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">// 以key(user.*)绑定队列和交换机 。user.* 表示key为两个单词，且第一个单词是user的key</span></span><br><span class="line">channel.queueBind(queue,exchange,<span class="string">&quot;user.*&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>测试：</p>
<ul>
<li>在发送key为user.save和user.save.name后的结果。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606120304.png"></p>
</li>
</ul>
<h2 id="模型的总结"><a href="#模型的总结" class="headerlink" title="模型的总结"></a>模型的总结</h2><ul>
<li>前面的五种模型可以分为两种：带交换机和不带交换机的。</li>
<li>不带交换机：比如直连模型和任务模型。<ul>
<li>其默认也是带交换机的，不过交换机是隐藏的。</li>
<li>默认的犯法策略是循环均匀分配。</li>
<li>当一个队列只对应一个消费者时，被简称为直连模型。</li>
<li>当一个队列对应多个消费者时，又加上自动确认机制，此时被称为任务模型。</li>
</ul>
</li>
<li>带交换机：比如广播模型和路由模型。<ul>
<li>广播模型类似于任务模型，不同之处在于交换机类型不一致，且分发机制不一样，广播是每个都分发。</li>
<li>广播模型中，由于信息是分发给所有消费者的，所以消息队列可以不创建或使用临时的。</li>
<li>路由模型在广播模型的基础上添加了一层身份验证。<ul>
<li>分发机制可能还是广播的机制，但消费者的接受机制可能只接收身份验证通过的消息。</li>
<li>或者在分发时只发给身份验证通过的消费者。</li>
</ul>
</li>
<li>动态路由模型是在订阅模型的基础上对身份验证信息进行了模糊化，采了通配符的方式。</li>
</ul>
</li>
<li>前面五种模型只是用到了三种交换机：direct,fanout,topic</li>
</ul>
<h1 id="SpringBoot集成RabbitMQ"><a href="#SpringBoot集成RabbitMQ" class="headerlink" title="SpringBoot集成RabbitMQ"></a>SpringBoot集成RabbitMQ</h1><ul>
<li><p>准备工作：</p>
<ul>
<li>创建springboot项目，</li>
<li>选择web支持和amqp支持。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606140133.png"></p>
<ul>
<li>或者不选择amqp支持而是手动添加依赖。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>基础配置文件：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个名字在微服务时有用</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">springboot-rabbitmq</span></span><br><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">192.168.56.110</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">ems</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">123</span></span><br><span class="line"><span class="meta">spring.rabbitmq.virtual-host</span>=<span class="string">/ems</span></span><br></pre></td></tr></table></figure></li>
<li><p>RabbitTemplate 是Spring中对RabbitMQ操作的模板对象。</p>
</li>
<li><p>RabbitTemplate 用来简化操作 ，使用时候直接在项目中注入即可使用。</p>
</li>
<li><p>RabbitTemplate 类似于JDBCtemplate。</p>
</li>
</ul>
<h2 id="直连式模型"><a href="#直连式模型" class="headerlink" title="直连式模型"></a>直连式模型</h2><ul>
<li><p>生产者</p>
<ul>
<li>注意：如果单独执行生产者的代码，是不会创建队列的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDirectQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//发送消息，</span></span><br><span class="line">  <span class="comment">//第一个参数为队列的名称</span></span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;directQueue&quot;</span>,<span class="string">&quot;hello springboot rabbitmq&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(</span></span><br><span class="line"><span class="meta">    queuesToDeclare =</span></span><br><span class="line"><span class="meta">    @Queue(value = &quot;directQueue&quot;,</span></span><br><span class="line"><span class="meta">        durable = &quot;false&quot;,</span></span><br><span class="line"><span class="meta">        autoDelete = &quot;false&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectQueueConsumer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 消费者的回调函数：即对消息的具体处理逻辑。</span></span><br><span class="line">  <span class="comment">// 方法名自定义，没有要求</span></span><br><span class="line">  <span class="meta">@RabbitHandler</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receivel</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;直连模型之消费者：&quot;</span> + message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606144736.png"></p>
</li>
</ul>
<h2 id="任务模型"><a href="#任务模型" class="headerlink" title="任务模型"></a>任务模型</h2><ul>
<li><p>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;workQueue&quot;</span>,<span class="string">&quot;hello task model = &quot;</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkConsumerA</span> </span>&#123;</span><br><span class="line">  <span class="comment">// RabbitListener直接加在方法上，表示当前方法就是处理消息的方法</span></span><br><span class="line">  <span class="meta">@RabbitListener(queuesToDeclare = @Queue(&quot;workQueue&quot;))</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receivel</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务模型之消费者A：&quot;</span> + message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(&quot;workQueue&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkConsumerB</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RabbitHandler</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receivel</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务模型之消费者B：&quot;</span> + message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以在一个类中定义多个方法，方法上都添加@RabbitListener注解，则每个方法表示一个消费者。</li>
</ul>
</li>
<li><p>测试：</p>
<ul>
<li>默认在Spring AMQP实现中Work这种方式就是公平调度,如果需要实现能者多劳需要额外配置。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606145215.png"></p>
</li>
</ul>
<h2 id="广播式模型"><a href="#广播式模型" class="headerlink" title="广播式模型"></a>广播式模型</h2><ul>
<li><p>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFanout</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//第一个参数表示交换机的名称，</span></span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;hello fanout model&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConsumer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(),  //不指定队列的名字，表示创建临时队列</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;logs&quot;,type = &quot;fanout&quot;)</span></span><br><span class="line"><span class="meta">  ))</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receivel1</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;广播模型之消费者A：&quot;</span> + message);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;logs&quot;,type = &quot;fanout&quot;)</span></span><br><span class="line"><span class="meta">  ))</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receivel2</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;广播模型之消费者B：&quot;</span> + message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606150232.png"></p>
</li>
</ul>
<h2 id="直连路由模型"><a href="#直连路由模型" class="headerlink" title="直连路由模型"></a>直连路由模型</h2><ul>
<li><p>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDirectRoute</span><span class="params">()</span></span>&#123;</span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;directLog&quot;</span>,<span class="string">&quot;error&quot;</span>,<span class="string">&quot;error message&quot;</span>);</span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;directLog&quot;</span>,<span class="string">&quot;waning&quot;</span>,<span class="string">&quot;waning message&quot;</span>);</span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;directLog&quot;</span>,<span class="string">&quot;info&quot;</span>,<span class="string">&quot;info message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectRouteConsumer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">      value = @Queue(),</span></span><br><span class="line"><span class="meta">      exchange = @Exchange(name = &quot;directLog&quot;, type = &quot;direct&quot;),</span></span><br><span class="line"><span class="meta">      key = &#123;&quot;error&quot;, &quot;waning&quot;, &quot;info&quot;&#125;</span></span><br><span class="line"><span class="meta">  ))</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receivel1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;订阅模型之消费者A：&quot;</span> + message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">      value = @Queue(),</span></span><br><span class="line"><span class="meta">      exchange = @Exchange(name = &quot;directLog&quot;, type = &quot;direct&quot;),</span></span><br><span class="line"><span class="meta">      key = &#123;&quot;error&quot;&#125;</span></span><br><span class="line"><span class="meta">  ))</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receivel2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;订阅模型之消费者B：&quot;</span> + message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606151345.png"></p>
</li>
</ul>
<h2 id="动态路由模型"><a href="#动态路由模型" class="headerlink" title="动态路由模型"></a>动态路由模型</h2><ul>
<li><p>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTopicRoute</span><span class="params">()</span></span>&#123;</span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;topicLog&quot;</span>,<span class="string">&quot;log.error&quot;</span>,<span class="string">&quot;log.error message&quot;</span>);</span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;topicLog&quot;</span>,<span class="string">&quot;log.waning.info&quot;</span>,<span class="string">&quot;log.waning.info message&quot;</span>);</span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;topicLog&quot;</span>,<span class="string">&quot;log&quot;</span>,<span class="string">&quot;log message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicRouteConsumer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">      value = @Queue(),</span></span><br><span class="line"><span class="meta">      exchange = @Exchange(name = &quot;topicLog&quot;, type = &quot;topic&quot;),</span></span><br><span class="line"><span class="meta">      key = &#123;&quot;log.*&quot;&#125;</span></span><br><span class="line"><span class="meta">  ))</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receivel1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;订阅模型之消费者A：&quot;</span> + message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">      value = @Queue(),</span></span><br><span class="line"><span class="meta">      exchange = @Exchange(name = &quot;topicLog&quot;, type = &quot;topic&quot;),</span></span><br><span class="line"><span class="meta">      key = &#123;&quot;log.#&quot;&#125;</span></span><br><span class="line"><span class="meta">  ))</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receivel2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;订阅模型之消费者B：&quot;</span> + message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606152230.png"></p>
</li>
</ul>
<h1 id="MQ的常用场景"><a href="#MQ的常用场景" class="headerlink" title="MQ的常用场景"></a>MQ的常用场景</h1><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><ul>
<li><p>场景说明：用户注册后，需要发注册邮件和注册短信,传统的做法有两种 1.串行的方式 2.并行的方式</p>
</li>
<li><p><code>串行方式:</code> 将注册信息写入数据库后,发送注册邮件,再发送注册短信,以上三个任务全部完成后才返回给客户端。 这有一个问题是,邮件,短信并不是必须的,它只是一个通知,而这种做法让客户端等待没有必要等待的东西. </p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153236.png"></p>
</li>
<li><p><code>并行方式: </code>将注册信息写入数据库后,发送邮件的同时,发送短信,以上三个任务完成后,返回给客户端,并行的方式能提高处理的时间。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153249.png"></p>
</li>
<li><p><code>消息队列:</code>假设三个业务节点分别使用50ms,串行方式使用时间150ms,并行使用时间100ms。虽然并行已经提高的处理时间,但是,前面说过,邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功,应该是写入数据库后就返回.  <code>消息队列</code>: 引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理 </p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153246.png"></p>
</li>
<li><p>由此可以看出,引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计),引入消息队列后处理后,响应时间是串行的3倍,是并行的2倍。</p>
</li>
</ul>
<h2 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h2><ul>
<li><p>场景：双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口. </p>
</li>
<li><p>传统做法：当库存系统出现故障时,订单就会失败。 订单系统和库存系统高耦合。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153150.png"></p>
</li>
<li><p>消息队列 ：</p>
<ul>
<li><code>订单系统:</code>用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。</li>
<li><code>库存系统:</code>订阅下单的消息,获取下单消息,进行库操作。  就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153141.png"></p>
</li>
</ul>
<h2 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h2><ul>
<li><p>场景:秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。</p>
</li>
<li><p>  <code>作用:</code> </p>
</li>
<li><p>1.可以控制活动人数，超过此一定阀值的订单直接丢弃。</p>
</li>
<li><p>2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单) 。</p>
</li>
</ul>
<p>  <img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153047.png"></p>
<ul>
<li><p>具体实现：</p>
<ul>
<li>1.用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面。  </li>
<li>2.秒杀业务根据消息队列中的请求信息，再做后续处理。</li>
</ul>
</li>
</ul>
<h1 id="RabbitMQ的集群"><a href="#RabbitMQ的集群" class="headerlink" title="RabbitMQ的集群"></a>RabbitMQ的集群</h1><h2 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h2><ul>
<li><p>架构图：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606153930.png"></p>
</li>
<li><p>默认情况下:RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是消息队列，默认情况下，消息队列位于一个节点上，尽管它们可以从所有节点看到和访问。</p>
<ul>
<li>即在<code>从服务器</code>中备份了<code>主服务器</code>的所有数据，但是消息队列的数据不备份。</li>
<li>但是消费者可以通过<code>从服务器</code>访问到消息队列的数据，因此<code>从服务器</code>会访问<code>主服务器</code>的消息队列。</li>
</ul>
</li>
<li><p><strong>产生的问题</strong>：当集群中某一时刻master节点宕机,可以对Quene中信息,进行备份</p>
</li>
<li><p>集群的搭建：</p>
<ul>
<li><p>准备工作：能够正常启动rabbitmq的三台服务器。</p>
</li>
<li><p>第一步：集群规划</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">								     集群名字</span></span><br><span class="line"><span class="code">node1: 192.168.56.110  mq1  master 主节点</span></span><br><span class="line"><span class="code">node2: 192.168.56.111  mq2  repl1  副本节点</span></span><br><span class="line"><span class="code">node3: 192.168.56.112  mq3  repl2  副本节点</span></span><br></pre></td></tr></table></figure></li>
<li><p>第二步：修改虚拟机的主机名和ip映射：</p>
<ul>
<li>第二步的作用是方便在三台虚拟机之间互相传递文件，安装rabbitmq。</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 修改主机名，三台机器各加各的，修改后重启服务器</span></span><br><span class="line">node1: vim /etc/hostname 加入:  mq1</span><br><span class="line">node2: vim /etc/hostname 加入:  mq2</span><br><span class="line">node3: vim /etc/hostname 加入:  mq3</span><br><span class="line"><span class="section"># 修改主机名的后果，三台服务器的命令行都变成了下述所示：</span></span><br><span class="line">[root@mq1 ~]# </span><br><span class="line">[root@mq2 ~]# </span><br><span class="line">[root@mq3 ~]# </span><br><span class="line"><span class="section"># 修改ip映射。下面的内容要添加在每一个服务器上。因此可以使用xshell的发送到所有会话功能操作</span></span><br><span class="line">[root@mq1 ~]# cd /</span><br><span class="line">[root@mq1 /]# vi /etc/hosts</span><br><span class="line">10.15.0.3 mq1</span><br><span class="line">10.15.0.4 mq2</span><br><span class="line">10.15.0.5 mq3</span><br></pre></td></tr></table></figure></li>
<li><p>第三步：三台机器都启动rabbitmq的插件和服务</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq<span class="emphasis">_management</span></span><br><span class="line"><span class="emphasis">systemsctl start rabbitmq-server</span></span><br></pre></td></tr></table></figure></li>
<li><p>第四步：同步三台机器的cookie文件。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 因为在第一二步设置了主机名和IP映射，因此可以使用scp命令将主机mq1的cookie传输到mq2,mq3</span></span><br><span class="line"><span class="section"># 传输前，先关闭三台服务器的rabbitmq-server的服务</span></span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@mq2:/var/lib/rabbitmq/</span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@mq3:/var/lib/rabbitmq/</span><br><span class="line"><span class="section"># 查看cookie文件内容</span></span><br><span class="line">[root@mq3 /]# cat /var/lib/rabbitmq/.erlang.cookie</span><br></pre></td></tr></table></figure></li>
<li><p>第五步：使用后台启动方式启动rabbitmq的服务。三个都启动</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br><span class="line"><span class="section"># 此方式启动后，无法查看后台界面。因此使用下列命令查看服务是否启动成功了</span></span><br><span class="line">rabbitmqctl cluster<span class="emphasis">_status</span></span><br><span class="line"><span class="emphasis"># 可看到显示的信息中 running node 后面显示的是当前的服务器</span></span><br></pre></td></tr></table></figure></li>
<li><p>第六步：将mq2和mq3加入以mq1为主的集群中。mq1不执行，mq2,mq3执行下列命令。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 此时mq1,mq2,mq3服务都启动</span></span><br><span class="line"><span class="section"># 关闭程序</span></span><br><span class="line">rabbitmqctl stop<span class="emphasis">_app</span></span><br><span class="line"><span class="emphasis"># 加入集群。此时的rabbit@是写死的，后面跟的是主机名，不能是主机ip。</span></span><br><span class="line"><span class="emphasis">rabbitmqctl join_</span>cluster rabbit@mq1</span><br><span class="line"><span class="section"># 启动服务</span></span><br><span class="line">rabbitmqctl start<span class="emphasis">_app</span></span><br><span class="line"><span class="emphasis"># 此时可以通过后台界面查看三个rabbitmq的状态。</span></span><br></pre></td></tr></table></figure></li>
<li><p>第七步：查看集群状态。在那个节点执行都行。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster<span class="emphasis">_status</span></span><br><span class="line"><span class="emphasis"># 显示下列信息</span></span><br><span class="line"><span class="emphasis">Cluster status of node rabbit@mq3 ...</span></span><br><span class="line"><span class="emphasis">[&#123;nodes,[&#123;disc,[rabbit@mq1,rabbit@mq2,rabbit@mq3]&#125;]&#125;,</span></span><br><span class="line"><span class="emphasis">&#123;running_</span>nodes,[rabbit@mq2,rabbit@mq1,rabbit@mq3]&#125;,</span><br><span class="line">&#123;cluster<span class="emphasis">_name,&lt;&lt;&quot;rabbit@mq1&quot;&gt;&gt;&#125;,</span></span><br><span class="line"><span class="emphasis">&#123;partitions,[]&#125;,</span></span><br><span class="line"><span class="emphasis">&#123;alarms,[&#123;rabbit@mq2,[]&#125;,&#123;rabbit@mq1,[]&#125;,&#123;rabbit@mq3,[]&#125;]&#125;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>测试：</p>
<ul>
<li>在主服务器上创建一个队列，并往队列中生产一个消息，会发现另外两个接待你也能看到这个队列。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606165116.png"></p>
<ul>
<li>关闭主服务器：执行rabbitmqctl stop_app。</li>
<li>此时查看从节点的界面发现，消息丢失了。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606165129.png"></p>
</li>
<li><p>如果主节点又重启了。此时分为两种情况：</p>
<ul>
<li>如果消息持久化了，则能正常的访问到这个消息，</li>
<li>如果消息没有持久化，则无法获取到这个消息。</li>
</ul>
</li>
</ul>
<h2 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a>镜像集群</h2><ul>
<li><p>镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间进行自动同步，且如果其中一个节点不可用，并不会导致消息丢失或服务不可用的情况，提升MQ集群的整体高可用性。</p>
<ul>
<li>能够解决普通集群存在的问题。</li>
</ul>
</li>
<li><p>镜像集群是在普通集群的基础上进行搭建的。</p>
</li>
<li><p>架构图：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210606154621.png"></p>
</li>
<li><p>集群的搭建：</p>
<ul>
<li>在普通集群中设置策略即可变成镜像集群</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 0.策略说明</span></span><br><span class="line"><span class="code">	rabbitmqctl set_policy [-p &lt;vhost&gt;] [--priority &lt;priority&gt;] [--apply-to &lt;apply-to&gt;] &lt;name&gt; &lt;pattern&gt;  &lt;definition&gt;</span></span><br><span class="line"><span class="code">	-p Vhost： 可选参数，针对指定虚拟主机下的queue进行设置</span></span><br><span class="line"><span class="code">	Name:     policy的名称</span></span><br><span class="line"><span class="code">	Pattern: queue的匹配模式(正则表达式)</span></span><br><span class="line"><span class="code">	Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode</span></span><br><span class="line"><span class="code">           		ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes</span></span><br><span class="line"><span class="code">                      all：表示在集群中所有的节点上进行镜像</span></span><br><span class="line"><span class="code">                      exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定</span></span><br><span class="line"><span class="code">                      nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定</span></span><br><span class="line"><span class="code">            	ha-params：ha-mode模式需要用到的参数</span></span><br><span class="line"><span class="code">              ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual(手动)</span></span><br><span class="line"><span class="code">              priority：可选参数，policy的优先级，数字越大优先级越高   </span></span><br><span class="line"><span class="code"># 1.查看当前策略</span></span><br><span class="line"><span class="code">	rabbitmqctl list_policies</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 2.添加策略</span></span><br><span class="line"><span class="code">	rabbitmqctl set_policy ha-all &#x27;^hello&#x27; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27; </span></span><br><span class="line"><span class="code">	说明:策略正则表达式为 “^” 表示所有匹配所有队列名称  ^hello:匹配hello开头队列，</span></span><br><span class="line"><span class="code">	    将所有服务器都进行镜像，队列的消息同步方式为自动</span></span><br><span class="line"><span class="code"># 3.删除策略</span></span><br><span class="line"><span class="code">	rabbitmqctl clear_policy ha-all</span></span><br><span class="line"><span class="code">	ha-all ：表示策略名</span></span><br></pre></td></tr></table></figure></li>
<li><p>与普通集群的区别：</p>
<ul>
<li>当主节点宕机后，会选出一个从服务器作为主节点，此时的集群中的消息可以被消费。</li>
<li>当老的主节点重启后，老的主节点会作为新主节点的从节点。</li>
</ul>
</li>
</ul>

    </div>

    
    
    


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/04/Java%E5%AD%A6%E4%B9%A0/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/Ngnix/" rel="prev" title="nginx的学习">
      <i class="fa fa-chevron-left"></i> nginx的学习
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/06/11/Java%E5%AD%A6%E4%B9%A0/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/zookeeper%E7%9A%84%E5%AD%A6%E4%B9%A0/" rel="next" title="Zookpeer的学习">
      Zookpeer的学习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#MQ%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">MQ的简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RabbitMQ%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="nav-number">2.</span> <span class="nav-text">RabbitMQ的简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ%E7%9A%84%E5%AE%89%E8%A3%85"><span class="nav-number">2.1.</span> <span class="nav-text">RabbitMQ的安装</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">RabbitMQ的使用方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A5%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">3.1.</span> <span class="nav-text">以命令行的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A5%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">以后台管理界面的方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8RabbitMQ"><span class="nav-number">4.</span> <span class="nav-text">使用RabbitMQ</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E5%AE%9E%E4%BE%8B"><span class="nav-number">5.</span> <span class="nav-text">模型实例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E8%BF%9E%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">直连模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#work%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.2.</span> <span class="nav-text">work模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fanout%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.3.</span> <span class="nav-text">fanout模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Routing%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.4.</span> <span class="nav-text">Routing模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E8%BF%9E%E5%BC%8FRouting%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.4.1.</span> <span class="nav-text">直连式Routing模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BC%8FRouting%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.4.2.</span> <span class="nav-text">动态式Routing模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">5.5.</span> <span class="nav-text">模型的总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringBoot%E9%9B%86%E6%88%90RabbitMQ"><span class="nav-number">6.</span> <span class="nav-text">SpringBoot集成RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E8%BF%9E%E5%BC%8F%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.1.</span> <span class="nav-text">直连式模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.2.</span> <span class="nav-text">任务模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E6%92%AD%E5%BC%8F%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.3.</span> <span class="nav-text">广播式模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E8%BF%9E%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.4.</span> <span class="nav-text">直连路由模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.5.</span> <span class="nav-text">动态路由模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MQ%E7%9A%84%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">7.</span> <span class="nav-text">MQ的常用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="nav-number">7.1.</span> <span class="nav-text">异步处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E8%A7%A3%E8%80%A6"><span class="nav-number">7.2.</span> <span class="nav-text">应用解耦</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0"><span class="nav-number">7.3.</span> <span class="nav-text">流量削峰</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RabbitMQ%E7%9A%84%E9%9B%86%E7%BE%A4"><span class="nav-number">8.</span> <span class="nav-text">RabbitMQ的集群</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4"><span class="nav-number">8.1.</span> <span class="nav-text">普通集群</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4"><span class="nav-number">8.2.</span> <span class="nav-text">镜像集群</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Plum Reiver</p>
  <div class="site-description" itemprop="description">技术，日常，笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
	
  </nav>
</div>


      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plum Reiver</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
