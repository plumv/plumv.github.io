<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"plumv.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="Redis命令参考文档：http:&#x2F;&#x2F;redisdoc.com&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis的使用">
<meta property="og:url" content="https://plumv.github.io/2021/04/24/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/index.html">
<meta property="og:site_name" content="李川的个人博客">
<meta property="og:description" content="Redis命令参考文档：http:&#x2F;&#x2F;redisdoc.com&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412123202.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412124350.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412125102.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412125415.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412130624.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412131458.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412131510.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412135033.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210413133611.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210413134700.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210413135951.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210413141004.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210416153009.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210416154630.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210416161810.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210416162500.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210416164407.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417084422.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417085519.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417092359.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417093828.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417105037.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417163442.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417163450.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418145928.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418150046.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418150410.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418150628.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418150745.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210419095202.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210419095707.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210419100017.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210419104629.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210419105312.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210419110126.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420101011.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420102046.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420103829.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420103857.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420104023.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420105657.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420111603.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420160145.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420160950.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420161857.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420163258.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420164118.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420164403.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420164436.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420171134.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420171445.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420173211.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420173951.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422090428.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422094937.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422104028.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422143019.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422143406.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422145251.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422154656.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422160159.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422160539.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422163037.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422163355.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422163247.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422164517.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423102609.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423103550.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423104528.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423152346.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423161223.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423162327.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423164415.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423164913.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423165833.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424145831.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423174533.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423175153.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423184709.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424094235.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424124949.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424130033.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424131755.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424132951.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424144749.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424143810.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424145545.png">
<meta property="article:published_time" content="2021-04-23T16:00:00.000Z">
<meta property="article:modified_time" content="2021-04-24T07:15:27.806Z">
<meta property="article:author" content="Plum Reiver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412123202.png">

<link rel="canonical" href="https://plumv.github.io/2021/04/24/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis的使用 | 李川的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李川的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>日志</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://plumv.github.io/2021/04/24/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plum Reiver">
      <meta itemprop="description" content="技术，日常，笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李川的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis的使用
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-24 00:00:00 / 修改时间：15:15:27" itemprop="dateCreated datePublished" datetime="2021-04-24T00:00:00+08:00">2021-04-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Redis命令参考文档：<a target="_blank" rel="noopener" href="http://redisdoc.com/">http://redisdoc.com/</a></p>
<span id="more"></span>

<h1 id="第一章：redis入门"><a href="#第一章：redis入门" class="headerlink" title="第一章：redis入门"></a>第一章：redis入门</h1><h3 id="Nosql"><a href="#Nosql" class="headerlink" title="Nosql"></a>Nosql</h3><ul>
<li><p>NoSQL：即 Not-Only SQL（ 泛指非关系型的数据库），作为关系型数据库的补充。</p>
</li>
<li><p>作用：应对基于海量用户和海量数据前提下的数据处理问题。</p>
</li>
<li><p>特征：</p>
<ul>
<li>可扩容，可伸缩</li>
<li>大数据量下高性能</li>
<li>灵活的数据模型</li>
<li>高可用</li>
</ul>
</li>
<li><p>常见 Nosql 数据库：</p>
<ul>
<li><strong>Redis</strong></li>
<li>memcache</li>
<li>HBase</li>
<li>MongoDB</li>
</ul>
</li>
<li><p>适用场景</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412123202.png"></p>
</li>
</ul>
<h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><ul>
<li>Redis概念：Redis (REmote DIctionary Server) 是用 <font color="red">C 语言</font>开发的一个开源的高性能键值对<font color="red">（key-value）</font>数据库。</li>
<li>特征：<ul>
<li>1.数据间没有必然的关联关系</li>
<li>2.内部采用单线程机制进行工作</li>
<li>3.高性能。官方提供测试数据，50个并发执行100000 个请求,读的速度是110000 次/s,写的速度是81000次/s。</li>
<li>4.多数据类型支持<ul>
<li>字符串类型 string</li>
<li> 列表类型 list</li>
<li>散列类型 hash</li>
<li>集合类型 set</li>
<li>有序集合类型 sorted_set</li>
</ul>
</li>
<li>5.持久化支持。可以进行数据灾难恢复。</li>
</ul>
</li>
<li>Redis的应用<ul>
<li>为热点数据加速查询（主要场景），如热点商品、热点新闻、热点资讯、推广类等高访问量信息</li>
<li>任务队列，如秒杀、抢购、购票排队等</li>
<li>即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等</li>
<li>时效性信息控制，如验证码控制、投票控制等</li>
<li>分布式数据共享，如分布式集群架构中的 session 分离</li>
<li>消息队列</li>
<li>分布式锁</li>
</ul>
</li>
</ul>
<h2 id="1-2-下载安装"><a href="#1-2-下载安装" class="headerlink" title="1.2 下载安装"></a>1.2 下载安装</h2><ul>
<li>Linux 版（适用于企业级开发）<ul>
<li>Redis 高级开始使用</li>
<li>以4.0 版本作为主版本</li>
<li>在后面讲解</li>
</ul>
</li>
<li>Windows 版本<ul>
<li>Redis 入门使用</li>
<li>以 3.2 版本作为主版本</li>
<li>下载地址：<a target="_blank" rel="noopener" href="https://github.com/MSOpenTech/redis/tags">https://github.com/MSOpenTech/redis/tags</a></li>
</ul>
</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li><p>第一步：打开下载网页：<a target="_blank" rel="noopener" href="https://github.com/microsoftarchive/redis/releases/tag/win-3.2.100">https://github.com/microsoftarchive/redis/releases/tag/win-3.2.100</a></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412124350.png"></p>
</li>
<li><p>第二步：解压到自己想要的位置即可</p>
</li>
<li><p>第三步：文件内容介绍</p>
<ul>
<li>redis-server.exe    服务器启动命令</li>
<li> redis-cli.exe    命令行客户端</li>
<li>redis.windows.conf    redis核心配置文件</li>
<li>redis-benchmark.exe    性能测试工具</li>
<li>redis-check-aof.exe    AOF文件修复工具</li>
<li>redis-check-dump.exe   RDB文件检查工具（快照持久化文件）</li>
</ul>
</li>
</ul>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><ul>
<li><p>启动Redis服务：双击redis-server.exe即可。启动后出现如下界面</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412125102.png"></p>
</li>
<li><p>启动Redis客户端(此处启动的是命令行式的客户端)</p>
<ul>
<li>双击 redis-cli.exe 文件即可。效果如下图所示</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412125415.png"></p>
<ul>
<li>既有命令行式客户端，也就有图形化式客户端。</li>
</ul>
</li>
<li><p>安装Redis图形化式客户端</p>
</li>
</ul>
<h2 id="1-3-基本操作"><a href="#1-3-基本操作" class="headerlink" title="1.3 基本操作"></a>1.3 基本操作</h2><ul>
<li><p>对于一个命令行模式的工具，一般我们想要从下面四个方面了解它</p>
<ul>
<li>功能性命令</li>
<li>清除屏幕命令</li>
<li>帮助查询命令</li>
<li>退出命令</li>
</ul>
</li>
<li><p>Redis的功能性命令(基础的)</p>
<ul>
<li>信息添加操作<ul>
<li>作用：设置key，value数据。当不存在key时添加，存在key时更新。</li>
<li>命令格式：set key value</li>
</ul>
</li>
<li>信息查询操作<ul>
<li>作用：根据 key 查询对应的 value，如果不存在，返回（nil） </li>
<li>命令格式：get key</li>
</ul>
</li>
<li>示例</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412130624.png"></p>
</li>
<li><p>Redis的清除屏幕命令</p>
<ul>
<li>作用：当屏幕有很多代码时，看着很烦，使用此命令能让屏幕恢复为白板状态</li>
<li>命令格式：clear</li>
</ul>
</li>
<li><p>Reids帮助查询命令</p>
<ul>
<li>作用：获取命令帮助文档，获取群组中所有命令信息。</li>
<li>命令格式：help 命令名称 /help @组名/ help</li>
<li>说明：在Redis中很多命令都在一个组中，Reids中有很多组。</li>
<li>示例：</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412131458.png"></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412131510.png"></p>
</li>
<li><p>Redis退出客户端命令</p>
<ul>
<li>作用：退出客户端模式。在cmd窗口下会退出此次客户端服务。</li>
<li>命令格式：quit / exit / Esc键</li>
</ul>
</li>
<li><p>Redis退出服务端命令</p>
<ul>
<li>作用：退出服务端</li>
<li>命令格式：Ctrl+c / 点击关闭按钮</li>
</ul>
</li>
</ul>
<h1 id="第二章：redis数据类型"><a href="#第二章：redis数据类型" class="headerlink" title="第二章：redis数据类型"></a>第二章：redis数据类型</h1><ul>
<li>首先Redis的数据类型不是固定的。而是在根据需求确定的。</li>
<li>经过过往的发展，目前确定Redis的基本数据类型有5种<ul>
<li>string      –&gt;类似于Java的String</li>
<li>hash      –&gt;类似于Java的HashMap</li>
<li>list      –&gt;类似于Java的LinkedList</li>
<li>set      –&gt;类似于Java的HashSet</li>
<li>sorted_set      –&gt;类似于Java的TreeSet</li>
</ul>
</li>
<li>Redis的数据存储格式：<ul>
<li>redis 自身是一个 Map，其中所有的数据都是采用 key : value 的形式存储</li>
<li><font color="red">此章节的数据类型</font>指的是存储的数据的类型，也就是 value 部分的类型，key 部分永远都是字符串。</li>
</ul>
</li>
</ul>
<h2 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h2><ul>
<li><p>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型</p>
</li>
<li><p>存储数据的格式：一个存储空间保存一个数据</p>
</li>
<li><p>存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用。但实质上存储的还是字符串。</p>
</li>
<li><p>基本操作</p>
<ul>
<li>添加修改数据：<em>set key value</em></li>
<li>获取数据：<em>get key</em></li>
<li>删除数据：<em>del key</em></li>
<li>添加修改多个数据：<em>mset key1 value1 key2 value2</em></li>
<li>获取多个数据：<em>mget key1 key2</em></li>
<li>获取数据字符个数(字符串长度)：<em>strlen key</em></li>
<li>追加信息到原始信息后部(如果原始信息存在就追加，否则新建)：<em>append key value</em></li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210412135033.png"></p>
</li>
<li><p>单数据操作和多数据操作的选择(以三条数据为例)</p>
<ul>
<li>单指令执行过程：发送三次指令+获取三次返回值+服务器执行三条数据的添加操作。</li>
<li>多指令执行过程：发送一次指令+获取一次返回值+服务器执行三条数据的添加操作。</li>
<li>由此看出多指令执行时间比单指令执行时间的区别在于发送指令的时间。</li>
<li>实际上，通常情况下会选择多指令执行，<ul>
<li>对于少量数据，单指令和多指令差别并不大。</li>
<li>对于大量数据而言，发送一个多指令是不行的，会发送多次多指令。</li>
</ul>
</li>
</ul>
</li>
<li><p>扩展操作</p>
</li>
<li><p>场景一：</p>
<ul>
<li>问题：在Mysql分表操作中，然后保证主键id的统一性？使用redis来设置主键的值。</li>
<li>操作一：设置数值数据增加指定范围的值。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">incr key           --&gt; 将key对应的值增加一个单位的数据</span><br><span class="line">incrby key increment --&gt; 将key对应的值增加increment个单位的数据</span><br><span class="line">incrbyfloat key increment  --&gt; 将key对应的值增加increment个单位的数据</span><br></pre></td></tr></table></figure>

<ul>
<li>操作二：设置数值数据减少指定范围的值。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decr key           --&gt; 将key对应的值增加一个单位的数据</span><br><span class="line">decr key increment --&gt; 将key对应的值增加increment个单位的数据</span><br></pre></td></tr></table></figure>

<ul>
<li>说明：<ul>
<li>key对应的value必须是数值类型的数据。否则会报错。</li>
<li>一个单位的数据一般指1，即进行加一减一操作。</li>
<li>increment的只可以为正为负。为负时原来的操作的意义就反过来了。</li>
<li>incrbyfloat操作的increment必须为小数形式。此操作用于浮点数的变换。</li>
</ul>
</li>
<li>数值操作说明：<ul>
<li>string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算。</li>
<li>redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。</li>
<li>注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。</li>
<li>最大值为：9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</li>
</ul>
</li>
<li>应用场景：<ul>
<li>redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性。</li>
<li>此方案适用于所有数据库，且支持数据库集群。</li>
</ul>
</li>
</ul>
</li>
<li><p>场景二</p>
<ul>
<li>作用：设置数据具有指定的生命周期。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setex key seconds value  --&gt;设置一个key,value的存活时间为几分钟</span><br><span class="line">psetex key milliseconds value --&gt;设置一个key,value的存活时间为几秒</span><br><span class="line">//例如</span><br><span class="line">setex num 10 abc  --&gt; 设置&lt;key,value&gt;为&lt;num,abc&gt;的数据存活时间为10分钟。</span><br><span class="line">psetex num 10 abc  --&gt;设置&lt;key,value&gt;为&lt;num,abc&gt;的数据存活时间为10秒</span><br></pre></td></tr></table></figure>

<ul>
<li>说明：<ul>
<li>当设置一个key,value后，在设置这个key的生命周期，则上一次的设置会被清除掉，即不起作用。</li>
</ul>
</li>
<li>应用场景：<ul>
<li>redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作。</li>
<li>微信投票的账号时效性，热点的时效性。</li>
</ul>
</li>
</ul>
</li>
<li><p>场景三：</p>
<ul>
<li><p>问题：主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数与微博数量。</p>
</li>
<li><p>解决方式一：在redis中为大V用户设定用户信息，以用户主键和属性值作为key，后台设定定时刷新策略即可。</p>
<ul>
<li>eg:  user:id :3506728370:fans →12210947</li>
</ul>
</li>
<li><p>解决方式二：在redis中以json格式存储大V用户信息，定时刷新（也可以使用hash类型）</p>
<ul>
<li>eg: user:id :3506728370 →{“id”:3506728370,”name”:”春晚”,”fans”:12210862,”blogs”:6164, “focus”:83}</li>
</ul>
</li>
<li><p>说明：此处的key一般有设置的约定。即固定的格式：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210413133611.png"></p>
</li>
<li><p>应用场景：</p>
<ul>
<li>redis应用于各种结构型和非结构型高热度数据访问加速。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>数据操作不成功的反馈与数据正常操作之间的差异<ul>
<li>第一种：表示运行结果是否成功</li>
<li>(integer) 0 →false   表示运行失败</li>
<li>(integer) 1 → true   表示运行成功</li>
<li>第二种：表示运行结果值</li>
<li>(integer) 3 →3   表示结果有3个 </li>
<li>(integer) 1 →1   表示结果有1个</li>
</ul>
</li>
<li>数据未获取到<ul>
<li>（nil）等同于null</li>
</ul>
</li>
<li>数据最大存储量<ul>
<li>512MB</li>
</ul>
</li>
<li>数值计算最大范围（java中的long的最大值）<ul>
<li>9223372036854775807</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h2><ul>
<li><p>引入</p>
<ul>
<li>上面存粉丝数量时，它的key的前几位一般都用一样。那么是否可以分开存呢？</li>
<li>hash类型提供了这个操作。hash将前面一样的作为key，不同的作为filed，值还是value。</li>
<li>即原先的&lt;key,value&gt;格式数据变成了&lt;key,filed,value&gt;格式，filed是对key的再细分。</li>
<li>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息。</li>
<li>需要的存储结构：一个存储空间(即key对应的value空间)保存多个键值对数据。</li>
<li>hash类型：底层使用哈希表结构实现数据存储</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210413134700.png"></p>
<ul>
<li>hash存储结构优化：<ul>
<li>如果field数量较少，存储结构优化为类数组结构。</li>
<li>如果field数量较多，存储结构使用HashMap结构。</li>
</ul>
</li>
</ul>
</li>
<li><p>基本使用：</p>
<ul>
<li>添加操作：<em>hset key field value</em>   ： 添加一个&lt;key,field,value&gt;数据</li>
<li>获取数据：<ul>
<li><em>hget key field</em>   ： 获取此key对应filed再对应的value的值</li>
<li><em>hgettall key</em>   ：获取此key对应的所有filed和value的值</li>
</ul>
</li>
<li>删除数据：<em>hdel key field1 [field2]</em>  ：删除此key对应的&lt;field,value&gt;的值。可以删除多个field。</li>
<li>添加/修改多个数据：<em>hmset key field1 value1 field2 value2 …</em> </li>
<li>获取多个数据：<em>hmget key field1 field2 …</em></li>
<li>获取哈希表中字段(即field)的数量：<em>hlen key</em></li>
<li>获取哈希表中是否存在指定的字段：<em>hexists  key field</em></li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210413135951.png"></p>
</li>
<li><p>扩展操作：</p>
<ul>
<li>获取哈希表中所有的字段名或字段值</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hkeys key  --&gt;获取此key对应的所有的field</span><br><span class="line">hvals key  --&gt;获取此key对应的所有的value</span><br></pre></td></tr></table></figure>

<ul>
<li>设置指定字段的数值数据增加指定范围的值（类比string类型的扩展操作）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hincrby key field increment</span><br><span class="line">hincrbyfloat key field increment</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210413141004.png"></p>
</li>
<li><p>注意事项：</p>
<ul>
<li>hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（nil） </li>
<li>每个 hash 可以存储 2^32 - 1 个键值对</li>
<li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，切记不可滥用，更不可以将hash作为对象列表使用</li>
<li>hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈</li>
</ul>
</li>
<li><p>场景一：</p>
<ul>
<li>业务：电商网站购物车设计与实现</li>
<li>解决方案：<ul>
<li> 以客户id作为key，每位客户创建一个hash存储结构存储对应的购物车信息</li>
<li>将商品编号作为field，购买数量作为value进行存储</li>
<li>添加商品：追加全新的field与value</li>
<li>浏览：遍历hash</li>
<li>更改数量：自增/自减，设置value值 </li>
<li>删除商品：删除field</li>
<li>清空：删除key</li>
<li>商品详细信息作为一个独立的hash类型数据存在。</li>
</ul>
</li>
<li>额外解决：<ul>
<li>对于每一个用户，在添加用户购物车信息时，会添加对应商品的详细信息进到redis中。</li>
<li>此时从都添加到redis中，使用hset命令必定会导致重复数据的使用。</li>
<li><strong>另一个命令</strong>：<em>hsetnx key field value</em>  ：当redis的key中不存在此field时插入；存在就不插入。</li>
</ul>
</li>
<li>应用场景：redis 应用于购物车数据存储设计。</li>
</ul>
</li>
<li><p>场景二：</p>
<ul>
<li>应用场景：redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计</li>
</ul>
</li>
<li><p>额外：string存储对象（json）与hash存储对象的区别在哪？</p>
<ul>
<li>string存储对象。注重的是对象整体，常用来对对象的添加和删除。偏向于读。</li>
<li>hash存储对象。注重的是对象的属性，常用来对属性的修改。偏向于写。</li>
</ul>
</li>
</ul>
<h2 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h2><ul>
<li><p>数据存储需求：存储多个数据，并对数据<strong>进入存储空间的顺序</strong>进行区分。</p>
</li>
<li><p>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序。</p>
</li>
<li><p>list类型：保存多个数据，底层使用<strong>双向链表</strong>存储结构实现。</p>
</li>
<li><p>基本操作</p>
<ul>
<li><p>添加/修改数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 往链表的头部依次插入value,value2。相当于Java的头插入</span></span><br><span class="line">lpush key value1 [value2] ……</span><br><span class="line"><span class="meta">#</span><span class="bash"> 往链表的尾部依次插入value,value2。相当于Java的尾插入</span></span><br><span class="line">rpush key value1 [value2] ……</span><br></pre></td></tr></table></figure></li>
<li><p>获取数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从左边读取链表，下标从start到stop。都是闭区间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> start取值从0开始，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> stop也从0开始，但有特殊情况，stop为负时表示倒数第几个。比如为-1表示倒数第一个。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通常在不知道链表的长度时可以使用lrange key 0 -1来获取链表的数据。但当链表只有一个元素时会返回一个空链表。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> start值大于链表长度时会返回一个空链表，start值大于stop值时会将stop的值改为最后的下标。</span></span><br><span class="line">lrange key start stop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取指定index下标位置的数据</span></span><br><span class="line">lindex key index</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取此链表数据的长度</span></span><br><span class="line">llen key</span><br></pre></td></tr></table></figure></li>
<li><p>获取并移除数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 移除链表左边的一个数据。返回值为被删除的元素</span></span><br><span class="line">lpop key</span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除链表右边的一个数据。返回值为被删除的元素</span></span><br><span class="line">rpop key</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210416153009.png"></p>
</li>
<li><p>扩展操作</p>
<ul>
<li><p>规定时间内获取并移除数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 阻塞指定时间内移除链表左边的一个数据。返回值为key和其被移除的数据</span></span><br><span class="line">blpop key1 [key2] timeout</span><br><span class="line"><span class="meta">#</span><span class="bash"> 阻塞指定时间内移除链表左边的一个数据。返回值为key和其被移除的数据</span></span><br><span class="line">brpop key1 [key2] timeout</span><br><span class="line">brpoplpush source destination timeout</span><br></pre></td></tr></table></figure>

<ul>
<li>说明：当链表中有数据时，直接移除数据；当链表中没有数据或没有此链表时，会等待指定的时间，如果此时间内此链表中添加了数据，则会在添加操作执行后有方向的移除数据。否则会返回空。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210416154630.png"></p>
</li>
<li><p>移除指定数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除链表中存在的value,删除count次。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> count大于0表示从左边开始搜索，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> count小于0表示从右边开始搜索，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> count=0表示删除全部于value相等的值</span></span><br><span class="line">lrem key count value</span><br></pre></td></tr></table></figure>

<ul>
<li>因此redis 应用于具有操作先后顺序的数据控制</li>
</ul>
</li>
</ul>
</li>
<li><p>list 类型数据操作注意事项</p>
<ul>
<li>list中保存的数据都是string类型的，数据总容量是有限的，最多2^32 - 1 个元素 (4294967295)</li>
<li>list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作。</li>
<li>获取全部数据操作结束索引设置为-1 。</li>
<li>list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载。</li>
</ul>
</li>
<li><p>list的应用场景</p>
<ul>
<li>twitter、新浪微博、腾讯微博中个人用户的关注列表需要按照用户的关注顺序进行展示，粉丝列表需要将最近关注的粉丝列在前面</li>
<li>新闻、资讯类网站如何将最新的新闻或资讯按照发生的时间顺序展示。</li>
<li>企业运营过程中，系统将产生出大量的运营数据，如何保障多台服务器操作日志的统一顺序输出？<ul>
<li>依赖list的数据具有顺序的特征对信息进行管理。</li>
<li>使用队列模型解决多路信息汇总合并的问题。</li>
<li>使用栈模型解决最新消息的问题。</li>
</ul>
</li>
<li>因此redis 可以应用于最新消息展示。</li>
</ul>
</li>
</ul>
<h2 id="set类型"><a href="#set类型" class="headerlink" title="set类型"></a>set类型</h2><ul>
<li><p>新的存储需求：存储大量的数据，在查询方面提供更高的效率。</p>
</li>
<li><p>需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询。</p>
</li>
<li><p>set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210416161810.png"></p>
</li>
<li><p>基本操作</p>
<ul>
<li><p>添加数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> member1表示数据</span></span><br><span class="line">sadd key member1 [member2]</span><br></pre></td></tr></table></figure></li>
<li><p>获取全部数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure></li>
<li><p>删除数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem key member1 [member2]</span><br></pre></td></tr></table></figure></li>
<li><p>获取集合数据总量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scard key</span><br></pre></td></tr></table></figure></li>
<li><p>判断集合中是否包含指定数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sismember key member</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210416162500.png"></p>
</li>
<li><p>扩展操作</p>
<ul>
<li><p>随机获取集合中指定数量的数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> count不写时，返回一个数据</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> count大于<span class="built_in">set</span>的数据量时，返回全部数据</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> count小于0时，返回以count长度的数组，数组元素中可以重复。</span></span><br><span class="line">srandmember key [count]</span><br></pre></td></tr></table></figure></li>
<li><p>随机获取集合中的某个数据并将该数据移出集合</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spop key [count]</span><br></pre></td></tr></table></figure></li>
<li><p>求两个集合的交、并、差集</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sinter key1 [key2] </span><br><span class="line">sunion key1 [key2] </span><br><span class="line"><span class="meta">#</span><span class="bash"> 差集表示为key1-key2的差</span></span><br><span class="line">sdiff key1 [key2]</span><br></pre></td></tr></table></figure></li>
<li><p>求两个集合的交、并、差集并存储到指定集合中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> destination为目标集合，即要存储到哪个集合中</span></span><br><span class="line">sinterstore destination key1 [key2] </span><br><span class="line">sunionstore destination key1 [key2] </span><br><span class="line">sdiffstore destination key1 [key2]</span><br></pre></td></tr></table></figure></li>
<li><p>将指定数据从原始集合中移动到目标集合中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">source</span>表示原始集合。整个作用相当于删除<span class="built_in">source</span>中的member并将其添加到destination中</span></span><br><span class="line">smove source destination member</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210416164407.png"></p>
</li>
<li><p>应用场景</p>
<ul>
<li>每位用户首次使用今日头条时会设置3项爱好的内容，但是后期为了增加用户的活跃度、兴趣点，必须让用户对其他信息类别逐渐产生兴趣，增加客户留存度，如何实现？<ul>
<li>系统分析出各个分类的最新或最热点信息条目并组织成set集合。</li>
<li>随机挑选其中部分信息。</li>
<li>配合用户关注信息分类中的热点信息组织成展示的全信息集合。</li>
</ul>
</li>
<li>因此redis 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等。</li>
<li>redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索</li>
<li>显示共同关注（一度）</li>
<li>显示共同好友（一度）</li>
<li>由用户A出发，获取到好友用户B的好友信息列表（一度）</li>
<li>由用户A出发，获取到好友用户B的购物清单列表（二度）</li>
<li>由用户A出发，获取到好友用户B的游戏充值列表（二度）</li>
<li>redis 应用于同类型数据的快速去重(网站的访问量)。</li>
<li>redis 应用于基于黑名单与白名单设定的服务控制。</li>
</ul>
</li>
<li><p>set 类型数据操作的注意事项</p>
<ul>
<li> set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份。</li>
<li>set 虽然与hash的存储结构相同，但是无法启用hash中存储值的空间。</li>
</ul>
</li>
</ul>
<h2 id="sorted-set类型"><a href="#sorted-set类型" class="headerlink" title="sorted_set类型"></a>sorted_set类型</h2><ul>
<li>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式。</li>
<li>需要的存储结构：新的存储模型，可以保存可排序的数据。</li>
<li>sorted_set类型：在set的存储结构基础上添加可排序字段。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417084422.png"></p>
<ul>
<li><p>基本操作</p>
<ul>
<li><p>添加数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加&lt;key,member&gt;&lt;score&gt;格式的数据，其中member最为key的值，score作为此键值对排序的依据</span></span><br><span class="line">zadd key score1 member1 [score2 member2]</span><br></pre></td></tr></table></figure></li>
<li><p>获取全部数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 正向遍历sorted_set,数据结果中不含有score数据。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果需要查看score数据，则需要加上 WITHSCORES</span></span><br><span class="line">zrange key start stop [WITHSCORES]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 逆向遍历sorted_set数据</span></span><br><span class="line">zrevrange key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure></li>
<li><p>删除数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 根据&lt;key,score&gt;删除数据</span></span><br><span class="line">zrem key member [member ...]</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417085519.png"></p>
<ul>
<li><p>按条件获取数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 按照score在[min,max]之间的正向输出结果。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">limit</span>和数据库的<span class="built_in">limit</span>操作相同，格式：<span class="built_in">limit</span> index num。表示从index开始取num个</span></span><br><span class="line">zrangebyscore key min max [WITHSCORES] [LIMIT]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 逆向按照score在[max,min]之间输出结果。</span></span><br><span class="line">zrevrangebyscore key max min [WITHSCORES]</span><br></pre></td></tr></table></figure></li>
<li><p>条件删除数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除索引位置在[start,stop]的数据</span></span><br><span class="line">zremrangebyrank key start stop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除score在[min,max]之间的数据</span></span><br><span class="line">zremrangebyscore key min max</span><br></pre></td></tr></table></figure>

<ul>
<li>min与max用于限定搜索查询的条件(全部为闭区间)。</li>
<li>start与stop用于限定查询范围，作用于索引，表示开始和结束索引</li>
<li>offset与count用于限定查询范围，作用于查询结果，表示开始位置和数据总量</li>
</ul>
</li>
<li><p>获取集合数据总量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zcard key</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取集合在[min,max]之间的数据的总量</span></span><br><span class="line">zcount key min max</span><br></pre></td></tr></table></figure></li>
<li><p>集合交、并操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 取集合中member的交集。numkeys表示集合的个数，一定要指明。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 交集后的score值默认为相加后的值，也可以改加为其他操作，比如取交集后score的最大值作为新集合的score值。</span></span><br><span class="line">zinterstore destination numkeys key [key ...]</span><br><span class="line">zunionstore destination numkeys key [key ...]</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417092359.png"></p>
</li>
<li><p>扩展操作</p>
<ul>
<li><p>获取数据对应的索引（排名）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 正向获取此member的索引</span></span><br><span class="line">zrank key member</span><br><span class="line"><span class="meta">#</span><span class="bash"> 逆向获取</span></span><br><span class="line">zrevrank key member</span><br></pre></td></tr></table></figure></li>
<li><p>score值获取与修改</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将member的score值加一</span></span><br><span class="line">zscore key member</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将member的score值加increment。increment可以是负数</span></span><br><span class="line">zincrby key increment member</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417093828.png"></p>
</li>
<li><p>注意事项</p>
<ul>
<li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li>
<li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时候要慎重。</li>
<li>sorted_set 底层存储还是基于set结构的，因此数据不能重复，如果重复添加相同的数据，score值将被反复覆盖，保留最后一次修改的结果。</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>redis 应用于定时任务执行顺序管理或任务过期管理</li>
<li>redis 应用于即时任务/消息队列执行管理</li>
</ul>
</li>
</ul>
<h2 id="redis的解决方案列表"><a href="#redis的解决方案列表" class="headerlink" title="redis的解决方案列表"></a>redis的解决方案列表</h2><ul>
<li>Tips 1：redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性</li>
<li>Tips 2：redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作</li>
<li>Tips 3：redis应用于各种结构型和非结构型高热度数据访问加速</li>
<li>Tips 4：redis 应用于购物车数据存储设计</li>
<li>Tips 5：redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计</li>
<li>Tips 6：redis 应用于具有操作先后顺序的数据控制</li>
<li>Tips 7：redis 应用于最新消息展示</li>
<li>Tips 8：redis 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等</li>
<li>Tips 9：redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索</li>
<li>Tips 10：redis 应用于同类型不重复数据的合并、取交集操作</li>
<li>Tips 11：redis 应用于同类型数据的快速去重</li>
<li>Tips 12：redis 应用于基于黑名单与白名单设定的服务控制</li>
<li>Tips 13：redis 应用于计数器组合排序功能对应的排名</li>
<li>Tips 14：redis 应用于定时任务执行顺序管理或任务过期管理</li>
<li>Tips 15：redis 应用于及时任务/消息队列执行管理</li>
<li>Tips 16：redis 应用于按次结算的服务控制</li>
<li>Tips 17：redis 应用于基于时间顺序的数据操作，而不关注具体时间</li>
</ul>
<h1 id="第三章：通用指令"><a href="#第三章：通用指令" class="headerlink" title="第三章：通用指令"></a>第三章：通用指令</h1><h2 id="key通用指令"><a href="#key通用指令" class="headerlink" title="key通用指令"></a>key通用指令</h2><ul>
<li><p>key特征：key是一个字符串，通过key获取redis中保存的数据。</p>
</li>
<li><p>key应该设计哪些操作？</p>
<ul>
<li>对于key自身状态的相关操作，例如：删除，判定存在，获取类型等</li>
<li>对于key有效性控制相关操作，例如：有效期设定，判定是否有效，有效状态的切换等</li>
<li>对于key快速查询操作，例如：按指定策略查询key</li>
</ul>
</li>
<li><p>基本操作</p>
<ul>
<li><p>删除指定key</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure></li>
<li><p>获取key是否存在</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure></li>
<li><p>获取key的类型</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>扩展操作（时效性控制）</p>
<ul>
<li><p>为指定key设置有效期</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expire key seconds</span><br><span class="line">pexpire key milliseconds</span><br><span class="line"><span class="meta">#</span><span class="bash"> timestamp表示时间戳，以秒为单位</span></span><br><span class="line">expireat key timestamp</span><br><span class="line">pexpireat key milliseconds-timestamp</span><br></pre></td></tr></table></figure></li>
<li><p>获取key的有效时间</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 返回值有三种类型：大于0表示剩余有效时间，-1表示当前key是永久存在的，-2表示当前key不存在</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回时间以秒为单位</span></span><br><span class="line">ttl key</span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回时间以毫秒为单位</span></span><br><span class="line">pttl key</span><br></pre></td></tr></table></figure></li>
<li><p>切换key从时效性转换为永久性</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persist key</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>扩展操作（查询模式）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys pattern</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查询模式规则（正则匹配）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 匹配任意数量的任意符号 </span><br><span class="line">? 配合一个任意符号 </span><br><span class="line">[] 匹配一个指定符号</span><br></pre></td></tr></table></figure></li>
<li><p>例如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">keys *           查询所有</span><br><span class="line">keys it*         查询所有以it开头</span><br><span class="line">keys *heima      查询所有以heima结尾</span><br><span class="line">keys ??heima     查询所有前面两个字符任意，后面以heima结尾</span><br><span class="line">keys user:?      查询所有以user:开头，最后一个字符任意</span><br><span class="line">keys u[st]er:1   查询所有以u开头，以er:1结尾，中间包含一个字母，s或t</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>其他操作</p>
<ul>
<li><p>为key改名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果newkey已存在，则将key的数据添加到newkey中。但要注意类型匹配</span></span><br><span class="line">rename key newkey</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果newkey不存在，重名名才成功</span></span><br><span class="line">renamenx key newkey</span><br></pre></td></tr></table></figure></li>
<li><p>对key的value排序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 排序只能排list,<span class="built_in">set</span>或sorted_set类型的数据</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 排序并不会影响原来key中的数据，排序后的数据会作为返回值给出</span></span><br><span class="line">sort</span><br></pre></td></tr></table></figure></li>
<li><p>key的常用操作的帮助文档</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help @generic</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="数据库通用指令"><a href="#数据库通用指令" class="headerlink" title="数据库通用指令"></a>数据库通用指令</h2><ul>
<li><p>key重复问题</p>
<ul>
<li>key是由程序员定义的。</li>
<li>redis在使用过程中，伴随着操作数据量的增加，会出现大量的数据以及对应的key。</li>
<li>数据不区分种类、类别混杂在一起，极易出现重复或冲突。</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li> redis为每个服务提供有16个数据库，编号从0到15。</li>
<li>每个数据库之间的数据相互独立。</li>
</ul>
</li>
<li><p>基本操作</p>
<ul>
<li><p>切换数据库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> index从0到15</span></span><br><span class="line">select index</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417105037.png"></p>
</li>
<li><p>其他操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 退出客户端，关闭客户端和服务器的连接</span></span><br><span class="line">quit</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试是否能连接上服务器</span></span><br><span class="line">ping</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印消息</span></span><br><span class="line">echo message</span><br></pre></td></tr></table></figure></li>
<li><p>数据移动</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 移动当前库中的key到db库中。db表示为0到15，为库的编号</span></span><br><span class="line">move key db</span><br></pre></td></tr></table></figure></li>
<li><p>数据清除</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前库中的数据的个数，即key的个数</span></span><br><span class="line">dbsize</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除当前库中的数据</span></span><br><span class="line">flushdb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有库中的数据。删库跑路。</span></span><br><span class="line">flushall</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="第四章：jedis"><a href="#第四章：jedis" class="headerlink" title="第四章：jedis"></a>第四章：jedis</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>jedis是编程语言连接redis数据库的中间桥梁。类比于JDBC是作用。</li>
<li>和jedis相同的其他工具有：<ul>
<li>SpringData Redis</li>
<li>Lettuce</li>
</ul>
</li>
<li>jedis适用于多种语言<ul>
<li>C 、C++ 、C# 、Erlang、Lua 、Objective-C 、Perl 、PHP 、Python 、Ruby 、Scala</li>
</ul>
</li>
</ul>
<h2 id="连接redis"><a href="#连接redis" class="headerlink" title="连接redis"></a>连接redis</h2><ul>
<li><p>准备工作</p>
<ul>
<li><p>jar包导入方式</p>
<ul>
<li>下载地址：<a target="_blank" rel="noopener" href="https://plumriver.lanzous.com/iTZHco7gc9i">https://plumriver.lanzous.com/iTZHco7gc9i</a></li>
</ul>
</li>
<li><p>maven依赖方式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>API使用文档：<a target="_blank" rel="noopener" href="https://www.javadoc.io/doc/redis.clients/jedis">https://www.javadoc.io/doc/redis.clients/jedis</a></p>
</li>
</ul>
</li>
<li><p>操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisTest</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testContention</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.连接redis</span></span><br><span class="line">    Jedis redis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">//2.操作redis</span></span><br><span class="line">    <span class="comment">//Jedis类中提供的方法名和redis的操作大致都相同，这很方便我们使用它</span></span><br><span class="line">    redis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;ls&quot;</span>);</span><br><span class="line">    String name = redis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="comment">//3.关闭连接</span></span><br><span class="line">    redis.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="使用jedis读写redis数据"><a href="#使用jedis读写redis数据" class="headerlink" title="使用jedis读写redis数据"></a>使用jedis读写redis数据</h2><ul>
<li><p>简单的体验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testList</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//1.连接redis</span></span><br><span class="line">  Jedis redis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">  <span class="comment">//2.操作redis</span></span><br><span class="line">  redis.del(<span class="string">&quot;list1&quot;</span>);</span><br><span class="line">  redis.lpush(<span class="string">&quot;list1&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">  redis.rpush(<span class="string">&quot;list1&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>);</span><br><span class="line">  List&lt;String&gt; list1 = redis.lrange(<span class="string">&quot;list1&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (String s : list1) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.关闭连接</span></span><br><span class="line">  redis.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHash</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//1.连接redis</span></span><br><span class="line">  Jedis redis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">  <span class="comment">//2.操作redis</span></span><br><span class="line"></span><br><span class="line">  redis.hset(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;ls&quot;</span>);</span><br><span class="line">  redis.hset(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Map&lt;String, String&gt; map = redis.hgetAll(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (String s : map.keySet()) &#123;</span><br><span class="line">    System.out.println(map.get(s));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.关闭连接</span></span><br><span class="line">  redis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="jedis简易化工具开发"><a href="#jedis简易化工具开发" class="headerlink" title="jedis简易化工具开发"></a>jedis简易化工具开发</h2><p><strong>基于连接池技术获取</strong></p>
<ul>
<li><p>JedisPool：Jedis提供的连接池技术</p>
<ul>
<li>poolConfig: 连接池配置对象</li>
<li>host: redis服务地址</li>
<li>port: redis服务端口号</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">  JedisPoolConfig jpc = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">  <span class="comment">//设置最大连接数量</span></span><br><span class="line">  jpc.setMaxTotal(<span class="number">30</span>);</span><br><span class="line">  <span class="comment">//设置最大空闲数量</span></span><br><span class="line">  jpc.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">  String host = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">  <span class="keyword">int</span> port = <span class="number">6379</span>;</span><br><span class="line">  jedisPool = <span class="keyword">new</span> JedisPool(jpc,host,port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>封装连接参数</strong></p>
<ul>
<li><p>使用类是jdbc配置文件的redis.properties</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jedis.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">jedis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">jedis.maxTotal</span>=<span class="string">30</span></span><br><span class="line"><span class="meta">jedis.maxIdle</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    ResourceBundle rb = ResourceBundle.getBundle(<span class="string">&quot;redis&quot;</span>);</span><br><span class="line">    String host = rb.getString(<span class="string">&quot;redis.host&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> port = Integer.parseInt(rb.getString(<span class="string">&quot;redis.port&quot;</span>));</span><br><span class="line">    <span class="keyword">int</span> maxTotal = Integer.parseInt(rb.getString(<span class="string">&quot;redis.maxTotal&quot;</span>));</span><br><span class="line">    <span class="keyword">int</span> maxIdle = Integer.parseInt(rb.getString(<span class="string">&quot;redis.maxIdle&quot;</span>));</span><br><span class="line">    JedisPoolConfig jpc = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">    jpc.setMaxTotal(maxTotal);</span><br><span class="line">    jpc.setMaxIdle(maxIdle);</span><br><span class="line"></span><br><span class="line">    jedisPool = <span class="keyword">new</span> JedisPool(jpc,host,port);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="可视化客户端"><a href="#可视化客户端" class="headerlink" title="可视化客户端"></a>可视化客户端</h2><p>RedisDesktopManager的安装</p>
<ul>
<li><p>下载地址：<a target="_blank" rel="noopener" href="https://plumriver.lanzous.com/iZuUyo7s8gd">https://plumriver.lanzous.com/iZuUyo7s8gd</a></p>
</li>
<li><p>连接redis</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417163442.png"></p>
</li>
<li><p>连接后的界面</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210417163450.png"></p>
</li>
</ul>
<h1 id="第五章：linux环境安装"><a href="#第五章：linux环境安装" class="headerlink" title="第五章：linux环境安装"></a>第五章：linux环境安装</h1><ul>
<li><p>linux-centos7下载地址：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/renlywen/p/13423722.html">https://www.cnblogs.com/renlywen/p/13423722.html</a></p>
</li>
<li><p>VB安装centos方法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013826105/article/details/100175510">https://blog.csdn.net/u013826105/article/details/100175510</a></p>
</li>
<li><p>准备工作：</p>
<ul>
<li>安装wget工具：yum -y install wget</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418145928.png"></p>
<ul>
<li>安装gcc工具：yum install gcc-c++ -y</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418150046.png"></p>
</li>
<li><p>Redis的安装：</p>
<ul>
<li>下载安装包：wget <a target="_blank" rel="noopener" href="http://download.redis.io/releases/redis-4.0.0.tar.gz">http://download.redis.io/releases/redis-4.0.0.tar.gz</a></li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418150410.png"></p>
<ul>
<li><p>解压：tar -xvf redis-4.0.0.tar.gz</p>
</li>
<li><p>进入解压后的文件下：cd redis-4.0.0</p>
</li>
<li><p>编译并安装：make install</p>
</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418150628.png"></p>
<ul>
<li>出现的错误：未装wget,未装gcc，make  distclean 清除编译残留文件</li>
</ul>
</li>
<li><p>Redis服务和客户端的启动</p>
<ul>
<li>默认配置启动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 默认端口启动</span><br><span class="line">redis-server</span><br><span class="line">redis-server --port 6379</span><br><span class="line"># 指定端口启动</span><br><span class="line">redis-server --port 6380 ……</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210418150745.png"></p>
<ul>
<li>Redis客户端连接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 默认连接</span><br><span class="line">redis-cli</span><br><span class="line"># 连接指定服务器</span><br><span class="line">redis-cli -h 127.0.0.1</span><br><span class="line">redis-cli –port 6379</span><br><span class="line">redis-cli -h 127.0.0.1 –port 6379</span><br></pre></td></tr></table></figure></li>
<li><p>使用配置文件文件启动服务</p>
<ul>
<li>查看配置文件。默认的配置文件为redis.conf。在redis目录下。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210419095202.png"></p>
<ul>
<li>redsi.conf默认配置<ul>
<li>*cat redis.conf | grep -v “#” | grep -v “^$”*：查看此文件并去掉文件中的注释和空行</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210419095707.png"></p>
<ul>
<li><p>修改配置文件</p>
<ul>
<li>一般我们都不在源文件上修改，而是复制一个文件，在复制后的文件上修改。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat redis.conf | grep -v &quot;#&quot; | grep -v &quot;^$&quot; &gt; redis-6379.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210419100017.png"></p>
<ul>
<li>修改redis-6379.conf配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 端口号</span><br><span class="line">port 6379</span><br><span class="line"># 表明当前服务是否是一个守护线程。为yes是不会打印日志信息，后台启动形式；为no时会打印日志信息</span><br><span class="line">daemonize yes</span><br><span class="line"># 生成的日志文件存放的位置。</span><br><span class="line">logfile &quot;6379.log&quot;</span><br><span class="line"># 设定当前服务文件保存位置，包含日志文件、持久化文件等。放在data目录下(先创建data目录)。</span><br><span class="line">dir &#x2F;redis-4.0.0&#x2F;data</span><br></pre></td></tr></table></figure>

<ul>
<li>启动。通过客户端连接测试也通过了</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210419104629.png"></p>
</li>
<li><p>创建配置文件管理目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir conf</span><br><span class="line">  或</span><br><span class="line">  mkdir config</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210419105312.png"></p>
</li>
<li><p>创建数据文件管理目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir data</span><br></pre></td></tr></table></figure></li>
<li><p>指定配置文件启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf</span><br><span class="line">  redis-server redis-6379.conf</span><br><span class="line">  redis-server redis-6380.conf ……</span><br><span class="line">  redis-server conf&#x2F;redis-6379.conf</span><br><span class="line">redis-server config&#x2F;redis-6380.conf ……</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Redis基础环境设置</p>
<ul>
<li><p>创建软连接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s 原始目录名 快速访问目录名</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="第六章：redis持久化"><a href="#第六章：redis持久化" class="headerlink" title="第六章：redis持久化"></a>第六章：redis持久化</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。</p>
</li>
<li><p>持久化的目的：防止数据的意外丢失，确保数据安全性。</p>
</li>
<li><p>持久化保存的数据</p>
<ul>
<li>将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据</li>
<li>将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210419110126.png"></p>
</li>
</ul>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><h3 id="第一种启动命令"><a href="#第一种启动命令" class="headerlink" title="第一种启动命令"></a>第一种启动命令</h3><ul>
<li><p>简介：是redis操作者在任何时间都可以保存数据。</p>
<ul>
<li>保存数据的文件名为dump.rdb。保存位置为配置文件的dir设置的目录下。</li>
</ul>
</li>
<li><p>基础命令</p>
<ul>
<li>手动的保存一次数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420101011.png"></p>
</li>
<li><p>相关配置。配置设置在.conf文件下</p>
<ul>
<li><em>dbfilename dump.rdb</em><ul>
<li>说明：设置本地数据库文件名，默认值为 dump.rdb</li>
<li>经验：通常设置为<strong>dump**</strong>-端口号.rdb**</li>
</ul>
</li>
<li><em>dir</em><ul>
<li>说明：设置存储.rdb文件的路径</li>
<li>经验：通常设置成存储空间较大的目录中，上面配置时已经设置为data</li>
</ul>
</li>
<li><em>rdbcompression yes</em><ul>
<li>说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩</li>
<li>经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）</li>
</ul>
</li>
<li><em>rdbchecksum yes</em><ul>
<li>说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行</li>
<li>经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420102046.png"></p>
</li>
<li><p>save指令工作原理</p>
<ul>
<li>由于redis在此版本中是单线程的，而且save指令会占用一定的CPU。</li>
<li>save指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用。</li>
</ul>
</li>
</ul>
<h3 id="第二种启动命令"><a href="#第二种启动命令" class="headerlink" title="第二种启动命令"></a>第二种启动命令</h3><ul>
<li><p>目的：解决<strong>数据量过大，单线程执行方式造成效率过低的问题</strong></p>
</li>
<li><p>使用方式：redis操作者发起指令，redis在合理的时间执行，执行保存数据。简而言之就是后台执行。</p>
</li>
<li><p>命令作用：手动启动，在后台保存。不是立即执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgsave</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420103829.png"></p>
<ul>
<li>后台执行的结果可以在日志中查看</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420103857.png"></p>
</li>
<li><p>工作原理</p>
<ul>
<li> bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用。</li>
<li>实质上是在接收到命令后，开启了子线程来执行保存操作</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420104023.png"></p>
</li>
<li><p>相关配置</p>
<ul>
<li><em>stop-writes-on-bgsave-error yes</em></li>
<li>说明：后台存储过程中如果出现错误现象，是否停止保存操作</li>
<li>经验：通常默认为开启状态</li>
</ul>
</li>
</ul>
<h3 id="第三种启动命令"><a href="#第三种启动命令" class="headerlink" title="第三种启动命令"></a>第三种启动命令</h3><ul>
<li><p>目的：<strong>解决反复执行保存指令，忘记了怎么办？不知道数据产生了多少变化，何时保存？</strong></p>
</li>
<li><p>使用方式：redis操作者发起指令，当满足一定条件，执行保存操作。</p>
</li>
<li><p>启动方式：使用配置来达成操作</p>
<ul>
<li><p>配置 :  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># second：监控时间范围</span><br><span class="line"># changes：监控key的变化量</span><br><span class="line">save second changes</span><br></pre></td></tr></table></figure></li>
<li><p>作用：满足限定时间范围内key的变化数量达到指定数量即进行持久化</p>
</li>
<li><p>位置：在.conf配置文件种配置</p>
</li>
<li><p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 在900秒内数据发生了一次变化</span><br><span class="line">save 900 1 </span><br><span class="line"># 在300秒没数据发生了一次变化</span><br><span class="line">save 300 10</span><br><span class="line"># 在60秒内，数据发生了10000次变化</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>工作原理</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420105657.png"></p>
</li>
<li><p>注意点：</p>
<ul>
<li> save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的。</li>
<li>save配置中对于second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系</li>
<li>save配置启动后执行的是bgsave操作。</li>
</ul>
</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table>
<thead>
<tr>
<th><strong>方式</strong></th>
<th><strong>save指令</strong></th>
<th><strong>bgsave指令</strong></th>
</tr>
</thead>
<tbody><tr>
<td>读写</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>阻塞客户端指令</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>额外内存消耗</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>启动新进程</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<h3 id="特殊的启动方式"><a href="#特殊的启动方式" class="headerlink" title="特殊的启动方式"></a>特殊的启动方式</h3><ul>
<li><p>全量复制：在后面</p>
</li>
<li><p>服务运行过程中重启，会自动执行保存命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug reload</span><br></pre></td></tr></table></figure></li>
<li><p>关闭客户端服务器时保存数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 指定保存数据或不保存数据</span><br><span class="line">shutdown save&#x2F;nosave</span><br></pre></td></tr></table></figure>

<ul>
<li>默认情况下执行shutdown命令时，自动执行bgsave(如果没有开启AOF持久化功能)</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>优点：<ul>
<li>RDB是一个紧凑压缩的二进制文件，存储效率较高</li>
<li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景</li>
<li>RDB恢复数据的速度要比AOF快很多</li>
<li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。</li>
</ul>
</li>
<li>缺点：<ul>
<li>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据</li>
<li>bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能</li>
<li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象.</li>
</ul>
</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><ul>
<li>RDB存储的弊端<ul>
<li> 存储数据量较大，时间效率较低。基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低</li>
<li>大数据量下的IO性能较低</li>
<li>基于fork创建子进程，内存产生额外消耗</li>
<li>宕机带来的数据丢失风险</li>
</ul>
</li>
<li>解决思路<ul>
<li>不写全数据，仅记录部分数据</li>
<li>降低区分数据是否改变的难度，改记录数据为记录操作过程</li>
<li>对所有操作均进行记录，排除丢失数据的风险</li>
</ul>
</li>
<li><strong>AOF(append only file)持久化</strong>：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程。</li>
<li>AOF的主要作用是<strong>解决了数据持久化的实时性</strong>，目前已经是Redis持久化的主流方式</li>
</ul>
<h3 id="AOF写策略"><a href="#AOF写策略" class="headerlink" title="AOF写策略"></a>AOF写策略</h3><ul>
<li><p>AOF写的过程</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420111603.png"></p>
</li>
<li><p>三种写策略</p>
<ul>
<li> always(每次）</li>
<li>每次写入操作均同步到AOF文件中，<font color="red">数据零误差，性能较低</font>，不建议使用。 </li>
<li>everysec（每秒）<ul>
<li>每秒将缓冲区中的指令同步到AOF文件中，<font color="red">数据准确性较高，性能较高</font>，建议使用，也是默认配置。在系统突然宕机的情况下丢失1秒内的数据。（存在aof缓冲区）</li>
</ul>
</li>
<li>no（系统控制）<ul>
<li>由操作系统控制每次同步到AOF文件的周期，整体过程<font color="red">不可控</font></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="AOF功能的开启"><a href="#AOF功能的开启" class="headerlink" title="AOF功能的开启"></a>AOF功能的开启</h3><ul>
<li><p>第一步：该配置</p>
<ul>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes|no</span><br></pre></td></tr></table></figure></li>
<li><p>作用：是否开启AOF持久化功能，默认为不开启状态</p>
</li>
</ul>
</li>
<li><p>第二步：配置写策略</p>
<ul>
<li>配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always|everysec|no</span><br></pre></td></tr></table></figure>

<ul>
<li>作用：AOF写数据策略</li>
</ul>
</li>
<li><p>aof文件所在的位置</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420160145.png"></p>
</li>
<li><p>相关的配置</p>
<ul>
<li><p>作用：AOF持久化文件名，默认文件名未appendonly.aof，建议配置为appendonly-端口号.aof</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfilename filename</span><br></pre></td></tr></table></figure></li>
<li><p>作用：AOF持久化文件保存路径，与RDB持久化文件保持一致即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><ul>
<li><p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将对同一个数据的若干个条命令执行结果转化成最终结果数据对应的指令进行记录。</p>
</li>
<li><p>作用：</p>
<ul>
<li>降低磁盘占用量，提高磁盘利用率</li>
<li>提高持久化效率，降低持久化写时间，提高IO性能</li>
<li>降低数据恢复用时，提高数据恢复效率</li>
</ul>
</li>
<li><p>重写效果示意图</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420160950.png"></p>
</li>
<li><p>重写规则</p>
<ul>
<li>进程内已超时的数据不再写入文件</li>
<li>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令<ul>
<li>如del key1、 hdel key2、srem key3、set key4 111、set key4 222等 </li>
</ul>
</li>
<li>对同一数据的多条写命令合并为一条命令<ul>
<li>如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c。</li>
<li>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</li>
</ul>
</li>
</ul>
</li>
<li><p>重写方式：</p>
<ul>
<li><p>手动重写指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># bg开头表示是系统后台运行的</span><br><span class="line">bgrewriteaof</span><br></pre></td></tr></table></figure>

<ul>
<li>重写工作原理的RDB的bgsave原理相似。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420161857.png"></p>
</li>
<li><p>自动重写配置</p>
<ul>
<li>自动重写触发条件设置(可以任选一个配置，也可以两个都配置)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 自动重写的文件大小，当达到最小值就重写</span><br><span class="line">auto-aof-rewrite-min-size size</span><br><span class="line"># 自动重写的百分比，达到百分比后就重写</span><br><span class="line">auto-aof-rewrite-percentage percent</span><br></pre></td></tr></table></figure>

<ul>
<li>自动重写触发对比参数( 客户端运行指令info Persistence获取运行属性值)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 当前缓冲中aof文件的大小，在运行时获取</span><br><span class="line">aof_current_size</span><br><span class="line"># aof文件的基础大小</span><br><span class="line">aof_base_size</span><br></pre></td></tr></table></figure>

<ul>
<li>自动重写触发条件</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420163258.png"></p>
</li>
</ul>
</li>
<li><p>重写的工作原理</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420164118.png"></p>
</li>
<li><p>AOF缓冲区同步文件策略：由参数appendfsync控制</p>
<ul>
<li>write操作会触发延迟写（delayed write）机制，Linux在内核提供页缓冲区用来提高硬盘IO性能。write操作在写入系统缓冲区后直接返回。同步硬盘操作依赖于系统调度机制，列如：缓冲区页空间写满或达到特定时间周期。同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。</li>
<li>fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞知道写入硬盘完成后返回，保证了数据持久化。</li>
<li>除了write、fsync、Linx还提供了sync、fdatasync操作，具体API说明参见：</li>
</ul>
</li>
</ul>
<h2 id="RDB和AOF的区别"><a href="#RDB和AOF的区别" class="headerlink" title="RDB和AOF的区别"></a>RDB和AOF的区别</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420164403.png"></p>
<ul>
<li>对数据非常敏感，建议使用默认的AOF持久化方案<ul>
<li>AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。</li>
<li>注意：由于AOF文件存储体积较大，且恢复速度较慢</li>
</ul>
</li>
<li>数据呈现阶段有效性，建议使用RDB持久化方案<ul>
<li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段点数据恢复通常采用RDB方案。</li>
<li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，</li>
</ul>
</li>
<li>综合比对<ul>
<li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊。</li>
<li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF。</li>
<li>如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB。</li>
<li>灾难恢复选用RDB。</li>
<li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量。</li>
</ul>
</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420164436.png"></p>
<h1 id="第七章：redis事务"><a href="#第七章：redis事务" class="headerlink" title="第七章：redis事务"></a>第七章：redis事务</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul>
<li><p>简介：</p>
<ul>
<li>redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性按照添加顺序依次执行，中间不会被打断或者干扰。</li>
<li>一个队列中，一次性、顺序性、排他性的执行一系列命令。</li>
</ul>
</li>
<li><p>Redis事务实现的方式：</p>
<ul>
<li>存在两个标记位multi和exec，标记位范围内的命令被组合成一个事务。</li>
</ul>
</li>
<li><p>基本操作</p>
<ul>
<li><p>开启事务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multi</span><br></pre></td></tr></table></figure>

<ul>
<li>作用：设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</li>
</ul>
</li>
<li><p>执行事务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec</span><br></pre></td></tr></table></figure>

<ul>
<li>作用：设定事务的结束位置，同时执行事务。与multi成对出现，成对使用</li>
</ul>
</li>
<li><p>取消事务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discard</span><br></pre></td></tr></table></figure>

<ul>
<li>作用：终止当前事务的定义，发生在multi之后，exec之前</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420171134.png"></p>
</li>
<li><p>注意：<font color="red">加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行</font></p>
</li>
<li><p>事务的工作流程</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420171445.png"></p>
</li>
<li><p>注意事项</p>
<ul>
<li><strong>定义事务的过程中，命令格式输入错误怎么办？</strong><ul>
<li>语法错误：指命令书写格式有误</li>
<li>处理结果：如果定义的事务中所包含的命令存在语法错误，整体事务中所有命令均不会执行。包括那些语法正确的命令。</li>
</ul>
</li>
<li><strong>定义事务的过程中，命令执行出现错误怎么办？</strong><ul>
<li>运行错误：指命令格式正确，但是无法正确的执行。例如对list进行incr操作。</li>
<li>处理结果：能够正确运行的命令会执行，运行错误的命令不会被执行。</li>
</ul>
</li>
<li>注意：已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚。</li>
</ul>
</li>
<li><p>事务回滚</p>
<ul>
<li>redis不提供自动回滚操作</li>
<li>使用手动回滚<ul>
<li>记录操作过程中被影响的数据之前的状态。</li>
<li>设置指令恢复所有的被修改的项。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="场景一：监视锁"><a href="#场景一：监视锁" class="headerlink" title="场景一：监视锁"></a>场景一：监视锁</h3><ul>
<li><p>业务场景</p>
<ul>
<li>天猫双11热卖过程中，对已经售罄的货物追加补货，4个业务员都有权限进行补货。补货的操作可能是一系列的操作，牵扯到多个连续操作，如何保障不会重复操作？</li>
</ul>
</li>
<li><p>业务分析</p>
<ul>
<li>多个客户端有可能同时操作同一组数据，并且该数据一旦被操作修改后，将不适用于继续操作</li>
<li>在操作之前锁定要操作的数据，一旦发生变化，终止当前操作</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch key1 [key2……]</span><br></pre></td></tr></table></figure></li>
<li><p>取消对所有 key 的监视</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unwatch</span><br><span class="line"># 当exec执行命令后，事务中的监视锁会被取消。</span><br><span class="line"># 当执行discard命令时，也会取消对所有key的监视。</span><br></pre></td></tr></table></figure></li>
<li><p>应用场景：redis 应用基于状态控制的批量任务执行</p>
</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420173211.png"></p>
</li>
</ul>
<h3 id="场景二：分布式锁-同步锁"><a href="#场景二：分布式锁-同步锁" class="headerlink" title="场景二：分布式锁/同步锁"></a>场景二：分布式锁/同步锁</h3><ul>
<li><p>业务场景</p>
<ul>
<li>天猫双11热卖过程中，对已经售罄的货物追加补货，且补货完成。客户购买热情高涨，3秒内将所有商品购买完毕。本次补货已经将库存全部清空，如何避免最后一件商品不被多人同时购买？【超卖问题】</li>
</ul>
</li>
<li><p>业务分析</p>
<ul>
<li>使用watch监控一个key有没有改变已经不能解决问题，此处要监控的是具体数据</li>
<li>虽然redis是单线程的，但是多个客户端对同一数据同时进行操作时，如何避免不被同时修改？</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>使用 setnx 设置一个公共锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># lock-key为锁的名字</span><br><span class="line">setnx lock-key value</span><br><span class="line"># 实际为string类型的操作，只是它的返回值具有一个特点。所以可以当锁使用。</span><br><span class="line"># 原型为 setnx key value</span><br></pre></td></tr></table></figure>

<ul>
<li>利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功</li>
<li>对于返回设置成功的，拥有控制权，进行下一步的具体业务操作。</li>
<li>对于返回设置失败的，不具有控制权，排队或等待。</li>
</ul>
</li>
<li><p>操作完毕通过del操作释放锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del lock-key</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>应用场景：redis 应用基于分布式锁对应的场景控制</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210420173951.png"></p>
</li>
</ul>
<h3 id="场景三：分布式锁的改良"><a href="#场景三：分布式锁的改良" class="headerlink" title="场景三：分布式锁的改良"></a>场景三：分布式锁的改良</h3><ul>
<li><p>业务场景</p>
<ul>
<li>依赖分布式锁的机制，某个用户操作时对应客户端宕机，且此时已经获取到锁。如何解决？</li>
</ul>
</li>
<li><p>业务分析</p>
<ul>
<li>由于锁操作由用户控制加锁解锁，必定会存在加锁后未解锁的风险。</li>
<li>需要解锁操作不能仅依赖用户控制，系统级别要给出对应的保底处理方案。</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>使用expire 为锁key添加时间限定，到时不释放，放弃锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expire lock-key second</span><br><span class="line">pexpire lock-key milliseconds</span><br></pre></td></tr></table></figure></li>
<li><p>由于操作通常都是微秒或毫秒级，因此该锁定时间不宜设置过大。具体时间需要业务测试后确认。</p>
<ul>
<li>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。 </li>
<li>测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时。</li>
<li>锁时间设定推荐：最大耗时*120%+平均网络延迟*110%</li>
<li>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可。</li>
</ul>
</li>
</ul>
<h1 id="第八章：删除策略"><a href="#第八章：删除策略" class="headerlink" title="第八章：删除策略"></a>第八章：删除策略</h1><h2 id="过期数据"><a href="#过期数据" class="headerlink" title="过期数据"></a>过期数据</h2><ul>
<li><p>Redis中的数据特征</p>
<ul>
<li>Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态</li>
<li>XX ：具有时效性的数据</li>
<li>-1 ：永久有效的数据</li>
<li> -2 ：<strong>已经过期的数据</strong> 或 被删除的数据 或 未定义的数据</li>
</ul>
</li>
<li><p>过期数据：指已经过期的数据，但是暂时并没有被删除的数据。</p>
</li>
<li><p>数据删除策略</p>
<ul>
<li>定时删除</li>
<li>惰性删除</li>
<li>定期删除</li>
</ul>
</li>
<li><p>Redis数据的时效性存储原理</p>
<ul>
<li>第一步：在内存中添加一个键值对，此时值的存储地址是已经知道的。</li>
<li>第二步：在内存中有一片区域是被称为过期区/时效区，此区域存放的键值对，键是上面的存储地址，值是时间。</li>
<li>示例如下</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422090428.png"></p>
</li>
</ul>
<h2 id="数据删除策略"><a href="#数据删除策略" class="headerlink" title="数据删除策略"></a>数据删除策略</h2><ul>
<li>目标：在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露。<ul>
<li>即：当CPU忙时，此时的过期数据不用现在就删除，可以等不忙的时候再删。</li>
</ul>
</li>
</ul>
<h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><ul>
<li>定义<ul>
<li>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作。</li>
</ul>
</li>
<li>优点：节约内存，到时就删除，快速释放掉不必要的内存占用。</li>
<li>缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量。</li>
<li>总结：到点就删，用处理器性能换取存储空间（拿时间换空间）</li>
</ul>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><ul>
<li>定义：<ul>
<li>数据到达过期时间，不做处理。等下次访问该数据时。<ul>
<li>如果未过期，返回数据。</li>
<li>发现已过期，删除，返回不存在。</li>
</ul>
</li>
<li>在redis中，每次执行获取操作之前都会先执行*expireIfNeeded()*方法，此方法用于判断数据是否过期。</li>
</ul>
</li>
<li>优点：节约CPU性能，发现必须删除的时候才删除。</li>
<li>缺点：内存压力很大，大量数据不删除会出现长期占用内存的数据。</li>
<li>总结：用存储空间换取处理器性能 （拿时间换空间）</li>
</ul>
<h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><ul>
<li>首先要知道redis有16个库，每个库都会有对应的过期区，从expires[0]到expires[15]</li>
<li>删除过程：<ul>
<li>首先：Redis启动服务器初始化时，读取配置server.hz的值，此值默认为10。</li>
<li>然后：Redis每秒钟执行server.hz次**serverCron()**方法</li>
<li>**serverCron()<strong>方法会调用</strong>databasesCron()**方法，</li>
<li>**activeExpireCycle()<strong>方法会循环查找每个库，循环过程中会调用</strong>activeExpireCycle()**方法。</li>
<li>**activeExpireCycle()**方法会对每个库中的expires区中的数据进行检测，每次执行时间为250ms/server.hz。</li>
<li>对某个expires检测时，随机挑选W个key检测<ul>
<li>如果key超时，删除key。</li>
<li>如果一轮中删除的key的数量&gt;W*25%，循环该过程。</li>
<li>如果一轮中删除的key的数量≤W*25%，检查下一个expires，0-15循环。</li>
</ul>
</li>
<li>检测过程中，参数current_db用于记录<strong>activeExpireCycle()</strong> 进入哪个库的expires 执行。</li>
<li>如果**activeExpireCycle()**执行时间到期，下次从current_db继续向下执行。</li>
</ul>
</li>
<li>补充说明：<ul>
<li>W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值。</li>
<li>在配置文件中配置。</li>
</ul>
</li>
<li>定义：<ul>
<li>周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度。</li>
</ul>
</li>
<li>特点：<ul>
<li>CPU性能占用设置有峰值，检测频度可自定义设置。</li>
<li>内存压力不是很大，长期占用内存的冷数据会被持续清理。</li>
</ul>
</li>
<li>总结：周期性抽查存储空间随机抽查，重点抽查）</li>
</ul>
<h3 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h3><ul>
<li>Redis默认使用的删除策略是<strong>惰性删除加定期删除</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">定时删除</th>
<th align="center">惰性删除</th>
<th align="center">定期删除</th>
</tr>
</thead>
<tbody><tr>
<td align="center">节约内存，无占用</td>
<td align="center">内存占用严重</td>
<td align="center">内存定期随机清理</td>
</tr>
<tr>
<td align="center">不分时段占用CPU资源，频度高</td>
<td align="center">延时执行，CPU利用率高</td>
<td align="center">每秒花费固定的CPU资源维护内存</td>
</tr>
<tr>
<td align="center">拿时间换空间</td>
<td align="center">拿空间换时间</td>
<td align="center">随机抽查，重点抽查</td>
</tr>
</tbody></table>
<h2 id="逐出算法"><a href="#逐出算法" class="headerlink" title="逐出算法"></a>逐出算法</h2><ul>
<li><p>出现的原因</p>
<ul>
<li>Redis使用内存存储数据，在执行每一个命令前，会调用**freeMemoryIfNeeded()**检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。</li>
<li>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422094937.png"></p>
<ul>
<li>即当redis中的数据太多了，已经占用满了内存，还想往redis中添加数据，此时就要删除一些数据了。</li>
</ul>
</li>
<li><p>相关配置</p>
<ul>
<li><p>配置redis最大可使用内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory</span><br></pre></td></tr></table></figure>

<ul>
<li>占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。</li>
</ul>
</li>
<li><p>配置每次选取待删除数据的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-samples</span><br></pre></td></tr></table></figure>

<ul>
<li>选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据。</li>
</ul>
</li>
<li><p>配置删除策略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy </span><br><span class="line"># 例如： maxmemory-policy  volatile-lru</span><br></pre></td></tr></table></figure>

<ul>
<li>达到最大内存后的，对被挑选出来的数据进行删除的策略。</li>
</ul>
</li>
</ul>
</li>
<li><p>8种逐出算法的删除策略</p>
<ul>
<li>检测易失数据（可能会过期的数据集server.db[i].expires ） <ul>
<li>① volatile-lru：挑选最近最少使用的数据淘汰</li>
<li>② volatile-lfu：挑选最近使用次数最少的数据淘汰</li>
<li>③ volatile-ttl：挑选将要过期的数据淘汰</li>
<li>④ volatile-random：任意选择数据淘汰</li>
</ul>
</li>
<li>检测全库数据（所有数据集server.db[i].dict ）<ul>
<li>⑤ allkeys-lru：挑选最近最少使用的数据淘汰</li>
<li>⑥ allkeys-lfu：挑选最近使用次数最少的数据淘汰</li>
<li>⑦ allkeys-random：任意选择数据淘汰</li>
</ul>
</li>
<li>放弃数据驱逐<ul>
<li>⑧ no-enviction（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory）</li>
</ul>
</li>
</ul>
</li>
<li><p>策略配置依据</p>
<ul>
<li>虽然我们并不能看到每个数据的使用情况。</li>
<li>但是我们可以使用INFO命令输出监控信息，查询缓存 hit 和 miss 的次数，根据业务需求调优Redis配置。</li>
<li>hit表示命中率，miss表示缺失率。</li>
</ul>
</li>
</ul>
<h1 id="第九章：redis服务器配置"><a href="#第九章：redis服务器配置" class="headerlink" title="第九章：redis服务器配置"></a>第九章：redis服务器配置</h1><ul>
<li>基本的配置。配置文件：redis.conf</li>
</ul>
<h2 id="服务器端设定"><a href="#服务器端设定" class="headerlink" title="服务器端设定"></a>服务器端设定</h2><ul>
<li><p>设置服务器以守护进程的方式运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes|no</span><br></pre></td></tr></table></figure></li>
<li><p>绑定主机地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1</span><br></pre></td></tr></table></figure></li>
<li><p>设置服务器端口号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br></pre></td></tr></table></figure></li>
<li><p>设置数据库数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">databases 16</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><ul>
<li><p>设置服务器以指定日志记录级别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loglevel debug|verbose|notice|warning</span><br></pre></td></tr></table></figure></li>
<li><p>日志记录文件名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logfile 端口号.log</span><br></pre></td></tr></table></figure></li>
<li><p>注意：日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频度。</p>
</li>
</ul>
<h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><ul>
<li><p>设置同一时间最大客户端连接数，默认无限制。当客户端连接到达上限，Redis会关闭新的连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxclients 0</span><br></pre></td></tr></table></figure></li>
<li><p>客户端闲置等待最大时长，达到最大值后关闭连接。如需关闭该功能，设置为 0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout 300</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="多服务器快捷配置"><a href="#多服务器快捷配置" class="headerlink" title="多服务器快捷配置"></a>多服务器快捷配置</h2><ul>
<li><p>导入并加载指定配置文件信息，用于快速创建redis公共配置较多的redis实例配置文件，便于维护</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &#x2F;path&#x2F;server-端口号.conf</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="第十章：高级数据类型"><a href="#第十章：高级数据类型" class="headerlink" title="第十章：高级数据类型"></a>第十章：高级数据类型</h1><h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><ul>
<li><p>BItmaps数据类型是以字符串string类型为基础的，在value上存储字符串，但字符串的数据格式是一个二进制数。理论上这个二进制数长度小于2^32。</p>
<ul>
<li>例如&lt;key,value&gt;  表示为&lt;08,001010&gt;。08表示key，001010表示value。</li>
<li>但是此数据类型并不是直接设置value值的，而是对二进制数的某一位进行操作。</li>
<li>此数据类型和二进制值相结合，通常只用来表示某种状态，而不是用来表示数的。</li>
<li>0和1可以表示两种相对立的状态。</li>
</ul>
</li>
<li><p>操作命令</p>
<ul>
<li><p>获取指定key对应偏移量上的bit值。(偏移量表示二进制数从右开始数的第几位)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如果 key不存在或者此偏移量上的值未被定义，都返回0</span><br><span class="line">getbit key offset</span><br></pre></td></tr></table></figure></li>
<li><p>设置指定key对应偏移量上的bit值，value只能是1或0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure></li>
<li><p>对指定key按位进行交、并、非、异或操作，并将结果保存到destKey中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># op表示要执行的操作类型，destKey是一个Bitmaps类型的数据</span><br><span class="line">bitop op destKey key1 [key2...]</span><br></pre></td></tr></table></figure>

<ul>
<li>and：交</li>
<li>or：并</li>
<li>not：非</li>
<li>xor：异或</li>
</ul>
</li>
<li><p>统计指定key中1的数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount key [start end]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>举例：统计电影院某天某部电影是否被点播，每天有多少电影没电播。</p>
<ul>
<li>0，4，5，8分别表示一部电影，11表示11号，12表示12号</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422104028.png"></p>
</li>
<li><p>应用：redis 应用于信息状态统计</p>
</li>
</ul>
<h2 id="HyperLongLong"><a href="#HyperLongLong" class="headerlink" title="HyperLongLong"></a>HyperLongLong</h2><ul>
<li><p>应用：统计用户的数量</p>
<ul>
<li>原始方法：使用set存储每个用户的id</li>
<li>改进方法：使用Bitmaps存储每个用户状态</li>
<li>全新方法：使用HyperLogLog</li>
</ul>
</li>
<li><p>HyperLogLog 是用来做基数统计的，运用了LogLog的算法</p>
<ul>
<li>基数是数据集去重后元素个数。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422143019.png"></p>
</li>
<li><p>命令操作</p>
<ul>
<li><p>添加数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element [element ...]</span><br></pre></td></tr></table></figure></li>
<li><p>统计数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfcount key [key ...]</span><br></pre></td></tr></table></figure></li>
<li><p>合并数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfmerge destkey sourcekey [sourcekey...]</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422143406.png"></p>
</li>
<li><p>应用：redis 应用于独立信息统计。</p>
</li>
<li><p>相关说明</p>
<ul>
<li>用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据</li>
<li>核心是基数估算算法，最终数值存在一定误差</li>
<li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li>
<li>耗空间极小，每个hyperloglog key占用了12K的内存用于标记基数</li>
<li>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大</li>
<li>Pfmerge命令合并后占用的存储空间为12K，无论合并之前数据量多少</li>
</ul>
</li>
</ul>
<h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><ul>
<li><p>简称地图。</p>
</li>
<li><p>适用于生活服务类软件。</p>
<ul>
<li>例如高德地图，美团，携程</li>
</ul>
</li>
<li><p>作用：在一个集合中，如果给定两个点的坐标，它会以地球为原型，从而计算出这两点之间的距离，以及执行相关的操作。</p>
</li>
<li><p>命令操作</p>
<ul>
<li><p>添加坐标点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># member表示坐标点的名称</span><br><span class="line">geoadd key longitude latitude member [longitude latitude member ...]</span><br></pre></td></tr></table></figure></li>
<li><p>获取指定点的坐标</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geopos key member [member ...]</span><br></pre></td></tr></table></figure></li>
<li><p>计算点与点之间的距离</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># unit表示单位，默认以m为单位。可以取值m|km|ft|mi</span><br><span class="line">geodist key member1 member2 [unit]</span><br></pre></td></tr></table></figure></li>
<li><p>以给订的作表为中心，返回距离中心不超过给定距离的所有位置的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># radius表示距离,withcoord表示经度和维度，withdist表示坐标</span><br><span class="line">georadius key longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count] [ASC|DESC]</span><br></pre></td></tr></table></figure></li>
<li><p>以某个坐标点为中心，返回距离中心不超过给定距离的所有位置的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count] [ASC|DESC]</span><br></pre></td></tr></table></figure></li>
<li><p>返回坐标点的hash表示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geohash key member [member ...]</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422145251.png"></p>
</li>
<li><p>应用：redis 应用于地理位置计算</p>
</li>
</ul>
<h1 id="第十一章：主从复制"><a href="#第十一章：主从复制" class="headerlink" title="第十一章：主从复制"></a>第十一章：主从复制</h1><ul>
<li>互联网的三高架构：<ul>
<li>高并发</li>
<li>高性能</li>
<li>高可用</li>
</ul>
</li>
</ul>
<h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>单机redis的风险与问题</p>
<ul>
<li>问题1：机器故障<ul>
<li>现象：硬盘故障、系统崩溃</li>
<li>本质：数据丢失，很可能对业务造成灾难性打击</li>
<li>结论：基本上会放弃使用redis。</li>
</ul>
</li>
<li>问题2.容量瓶颈<ul>
<li>现象：内存不足，从16G升级到64G，从64G升级到128G，无限升级内存</li>
<li>本质：穷，硬件条件跟不上</li>
<li>结论：放弃使用redis</li>
</ul>
</li>
<li>结论：为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服务器上，连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据冗余备份。</li>
</ul>
</li>
<li><p>多台服务器连接方案</p>
<ul>
<li>提供数据方：master<ul>
<li>主服务器，主节点，主库，主客户端</li>
</ul>
</li>
<li>接收数据方：slave<ul>
<li>从服务器，从节点，从库，从客户端</li>
</ul>
</li>
<li>需要解决的问题：数据同步</li>
<li>核心工作：master的数据复制到slave中</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422154656.png"></p>
</li>
<li><p>主从复制</p>
<ul>
<li>主从复制即将master中的数据即时、有效的复制到slave中。</li>
<li>特征：一个master可以拥有多个slave，一个slave只对应一个master。</li>
<li>master:<ul>
<li>写数据</li>
<li>执行写操作时，将出现变化的数据自动同步到slave</li>
<li>读数据（可忽略）</li>
</ul>
</li>
<li>slave:<ul>
<li>读数据</li>
<li>写数据（禁止）</li>
</ul>
</li>
</ul>
</li>
<li><p>主从复制的作用</p>
<ul>
<li>读写分离：master写、slave读，提高服务器的读写负载能力</li>
<li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li>
<li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li>
<li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li>
<li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li>
</ul>
</li>
</ul>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul>
<li><p>主从复制过程大体可以分为3个阶段</p>
<ul>
<li>建立连接阶段（即准备阶段）</li>
<li>数据同步阶段</li>
<li>命令传播阶段 </li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422160159.png"></p>
</li>
</ul>
<h3 id="建立连接阶段"><a href="#建立连接阶段" class="headerlink" title="建立连接阶段"></a>建立连接阶段</h3><ul>
<li><p> 目的：建立slave到master的连接，使master能够识别slave，并保存slave端口号。</p>
</li>
<li><p>步骤：</p>
<ul>
<li>步骤1：设置master的地址和端口，保存master信息</li>
<li>步骤2：建立socket连接</li>
<li>步骤3：发送ping命令（定时器任务）</li>
<li>步骤4：身份验证</li>
<li>步骤5：发送slave端口信息</li>
<li>至此，主从连接成功！</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422160539.png"></p>
</li>
<li><p>状态：</p>
<ul>
<li>slave：<ul>
<li>保存master的地址与端口</li>
</ul>
</li>
<li>master：<ul>
<li>保存slave的端口</li>
</ul>
</li>
<li>总体：<ul>
<li>创建了连接的socket</li>
</ul>
</li>
</ul>
</li>
<li><p>连接命令</p>
<ul>
<li><p>方式一：slave客户端发送命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"># 例如：slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure></li>
<li><p>方式二：启动slave服务器时添加参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"># 例如：redis-server redis-6378.conf -slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure></li>
<li><p>方式三：slave服务器配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422163037.png"></p>
</li>
<li><p>连接后的状态。输入info</p>
<ul>
<li>master服务器</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422163355.png"></p>
<ul>
<li>slave服务器</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422163247.png"></p>
</li>
</ul>
</li>
<li><p>断开连接命令</p>
<ul>
<li><p>slave客户端发送指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure></li>
<li><p>slave断开连接后，不会删除已有数据，只是不再接受master发送的数据</p>
</li>
</ul>
</li>
<li><p>授权访问的命令</p>
<ul>
<li><p>master服务器设置密码</p>
<ul>
<li>master客户端发送命令设置密码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass &lt;password&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>master配置文件设置密码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config set requirepass &lt;password&gt;</span><br><span class="line">config get requirepass</span><br></pre></td></tr></table></figure></li>
<li><p>slave连接带密码的master服务器</p>
<ul>
<li>slave客户端发送命令设置密码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在发送连接命令后加上下面命令</span><br><span class="line">auth &lt;password&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>slave配置文件设置密码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>slave启动服务器设置密码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server –a &lt;password&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="数据同步阶段"><a href="#数据同步阶段" class="headerlink" title="数据同步阶段"></a>数据同步阶段</h3><ul>
<li><p>目的：</p>
<ul>
<li>在slave初次连接master后，复制master中的所有数据到slave。</li>
<li>将slave的数据库状态更新成master当前的数据库状态。</li>
</ul>
</li>
<li><p>步骤：</p>
<ul>
<li>步骤1：请求同步数据</li>
<li>步骤2：创建RDB同步数据</li>
<li>步骤3：恢复RDB同步数据</li>
<li>步骤4：请求部分同步数据</li>
<li>步骤5：恢复部分同步数据</li>
<li>至此，数据同步工作完成！</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210422164517.png"></p>
</li>
<li><p>状态：</p>
<ul>
<li>slave：<ul>
<li>具有master端全部数据，包含RDB过程接收的数据</li>
</ul>
</li>
<li>master：<ul>
<li>保存slave当前数据同步的位置</li>
</ul>
</li>
<li>总体：<ul>
<li>完成了数据克隆</li>
</ul>
</li>
</ul>
</li>
<li><p>master部分说明</p>
<ul>
<li><p> 如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行</p>
</li>
<li><p>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 配置master服务器缓冲区的大小</span><br><span class="line">repl-backlog-size 1mb</span><br></pre></td></tr></table></figure></li>
<li><p>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执行bgsave命令和创建复制缓冲区</p>
</li>
</ul>
</li>
<li><p>slave部分说明</p>
<ul>
<li><p>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># slave服务器设置为是否只读</span><br><span class="line">slave-serve-stale-data yes|no</span><br></pre></td></tr></table></figure></li>
<li><p>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令。</p>
</li>
<li><p>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰。</p>
</li>
<li><p>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟较大，数据一致性变差，应谨慎选择。</p>
</li>
</ul>
</li>
</ul>
<h3 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h3><ul>
<li><p>目的：</p>
<ul>
<li>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，同步的动作称为命令传播。</li>
<li>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令。</li>
</ul>
</li>
<li><p>命令传播阶段出现了断网现象</p>
<ul>
<li>网络闪断闪连   –&gt;  忽略</li>
<li>短时间网络中断  –&gt;  部分复制</li>
<li>长时间网络中断  –&gt;  全量复制</li>
</ul>
</li>
<li><p>部分复制的三个核心要素</p>
<ul>
<li>服务器的运行 id（run id） </li>
<li>主服务器的复制积压缓冲区</li>
<li>主从服务器的复制偏移量</li>
</ul>
</li>
<li><p><strong>服务器运行ID（runid）</strong></p>
<ul>
<li>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</li>
<li>组成：运行id由40位字符组成，是一个随机的十六进制字符<ul>
<li>例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce</li>
</ul>
</li>
<li>作用：运行id被用于在服务器间进行传输，识别身份如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</li>
<li>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过info Server命令，可以查看节点的runid</li>
</ul>
</li>
<li><p><strong>复制积压缓冲区</strong></p>
<ul>
<li>概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区。</li>
<li>复制缓冲区默认数据存储空间大小是1M，由于存储空间大小是固定的，当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列</li>
<li>组成：偏移量+字节值</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423102609.png"></p>
<ul>
<li>工作原理<ul>
<li>通过offset区分不同的slave当前数据传播的差异</li>
<li>master记录已发送的信息对应的offset</li>
<li>slave记录已接收的信息对应的offset</li>
</ul>
</li>
<li>由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区。</li>
<li>作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select） </li>
<li>数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中</li>
</ul>
</li>
<li><p><strong>主从服务器复制偏移量（offset）</strong> </p>
<ul>
<li>概念：一个数字，描述复制缓冲区中的指令字节位置</li>
<li>分类：<ul>
<li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）</li>
<li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）</li>
</ul>
</li>
<li>数据来源：<ul>
<li>master端：发送一次记录一次</li>
<li>slave端：接收一次记录一次</li>
</ul>
</li>
<li>作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用</li>
</ul>
</li>
</ul>
<h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><ul>
<li><p>进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</p>
</li>
<li><p>master心跳：</p>
<ul>
<li>指令：PING</li>
<li>周期：由repl-ping-slave-period决定，默认10秒 </li>
<li>作用：判断slave是否在线</li>
<li>查询：INFO replication      获取slave最后一次连接时间间隔，lag项维持在0或1视为正常</li>
</ul>
</li>
<li><p>slave心跳任务</p>
<ul>
<li>指令：REPLCONF ACK {offset}</li>
<li>周期：1秒 </li>
<li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li>
<li>作用2：判断master是否在线</li>
</ul>
</li>
<li><p>心跳阶段注意事项</p>
<ul>
<li><p>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># slave在线的最小数量，小于此数就停止写服务</span><br><span class="line">min-slaves-to-write 2</span><br><span class="line"># slave的延迟最小值</span><br><span class="line">min-slaves-max-lag 8</span><br></pre></td></tr></table></figure>

<ul>
<li>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步。</li>
</ul>
</li>
<li><p>slave数量由slave发送<strong>REPLCONF ACK</strong>命令做确认。</p>
</li>
<li><p>slave延迟由slave发送<strong>REPLCONF ACK</strong>命令做确认。</p>
</li>
</ul>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423103550.png"></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423104528.png"></p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="频繁的全量复制（1）"><a href="#频繁的全量复制（1）" class="headerlink" title="频繁的全量复制（1）"></a>频繁的全量复制（1）</h3><ul>
<li><p>伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的全量复制操作</p>
</li>
<li><p>内部优化调整方案(不用修改)：</p>
<ol>
<li><p>master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave</p>
</li>
<li><p>在master关闭时执行命令 <strong>shutdown</strong> save，进行RDB持久化,将runid与offset保存到RDB文件中</p>
<ul>
<li>repl-id repl-offset </li>
<li>通过 <em>redis-check-rdb文件</em>  命令可以查看该信息</li>
</ul>
</li>
<li><p>master重启后加载RDB文件，恢复数据</p>
<ul>
<li>重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中</li>
<li>master_repl_id =repl   master_repl_offset =repl-offset</li>
<li>通过info命令可以查看该信息</li>
</ul>
</li>
</ol>
</li>
<li><p>作用：</p>
<ul>
<li>本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master</li>
</ul>
</li>
</ul>
<h3 id="频繁的全量复制（2）"><a href="#频繁的全量复制（2）" class="headerlink" title="频繁的全量复制（2）"></a>频繁的全量复制（2）</h3><ul>
<li><p>问题现象</p>
<ul>
<li>网络环境不佳，出现网络中断，slave不提供服务</li>
</ul>
</li>
<li><p>问题原因</p>
<ul>
<li>复制缓冲区过小，断网后slave的offset越界，触发全量复制</li>
</ul>
</li>
<li><p>最终结果</p>
<ul>
<li>slave反复进行全量复制</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>修改复制缓冲区大小</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-size</span><br></pre></td></tr></table></figure></li>
<li><p>建议设置如下：</p>
<ol>
<li><p>测算从master到slave的重连平均时长second</p>
</li>
<li><p>获取master平均每秒产生写命令数据总量write_size_per_second</p>
</li>
<li><p>最优复制缓冲区空间 =2 * second * write_size_per_second</p>
</li>
</ol>
</li>
</ul>
<h3 id="频繁的网络中断（1）"><a href="#频繁的网络中断（1）" class="headerlink" title="频繁的网络中断（1）"></a>频繁的网络中断（1）</h3><ul>
<li><p>问题现象</p>
<ul>
<li>master的CPU占用过高 或 slave频繁断开连接</li>
</ul>
</li>
<li><p>问题原因</p>
<ul>
<li>slave每1秒发送REPLCONF ACK命令到master</li>
<li>当slave接到了慢查询时（keys *，hgetall等），会大量占用CPU性能</li>
<li>master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应</li>
</ul>
</li>
<li><p>最终结果</p>
<ul>
<li>master各种资源（输出缓冲区、带宽、连接等）被严重占用</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>通过设置合理的超时时间，确认是否释放slave</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-timeout</span><br></pre></td></tr></table></figure>

<ul>
<li>该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="频繁的网络中断（2）"><a href="#频繁的网络中断（2）" class="headerlink" title="频繁的网络中断（2）"></a>频繁的网络中断（2）</h3><ul>
<li><p>问题现象</p>
<ul>
<li>slave与master连接断开</li>
</ul>
</li>
<li><p>问题原因</p>
<ul>
<li>master发送ping指令频度较低</li>
<li>master设定超时时间较短</li>
<li>ping指令在网络中存在丢包</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>提高ping指令发送的频度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-ping-slave-period</span><br></pre></td></tr></table></figure>

<ul>
<li>超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h3><ul>
<li><p>问题现象</p>
<ul>
<li>多个slave获取相同数据不同步</li>
</ul>
</li>
<li><p>问题原因</p>
<ul>
<li>网络信息不同步，数据发送有延迟</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象</p>
</li>
<li><p>监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave-serve-stale-data yes|no</span><br></pre></td></tr></table></figure>

<ul>
<li>开启后仅响应info、slaveof等少数命令（慎用，除非对数据一致性要求很高）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第十二章：哨兵模式"><a href="#第十二章：哨兵模式" class="headerlink" title="第十二章：哨兵模式"></a>第十二章：哨兵模式</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>问题：主机宕机</p>
<ul>
<li>当master主机宕机怎么办？<ul>
<li>关闭master和所有slave</li>
<li>找一个slave作为master</li>
<li>修改其他slave的配置，连接新的主</li>
<li>启动新的master与slave</li>
<li>全量复制*N+部分复制*N </li>
</ul>
</li>
<li>那么<ul>
<li>关闭期间的数据服务谁来承接？</li>
<li>找一个主？怎么找法？</li>
<li>修改配置后，原始的主恢复了怎么办？</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>哨兵(sentinel)</strong> 是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的master并将所有slave连接到新的master。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423152346.png"></p>
</li>
<li><p>功能：</p>
<ul>
<li>监控<ul>
<li>不断的检查master和slave是否正常运行。</li>
<li>master存活检测、master与slave运行情况检测。</li>
</ul>
</li>
<li>通知（提醒）<ul>
<li>当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。</li>
</ul>
</li>
<li>自动故障转移<ul>
<li>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意：哨兵也是一台redis服务器，只是不提供数据服务。通常哨兵配置数量为单数。</p>
</li>
</ul>
<h2 id="启动哨兵模式"><a href="#启动哨兵模式" class="headerlink" title="启动哨兵模式"></a>启动哨兵模式</h2><ul>
<li><p>配置哨兵</p>
<ul>
<li>配置文件为sentinel.conf</li>
</ul>
</li>
<li><p>配置项解释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 哨兵的服务端口号，一般为监听的redis服务器的端口号前加2</span><br><span class="line">port 26379</span><br><span class="line"># 日志，数据目录</span><br><span class="line">dir &#x2F;tmp</span><br><span class="line"># 配置监听的redis服务器。mymaster为服务器名称，可以自定义，后面跟服务器的IP和端口号。</span><br><span class="line"># 最后边的数为参与选举成功的数量，一般为哨兵数量的一半加1</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"># 当主机连接超过30秒时认为它宕机了。数字的单位是毫秒</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"># 指定同时进行主从的slave数量，数值越大，要求网络资源越高，要求约小，同步时间约长</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"># 指定出现故障后，故障切换的最大超时时间，超过该值，认定切换失败，默认3分钟</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line">#其他的配置</span><br><span class="line"># 连接服务器口令。例如：sentinel auth-pass mymaster 123456</span><br><span class="line">sentinel auth-pass &lt;服务器名称&gt; &lt;password&gt;</span><br><span class="line"># 服务器无法正常联通时，设定的执行脚本，通常调试使用。</span><br><span class="line">sentinel notification-script &lt;服务名称&gt;&lt;脚本路径&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>启动哨兵：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel sentinel配置文件.conf</span><br></pre></td></tr></table></figure></li>
<li><p>演示：</p>
<ul>
<li>配置三个哨兵，除了端口号不同，其他的都可以一样。三个哨兵监视的都是一个主机。</li>
<li>启动顺序：先启动master，在启动slave，最后启动哨兵</li>
<li>哨兵的客户端连接也使用<em>redis-cli -p  端口号</em>。但是这个客户端不能进行数据的操作。</li>
<li>在客户端输入<em>info</em>命令能看到当前哨兵的一些信息。</li>
<li>当哨兵启动后，它的配置文件会发生一些改变，会保存对应主机的信息，以及从机的信息。</li>
<li>当新哨兵启动时，已经启动的哨兵会识别到新启动的哨兵。</li>
<li>哨兵的启动</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423161223.png"></p>
<ul>
<li>当主master宕机时，哨兵打印的日志</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423162327.png"></p>
<ul>
<li>此时6379又重新启动时，6378任作为主机，而6379变成了从机。</li>
</ul>
</li>
</ul>
<h2 id="哨兵工作原理"><a href="#哨兵工作原理" class="headerlink" title="哨兵工作原理"></a>哨兵工作原理</h2><ul>
<li>哨兵在进行主从切换过程中经历三个阶段<ul>
<li>监控</li>
<li>通知</li>
<li>故障转移</li>
</ul>
</li>
</ul>
<h3 id="阶段一：监控阶段"><a href="#阶段一：监控阶段" class="headerlink" title="阶段一：监控阶段"></a>阶段一：监控阶段</h3><ul>
<li><p>用于同步各个节点的状态信息</p>
<ul>
<li>获取各个sentinel的状态（是否在线）(通过ping命令)</li>
<li>获取master的状态（通过info命令）<ul>
<li>master属性<ul>
<li>runid</li>
<li>role：master</li>
</ul>
</li>
<li>各个slave的详细信息</li>
</ul>
</li>
<li>获取所有slave的状态（根据master中的slave信息）（通过info命令）<ul>
<li>slave属性<ul>
<li>runid</li>
<li>role：slave</li>
<li>master_host、master_port</li>
<li>offest</li>
<li>…..</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>详细过程</p>
<ul>
<li>第一步：第一个哨兵启动时，先通过info命令获取master的信息。</li>
<li>第二步：第一个哨兵和master建立cmd连接。<ul>
<li>此时，哨兵会保存<strong>SentinelState</strong>信息。master会保存<strong>SentinelRedisInstance</strong>信息。</li>
</ul>
</li>
<li>第三步：第一个哨兵根据获取的信息，通过info命令连接其他的slave。</li>
<li>第四步：当第二个哨兵启动时，先通过info命令获取master的信息。</li>
<li>第五步：第二个哨兵和master建立cmd连接。并保存<strong>SentinelState</strong>信息，master保存的信息会被更新。</li>
<li>第六步：第二个哨兵会和第一个哨兵建立publish subscribe约定，以保证信息共享。<ul>
<li>同时，这两个哨兵会发ping命令，以保证相互之间是存在的。</li>
</ul>
</li>
<li>第七步：第二个哨兵连接slave。</li>
<li>再有新哨兵启动时，会按照第四步到第七步依次执行。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423164415.png"></p>
</li>
</ul>
<h3 id="阶段二：通知阶段"><a href="#阶段二：通知阶段" class="headerlink" title="阶段二：通知阶段"></a>阶段二：通知阶段</h3><ul>
<li>第一步：哨兵中的一个哨兵接收主机和从机的信息。</li>
<li>第二步：这个哨兵将接受到的信息发送到publish subscribe区域。</li>
<li>第三步：其他哨兵直接重这个区域获取主机和从机的信息。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423164913.png"></p>
<h3 id="阶段三：故障转移"><a href="#阶段三：故障转移" class="headerlink" title="阶段三：故障转移"></a>阶段三：故障转移</h3><ul>
<li><p><strong>发现故障：</strong></p>
<ul>
<li>第一步：哨兵1连续获取master信息，发现获取不了，标记master的状态为S_DOWN,并将这个消息发送到publish subscribe区域。</li>
<li>第二步：其他哨兵看到哨兵1的消息后，都尝试获取这个master的信息。超过半数无法获取时，就会将master的状态标志位0_DOWN。<ul>
<li>标记为S_DOWN的被称为主观下线。</li>
<li>标记为0_DOWN的被称为客观下线。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423165833.png"></p>
</li>
<li><p><strong>发现故障后，所有的sentinel将选举出一个sentinel来处理这个master。</strong></p>
<ul>
<li>第一步：所有哨兵发送命令到publish subscribe区域。</li>
<li>第二步：哨兵们进行投票。</li>
<li>第三步：投票没有结果时，再进行一次投票。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424145831.png"></p>
</li>
<li><p><strong>投票后的sentinel对master进行处置。</strong></p>
<ul>
<li>服务器列表中挑选备选master<ul>
<li>选取在线的。</li>
<li>再选取响应快的。</li>
<li>再选取与原master断开时间短的。</li>
<li>优先原则<ul>
<li>再选取优先级高的</li>
<li>再选取offset小的</li>
<li>再选取runid小的</li>
</ul>
</li>
</ul>
</li>
<li>发送指令（ sentinel ）<ul>
<li>向新的master发送slaveof no one。让它作为新的master</li>
<li>向其他slave发送slaveof 新masterIP端口。让它们连新的master</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li> 监控</li>
<li>同步信息。</li>
<li>通知<ul>
<li>保持联通。</li>
</ul>
</li>
<li>故障转移<ul>
<li>发现问题。</li>
<li>竞选负责人。</li>
<li>优选新master。</li>
<li>新master上任，其他slave切换master，原master作为slave故障回复后连接。</li>
</ul>
</li>
</ul>
<h1 id="第十三章：集群"><a href="#第十三章：集群" class="headerlink" title="第十三章：集群"></a>第十三章：集群</h1><h2 id="集群介绍"><a href="#集群介绍" class="headerlink" title="集群介绍"></a>集群介绍</h2><ul>
<li>出现的问题：业务发展过程中遇到的峰值瓶颈。<ul>
<li>redis提供的服务OPS可以达到10万/秒，当前业务OPS已经达到20万/秒 。<ul>
<li>OPS指一秒内可以执行的命令数量。</li>
</ul>
</li>
<li>内存单机容量达到256G，当前业务需求内存容量1T。</li>
</ul>
</li>
<li> 使用集群的方式可以快速解决上述问题。</li>
<li><strong>集群</strong>就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果</li>
<li>集群的作用：<ul>
<li> 分散单台服务器的访问压力，实现负载均衡。</li>
<li>分散单台服务器的存储压力，实现可扩展性。</li>
<li>降低单台服务器宕机带来的业务灾难。</li>
</ul>
</li>
</ul>
<h2 id="Redis集群结构设计"><a href="#Redis集群结构设计" class="headerlink" title="Redis集群结构设计"></a>Redis集群结构设计</h2><h3 id="数据存储设计"><a href="#数据存储设计" class="headerlink" title="数据存储设计"></a>数据存储设计</h3><ul>
<li><p>问题：当我们又很多个redis服务器做集群。有一个key过来了，我们要在哪个redis服务器中处理它呢？</p>
</li>
<li><p>集群的数据存储设计：</p>
<ul>
<li>首先通过算法设计，计算出key应该保存的位置。在让位置对16384区域。得到的就是该key存放的<strong>槽</strong>。</li>
<li>集群将所有redis服务器的存储空间计划切割成16384份，每台主机保存一部分。<ul>
<li>每份代表的是一个存储空间，不是一个key的保存空间。</li>
</ul>
</li>
<li>将key按照计算出的结果放到对应的存储空间</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423174533.png"></p>
</li>
<li><p>当添加一个redis服务器，或删除一个服务器时。集群又是如何做的呢？</p>
</li>
<li><p>以添加redis服务器为例：</p>
<ul>
<li>集群会将已存在的redis服务器，每个服务器把一个槽给新添加的服务器。</li>
<li>体现了增强可扩展性。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423175153.png"></p>
</li>
</ul>
<h3 id="集群内部通讯设计"><a href="#集群内部通讯设计" class="headerlink" title="集群内部通讯设计"></a>集群内部通讯设计</h3><ul>
<li><p>各个数据库相互通信，保存各个库中槽的编号数据。</p>
<ul>
<li>一次命中，直接返回。</li>
<li>一次未命中，告知具体位置。<ul>
<li>通过查询保存的数据，就能知道因该访问哪个服务器。 </li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210423184709.png"></p>
</li>
</ul>
<h2 id="cluster集群结构搭建"><a href="#cluster集群结构搭建" class="headerlink" title="cluster集群结构搭建"></a>cluster集群结构搭建</h2><ul>
<li>cluster是集群框架的一种，经典常用的一种。</li>
</ul>
<h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><ul>
<li><p>搭建6个redis服务器（三主三从）</p>
</li>
<li><p>第一步：配置文件样式如下。（每个服务器的配置文件中，只有端口号不一样）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">daemonize no</span><br><span class="line">dir &#x2F;redis-4.0.0&#x2F;data</span><br><span class="line"># rdb配置</span><br><span class="line">dbfilename dump-6379.rdb</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br><span class="line">save 10 2</span><br><span class="line"># aof配置</span><br><span class="line">appendonly yes</span><br><span class="line">appendfsync always</span><br><span class="line">appendfilename appendonly-6379.aof</span><br><span class="line">bind 127.0.0.1</span><br><span class="line">databases 16</span><br><span class="line"># cluster配置</span><br><span class="line"># 启动cluster功能</span><br><span class="line">cluster-enabled yes</span><br><span class="line"># cluster的配置文件的名称</span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line"># 配置节点响应超时时间。10秒</span><br><span class="line">cluster-node-timeout 10000</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将当前配置文件拷贝6份</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#39;s&#x2F;6379&#x2F;6380&#x2F;g&#39; redis-6379.conf &gt; redis-6380.conf </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>第二步：启动6个redis服务器</p>
<ul>
<li>启动成功后，在linux查看进程会发现如下信息</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424094235.png"></p>
</li>
<li><p>第三步：启动cluster</p>
<ul>
<li>redis-trib.rb指令要想成功执行。需要基于两个工具ruby和RubyGems <ul>
<li>安装ruby：<em>sudo yum install ruby</em>（安装高版本的ruby）</li>
<li>安装RubyGems ：<em>yum install rubygems</em><ul>
<li>执行<em>gem update –system</em></li>
<li>执行<em>gem sources -a <a target="_blank" rel="noopener" href="https://rubygems.org/">https://rubygems.org</a></em></li>
</ul>
</li>
<li>安装redis-xxx.gem组件：<em>gem sources -a <a target="_blank" rel="noopener" href="https://rubygems.org/">https://rubygems.org</a></em></li>
</ul>
</li>
<li>然后执行下面命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;redis-4.0.0&#x2F;src&#x2F;redis-trib.rb create --replicas 1 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384</span><br><span class="line"># &#x2F;redis-4.0.0&#x2F;src&#x2F;是因为此命令只在src目录下有效</span><br><span class="line"># 1 表示后面的IP中一个主节点对应一个从节点，因为有6个节点，又是一对一的关系，所以前三个为主节点</span><br><span class="line"># 后面要将所有服务器的IP和端口号都加上</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424124949.png"></p>
</li>
<li><p>第四步</p>
<ul>
<li>输入yes接口。出现*All 16384 slots covered.*表示成功。</li>
</ul>
</li>
</ul>
<h3 id="客户端的使用"><a href="#客户端的使用" class="headerlink" title="客户端的使用"></a>客户端的使用</h3><ul>
<li><p>会发现原来使用<em>redis-cli</em>的客户端在添加数据时会出错，并且让你去其他服务器添加数据。</p>
</li>
<li><p>对于集群的客户端要使用<em>reids-cli -c</em>命令。即在原来的命令的基础上加上-c。</p>
<ul>
<li>此时添加数据时，集群会自动将数据放到对应的槽中。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424130033.png"></p>
</li>
</ul>
<h3 id="集群的使用"><a href="#集群的使用" class="headerlink" title="集群的使用"></a>集群的使用</h3><ul>
<li><p>当从节点下线后。</p>
<ul>
<li>比如slave1下线。对应的master1会显示slave1下线了，并将这个消息给其他四个服务器。</li>
<li>当这个从节点又上线时，对应的master1会同步信息，并将这个消息告诉其他四个服务器。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424131755.png"></p>
</li>
<li><p>当主节点下线后。</p>
<ul>
<li>从节点会一直请求连接，直到到达设定的时间，从节点会变成主节点。并告诉其他节点。<ul>
<li>使用<em>cluster nodes</em>可以查看到主节点挂掉，从节点变成了master</li>
</ul>
</li>
<li>当主节点重新启动时，由于对应的从节点已经变成了主节点。因此这个主节点启动后只能当从节点使用。<ul>
<li>使用<em>cluster nodes</em>可以查看到主节点变成了slave</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424132951.png"></p>
</li>
</ul>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li><p>Cluster的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 添加节点</span><br><span class="line">cluster-enabled yes|no</span><br><span class="line"># cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容</span><br><span class="line">cluster-config-file &lt;filename&gt;</span><br><span class="line"># 节点服务响应超时时间，用于判定该节点是否下线或切换为从节点</span><br><span class="line">cluster-node-timeout &lt;milliseconds&gt;</span><br><span class="line"># master连接的slave最小数量</span><br><span class="line">cluster-migration-barrier &lt;count&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>Cluster节点操作命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查看集群节点信息</span><br><span class="line">cluster nodes</span><br><span class="line"># 进入一个从节点 redis，切换其主节点</span><br><span class="line">cluster replicate &lt;master-id&gt;</span><br><span class="line"># 发现一个新节点，新增主节点</span><br><span class="line">cluster meet ip:port</span><br><span class="line"># 忽略一个没有solt的节点</span><br><span class="line">cluster forget &lt;id&gt;</span><br><span class="line"># 手动故障转移</span><br><span class="line">cluster failover</span><br></pre></td></tr></table></figure></li>
<li><p>redis-trib命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 添加节点</span><br><span class="line">redis-trib.rb add-node</span><br><span class="line"># 删除节点</span><br><span class="line">redis-trib.rb del-node</span><br><span class="line"># 重新分片</span><br><span class="line">redis-trib.rb reshard</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="第十四章：企业特技解决方案"><a href="#第十四章：企业特技解决方案" class="headerlink" title="第十四章：企业特技解决方案"></a>第十四章：企业特技解决方案</h1><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><ul>
<li>问题：<ul>
<li>服务器运行过程中关机了，想要重启，结果在重启后又迅速宕机了。</li>
</ul>
</li>
<li>原因：<ul>
<li>请求数量较高。</li>
<li>主从之间数据吞吐量较大，数据同步操作频度较高。</li>
</ul>
</li>
<li>解决方案：<ul>
<li>前置准备工作：<ul>
<li>日常例行统计数据访问记录，统计访问频度较高的热点数据</li>
<li>利用LRU数据删除策略，构建数据留存队列<ul>
<li>例如：storm与kafka配合</li>
</ul>
</li>
</ul>
</li>
<li>准备工作：<ul>
<li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</li>
<li>利用分布式多服务器同时进行数据读取，提速数据加载过程</li>
<li>热点数据主从同时预热</li>
</ul>
</li>
<li>实施： <ul>
<li>使用脚本程序固定触发数据预热过程</li>
<li>如果条件允许，使用了CDN（内容分发网络），效果会更好</li>
</ul>
</li>
</ul>
</li>
<li>总结：缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><ul>
<li>问题：<ul>
<li>首先系统平稳运行过程中，忽然数据库连接量激增。然后应用服务器无法及时处理请求。</li>
<li>然后大量408，500错误页面出现。导致客户反复刷新页面获取数据。</li>
<li>最后数据库崩溃，应用服务器崩溃。</li>
<li>发现重启应用服务器无效。</li>
<li>导致Redis服务器崩溃，Redis集群崩溃。</li>
<li>再次重启数据库后再次被瞬间流量放倒。</li>
</ul>
</li>
<li>原因：<ul>
<li>在一个较短的时间内，缓存中较多的key集中过期。</li>
<li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据。</li>
<li>数据库同时接收到大量的请求无法及时处理。</li>
<li>Redis大量请求被积压，开始出现超时现象。</li>
<li>数据库流量激增，数据库崩溃。</li>
<li>重启后仍然面对缓存中无数据可用。</li>
<li>Redis服务器资源被严重占用，Redis服务器崩溃。</li>
<li>Redis集群呈现崩塌，集群瓦解。</li>
<li>应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃。</li>
<li>应用服务器，redis，数据库全部重启，效果不理想。</li>
<li>总结：短时间范围内大量key集中过期导致的。</li>
</ul>
</li>
<li>解决方案1：<ul>
<li>更多的页面静态化处理</li>
<li>构建多级缓存架构<ul>
<li>Nginx缓存+redis缓存+ehcache缓存</li>
</ul>
</li>
<li>检测Mysql严重耗时业务进行优化<ul>
<li>对数据库的瓶颈排查：例如超时查询、耗时较高事务等</li>
</ul>
</li>
<li>灾难预警机制<ul>
<li>监控redis服务器性能指标</li>
<li>CPU占用、CPU使用率</li>
<li>内存容量</li>
<li>查询平均响应时间</li>
<li>线程数</li>
</ul>
</li>
<li>限流、降级<ul>
<li>短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li>
</ul>
</li>
</ul>
</li>
<li>解决方案2：<ul>
<li>LRU与LFU切换。</li>
<li>数据有效期策略调整。<ul>
<li>根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟。</li>
<li>过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量。</li>
</ul>
</li>
<li>超热数据使用永久key。</li>
<li>定期维护（自动+人工）。<ul>
<li>对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时。</li>
</ul>
</li>
<li>加锁(不推荐使用)。</li>
</ul>
</li>
<li>总结：<ul>
<li>缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现（约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</li>
</ul>
</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><ul>
<li>问题：<ul>
<li>系统平稳运行过程中。</li>
<li>数据库连接量瞬间激增。</li>
<li>Redis服务器无大量key过期。</li>
<li>Redis内存平稳，无波动。</li>
<li>Redis服务器CPU正常。</li>
<li>数据库崩溃。</li>
</ul>
</li>
<li>原因：<ul>
<li>问题排查：<ul>
<li>Redis中某个key过期，该key访问量巨大。</li>
<li>多个数据请求从服务器直接压到Redis后，均未命中。</li>
<li>Redis在短时间内发起了大量对数据库中同一数据的访问。</li>
</ul>
</li>
<li>问题分析：<ul>
<li>单个key高热数据</li>
<li>key过期</li>
</ul>
</li>
</ul>
</li>
<li>解决方案：<ul>
<li>预先设定<ul>
<li>以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长</li>
<li>注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</li>
</ul>
</li>
<li>现场调整<ul>
<li>监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</li>
</ul>
</li>
<li>后台刷新数据<ul>
<li>启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</li>
</ul>
</li>
<li>二级缓存<ul>
<li>设置不同的失效时间，保障不会被同时淘汰就行</li>
</ul>
</li>
<li>加锁<ul>
<li>分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！</li>
</ul>
</li>
</ul>
</li>
<li>总结：<ul>
<li>缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可。</li>
</ul>
</li>
</ul>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ul>
<li>问题：<ul>
<li>系统平稳运行过程中。</li>
<li>应用服务器流量随时间增量较大。</li>
<li>Redis服务器命中率随时间逐步降低。</li>
<li>Redis内存平稳，内存无压力。</li>
<li>Redis服务器CPU占用激增。</li>
<li>数据库服务器压力激增。</li>
<li>数据库崩溃。</li>
</ul>
</li>
<li>原因：<ul>
<li>问题排查<ul>
<li>Redis中大面积出现未命中。</li>
<li>出现非正常URL访问。</li>
</ul>
</li>
<li>问题分析<ul>
<li>获取的数据在数据库中也不存在，数据库查询未得到对应数据。</li>
<li>Redis获取到null数据未进行持久化，直接返回。</li>
<li>下次此类数据到达重复上述过程。</li>
<li>出现黑客攻击服务器。</li>
</ul>
</li>
</ul>
</li>
<li>解决方案：<ul>
<li>缓存null<ul>
<li>对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟。</li>
</ul>
</li>
<li>白名单策略<ul>
<li>提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放行，加载异常数据时直接拦截（效率偏低）。</li>
<li>使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）。</li>
</ul>
</li>
<li>实施监控<ul>
<li>实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比。<ul>
<li>非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象。</li>
<li>活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象。</li>
</ul>
</li>
<li>根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）。</li>
</ul>
</li>
<li>key加密<ul>
<li>问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验。</li>
<li>例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问。</li>
</ul>
</li>
</ul>
</li>
<li>总结：<ul>
<li>缓存击穿访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时<font color="red">报警</font>。应对策略应该在临时预案防范方面多做文章。</li>
<li>无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。</li>
</ul>
</li>
</ul>
<h2 id="性能指标监控"><a href="#性能指标监控" class="headerlink" title="性能指标监控"></a>性能指标监控</h2><ul>
<li><p>常监控的性能有</p>
<ul>
<li>性能指标：Performance</li>
<li>内存指标：Memory</li>
<li>基本活动指标：Basic activity</li>
<li>持久性指标：Persistence</li>
<li>错误指标：Error</li>
</ul>
</li>
<li><p>性能指标：Performance</p>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">latency</td>
<td align="center">Redis响应一个 请求的时间</td>
</tr>
<tr>
<td align="center">instantaneous_ops_per_sec</td>
<td align="center">平均每秒处理请求总数</td>
</tr>
<tr>
<td align="center">hit rate (calculated)</td>
<td align="center">缓存命中率(计算出来的)</td>
</tr>
</tbody></table>
</li>
<li><p>内存指标：Memory</p>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">used_ memory</td>
<td align="center">已使用内存</td>
</tr>
<tr>
<td align="center">mem_ fragmentation_ ratio</td>
<td align="center">内存碎片率</td>
</tr>
<tr>
<td align="center">evicted_ keys</td>
<td align="center">由于最大内存限制被移除的key的数量</td>
</tr>
<tr>
<td align="center">blocked_ clients</td>
<td align="center">由于BLPOP, BRPOP, or BRPOPLPUSH而备阻塞的客户端</td>
</tr>
</tbody></table>
</li>
<li><p>基本活动指标：Basic activity</p>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">connected_ clients</td>
<td align="center">客户端连接数</td>
</tr>
<tr>
<td align="center">connected_slaves</td>
<td align="center">Slave数量</td>
</tr>
<tr>
<td align="center">master_last_io_seconds_ago</td>
<td align="center">最近一次主从交互之后的秒数</td>
</tr>
<tr>
<td align="center">keyspace</td>
<td align="center">数据库中的key值总数</td>
</tr>
</tbody></table>
</li>
<li><p>持久性指标：Persistence</p>
<table>
<thead>
<tr>
<th>name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>rdb_last_save_time</td>
<td>最后一次持久化保存到磁盘的时间戳</td>
</tr>
<tr>
<td>rdb_changes_since_last_save</td>
<td>自最后一次持久化以来数据库的更改数</td>
</tr>
</tbody></table>
</li>
<li><p>错误指标：Error</p>
<table>
<thead>
<tr>
<th>name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>rejected_connections</td>
<td>由于达到maxclient限制而被拒绝的连接数</td>
</tr>
<tr>
<td>keyspace_misses</td>
<td>Key值查找失败(没有命中)次数</td>
</tr>
<tr>
<td>master_link_down_since_seconds</td>
<td>主从断开的持续时间(以秒为单位)</td>
</tr>
</tbody></table>
</li>
<li><p>监控方式：</p>
<ul>
<li>工具：<ul>
<li>Cloud Insight Redis</li>
<li>Prometheus</li>
<li>Redis-stat</li>
<li>Redis-faina</li>
<li>RedisLive</li>
<li>zabbix</li>
</ul>
</li>
<li>命令：<ul>
<li><em>benchmark</em></li>
<li>redis cli<ul>
<li><em>monitor</em></li>
<li><em>showlog</em></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>命令说明：</p>
<ul>
<li><p>benchmark</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark [-h ] [-p ] [-c ] [-n &lt;requests]&gt; [-k ]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>作用：压力测试。此测试在命令行执行，不是在客户端执行。</p>
</li>
<li><p>示例一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 默认50个连接，10000次请求对应的性能</span><br><span class="line">redis-benchmark</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424144749.png"></p>
</li>
<li><p>示例二</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 100个连接，5000次请求对应的性能</span><br><span class="line">redis-benchmark -c 100 -n 5000</span><br></pre></td></tr></table></figure></li>
<li><p>参数说明：</p>
</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424143810.png"></p>
</li>
<li><p>monitor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitor</span><br></pre></td></tr></table></figure>

<ul>
<li>作用：打印服务器调试信息。在客户端里执行命令。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20210424145545.png"></p>
</li>
<li><p>showlog</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># operator可以是get&#x2F;len&#x2F;reset</span><br><span class="line">showlong [operator]</span><br></pre></td></tr></table></figure>

<ul>
<li>get ：获取慢查询日志。</li>
<li>len ：获取慢查询日志条目数。</li>
<li>reset ：重置慢查询日志。</li>
<li>相关配置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slowlog-log-slower-than 1000    #设置慢查询的时间下线，单位：微妙</span><br><span class="line">slowlog-max-len 100    #设置慢查询命令对应的日志显示长度，单位：命令数</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

    </div>

    
    
    


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/18/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/%E9%9B%86%E6%88%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/linux%E7%9A%84%E6%90%AD%E5%BB%BA/" rel="prev" title="linux的搭建">
      <i class="fa fa-chevron-left"></i> linux的搭建
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/29/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/" rel="next" title="七大设计原则">
      七大设计原则 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9Aredis%E5%85%A5%E9%97%A8"><span class="nav-number">1.</span> <span class="nav-text">第一章：redis入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Nosql"><span class="nav-number">1.0.1.</span> <span class="nav-text">Nosql</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 下载安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">1.2.1.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">启动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 基本操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9Aredis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">第二章：redis数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#string%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">string类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hash%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">hash类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.3.</span> <span class="nav-text">list类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.4.</span> <span class="nav-text">set类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sorted-set%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.5.</span> <span class="nav-text">sorted_set类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%88%97%E8%A1%A8"><span class="nav-number">2.6.</span> <span class="nav-text">redis的解决方案列表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">3.</span> <span class="nav-text">第三章：通用指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#key%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">3.1.</span> <span class="nav-text">key通用指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">3.2.</span> <span class="nav-text">数据库通用指令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9Ajedis"><span class="nav-number">4.</span> <span class="nav-text">第四章：jedis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">4.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5redis"><span class="nav-number">4.2.</span> <span class="nav-text">连接redis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8jedis%E8%AF%BB%E5%86%99redis%E6%95%B0%E6%8D%AE"><span class="nav-number">4.3.</span> <span class="nav-text">使用jedis读写redis数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jedis%E7%AE%80%E6%98%93%E5%8C%96%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91"><span class="nav-number">4.4.</span> <span class="nav-text">jedis简易化工具开发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">4.5.</span> <span class="nav-text">可视化客户端</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9Alinux%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85"><span class="nav-number">5.</span> <span class="nav-text">第五章：linux环境安装</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9Aredis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">6.</span> <span class="nav-text">第六章：redis持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="nav-number">6.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB"><span class="nav-number">6.2.</span> <span class="nav-text">RDB</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">6.2.1.</span> <span class="nav-text">第一种启动命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">6.2.2.</span> <span class="nav-text">第二种启动命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">6.2.3.</span> <span class="nav-text">第三种启动命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94"><span class="nav-number">6.2.4.</span> <span class="nav-text">对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">6.2.5.</span> <span class="nav-text">特殊的启动方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.2.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF"><span class="nav-number">6.3.</span> <span class="nav-text">AOF</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="nav-number">6.3.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF%E5%86%99%E7%AD%96%E7%95%A5"><span class="nav-number">6.3.2.</span> <span class="nav-text">AOF写策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF%E5%8A%9F%E8%83%BD%E7%9A%84%E5%BC%80%E5%90%AF"><span class="nav-number">6.3.3.</span> <span class="nav-text">AOF功能的开启</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF%E9%87%8D%E5%86%99"><span class="nav-number">6.3.4.</span> <span class="nav-text">AOF重写</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB%E5%92%8CAOF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.4.</span> <span class="nav-text">RDB和AOF的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">6.5.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9Aredis%E4%BA%8B%E5%8A%A1"><span class="nav-number">7.</span> <span class="nav-text">第七章：redis事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">7.1.</span> <span class="nav-text">事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">7.2.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%80%EF%BC%9A%E7%9B%91%E8%A7%86%E9%94%81"><span class="nav-number">7.2.1.</span> <span class="nav-text">场景一：监视锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%8C%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E5%90%8C%E6%AD%A5%E9%94%81"><span class="nav-number">7.2.2.</span> <span class="nav-text">场景二：分布式锁&#x2F;同步锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%89%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%94%B9%E8%89%AF"><span class="nav-number">7.2.3.</span> <span class="nav-text">场景三：分布式锁的改良</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-number">8.</span> <span class="nav-text">第八章：删除策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE"><span class="nav-number">8.1.</span> <span class="nav-text">过期数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-number">8.2.</span> <span class="nav-text">数据删除策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4"><span class="nav-number">8.2.1.</span> <span class="nav-text">定时删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="nav-number">8.2.2.</span> <span class="nav-text">惰性删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="nav-number">8.2.3.</span> <span class="nav-text">定期删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94-1"><span class="nav-number">8.2.4.</span> <span class="nav-text">对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%90%E5%87%BA%E7%AE%97%E6%B3%95"><span class="nav-number">8.3.</span> <span class="nav-text">逐出算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9Aredis%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">9.</span> <span class="nav-text">第九章：redis服务器配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AE%BE%E5%AE%9A"><span class="nav-number">9.1.</span> <span class="nav-text">服务器端设定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE"><span class="nav-number">9.2.</span> <span class="nav-text">日志配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE"><span class="nav-number">9.3.</span> <span class="nav-text">客户端配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BF%AB%E6%8D%B7%E9%85%8D%E7%BD%AE"><span class="nav-number">9.4.</span> <span class="nav-text">多服务器快捷配置</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.</span> <span class="nav-text">第十章：高级数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Bitmaps"><span class="nav-number">10.1.</span> <span class="nav-text">Bitmaps</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HyperLongLong"><span class="nav-number">10.2.</span> <span class="nav-text">HyperLongLong</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GEO"><span class="nav-number">10.3.</span> <span class="nav-text">GEO</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">11.</span> <span class="nav-text">第十一章：主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="nav-number">11.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">11.2.</span> <span class="nav-text">工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E9%98%B6%E6%AE%B5"><span class="nav-number">11.2.1.</span> <span class="nav-text">建立连接阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E9%98%B6%E6%AE%B5"><span class="nav-number">11.2.2.</span> <span class="nav-text">数据同步阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD%E9%98%B6%E6%AE%B5"><span class="nav-number">11.2.3.</span> <span class="nav-text">命令传播阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="nav-number">11.2.4.</span> <span class="nav-text">心跳机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">11.2.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">11.3.</span> <span class="nav-text">常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%91%E7%B9%81%E7%9A%84%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6%EF%BC%881%EF%BC%89"><span class="nav-number">11.3.1.</span> <span class="nav-text">频繁的全量复制（1）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%91%E7%B9%81%E7%9A%84%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6%EF%BC%882%EF%BC%89"><span class="nav-number">11.3.2.</span> <span class="nav-text">频繁的全量复制（2）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%91%E7%B9%81%E7%9A%84%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%96%AD%EF%BC%881%EF%BC%89"><span class="nav-number">11.3.3.</span> <span class="nav-text">频繁的网络中断（1）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%91%E7%B9%81%E7%9A%84%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%96%AD%EF%BC%882%EF%BC%89"><span class="nav-number">11.3.4.</span> <span class="nav-text">频繁的网络中断（2）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="nav-number">11.3.5.</span> <span class="nav-text">数据不一致</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="nav-number">12.</span> <span class="nav-text">第十二章：哨兵模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="nav-number">12.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="nav-number">12.2.</span> <span class="nav-text">启动哨兵模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">12.3.</span> <span class="nav-text">哨兵工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E7%9B%91%E6%8E%A7%E9%98%B6%E6%AE%B5"><span class="nav-number">12.3.1.</span> <span class="nav-text">阶段一：监控阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9A%E9%80%9A%E7%9F%A5%E9%98%B6%E6%AE%B5"><span class="nav-number">12.3.2.</span> <span class="nav-text">阶段二：通知阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9A%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="nav-number">12.3.3.</span> <span class="nav-text">阶段三：故障转移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">12.3.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%9A%E9%9B%86%E7%BE%A4"><span class="nav-number">13.</span> <span class="nav-text">第十三章：集群</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E4%BB%8B%E7%BB%8D"><span class="nav-number">13.1.</span> <span class="nav-text">集群介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">13.2.</span> <span class="nav-text">Redis集群结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">13.2.1.</span> <span class="nav-text">数据存储设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E5%86%85%E9%83%A8%E9%80%9A%E8%AE%AF%E8%AE%BE%E8%AE%A1"><span class="nav-number">13.2.2.</span> <span class="nav-text">集群内部通讯设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cluster%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84%E6%90%AD%E5%BB%BA"><span class="nav-number">13.3.</span> <span class="nav-text">cluster集群结构搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4"><span class="nav-number">13.3.1.</span> <span class="nav-text">搭建集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">13.3.2.</span> <span class="nav-text">客户端的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">13.3.3.</span> <span class="nav-text">集群的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E"><span class="nav-number">13.3.4.</span> <span class="nav-text">说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%EF%BC%9A%E4%BC%81%E4%B8%9A%E7%89%B9%E6%8A%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">14.</span> <span class="nav-text">第十四章：企业特技解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="nav-number">14.1.</span> <span class="nav-text">缓存预热</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">14.2.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">14.3.</span> <span class="nav-text">缓存击穿</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">14.4.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7"><span class="nav-number">14.5.</span> <span class="nav-text">性能指标监控</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Plum Reiver</p>
  <div class="site-description" itemprop="description">技术，日常，笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
	
  </nav>
</div>


      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plum Reiver</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
