<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"plumv.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="Java中的继承性,权限访问符,多态性">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象(中)">
<meta property="og:url" content="https://plumv.github.io/2020/12/13/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%AD/index.html">
<meta property="og:site_name" content="李川的个人博客">
<meta property="og:description" content="Java中的继承性,权限访问符,多态性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184321.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184322.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184323.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184324.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184325.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184326.png">
<meta property="article:published_time" content="2020-12-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-21T13:10:15.095Z">
<meta property="article:author" content="Plum Reiver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184321.png">

<link rel="canonical" href="https://plumv.github.io/2020/12/13/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%AD/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面向对象(中) | 李川的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李川的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>日志</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://plumv.github.io/2020/12/13/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plum Reiver">
      <meta itemprop="description" content="技术，日常，笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李川的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面向对象(中)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-13 00:00:00" itemprop="dateCreated datePublished" datetime="2020-12-13T00:00:00+08:00">2020-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-21 21:10:15" itemprop="dateModified" datetime="2021-03-21T21:10:15+08:00">2021-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">Java基础语法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Java中的继承性,权限访问符,多态性</p>
<span id="more"></span>
<h1 id="OOP特征二：继承性"><a href="#OOP特征二：继承性" class="headerlink" title="OOP特征二：继承性"></a>OOP特征二：继承性</h1><ul>
<li><p>为什么要有继承？</p>
<ul>
<li>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。</li>
</ul>
</li>
<li><p>此处的多个类称为子类(派生类)，单独的这个类称为父类(基类 或超类)。可以理解为:“子类 is a 父类”</p>
</li>
<li><p>类继承语法规则:class Subclass extends SuperClass{ }</p>
</li>
<li><p>继承的作用：</p>
<ul>
<li>继承的出现减少了代码冗余，提高了代码的复用性。</li>
<li>继承的出现，更有利于功能的扩展。</li>
<li>继承的出现让类与类之间产生了关系，提供了多态的前提。 </li>
</ul>
</li>
<li><p>注意：不要仅为了获取其他类中某个功能而去继承</p>
</li>
<li><p>子类继承了父类，就继承了父类的方法和属性。</p>
</li>
<li><p>在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。</p>
</li>
<li><p>在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展”。</p>
</li>
<li><p>关于继承的规则：</p>
<ul>
<li><p>子类不能直接访问父类中私有的(private)的成员变量和方法</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184321.png"></p>
</li>
<li><p>Java只支持单继承和多层继承，不允许多重继承</p>
<ul>
<li>一个子类只能有一个父类</li>
<li>一个父类可以派生出多个子类</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184322.png"></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;读书&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.eat();</span><br><span class="line">    student.say();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">吃饭</span><br><span class="line">读书</span><br></pre></td></tr></table></figure>

<h1 id="方法的重写-override"><a href="#方法的重写-override" class="headerlink" title="方法的重写(override)"></a>方法的重写(override)</h1><ul>
<li>定义：在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。</li>
<li>要求：<ul>
<li>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表</li>
<li>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型</li>
<li>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限<ul>
<li>子类不能重写父类中声明为private权限的方法</li>
</ul>
</li>
<li>子类方法抛出的异常不能大于父类被重写方法的异常</li>
</ul>
</li>
<li>注意：子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;学生吃饭&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;读书&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.eat();</span><br><span class="line">    student.say();</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">	person.eat();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">学生吃饭</span><br><span class="line">读书</span><br><span class="line">吃饭</span><br></pre></td></tr></table></figure>

<h1 id="四种访问权限修饰符"><a href="#四种访问权限修饰符" class="headerlink" title="四种访问权限修饰符"></a>四种访问权限修饰符</h1><ul>
<li>Java权限修饰符public、protected、(缺省)、private置于类的成员定义前，用来限定对象对该类成员的访问权限。</li>
</ul>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类内部</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>YES</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>default(缺省)</td>
<td>YES</td>
<td>YES</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protectd</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
</tbody></table>
<ul>
<li>对于class的权限修饰只可以用public和default(缺省)。<ul>
<li>public类可以在任何对方被访问</li>
<li>default类之可以被同一个包内部的类访问</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184323.png"></p>
<h1 id="关键字super"><a href="#关键字super" class="headerlink" title="关键字super"></a>关键字super</h1><ul>
<li><p>在Java类中使用super来调用父类中的指定操作：</p>
<ul>
<li>super可用于访问父类中定义的属性</li>
<li>super可用于调用父类中定义的成员方法</li>
<li>super可用于在子类构造器中调用父类的构造器</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员</li>
<li>super的追溯不仅限于直接父类 </li>
<li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识</li>
</ul>
</li>
<li><p>调用父类的构造器时：</p>
<ul>
<li>子类中所有的构造器默认都会访问父类中空参数的构造器</li>
<li>当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器。同时，只能”二选一”，且必须放在构造器的首行</li>
<li>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错</li>
</ul>
</li>
<li><p>this和super的区别</p>
<table>
<thead>
<tr>
<th align="center">区别点</th>
<th align="center">this</th>
<th align="center">super</th>
</tr>
</thead>
<tbody><tr>
<td align="center">访问属性</td>
<td align="center">访问本类中的属性，如果本类没有此属性则从父类中继续查找</td>
<td align="center">直接访问父类中的属性</td>
</tr>
<tr>
<td align="center">调用方法</td>
<td align="center">访问本类中的方法，如果本类没有此方法则从父类中继续查找</td>
<td align="center">直接访问父类中的方法</td>
</tr>
<tr>
<td align="center">调用构造器</td>
<td align="center">调用本类构造器，必须放在构造器的首行</td>
<td align="center">调用父类构造器，必须放在子类构造器的首行</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;创建一个人&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//super() 首行隐藏了super()</span></span><br><span class="line">		System.out.println(<span class="string">&quot;创建一个学生&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;学生吃饭&quot;</span>);</span><br><span class="line">		<span class="keyword">super</span>.eat();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;读书&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.eat();</span><br><span class="line">    student.say();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">创建一个人  </span><br><span class="line">创建一个学生</span><br><span class="line">学生吃饭</span><br><span class="line">吃饭</span><br><span class="line">读书</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="OOP特征三：多态性"><a href="#OOP特征三：多态性" class="headerlink" title="OOP特征三：多态性"></a>OOP特征三：多态性</h1><ul>
<li><p>多态性，是面向对象中最重要的概念，在Java中的体现：</p>
<ul>
<li>对象的多态性：父类的引用指向子类的对象</li>
<li>可以直接应用在抽象类和接口上</li>
</ul>
</li>
<li><p>Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。</p>
<ul>
<li>简称：编译时，看左边；运行时，看右边。</li>
<li>若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)</li>
<li>多态情况下，“看左边”：看的是父类的引用（父类中不具备子类特有的方法）</li>
<li>“看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）</li>
</ul>
</li>
<li><p>对象的多态 —在Java中,子类的对象可以替代父类的对象使用</p>
<ul>
<li>一个变量只能有一种确定的数据类型</li>
<li>一个引用类型变量可能指向(引用)多种不同类型的对象</li>
</ul>
</li>
<li><p>子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。</p>
</li>
<li><p>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student m = <span class="keyword">new</span> Student();</span><br><span class="line">m.school = “pku”; <span class="comment">//合法,Student类有school成员变量</span></span><br><span class="line">Person e = <span class="keyword">new</span> Student(); </span><br><span class="line">e.school = “pku”; <span class="comment">//非法,Person类没有school成员变量</span></span><br></pre></td></tr></table></figure>

<ul>
<li>属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误</li>
</ul>
</li>
<li><p>虚拟方法调用(多态情况下)</p>
<ul>
<li>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person e = <span class="keyword">new</span> Student();</span><br><span class="line">e.getInfo(); <span class="comment">//调用Student类的getInfo()方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类 的getInfo()方法。——动态绑定</li>
</ul>
</li>
<li><p>从编译和运行的角度看</p>
<ul>
<li>重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；</li>
<li>而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。</li>
<li>引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”</li>
</ul>
</li>
<li><p>多态作用：提高了代码的通用性，常称作接口重用</p>
</li>
<li><p>前提：需要存在继承或者实现关系。有方法的重写</p>
</li>
<li><p>成员方法：</p>
<ul>
<li>编译时：要查看引用变量所声明的类中是否有所调用的方法。</li>
<li>运行时：调用实际new的对象所属的类中的重写方法。</li>
</ul>
</li>
<li><p>成员变量：不具备多态性，只看引用变量所声明的类</p>
</li>
<li><p>子类继承父类</p>
<ul>
<li>若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。</li>
<li>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量</li>
</ul>
</li>
</ul>
<h2 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h2><ul>
<li>x instanceof A：检验x是否为类A的对象，返回值为boolean型。<ul>
<li>要求x所属的类与类A必须是子类和父类的关系，否则编译错误。</li>
<li>如果x属于类A的子类B，x instanceof A值也为true</li>
</ul>
</li>
</ul>
<h2 id="对象类型转换-Casting"><a href="#对象类型转换-Casting" class="headerlink" title="对象类型转换(Casting)"></a>对象类型转换(Casting)</h2><ul>
<li>基本数据类型的Casting：<ul>
<li>自动类型转换：小的数据类型可以自动转换成大的数据类型</li>
<li>强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型</li>
</ul>
</li>
<li>对Java对象的强制类型转换称为造型<ul>
<li>从子类到父类的类型转换可以自动进行</li>
<li>从父类到子类的类型转换必须通过造型(强制类型转换)实现</li>
<li>无继承关系的引用类型间的转换是非法的</li>
<li>在造型前可以使用instanceof操作符测试一个对象的类型</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184324.png"></p>
<h1 id="Object类的使用"><a href="#Object类的使用" class="headerlink" title="Object类的使用"></a>Object类的使用</h1><ul>
<li>Object类是所有Java类的根父类</li>
<li>如果在类的声明中未使用extends关键字指明其父类，则默认父类 为java.lang.Object类</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public Object()</td>
<td>构造</td>
<td>构造器</td>
</tr>
<tr>
<td>public boolean equals(Object obj)</td>
<td>普通</td>
<td>对象比较</td>
</tr>
<tr>
<td>public int hashCode()</td>
<td>普通</td>
<td>取得Hash码</td>
</tr>
<tr>
<td>public String toString()</td>
<td>普通</td>
<td>对象打印时调用</td>
</tr>
</tbody></table>
<ul>
<li><p>==操作符与equals方法</p>
<ul>
<li>==<ul>
<li>基本类型比较值:只要两个变量的值相等，即为true。</li>
<li>引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，==才返回true。</li>
<li>用“==”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错</li>
</ul>
</li>
<li>equals<ul>
<li>所有类都继承了Object，也就获得了equals()方法。还可以重写。 </li>
<li>只能比较引用类型，其作用与“==”相同,比较是否指向同一个对象。 </li>
<li>格式:obj1.equals(obj2) </li>
<li>特例：当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象.<ul>
<li>原因：在这些类中重写了Object类的equals()方法。</li>
</ul>
</li>
<li>当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等</li>
</ul>
</li>
</ul>
</li>
<li><p>重写equals()方法的原则</p>
<ul>
<li>对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。</li>
<li>自反性：x.equals(x)必须返回是“true”。</li>
<li>传递性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。</li>
<li>一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。</li>
<li>任何情况下，x.equals(null)，永远返回是“false”； x.equals(和x不同类型的对象)永远返回是“false”。</li>
</ul>
</li>
<li><p>toString方法</p>
<ul>
<li>toString()方法在Object类中定义，其返回值是String类型，返回类名和它的引用地址。 </li>
<li>在进行String与其它类型数据的连接操作时，自动调用toString()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date now=<span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(“now=”+now); 相当于</span><br><span class="line">System.out.println(“now=”+now.toString()); </span><br></pre></td></tr></table></figure>

<ul>
<li>可以根据需要在用户自定义类型中重写toString()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如String 类重写了toString()方法，返回字符串的值。 </span><br><span class="line">s1=“hello”;</span><br><span class="line">System.out.println(s1);<span class="comment">//相当于System.out.println(s1.toString());</span></span><br></pre></td></tr></table></figure>

<ul>
<li>基本类型数据转换为String类型时，调用了对应包装类的toString()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>; System.out.println(“a=”+a);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="JUnit单元测试步骤-Eclipse版"><a href="#JUnit单元测试步骤-Eclipse版" class="headerlink" title="JUnit单元测试步骤(Eclipse版)"></a>JUnit单元测试步骤(Eclipse版)</h1><ul>
<li>选中当前工程-右键选择-点击build path-点击add libraries-选中JUnit 4-下一步</li>
<li>创建Java类，进行单元测试。<ul>
<li>此时的Java类要求：①此类是public的，②此类有公共的无参构造器</li>
</ul>
</li>
<li>测试方法的格式：方法的权限是public的，没有返回值，方法名自定义</li>
<li>此单元测试方法上需要声明注解：@Test,并在单元测试类中导入对应包：</li>
<li>声明好单元测试方法以后，就可以在方法体内测试相关的代码</li>
<li>写完代码以后，左键双击单元测试方法名，右键-run as-JUnit Test</li>
<li>说明：如果执行结果没有任何异常，则显示为绿条。如果执行结果出现异常，则显示红条</li>
</ul>
<h1 id="包装类的使用"><a href="#包装类的使用" class="headerlink" title="包装类的使用"></a>包装类的使用</h1><ul>
<li>针对八种基本数据类型定义相应的引用类型—包装类（封装类）</li>
<li>有了类的特点，就可以调用类中的方法，Java才是真正的面向对象</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184325.png"></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184326.png"></p>
<ul>
<li><p>基本数据类型包装成包装类的实例 —装箱</p>
<ul>
<li>通过包装类的构造器实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本数据类型转换成包装类：调用包装类的构造器</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">Integer in1 = <span class="keyword">new</span> Integer(num);</span><br><span class="line">System.out.println(in1);<span class="comment">//10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>还可以通过字符串参数构造包装类对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本数据类型转换成包装类：通过字符串参数构造包装类对象</span></span><br><span class="line">Integer in2 = <span class="keyword">new</span> Integer(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(in2);<span class="comment">//123</span></span><br><span class="line"><span class="comment">//下面两行会报异常</span></span><br><span class="line"><span class="comment">//Integer in3 = new Integer(&quot;123asd&quot;);</span></span><br><span class="line"><span class="comment">//System.out.println(in3);</span></span><br><span class="line"><span class="comment">//特殊情况:与其他类型相比，这个不会报异常</span></span><br><span class="line">Boolean bool = <span class="keyword">new</span> Boolean(<span class="string">&quot;true123&quot;</span>);</span><br><span class="line">System.out.println(bool);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>自动封箱(JDK5.0以后支持),但类型必须匹配。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本数据类型转换成包装类：自动封箱(JDK5.0以后支持)</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">Integer in = a;</span><br><span class="line">System.out.println(in);<span class="comment">//10</span></span><br></pre></td></tr></table></figure></li>
<li><p>获得包装类对象中包装的基本类型变量 —拆箱</p>
<ul>
<li>调用包装类的.xxxValue()方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装类转换成基本数据类型：调用包装类的xxxValue()方法</span></span><br><span class="line">		Integer in = <span class="keyword">new</span> Integer(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> a = in.intValue();</span><br><span class="line">		System.out.println(a);<span class="comment">//123</span></span><br></pre></td></tr></table></figure>

<ul>
<li>自动拆箱(JDK5.0以后支持),但类型必须匹配。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;包装类转换成基本数据类型：自动拆箱(JDK5.0以后支持)</span><br><span class="line">Integer in &#x3D; new Integer(&quot;123&quot;);</span><br><span class="line">int a &#x3D; in;</span><br><span class="line">System.out.println(a);&#x2F;&#x2F;123</span><br></pre></td></tr></table></figure></li>
<li><p>字符串转换成基本数据类型</p>
<ul>
<li>通过包装类的构造器实现：</li>
<li>通过包装类的parseXxx(String s)静态方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String类型转换成基本数据类型，包装类：</span></span><br><span class="line"><span class="comment">//1.调用包装类的parseXxx(String s)方法</span></span><br><span class="line">String str1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> num1 = Integer.parseInt(str1);</span><br><span class="line">System.out.println(num1);<span class="comment">//123</span></span><br><span class="line"><span class="comment">//报NumberFormatException异常</span></span><br><span class="line"><span class="comment">//String str4 = &quot;123a&quot;;</span></span><br><span class="line"><span class="comment">//int num2 = Integer.parseInt(str4);</span></span><br><span class="line"><span class="comment">//System.out.println(num2);//123</span></span><br><span class="line"></span><br><span class="line">String str2 = <span class="string">&quot;true&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> boo1 = Boolean.parseBoolean(str2);</span><br><span class="line">System.out.println(boo1);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//特殊情况：不会报异常</span></span><br><span class="line">String str3 = <span class="string">&quot;true1&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> boo2 = Boolean.parseBoolean(str3);</span><br><span class="line">System.out.println(boo2);<span class="comment">//false</span></span><br><span class="line"><span class="comment">//2.调用包装类的构造器</span></span><br><span class="line">String str5 = <span class="string">&quot;12&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> num3 = <span class="keyword">new</span> Integer(str5);</span><br><span class="line">System.out.println(num3);<span class="comment">//12</span></span><br></pre></td></tr></table></figure></li>
<li><p>基本数据类型转换成字符串</p>
<ul>
<li>调用字符串重载的valueOf()方法：</li>
<li>更直接的方式：连接运算</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本数据类型，包装类转换成String类型</span></span><br><span class="line"><span class="comment">//1.连接运算</span></span><br><span class="line">String str1 = <span class="number">10</span> + <span class="string">&quot;&quot;</span>;</span><br><span class="line">System.out.println(str1);<span class="comment">//10</span></span><br><span class="line"><span class="comment">//2.调用String的valueOf(Object,object或基本数据类型)方法</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">String str2 = String.valueOf(i);</span><br><span class="line">System.out.println(str2);<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">Double d = <span class="keyword">new</span> Double(<span class="number">12.4</span>);</span><br><span class="line">String str3 = String.valueOf(d);</span><br><span class="line">System.out.println(str3);<span class="comment">//12.4</span></span><br></pre></td></tr></table></figure></li>
<li><p>装箱：包装类使得一个基本数据类型的数据变成了类。有了类的特点，可以调用类中的方法。</p>
</li>
<li><p>拆箱：将数字包装类中内容变为基本数据类型</p>
</li>
<li><p>包装类在实际开发中用的最多的在于字符串变为基本数据类型</p>
</li>
<li><p>Integer的补充</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer内部定义了静态的IntegerCache结构，IntegerCache中定义了一个Integer[],</span></span><br><span class="line"><span class="comment">//数组静态保存了从-128~127范围的数。如果我们使用自动装箱的方式，给Integer赋值的范围在</span></span><br><span class="line"><span class="comment">//-128~127之间，可以直接使用数组中的元素，不用再去new了。</span></span><br><span class="line">Integer a = <span class="number">1</span>;</span><br><span class="line">Integer b = <span class="number">1</span>;</span><br><span class="line">System.out.println(a);<span class="comment">//1</span></span><br><span class="line">System.out.println(b);<span class="comment">//1</span></span><br><span class="line">System.out.println(a == b);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Integer in1 = <span class="number">128</span>;</span><br><span class="line">Integer in2 = <span class="number">128</span>;</span><br><span class="line">System.out.println(in1);<span class="comment">//128</span></span><br><span class="line">System.out.println(in2);<span class="comment">//128</span></span><br><span class="line">System.out.println(in1 == in2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.面向对象的特征之二</span></span><br><span class="line"><span class="comment"> * 	一，继承性的好处</span></span><br><span class="line"><span class="comment"> * 		①减少了代码的冗余，提高了代码的复用性</span></span><br><span class="line"><span class="comment"> * 		②便于功能的扩展</span></span><br><span class="line"><span class="comment"> * 		③为多态性的使用，提供了前提</span></span><br><span class="line"><span class="comment"> * 	二，继承的格式：class A extends B&#123;&#125;</span></span><br><span class="line"><span class="comment"> * 		A:子类，派生类，subclass</span></span><br><span class="line"><span class="comment"> * 		B:父类，超类，基类，superclass</span></span><br><span class="line"><span class="comment"> *		extends：延展，扩展</span></span><br><span class="line"><span class="comment"> * 		2.1体现：一旦子类A继承了父类B以后，子类A中就获取了父类B中声明的所有属性和方法。</span></span><br><span class="line"><span class="comment"> * 			特别的，父类中声明为private的属性和方法，子类继承父类后，仍然认为获取了父类中私有的结构。</span></span><br><span class="line"><span class="comment"> * 			只是因为封装性的影响，使得子类不能直接调用父类的结构而已</span></span><br><span class="line"><span class="comment"> * 		2.2子类继承父类以后，还可以声明自己特有的属性和方法：实现功能的扩展</span></span><br><span class="line"><span class="comment"> * 			子类和父类的关系，不同于子集和集合的关系</span></span><br><span class="line"><span class="comment"> * 	三，Java中关于继承的规定 </span></span><br><span class="line"><span class="comment"> * 		①一个类可以被多个子类继承</span></span><br><span class="line"><span class="comment"> * 		②Java中类的单继承性：一个类只能有一个父类</span></span><br><span class="line"><span class="comment"> * 		③子负类是相对的概念</span></span><br><span class="line"><span class="comment"> * 		④子类直接继承的父类称为：直接父类。间接继承的父类称为：间接父类</span></span><br><span class="line"><span class="comment"> * 		⑤子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法</span></span><br><span class="line"><span class="comment"> *	四，如果我们没有显示的定义一个类的父类的话，则此类继承于java.lang.Object类</span></span><br><span class="line"><span class="comment"> *		所有的java类(除java.lang.Object类)都直接或间接的继承于java.lang.Object</span></span><br><span class="line"><span class="comment"> *		所以所有的java类具有java.lang.Object类声明的功能</span></span><br><span class="line"><span class="comment"> * 2.方法的重写(override)</span></span><br><span class="line"><span class="comment"> *	一，重写：子类继承父类以后，可以对父类中同名参数的方法进行覆盖操作</span></span><br><span class="line"><span class="comment"> *	二，应用：重写以后，当创建子类对象以后，通过子类对象调用父类中的同名同参数的方法时，</span></span><br><span class="line"><span class="comment"> *		实际执行的是子类重写父类的方法</span></span><br><span class="line"><span class="comment"> *	三，重写的规定：</span></span><br><span class="line"><span class="comment"> *			方法的声明：权限修饰符 返回值类型 方法名(形参列表)&#123;</span></span><br><span class="line"><span class="comment"> *								//方法体</span></span><br><span class="line"><span class="comment"> *						&#125;</span></span><br><span class="line"><span class="comment"> *			约定俗称：</span></span><br><span class="line"><span class="comment"> *		①子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和参数列表形同</span></span><br><span class="line"><span class="comment"> *		②子类重写的方法的权限修饰符不小于父类被重写的 方法的权限修饰符</span></span><br><span class="line"><span class="comment"> *			&gt;特殊情况：子类不能重写父类中声明为private权限的方法</span></span><br><span class="line"><span class="comment"> *		③返回值类型</span></span><br><span class="line"><span class="comment"> *			&gt;父类被重写的方法的返回值类型是void,则子类重写的方法的返回值只能是void</span></span><br><span class="line"><span class="comment"> *			&gt;父类被重写的方法的返回值类型是A类型(引用类型),则子类重写的方法的返回值可以是A类型的或A类的子类</span></span><br><span class="line"><span class="comment"> *			&gt;父类被重写的方法的返回值类型是基本数据类型,则子类重写的方法的返回值只能也是对应的基本类型</span></span><br><span class="line"><span class="comment"> *		④子类重写的方法抛出的异常类型不大于父类被重写的方法排除的异常类型</span></span><br><span class="line"><span class="comment"> *		⑤子类和父类中同名同参数的方法要么都声明为非static的(可以重写)，要么都声明为static的(不是重写)</span></span><br><span class="line"><span class="comment"> * 3.super关键字的使用</span></span><br><span class="line"><span class="comment"> * 	一，super理解为：父类的</span></span><br><span class="line"><span class="comment"> * 	二，super可以用来调用：属性，方法，构造器</span></span><br><span class="line"><span class="comment"> * 	三，super调用属性或方法：</span></span><br><span class="line"><span class="comment"> * 		①我们可以在子类的方法或构造器中，通过使用“super.属性”或“super.方法”的方式，显示的调用</span></span><br><span class="line"><span class="comment"> * 		父类中声明的属性或方法。但是通常情况下我们都习惯省略“super.”</span></span><br><span class="line"><span class="comment"> * 		②特殊情况：当子类和父类中定义了同名的属性时，我们想要在子类中调用父类中声明的属性，则必须显示的使用</span></span><br><span class="line"><span class="comment"> * 		“super.属性”的方式，表明调用的是父类中声明的属性。</span></span><br><span class="line"><span class="comment"> * 		③特殊情况：当子类重写了父类的方法以后，外卖想在子类的方法中调用父类中被重写的方法时，必须显示的使用</span></span><br><span class="line"><span class="comment"> * 		“super.方法”的方式，表明调用的是父类中被重写的方法。</span></span><br><span class="line"><span class="comment"> *	四，super调用构造器：</span></span><br><span class="line"><span class="comment"> *		①我们可以在子类的构造器中显式的使用“super(形参列表)”的方式，调用父类中声明的制定的构造器</span></span><br><span class="line"><span class="comment"> *		②“super(形参列表)”的使用，必须声明在子类构造器的首行</span></span><br><span class="line"><span class="comment"> *		③我们在类的构造器中，针对“this(形参列表)”或“super(形参列表)”只能二选一，不能同时出现</span></span><br><span class="line"><span class="comment"> *		④在构造器的首行没有显示的声明“this(形参列表)”或“super(形参列表)”，则默认使用“super()”调用父类中空参的构造器</span></span><br><span class="line"><span class="comment"> *		⑤在类的多个构造器中，至少有一个类的构造器中使用了“super(形参列表)”，调用父类中的构造器</span></span><br><span class="line"><span class="comment"> * 4.子类对象实例化的过程</span></span><br><span class="line"><span class="comment"> * 	一，从结果上看：（继承性）</span></span><br><span class="line"><span class="comment"> *		子类继承父类后，就获取了父类中声明的属性或方法</span></span><br><span class="line"><span class="comment"> *		创建子类的对象，在堆空间中，就会加载所有父类中的声明的属性</span></span><br><span class="line"><span class="comment"> *	二，从过程上看：</span></span><br><span class="line"><span class="comment"> *		当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器</span></span><br><span class="line"><span class="comment"> *		直到调用了java.lang.Obkect类中空参的构造器为止，正因为加载了所有的父类的结构，所以才可以看到内存中有父类中</span></span><br><span class="line"><span class="comment"> *		的结构，子类对象才可以调用父类的结构</span></span><br><span class="line"><span class="comment"> *	明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建了一个对象，即为new的子类对象</span></span><br><span class="line"><span class="comment"> * 5.多态性的理解</span></span><br><span class="line"><span class="comment"> * 	一，理解多态性：可以理解为一个事务的多种形态</span></span><br><span class="line"><span class="comment"> * 	二，何为多态性</span></span><br><span class="line"><span class="comment"> * 		对象多态性：父类的引用指向子类的对象(或子类的对象赋给对象的引用)</span></span><br><span class="line"><span class="comment"> *	三，多态的使用：虚拟方法调用</span></span><br><span class="line"><span class="comment"> *		有了对象的多态性后，我们在编译时期，只能调用父类中声明的方法，但在运行时期，我们实际调用的是父类中重写子类的方法</span></span><br><span class="line"><span class="comment"> *		举例。我们定义了一个A类，定义了一个B类，且B类继承A类。在A类中定义一个输出方法输出a。B类中重写这个输出方法输出b。</span></span><br><span class="line"><span class="comment"> *			另外B类中在定义一个show()方法，输出show。</span></span><br><span class="line"><span class="comment"> *			当执行A a = new B(); a.printf(); 此时的输出是B类中重写的内容。即输出b</span></span><br><span class="line"><span class="comment"> *			但当编写a.show()时会编译不通过。</span></span><br><span class="line"><span class="comment"> *		总结：编译看左边，运行看右边。</span></span><br><span class="line"><span class="comment"> *	四，多态性的使用前提：</span></span><br><span class="line"><span class="comment"> *			①类有继承关系。②方法要重写。</span></span><br><span class="line"><span class="comment"> *	五，多态性的好处：</span></span><br><span class="line"><span class="comment"> *			①在调用以对象为参数的方法时，将方法的参数设置为父类，那么当传进去不同子类的对象时，执行的结果也就不同。</span></span><br><span class="line"><span class="comment"> *			如果此时没有多态性。我们必须将这个方法重写很多次以适应子类的不同。因此多态性可以减少代码的编写</span></span><br><span class="line"><span class="comment"> *	六，多态性的注意点：</span></span><br><span class="line"><span class="comment"> *			①对象多态性只适用于方法，不适用于属性(属性和方法都看左边)		</span></span><br><span class="line"><span class="comment"> *	七，内存中的变化。</span></span><br><span class="line"><span class="comment"> *			多态性的使用时，内存中实际上是加载了子类特有的属性何方法的。但是由于变量被声明为父类类型，导致编译时，</span></span><br><span class="line"><span class="comment"> *			只能调用父类中声明的属性何方法。子类特有的属性仍然存在在内存中但无法调用</span></span><br><span class="line"><span class="comment"> * 6.instanceof关键字</span></span><br><span class="line"><span class="comment"> *	一，多态性使用后如何让变量调用子类特有的属性和方法？</span></span><br><span class="line"><span class="comment"> *		①向下转型，使用强制类型转换符</span></span><br><span class="line"><span class="comment"> *			缺点：A类是B类和C类的父类。当A a = new B();时，强转a为C类时会出现ClassCastException异常</span></span><br><span class="line"><span class="comment"> *		②使用instanceof关键字提前判断是否可以强转</span></span><br><span class="line"><span class="comment"> *	二，使用：a instanceof A：表示判断对象a是否是类A的实例。如果是返回true。如果不是返回false</span></span><br><span class="line"><span class="comment"> *	三，使用情景：为了避免在向下转型时出现ClassCastException异常，我们在向下转型之前，先进行instanceof的判断</span></span><br><span class="line"><span class="comment"> *				，一旦返回true就进行向下转型。如果返回false则不能进行向下转型</span></span><br><span class="line"><span class="comment"> *	四，补充：B类是A类的父类的话那么a instanceof A返回true,且a instanceof B也返回true.</span></span><br><span class="line"><span class="comment"> * 7.Object类</span></span><br><span class="line"><span class="comment"> * 	 ①：Object类是所有Java类的根父类</span></span><br><span class="line"><span class="comment"> * 	 ②：如果在类的声明中未使用extends关键字指明其父类。则默认父类为java.lang.Object类	</span></span><br><span class="line"><span class="comment"> * 	 ③：Object类中的功能(属性，方法)具有通用性。</span></span><br><span class="line"><span class="comment"> * 		属性：无</span></span><br><span class="line"><span class="comment"> * 		方法：equals()/toStrings()/getClass()/hasCode()/clone()/finalize()/wait()/notify()/notifyAll()</span></span><br><span class="line"><span class="comment"> *   ④：Object类只声明了一个空参的构造器</span></span><br><span class="line"><span class="comment"> *  一，==和equals()的区别</span></span><br><span class="line"><span class="comment"> *   ==的使用：</span></span><br><span class="line"><span class="comment"> *   	①：可以使用在基本数据类型和引用数据类型变量中</span></span><br><span class="line"><span class="comment"> *   	②：如果比较的是基本数据类型变量，比较两个变量的数据是否相等。(不一定类型相同)</span></span><br><span class="line"><span class="comment"> *   	③：如果比较的是引用数据类型变量，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体</span></span><br><span class="line"><span class="comment"> *   	④：==符号在使用时要保证符号两边的数据类型要一致。既可以比较</span></span><br><span class="line"><span class="comment"> *   equals()的使用</span></span><br><span class="line"><span class="comment"> *   	①：是一个方法，而非运算符</span></span><br><span class="line"><span class="comment"> *   	②：只能适用于引用数据类型</span></span><br><span class="line"><span class="comment"> *   	③：Object类中的equals()中对定义:和==是相同的，都是比较两个对象的地址值是否相同</span></span><br><span class="line"><span class="comment"> *   	源码：public boolean equals(Object obj) &#123;</span></span><br><span class="line"><span class="comment"> *       			return (this == obj);</span></span><br><span class="line"><span class="comment"> *   		  &#125;</span></span><br><span class="line"><span class="comment"> *   	④：像String,Date,File,包装类等都重写了Object类中的equals()方法，重写后比较的是两个对象的“实体内容”是否相同</span></span><br><span class="line"><span class="comment"> *   		而不是引用的地址是否相同</span></span><br><span class="line"><span class="comment"> *   	⑤： 自定义类的比较需要我们重写equals()方法。一般情况下我们会选择自动生成的equals()方法。而不自己写。</span></span><br><span class="line"><span class="comment"> *	二，toString()方法的使用</span></span><br><span class="line"><span class="comment"> *		①：Object类的toString()方法输出的是对象的引用地址值</span></span><br><span class="line"><span class="comment"> *		②：当我们输出一个对象的应用时，实际上是调用对象的toString()方法</span></span><br><span class="line"><span class="comment"> *		③：像String,Date,File,包装类等都重写了Object类中的toString()方法。</span></span><br><span class="line"><span class="comment"> *			使得在调用上述类型的对象的toString()方法时，返回的是对象的“实体内容”信息</span></span><br><span class="line"><span class="comment"> *		④：自定义的类可以重写toString()方法。重写此方法一般使用自动生成，重写后的方法返回的是实体内容的信息</span></span><br><span class="line"><span class="comment"> * 8.包装类的使用</span></span><br><span class="line"><span class="comment"> * 	 ①：Java提供了8中基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征</span></span><br><span class="line"><span class="comment"> *	 ②：基本数据类型，包装类，String三者之间的转换</span></span><br><span class="line"><span class="comment"> *		一，基本数据类型转换成包装类</span></span><br><span class="line"><span class="comment"> *			①：调用包装类的构造</span></span><br><span class="line"><span class="comment"> *			②：自送封箱(JDK5.0以后支持)</span></span><br><span class="line"><span class="comment"> *		二，包装类转换成基本数据类型</span></span><br><span class="line"><span class="comment"> *			①：调用包装类的xxxValue()方法</span></span><br><span class="line"><span class="comment"> *			②：自动拆箱(JDK5.0以后支持)</span></span><br><span class="line"><span class="comment"> *		三，基本数据类型，包装类转换成String类型</span></span><br><span class="line"><span class="comment"> *			①：连接运算</span></span><br><span class="line"><span class="comment"> *			②：调用String的valueOf(Object,object或基本数据类型)方法</span></span><br><span class="line"><span class="comment"> *		四，String类型转换成基本数据类型，包装类</span></span><br><span class="line"><span class="comment"> *			①：调用包装类的parseXxx(String s)方法</span></span><br><span class="line"><span class="comment"> *			②：调用包装类的构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


    </div>

    
    
    


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/12/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/7-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/" rel="prev" title="面向对象(上)">
      <i class="fa fa-chevron-left"></i> 面向对象(上)
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/14/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/" rel="next" title="mysql学习">
      mysql学习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#OOP%E7%89%B9%E5%BE%81%E4%BA%8C%EF%BC%9A%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">OOP特征二：继承性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99-override"><span class="nav-number">2.</span> <span class="nav-text">方法的重写(override)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">3.</span> <span class="nav-text">四种访问权限修饰符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97super"><span class="nav-number">4.</span> <span class="nav-text">关键字super</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#OOP%E7%89%B9%E5%BE%81%E4%B8%89%EF%BC%9A%E5%A4%9A%E6%80%81%E6%80%A7"><span class="nav-number">5.</span> <span class="nav-text">OOP特征三：多态性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#instanceof%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.1.</span> <span class="nav-text">instanceof操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-Casting"><span class="nav-number">5.2.</span> <span class="nav-text">对象类型转换(Casting)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Object%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">6.</span> <span class="nav-text">Object类的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%AD%A5%E9%AA%A4-Eclipse%E7%89%88"><span class="nav-number">7.</span> <span class="nav-text">JUnit单元测试步骤(Eclipse版)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">8.</span> <span class="nav-text">包装类的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">9.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Plum Reiver</p>
  <div class="site-description" itemprop="description">技术，日常，笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
	
  </nav>
</div>


      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plum Reiver</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
