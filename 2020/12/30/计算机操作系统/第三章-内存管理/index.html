<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"plumv.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="内存的基本知识，链接的三种方式，内存的扩充技术，分配与回收，动态分区分配算法分页存储，分段存储，虚拟内存。">
<meta property="og:type" content="article">
<meta property="og:title" content="第二章-内存管理">
<meta property="og:url" content="https://plumv.github.io/2020/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="李川的个人博客">
<meta property="og:description" content="内存的基本知识，链接的三种方式，内存的扩充技术，分配与回收，动态分区分配算法分页存储，分段存储，虚拟内存。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223212522.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223211853.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223213245.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224103423.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224103252.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224115017.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224115050.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224115059.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224115203.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224115319.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224114627.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224120919.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225090814.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225090949.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225091029.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225091124.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225091804.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225090631.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225093227.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225093556.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225093404.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225093227.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225100835.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225100953.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225102602.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225102708.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225102422.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225105247.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225105425.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225105509.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225105031.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225110659.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225110820.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225111021.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225110631.png">
<meta property="article:published_time" content="2020-12-29T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-21T12:21:27.152Z">
<meta property="article:author" content="Plum Reiver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223212522.png">

<link rel="canonical" href="https://plumv.github.io/2020/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>第二章-内存管理 | 李川的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李川的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>日志</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://plumv.github.io/2020/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plum Reiver">
      <meta itemprop="description" content="技术，日常，笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李川的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          第二章-内存管理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-30 00:00:00" itemprop="dateCreated datePublished" datetime="2020-12-30T00:00:00+08:00">2020-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-21 20:21:27" itemprop="dateModified" datetime="2021-03-21T20:21:27+08:00">2021-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算机操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>内存的基本知识，链接的三种方式，内存的扩充技术，分配与回收，动态分区分配算法<br>分页存储，分段存储，虚拟内存。</p>
<span id="more"></span>
<h1 id="第一节：内存的基本知识"><a href="#第一节：内存的基本知识" class="headerlink" title="第一节：内存的基本知识"></a>第一节：内存的基本知识</h1><h2 id="1-1-装入的三种方式"><a href="#1-1-装入的三种方式" class="headerlink" title="1.1 装入的三种方式"></a>1.1 装入的三种方式</h2><ul>
<li><strong>绝对装入</strong>：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。<ul>
<li>绝对装入只适用于单道程序环境。</li>
</ul>
</li>
<li><strong>静态重定位</strong>：又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址(地址变换是在装入时一次完成的)。<ul>
<li>静态重定位的特点是在–个作业装入内存时，必须分配其要求的全部内存空间，， 如果没有足够的内存，就不能装入该作业。</li>
<li>作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。.</li>
</ul>
</li>
<li><strong>动态重定位</strong>：又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要-一个重定位寄存器的支持。<ul>
<li>重定位寄存器:存放装入模块存放的起始位置。</li>
<li>采用动态重定位时允许程序在内存中发生移动。</li>
<li>并且可将程序分配到不连续的存储区中;在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存;便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</li>
</ul>
</li>
</ul>
<h2 id="1-2-程序的编写到运行的过程"><a href="#1-2-程序的编写到运行的过程" class="headerlink" title="1.2 程序的编写到运行的过程"></a>1.2 程序的编写到运行的过程</h2><ul>
<li><strong>编译</strong>：由编译程序将用户源代码编译成若干个目标模块(编译就是把高级语言翻译为机器语言)</li>
<li><strong>链接</strong>：由链接程序将编译后形成的一-组目标模块，以及所需库函数链接在一起，形成-一个完整的装入模块</li>
<li><strong>装入(装载)</strong> ：由装入程序将装入模块装入内存运行</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223212522.png"></p>
<h2 id="1-3-链接的三种方式"><a href="#1-3-链接的三种方式" class="headerlink" title="1.3 链接的三种方式"></a>1.3 链接的三种方式</h2><ul>
<li>1.<strong>静态链接</strong>:在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件(装入模块) ,之,后不再拆开。</li>
<li>2.<strong>装入时动态链接</strong>:将各目标模块装入内存时，边装入边链接的链接方式。</li>
<li>3.<strong>运行时动态链接</strong>:在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</li>
</ul>
<h2 id="1-4总结"><a href="#1-4总结" class="headerlink" title="1.4总结"></a>1.4总结</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223211853.png"></p>
<h1 id="第二节-内存的管理功能"><a href="#第二节-内存的管理功能" class="headerlink" title="第二节 内存的管理功能"></a>第二节 内存的管理功能</h1><ul>
<li><p>1.操作系统负责内存空间的分配与回收。</p>
</li>
<li><p>2.操作系统需要提供某种技术从逻辑上对内存空间进行扩充。</p>
</li>
<li><p>3.操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。</p>
<ul>
<li>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换(这个过程称为地址重定位)应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223213245.png"></p>
</li>
<li><p>4.操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。</p>
<ul>
<li>方法一:在CPU中设置- -对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</li>
<li>方法二:采用重定位寄存器(又称基址寄存器)和界地址寄存器(又称限长寄存器)进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。</li>
</ul>
</li>
</ul>
<h2 id="2-1-内存空间的扩充功能"><a href="#2-1-内存空间的扩充功能" class="headerlink" title="2.1 内存空间的扩充功能"></a>2.1 内存空间的扩充功能</h2><h3 id="2-1-1覆盖技术"><a href="#2-1-1覆盖技术" class="headerlink" title="2.1.1覆盖技术"></a>2.1.1覆盖技术</h3><ul>
<li>覆盖技术的思想:将程序分为多个段(多个模块)。常用的段常驻内存，不常用的段在需要时调入内存。</li>
<li>内存中分为- -个“固定区”和若千个“覆盖区”。</li>
<li>需要常驻内存的段放在“固定区”中，调入后就不再调出( 除非运行结束)</li>
<li>不常用的段放在“覆盖区”，需要用到时调入内存,用不到时调出内存</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224103423.png"></p>
<ul>
<li>必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点:对用户不透明，增加了用户编程负担。</li>
<li>覆盖技术只用于早期的操作系统中，现在已成为历史。</li>
</ul>
<h3 id="2-1-2交换技术"><a href="#2-1-2交换技术" class="headerlink" title="2.1.2交换技术"></a>2.1.2交换技术</h3><ul>
<li>交换(对换)技术的设计思想:内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)</li>
<li>1.应该在外存(磁盘)的什么位置保存被换出的进程?<ul>
<li>具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I/O速度比文件区的更快。</li>
</ul>
</li>
<li>2.什么时候应该交换?<ul>
<li>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。</li>
</ul>
</li>
<li>3.应该换出哪些进程?<ul>
<li>可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…</li>
<li>(注意: PCB会常驻内存，不会被换出外存)</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224103252.png"></p>
<h3 id="2-1-3虚拟存储技术"><a href="#2-1-3虚拟存储技术" class="headerlink" title="2.1.3虚拟存储技术"></a>2.1.3虚拟存储技术</h3><h2 id="2-2-内存空间的分配与回收"><a href="#2-2-内存空间的分配与回收" class="headerlink" title="2.2 内存空间的分配与回收"></a>2.2 内存空间的分配与回收</h2><h3 id="连续分配管理"><a href="#连续分配管理" class="headerlink" title="连续分配管理"></a>连续分配管理</h3><ul>
<li>连续分配:指为用户进程分配的必须是- -个连续的内存空间。</li>
</ul>
<h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><ul>
<li>在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据;用户区用于存放用户进程相关数据。内存中只能有-道用户程序，用户程序独占整个用户区空间。</li>
<li>优点:实现简单;无外部碎片;可以采用覆盖技术扩充内存;不一定需要采取内存保护(eg: 早期的PC操作系统MS-DOS)。</li>
<li>缺点:只能用于单用户、单任务的操作系统中;有内部碎片;存储器利用率极低。</li>
</ul>
<h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><ul>
<li><p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入-道作业，这样就形成了最早的、最简单的一-种可运行多道程序的内存管理方式。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224115017.png"></p>
</li>
<li><p>分区大小相等:缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合(比如:钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序)。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224115050.png"></p>
</li>
<li><p>分区大小不等:增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分(比如:划分多个小分区、适量中等分区、少量大分区)。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224115059.png"></p>
</li>
<li><p>操作系统需要建立-一个数据结构–分区 说明表，来实现各个分区的分配与回收。每个表项对应-一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态(是否已分配)。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224115203.png"></p>
</li>
<li><p>当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。</p>
</li>
<li><p>优点:实现简单，无外部碎片。</p>
</li>
<li><p>缺点: a.当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能; b. 会产生内部碎片，内存利用率低。</p>
</li>
</ul>
<h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><ul>
<li><p>动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。(eg: 假设某计算机内存大小为64MB，系统区8MB,用户区共56 M…)</p>
</li>
<li><p>1.系统要用什么样的数据结构记录内存的使用情况?</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224115319.png"></p>
</li>
<li><p>2.当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?</p>
<ul>
<li>把一个新作业装入内存时，须按照- -定的动态分区分配算法，从空闲分区表(或空闲分区链)中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。</li>
</ul>
</li>
<li><p>3.如何进行分区的分配与回收操作?</p>
<ul>
<li>情况-一;回收区的后面有一个相邻的空闲分区，两个相邻的空闲分区合并为-一个</li>
<li>情况二:回收区的前面有一个相邻的空闲分区，两个相邻的空闲分区合并为-一个</li>
<li>情况三:回收区的前、后各有一个相邻的空闲分区，三个相邻的空闲分区合并为一个</li>
<li>情况四:回收区的前、后都没有相邻的空闲分区，新增一个表项<ul>
<li>注:各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定。</li>
</ul>
</li>
</ul>
</li>
<li><p>动态分区分配没有内部碎片，但是有外部碎片。</p>
<ul>
<li>内部碎片：分配给某进程的内存区域中，如果有些部分没有用上。</li>
<li>外部碎片：是指内存中的某些空闲分区由于太小而难以利用。</li>
</ul>
</li>
<li><p>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一- 整块连续的内存空间，因此这些“碎片”不能满足进程的需求。</p>
</li>
<li><p>可以通过紧凑(拼凑，Compaction) 技术来解决外部碎片。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224114627.png"></p>
<h3 id="非连续分配管理"><a href="#非连续分配管理" class="headerlink" title="非连续分配管理"></a>非连续分配管理</h3><h4 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h4><h4 id="分段存储管理"><a href="#分段存储管理" class="headerlink" title="分段存储管理"></a>分段存储管理</h4><h2 id="2-3-动态分区分配算法"><a href="#2-3-动态分区分配算法" class="headerlink" title="2.3 动态分区分配算法"></a>2.3 动态分区分配算法</h2><h3 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h3><ul>
<li>算法思想:每次都从低地址开始查找，找到第- -个能满足大小的空闲分区。</li>
<li>如何实现:空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一 个空闲分区。</li>
</ul>
<h3 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h3><ul>
<li>算法思想:由于动态分区分配是–种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。</li>
<li>如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链( 或空闲分区表)，找到大小能满足要求的第一- 个空闲分区。</li>
<li>缺点:每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。</li>
</ul>
<h3 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h3><ul>
<li>又称最大适应算法( Largest Fit)</li>
<li>算法思想:为了解决最佳适应算法的问题—-即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</li>
<li>如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。</li>
<li>缺点:每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</li>
</ul>
<h3 id="邻近适应算法"><a href="#邻近适应算法" class="headerlink" title="邻近适应算法"></a>邻近适应算法</h3><ul>
<li>算法思想:首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</li>
<li>如何实现:空闲分区以地址递增的顺序排列(可排成-一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</li>
<li>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来(最佳适应算法的优点)。</li>
<li>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用( 最大适应算法的缺点)。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201224120919.png"></p>
<h1 id="第三节：非连续分配管理"><a href="#第三节：非连续分配管理" class="headerlink" title="第三节：非连续分配管理"></a>第三节：非连续分配管理</h1><h2 id="3-1-分页存储管理"><a href="#3-1-分页存储管理" class="headerlink" title="3.1 分页存储管理"></a>3.1 分页存储管理</h2><ul>
<li>将内存空间分为-一个个大小相等的分区(比如:每个分区4KB)，每个分区就是一个“页框”(页框=页 帧=内存块=物理块=物理页面)。每个页框有一一个编号，即“页框号”(页框号=页帧号=内存块号=物理块号=物理页号)，页框号从0开始。</li>
<li>将进程的逻辑地址空间也分为与页框大小相等的一一个个部分，每个部分称为-一个“页”或“页面”。每个页面也有-一个编号，即“页号”，页号也是从0开始。</li>
<li>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入-一个页框中。也就是说，进程的页面与内存的页框有一- -对应的关系。</li>
<li>各个页面不必连续存放，可以放到不相邻的各个页框中。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225090814.png"></p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><ul>
<li><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一-张页表。</p>
<ul>
<li>注:页表通常存在PCB (进程控制块)中</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225090949.png"></p>
<ul>
<li>1.一个进程对应- -张页表</li>
<li>2.进程的每个页面对应-一个页表项</li>
<li>3.每个页表项由“页号”和“块号”组成</li>
<li>4.页表记录进程页面和实际存放的内存块之间的映射关系</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225091029.png"></p>
</li>
</ul>
<h3 id="页表的地址转换"><a href="#页表的地址转换" class="headerlink" title="页表的地址转换"></a>页表的地址转换</h3><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225091124.png"></p>
<ul>
<li><p>如果每个页面大小为2KB,用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分就是页号。</p>
</li>
<li><p>分页存储管理的逻辑地址结构如下所示:</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225091804.png"></p>
</li>
<li><p>地址结构包含两个部分:前- -部分为页号，后一部分为页内偏移量W。在上图所示的例子中，地址长度为32位，其中0<del>11位为“页内偏移量”，或称“页内地址”; 12</del>31 位为“页号”。</p>
</li>
<li><p>如果有K位表示“页内偏移量”，则说明该系统中-一个页面的大小是2K个内存单元。</p>
</li>
<li><p>如果有M位表示“页号”，则说明在该系统中，一个进程最多允许有2M个页面。</p>
</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225090631.png"></p>
<h3 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h3><ul>
<li><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</p>
</li>
<li><p>通常会在系统中设置一一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p>
</li>
<li><p>设页面大小为L，逻辑地址A到物理地址E的变换过程如下:</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225093227.png"></p>
<ul>
<li>①计算页号P和页内偏移量W (如果用十进制数手算，则P=A/L, W=A%L; 但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量)</li>
<li>②比较页号P和页表长度M，若P2M，则产生越界中断，否则继续执行。(注意: 页号是从0开始的，而页表长度至少是1，因此P=M时也会越界)</li>
<li>③页表中页号P对应的页表项地址=页表起始地址F+页号P*页表项长度，取出该页表项内容b,即为内存块号。(注意区分页表项长度、 页表长度、页面大小的区别。页表长度指的是这个页表中总共有几个页表项，即总共有几个页;页表项长度指的是每个页表项占多大的存储空间;页面大小指的是一个页面占多大的存储空间)</li>
<li><em>④计算E=b</em>L+W，用得到的物理地址E去访存。 (如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了)</li>
</ul>
</li>
<li><p>例题：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225093556.png"></p>
</li>
<li><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225093404.png"></p>
</li>
<li><p>在分页存储管理(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p>
</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225093227.png"></p>
<h3 id="具有快表的基本地址变换机构"><a href="#具有快表的基本地址变换机构" class="headerlink" title="具有快表的基本地址变换机构"></a>具有快表的基本地址变换机构</h3><ul>
<li><p>快表，又称联想寄存器(TLB，translation lookaside buffer )，是一-种访问速度比内存快很多的高速缓存(TLB不是内存! )，用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。</p>
</li>
<li><p>快表的访问过程</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225100835.png"></p>
<ul>
<li>①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</li>
<li>②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</li>
<li>③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换)</li>
</ul>
</li>
<li><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，-般来说快表的命中率可以达到90%以上。</p>
</li>
<li><p>快表的例题</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225100953.png"></p>
</li>
<li><p>局部性原理</p>
<ul>
<li><strong>时间局部性</strong>:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。( 因为程序中存在大量的循环)。</li>
<li><strong>空间局部性</strong>:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很 多数据在内存中都是连续存放的)。</li>
</ul>
</li>
</ul>
<h3 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h3><p><strong>单级页表存在的问题</strong></p>
<ul>
<li>问题一:页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</li>
<li>问题二:没有必要让整个页表常驻内存，因为进程在–段时间内可能只需要访问某几个特定的页面。</li>
</ul>
<p><strong>两级页表</strong></p>
<ul>
<li><p>为离散分配的页表再建立一张页表，称为页目录表，或称外层页表，或称顶层页表</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225102602.png"></p>
</li>
<li><p>地址变换过程</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225102708.png"></p>
</li>
<li><p>注意：</p>
</li>
<li><p>1.若采用多级页表机制，则各级页表的大小不能超过一个页面</p>
</li>
<li><p>2.两级页表的访存次数分析(假设没有快表机构)</p>
<ul>
<li>第一次访存:访问内存中的页目录表</li>
<li>第二次访存:访问内存中的二级页表</li>
<li>第三次访存:访问目标内存单元</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225102422.png"></p>
<h2 id="3-2-分段存储管理"><a href="#3-2-分段存储管理" class="headerlink" title="3.2 分段存储管理"></a>3.2 分段存储管理</h2><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><ul>
<li><p>进程的地址空间:按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名(在低级语言中，程序员使用段名来编程)，每段从0开始编址</p>
</li>
<li><p>内存分配规则:以段为单位进行分配，每个段在内存中占据连续空间，各段之间可以不相邻。</p>
</li>
<li><p>分段系统的逻辑地址结构由段号(段名)和段内地址(段内偏移量)所组成。如:</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225105247.png"></p>
</li>
<li><p>段号的位数决定了每个进程最多可以分几个段。</p>
</li>
<li><p>段内地址位数决定了每个段的最大长度是多少。</p>
</li>
</ul>
<h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><ul>
<li>问题:程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立- -张段映射表，简称“段表“。</li>
<li>1.每个段对应-一个段表项，其中记录了该段在内存中的起始位置(又称“基址”)和段的长度。</li>
<li>2.各个段表项的长度是相同的。例如:某系统按字节寻址，采用分段存储管理，逻辑地址结构为(段号16位，段内地址16位)，因此用16位即可表示最大段长。物理内存大小为4GB (可用32位表示整个物理内存地址空间)。因此，可以让每个段表项占16+32=48位，即6B。由于段表项长度相同，因此段号可以是隐含的，不占存储空间。若段表存放的起始地址为M,则K号段对应的段表项存放的地址为M + K*6。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225105425.png"></p>
<h3 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h3><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225105509.png"></p>
<h3 id="分段与分页的区别"><a href="#分段与分页的区别" class="headerlink" title="分段与分页的区别"></a>分段与分页的区别</h3><ul>
<li>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</li>
<li>段是信息的逻辑单位。分页的主要目的是更好地满足用户需求。一个段通常包含着一-组属于-一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</li>
<li>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。<ul>
<li>分页的用户进程地址空间是一-维的，程序员只需给出一个记忆符即可表示一一个地址。</li>
<li>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</li>
</ul>
</li>
<li>分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码(不属于临界资源)，这样的代码是可以共享的。可修改的代码是不能共享的</li>
<li>访问一个逻辑地址需要几次访存?<ul>
<li>分页(单级页表) :第一次访存–查内存中的页表，第二次访存一–访问目标内存单元。总共两次访存</li>
<li>分段:第一次访存- –查内存中的段表，第二次访存- - -访问目标内存单元。总共两次访存</li>
</ul>
</li>
<li>与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225105031.png"></p>
<h2 id="3-3-段页式存储管理方式"><a href="#3-3-段页式存储管理方式" class="headerlink" title="3.3 段页式存储管理方式"></a>3.3 段页式存储管理方式</h2><h3 id="分段和分页的优缺点"><a href="#分段和分页的优缺点" class="headerlink" title="分段和分页的优缺点"></a>分段和分页的优缺点</h3><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225110659.png"></p>
<h3 id="段页式存储"><a href="#段页式存储" class="headerlink" title="段页式存储"></a>段页式存储</h3><ul>
<li><p>将进程按逻辑模块分段，再将各段分页(如每个页面4KB)再将内存空间分为大小相同的内存块/页框/页帧/物理块进程前将各页面分别装入各内存块中。</p>
</li>
<li><p>段页式系统的逻辑地址结构由段号、页号、页内地址(页内偏移量)组成。如:</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225110820.png"></p>
<ul>
<li>段号的位数决定了每个进程最多可以分几个段</li>
<li>页号位数决定了每个段最大有多少页</li>
<li>页内偏移量决定了页面大小、内存块大小是多少</li>
<li>“分段”对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将各段“分页”对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此段页式管理的地址结构是二维的。</li>
</ul>
</li>
<li><p>每个段对应一一个段表项，每个段表项由段号、页表长度、页表存放块号(页表起始地址)组成。每个段表项长度相等，段号是隐含的。</p>
</li>
<li><p>每个页面对应一一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。</p>
</li>
</ul>
<h3 id="地址变换-1"><a href="#地址变换-1" class="headerlink" title="地址变换"></a>地址变换</h3><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225111021.png"></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201225110631.png"></p>
<h1 id="第四节：虚拟内存"><a href="#第四节：虚拟内存" class="headerlink" title="第四节：虚拟内存"></a>第四节：虚拟内存</h1>
    </div>

    
    
    


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" rel="prev" title="第二章-进程管理">
      <i class="fa fa-chevron-left"></i> 第二章-进程管理
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" rel="next" title="第一章-计算机系统概述">
      第一章-计算机系统概述 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">第一节：内存的基本知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E8%A3%85%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 装入的三种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E5%86%99%E5%88%B0%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 程序的编写到运行的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E9%93%BE%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 链接的三种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4%E6%80%BB%E7%BB%93"><span class="nav-number">1.4.</span> <span class="nav-text">1.4总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-%E5%86%85%E5%AD%98%E7%9A%84%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="nav-number">2.</span> <span class="nav-text">第二节 内存的管理功能</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%85%85%E5%8A%9F%E8%83%BD"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 内存空间的扩充功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1覆盖技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2交换技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3虚拟存储技术</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 内存空间的分配与回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86"><span class="nav-number">2.2.1.</span> <span class="nav-text">连续分配管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">单一连续分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">固定分区分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">动态分区分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86"><span class="nav-number">2.2.2.</span> <span class="nav-text">非连续分配管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">分页存储管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">分段存储管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 动态分区分配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.1.</span> <span class="nav-text">首次适应算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.2.</span> <span class="nav-text">最佳适应算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.3.</span> <span class="nav-text">最坏适应算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.4.</span> <span class="nav-text">邻近适应算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">2.3.5.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82%EF%BC%9A%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">第三节：非连续分配管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 分页存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8"><span class="nav-number">3.1.1.</span> <span class="nav-text">页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.1.2.</span> <span class="nav-text">页表的地址转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="nav-number">3.1.3.</span> <span class="nav-text">基本地址变换机构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="nav-number">3.1.4.</span> <span class="nav-text">具有快表的基本地址变换机构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">3.1.5.</span> <span class="nav-text">两级页表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 分段存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%AE%B5"><span class="nav-number">3.2.1.</span> <span class="nav-text">分段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E8%A1%A8"><span class="nav-number">3.2.2.</span> <span class="nav-text">段表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="nav-number">3.2.3.</span> <span class="nav-text">地址变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E4%B8%8E%E5%88%86%E9%A1%B5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.4.</span> <span class="nav-text">分段与分页的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">3.2.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 段页式存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.3.1.</span> <span class="nav-text">分段和分页的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-number">3.3.2.</span> <span class="nav-text">段页式存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2-1"><span class="nav-number">3.3.3.</span> <span class="nav-text">地址变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-number">3.3.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">4.</span> <span class="nav-text">第四节：虚拟内存</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Plum Reiver</p>
  <div class="site-description" itemprop="description">技术，日常，笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
	
  </nav>
</div>


      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plum Reiver</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
