<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"plumv.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="进程的概念，状态，进程控制，进程通信，线程，多线程，处理机调度，进程调度调度算法，先来先服务，进程的同步和互斥，信号量机制，生产者与消费者，管程，死锁，死锁的处理。">
<meta property="og:type" content="article">
<meta property="og:title" content="第二章-进程管理">
<meta property="og:url" content="https://plumv.github.io/2020/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="李川的个人博客">
<meta property="og:description" content="进程的概念，状态，进程控制，进程通信，线程，多线程，处理机调度，进程调度调度算法，先来先服务，进程的同步和互斥，信号量机制，生产者与消费者，管程，死锁，死锁的处理。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210201659.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210202032.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210202428.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210202759.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210204658.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210204615.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210205035.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210205108.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210205248.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210212742.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211062820.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211063138.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211063603.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211063809.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211064008.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211064111.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211064902.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211065340.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211065610.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211114714.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211115156.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219171331.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211143409.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211143632.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211114525.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212084518.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212084842.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212084849.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212085335.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212085054.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212085413.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212090439.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212090501.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212091136.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212091237.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212094214.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212095308.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212095425.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212095620.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212095731.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212095931.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212100106.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212105645.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212105648.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212105654.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212105658.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212105703.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212110033.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212110046.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212110148.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212140802.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212140944.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212141322.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212141243.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212141248.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212141733.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212141904.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212142133.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212143056.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212143338.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212143541.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212142914.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212145904.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212150337.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212150631.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212150840.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212151023.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212155414.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212155635.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212155841.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212155910.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212161122.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212161254.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212161503.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212162133.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212173644.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212173824.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212173828.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212173907.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212174117.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212174234.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212174326.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212174402.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223164347.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223164427.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223164525.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223164628.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223181258.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223182852.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223183648.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223185245.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223203438.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223203536.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223204639.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223204500.png">
<meta property="article:published_time" content="2020-12-29T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-21T12:19:42.208Z">
<meta property="article:author" content="Plum Reiver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210201659.png">

<link rel="canonical" href="https://plumv.github.io/2020/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>第二章-进程管理 | 李川的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李川的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>日志</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://plumv.github.io/2020/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plum Reiver">
      <meta itemprop="description" content="技术，日常，笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李川的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          第二章-进程管理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-30 00:00:00" itemprop="dateCreated datePublished" datetime="2020-12-30T00:00:00+08:00">2020-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-21 20:19:42" itemprop="dateModified" datetime="2021-03-21T20:19:42+08:00">2021-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算机操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>进程的概念，状态，进程控制，进程通信，线程，多线程，处理机调度，进程调度<br>调度算法，先来先服务，进程的同步和互斥，信号量机制，生产者与消费者，管程，<br>死锁，死锁的处理。</p>
<span id="more"></span>
<h1 id="一，进程的概念，组成，特征"><a href="#一，进程的概念，组成，特征" class="headerlink" title="一，进程的概念，组成，特征"></a>一，进程的概念，组成，特征</h1><h2 id="1-1进程的概念"><a href="#1-1进程的概念" class="headerlink" title="1.1进程的概念"></a>1.1进程的概念</h2><p><strong>程序</strong>:是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。</p>
<p><strong>进程(Process)</strong> :是动态的，是程序的一次执行过程</p>
<p>​                            同一个程序多次执行会对应多个进程。</p>
<h2 id="1-2进程的组成"><a href="#1-2进程的组成" class="headerlink" title="1.2进程的组成"></a>1.2进程的组成</h2><p>思考:操作系统是这些进程的管理者，它要怎么区分各个进程?</p>
<p>答：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”–PID (Process ID，进程ID)。</p>
<p>操作系统对进程做的操作：</p>
<p>1.要记录PID、进程所属用户ID (UID)。            –基本的进程描述信息，可以让操作系统区分各个进程</p>
<p>2.要记录给进程分配了哪些资源(如:分配了多少内存、正在使用哪些1I/O设备、正在使用哪些文件)。 –可用于实现操作系统对资源的管理。</p>
<p>3.要记录进程的运行情况(如: CPU使用时间、磁盘使用情况、网络流量使用情况等)。    –可用于实现操作系统对进程的控制、调度。</p>
<p><strong>进程控制块PCB</strong>：PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。</p>
<p>操作系统对进程进行<font color="red">管理工作所需的信息</font>都存在PCB中。</p>
<p>PCB的组成：<img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210201659.png"></p>
<p>一个<font color="red">进程实体(进程映像)</font>由<font color="red">PCB、 程序段、数据段</font>组成。</p>
<p><font color="red">进程</font>是<font color="red">动态</font>的， <font color="red">进程实体(进程映像)</font>是<font color="red">静态</font>的。</p>
<p>​    进程实体反映了进程在<font color="red">某一时刻</font>的状态。</p>
<p>进程实体的组成：<img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210202032.png"></p>
<p>PCB是给操作系统用的。</p>
<p>程序段、数据段是给进程自己用的，与进程自身的运行逻辑有关。</p>
<p> <font color="red">程序段、数据段、PCB</font>三部分组成了 <font color="red">进程实体(进程映像)</font>。</p>
<p>引入进程实体的概念后，可把进程定义为: <font color="red">进程</font>是进程实体的 <font color="red">运行过程</font>，是系统进行 <font color="red">资源分配</font>和 <font color="red">调度</font>的一个独立单位。</p>
<p>​                一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行。</p>
<p><strong>举例</strong>：同时挂三个QQ号，会对应三个QQ进程，它们 的PCB、数据段各不相同，但程序段的内容都是相同的(都是运行着相同的QQ程序)。</p>
<h2 id="1-3进程的特征"><a href="#1-3进程的特征" class="headerlink" title="1.3进程的特征"></a>1.3进程的特征</h2><p>程序是静态的，进程是动态的，相比于程序，进程拥有以下特征:</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210202428.png"></p>
<p>动态性是进程的<font color="red">最基本的特征</font>。</p>
<p>异步性会导致并发程序执行结果的不确定性。</p>
<p>​                                                                <strong><font size="15px">小结：</font></strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210202759.png"></p>
<h1 id="二，进程的状态与转换"><a href="#二，进程的状态与转换" class="headerlink" title="二，进程的状态与转换"></a>二，进程的状态与转换</h1><h2 id="2-1进程的状态"><a href="#2-1进程的状态" class="headerlink" title="2.1进程的状态"></a>2.1进程的状态</h2><p>​        进程正在被创建时，它的状态是“<font color="red">创建态</font>”，在这个阶段操作系统会为进程分配资源、初始化PCB。</p>
<p>​        当进程创建完成后，便进入‘‘ <font color="red">就绪态</font>”处于就绪态的进程已经具备运行条件,但由于没有空闲CPU，就暂时不能运行。</p>
<p>如果一个进程此时在CPU上运行，那么这个进程处于“ <font color="red">运行态</font>’。CPU会执行该进程对应的程序(执行指令序列)。</p>
<p>在进程运行的过程中，可能会请求等待某个事件的发生(如等待某种系统资源的分配，或者等待其他进程的响应)。在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入” <font color="red">阻塞态</font>”。当CPU空闲时，又会选择另-一个“就绪态”进程上CPU运行。</p>
<p>一个进程可以执行exit系统调用，请求操作系统终止该进程。此时该进程会进入“ <font color="red">终止态</font>”，操作系统会让该进程下CPU,并回收内存空间等资源，最后还要回收该进程的PCB。当终止进程的工作完成之后，这个进程就彻底消失了。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210204658.png"></p>
<p>进程的整个生命周期中，大部分时间都处于<font color="red">三种基本状态:运行态，就绪态，阻塞态</font>。</p>
<p>单CPU情况下，同一时刻只会有一个进程处于运行态，多核CPU情况下，可能有多个进程处于运行态。</p>
<p><font color="red">进程PCB中，会有-一个变量state来表示进程的当前状态</font>。如: 1表示创建态、2表示就绪态、3表示运行态….</p>
<p>为了对同一个状态下的各个进程进行统一一的管理，操作系统会将各个进程的PCB组织起来。</p>
<h2 id="2-2状态之间的转换"><a href="#2-2状态之间的转换" class="headerlink" title="2.2状态之间的转换"></a>2.2状态之间的转换</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210204615.png"></p>
<p>注意：运行态→阻塞态是一种进程自身做出的<font color="red">主动行为</font>。</p>
<p>​            阻塞态&gt;就绪态是不是 进程自身能控制的，是一种<font color="red">被动行为</font>。</p>
<p>**注意:**不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态(因为进入阻塞状态是进程主动请求的，必然需要进程在运行时才能发出这种请求).</p>
<h2 id="2-3进程的组织方式"><a href="#2-3进程的组织方式" class="headerlink" title="2.3进程的组织方式"></a>2.3进程的组织方式</h2><p><strong>链接方式</strong>：按照进程状态将PCB分为多个队列。操作系统持有指向各个队列的指针。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210205035.png"></p>
<p><strong>索引方式</strong>：根据进程状态的不同，建立几张索引表。操作系统持有指向各个索引表的指针<img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210205108.png"></p>
<p>​                                                                <strong><font size="15px">小结：</font></strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210205248.png"></p>
<h1 id="三，进程控制"><a href="#三，进程控制" class="headerlink" title="三，进程控制"></a>三，进程控制</h1><h2 id="3-1基本概念"><a href="#3-1基本概念" class="headerlink" title="3.1基本概念"></a>3.1基本概念</h2><p><strong>进程控制</strong>：主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销己有进程、实现进程状态转换等功能。总之：进程控制就是要<font color="red">实现进程状态转换</font>。</p>
<p><strong>进程控制的实现：</strong>用”原语“实现。原语的执行具有“原子性”，一气呵成。</p>
<p><strong>思考</strong>:为何进程控制(状态转换)的过程要‘一气呵成”?</p>
<p>​        如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作。</p>
<p><font color="red">原语</font>的执行具有<font color="red">原子性</font>，即执行过程只能- -气呵成，期间<font color="red">不允许被中断</font>。</p>
<p>可以用“<font color="red">关中断指令</font>”和“<font color="red">开中断指令</font>”这两个<font color="red">特权指令</font>实现原子性。</p>
<p>关/开中断的作用：CPU执行了<font color="red">关中断指令&lt;</font>之后，就不再例行检查中断信号，直到执行<font color="red">开中断指令</font>之后才会恢复检查。</p>
<h2 id="3-2相关原语"><a href="#3-2相关原语" class="headerlink" title="3.2相关原语"></a>3.2相关原语</h2><p><strong>创建原语</strong>：</p>
<p>​        作用：创建态 —&gt; 就绪态</p>
<p>​        功能：①申请空白PCB。②为新进程分配所需资源。③初始化PCB。④将PCB插入就绪队列。</p>
<p>​        引起进程创建的事件：</p>
<p>​                ①用户登录：分时系统中，用户登录成功，系统会建立为其建立-一个新的进程。</p>
<p>​                ②作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立-个新的进程。</p>
<p>​                ③提供服务：用户向操作系统提出某些请求时，会新建一个进程 处理该请求。</p>
<p>​                ④应用请求：由用户进程主动请求创建一个子进程。</p>
<p><strong>撤销原语</strong>：</p>
<p>​        作用：就绪态/阻塞态/运行态 —&gt; 终止态 —&gt; 无</p>
<p>​        功能：①从PCB集合中找到终止进程的PCB。</p>
<p>​                    ②若进程正在运行，立即剥夺CPU,将CPU分配给其他进程。</p>
<p>​                    ③终止其所有子进程。（进程间的关系是树形结构）</p>
<p>​                    ④将该进程拥有的所有资源归还给父进程或操作系统。</p>
<p>​                    ⑤删除PCB。</p>
<p>​        引起进程撤销的事件：①正常结束。(进程自已请求终止(exit系统调用))。</p>
<p>​                                                ②异常结束。(整数除以0、非法使用特权指令，然后被操作系统强行杀掉)。</p>
<p>​                                                ③外界干预。(Ctrl+Alt+delete，用户选择杀掉进程)。</p>
<p><strong>阻塞原语</strong>：</p>
<p>​        作用：运行态 —&gt; 阻塞态</p>
<p>​        功能：①找到要阻塞的进程对应的PCB。</p>
<p>​                    ②保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行。</p>
<p>​                    ③将PCB插入相应事件的等待队列。</p>
<p>​        引起进程阻塞的事件：①需要等待系统分配某种资源。</p>
<p>​                                               ②需要等待相互合作的其他进程完成工作。</p>
<p><strong>唤醒原语</strong>：</p>
<p>​        作用：阻塞态 —&gt; 运行态</p>
<p>​        功能：①在事件等待队列中找到PCB。</p>
<p>​                    ②将PCB从等待队列移除，设置进程为就绪态。</p>
<p>​                    ③将PCB插入就绪队列，等待被调度。</p>
<p>​        引起进程唤醒的事件：①等待的事件发生一因何事阻塞， 就应由何事唤醒。</p>
<p><font color="red" size="5px">阻塞原语和唤醒原语必须成对使用。</font></p>
<p><strong>切换原语</strong>：</p>
<p>​        作用：运行态 —&gt; 就绪态。就绪态 —&gt; 运行态</p>
<p>​        功能：①将运行环境信息(进程上下文)存入PCB。</p>
<p>​                    ②PCB移入相应队列。</p>
<p>​                    ③选择另一个进程执行，并更新其PCB。</p>
<p>​                    ④根据PCB恢复新进程所需的运行环境。</p>
<p>​        引起进程切换的事件：①当前进程时间片到。</p>
<p>​                                              ②有更高优先级的进程到达。</p>
<p>​                                              ③当前进程主动阻塞。</p>
<p>​                                              ④当前进程终止。</p>
<p>​                                                                <strong><font size="15px">小结：</font></strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201210212742.png"></p>
<h1 id="四，进程通信"><a href="#四，进程通信" class="headerlink" title="四，进程通信"></a>四，进程通信</h1><p>顾名思义，进程通信就是指进程之间的信息交换。</p>
<p>进程是分配系统资源的单位(包括内存地址空间)，因此<font color="red">各进程</font>拥有的<font color="red">内存地址空间相互独立</font>。</p>
<p>为了保证安全，<font color="red">一个进程不能直接访问另一个进程的地址空间</font>。</p>
<p>但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。</p>
<p>进程通信的方式：共享存储，消息传递，管道通信。</p>
<h2 id="4-1共享存储"><a href="#4-1共享存储" class="headerlink" title="4.1共享存储"></a>4.1共享存储</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211062820.png"></p>
<p>两个进程对共享空间的访问必须是<font color="red">互斥</font>的(互斥访问通过操作系统提供的工具实现)。</p>
<p>操作系统只负责提供共享空间和同步互斥工具(如P、V操作)。</p>
<p>gnn共享存储又分为：基于数据结构的共享；基于存储区的共享。</p>
<p>**基于数据结构的共享:**比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种<font color="red">低级通信</font>方式。</p>
<p><strong>基于存储区的共享</strong>:在内存中画出一-块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种<font color="red">高级通信</font>方式。</p>
<h2 id="4-2管道通信"><a href="#4-2管道通信" class="headerlink" title="4.2管道通信"></a>4.2管道通信</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211063138.png"></p>
<p>“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。</p>
<p><strong>特点：</strong></p>
<ol>
<li>管道只能采用<font color="red">半双工通信</font>，某一时间段内只能实现单向的传输。如果要实现<font color="red">双向同时通信</font>，则<font color="red">需要设置两个管道</font>。 </li>
<li>各进程要<font color="red">互斥</font>地访问管道。</li>
<li>数据以字符流的形式写入管道，当<font color="red">管道写满</font>时，<font color="red">写进程</font>的write()系统调用将被<font color="red">阻塞</font>，等待读进程将数据取走。当读进程将数据全部取走后，<font color="red">管道变空</font>，此时<font color="red">读进程</font>的read()系统调用将被<font color="red">阻塞</font>。</li>
<li>如果<font color="red">没写满</font>，就不允许读。如果<font color="red">没读空</font>，就不允许写。</li>
<li>数据一且被读出，就从管道中被拋弃，这就意味着<font color="red">读进程最多只能有一个</font>，否则可能会有读错数据的情况。</li>
</ol>
<h2 id="4-3消息传递"><a href="#4-3消息传递" class="headerlink" title="4.3消息传递"></a>4.3消息传递</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211063603.png"></p>
<p>进程间的数据交换以<font color="red">格式化的消息(Message) </font>为单位。进程通过操作系统提供的“<font color="red">发送消息/接收消息</font>”两个原语进行数据交换。</p>
<p>消息头包括:发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息(计算机网络中发送的“报文”其实就是一种格式化的消息)。</p>
<p>消息传递分为：直接通信方式；间接通信方式。</p>
<p><strong>直接通信方式</strong>：消息直接挂到接收进程的消息缓冲队列上。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211063809.png"></p>
<p><strong>间接通信方式：</strong>消息要先发送到中间实体(信箱)中，因此也称为”信箱通信方式“。例如：计算机网络中的电子邮件系统。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211064008.png"></p>
<p>​                                                                <strong><font size="15px">小结：</font></strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211064111.png"></p>
<h1 id="五，线程概念"><a href="#五，线程概念" class="headerlink" title="五，线程概念"></a>五，线程概念</h1><h2 id="5-1线程的基本概念"><a href="#5-1线程的基本概念" class="headerlink" title="5.1线程的基本概念"></a>5.1线程的基本概念</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211064902.png"></p>
<p>可以把线程理解为“轻量级进程”。</p>
<p><font color="red">线程</font>是一个<font color="red">基本的CPU执行单元</font>，也是<font color="red">程序执行流的最小单位</font>。</p>
<p>引入线程之后，不仅是进程之间可以并发，进程内的<font color="red">各线程之间也可以并发</font>，从而进一步<font color="red">提升了系统的并发度</font>，使得-一个进程内也可以并发处理各种任务( 如QQ视频、文字聊天、传文件)。</p>
<p>引入线程后，<font color="red">进程</font>只作为<font color="red">除CPU之外的系统资源的分配单元</font>(如打印机、内存地址空间等都是分配给进程的)</p>
<h2 id="5-2引入线程后的变化"><a href="#5-2引入线程后的变化" class="headerlink" title="5.2引入线程后的变化"></a>5.2引入线程后的变化</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211065340.png"></p>
<h2 id="5-3线程的属性"><a href="#5-3线程的属性" class="headerlink" title="5.3线程的属性"></a>5.3线程的属性</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211065610.png"></p>
<h1 id="六，线程的实现方式"><a href="#六，线程的实现方式" class="headerlink" title="六，线程的实现方式"></a>六，线程的实现方式</h1><h2 id="6-1线程的实现方式"><a href="#6-1线程的实现方式" class="headerlink" title="6.1线程的实现方式"></a>6.1线程的实现方式</h2><p><strong>用户级线程：</strong></p>
<p>​    历史背景:早期的操作系统(如:早期Unix) 只支持进程，不支持线程。当时的“线程”是由线程库实现的</p>
<p>​    示意：<img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211114714.png"></p>
<p>​    问题：</p>
<p>1.线程的管理工作由谁来完成?</p>
<p>​    答：用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责(包括线程切换)。</p>
<p>2.线程切换是否需要CPU变态?</p>
<p>​    答：用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</p>
<p>3.操作系统是否能意识到用户级线程的存在?</p>
<p>​    答：在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程”。</p>
<p>4.这种线程的实现方式有什么优点和缺点?</p>
<p>​    答：优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。</p>
<p>​            缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</p>
<p><strong>内核级线程：</strong></p>
<p>内核级线程( Kernel-Level Thread, KLT,又称“内核支持的线程:“由操作系统支持的线程个件。</p>
<p>示意：<img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211115156.png"></p>
<p>1.线程的管理工作由谁来完成?</p>
<p>​    答：1.内核级线程的管理工作由操作系统内核完成。</p>
<p>2.线程切换是否需要CPU变态?</p>
<p>​    答：2.线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</p>
<p>3.操作系统是否能意识到内核级线程的存在?</p>
<p>​    答：3.操作系统会为每个内核级线程建立相应的TCB (Thread Control Block,线程控制块) , 通过TCB对线程进行管理。“内核级线程” 就是“从操作系统内核视角看能看到的线程。</p>
<p>4.这种线程的实现方式有什么优点和缺点?</p>
<p>​    答：优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机.上并行执行。</p>
<p>​            缺点: - 一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p>
<h2 id="6-2多线程模型"><a href="#6-2多线程模型" class="headerlink" title="6.2多线程模型"></a>6.2多线程模型</h2><p><strong>一对一模型</strong>：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201219171331.png"></p>
<p>优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机_上并行执行。</p>
<p>缺点:一个用户进程会占用多个内核级线程,线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p>
<p><strong>多对一模型</strong>：多个用户级线程映射到一个内核级线程。且一一个进程只被分配-一个内核级线程。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211143409.png"></p>
<p>优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。</p>
<p>缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</p>
<p><font color="blue">重点重点重点</font>:操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</p>
<p><strong>多对多模型</strong>： n用户及线程映射到m个内核级线程(n&gt;=m)。每个用户进程对应m个内核级线程。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211143632.png"></p>
<p>克服了多对一-模型并发度不高的缺点(一个阻塞全体阻塞)，又克服了一对- -模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>
<p>可以这么理解:用户级线程是“代码逻辑”的载体。</p>
<p>​                        内核级线程是“运行机会”的载体。</p>
<p><font color="red">内核级线程才是处理机分配的单位</font>。例如:多核CPU环境下，左边这个进程最多能被分配两个核。</p>
<p>一段“代码逻辑”只有获得了“运行机会”才能被CPU执行。</p>
<p>内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞。</p>
<p>​                                                                <strong><font size="15px">小结：</font></strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201211114525.png"></p>
<h1 id="七，处理机调度"><a href="#七，处理机调度" class="headerlink" title="七，处理机调度"></a>七，处理机调度</h1><h2 id="7-1基本概念"><a href="#7-1基本概念" class="headerlink" title="7.1基本概念"></a>7.1基本概念</h2><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定<font color="red">某种规则</font>来决定处理这些任务的<font color="red">顺序</font>，这就是<font color="red">“调度”</font>研究的问题。</p>
<p>**作业:**一个具体的任务</p>
<p>用户向系统提交一个作业≈用户让操作系统启动-一个程序(来处理一个具体的任务)</p>
<h2 id="7-2高级调度"><a href="#7-2高级调度" class="headerlink" title="7.2高级调度"></a>7.2高级调度</h2><p>**高级调度(作业调度)**：按一定的原则从<font color="red">外存</font>的作业后备队列中挑选-一个<font color="red">作业</font>调入<font color="red">内存</font>，并创建进程。，每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212084518.png"></p>
<h2 id="7-3中级调度"><a href="#7-3中级调度" class="headerlink" title="7.3中级调度"></a>7.3中级调度</h2><p>内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。</p>
<p>暂时调到外存等待的进程状态为<font color="red">挂起状态</font>。被挂起的进程PCB会被组织成<font color="red">挂起队列</font>。</p>
<p>**中级调度(内存调度)**：按照某种策略决定将哪个处于挂起状态的<font color="red">进程</font>重新调入<font color="red">内存</font>。</p>
<p>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要<font color="red">比高级调度更高</font>。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212084842.png"></p>
<h2 id="7-4低级调度"><a href="#7-4低级调度" class="headerlink" title="7.4低级调度"></a>7.4低级调度</h2><p>**低级调度(进程调度/处理机调度)**：按照某种策略从就绪队列中选取-一个<font color="red">进程</font>，将<font color="red">处理机</font>分配给它。</p>
<p>进程调度是操作系统中<font color="red">最基本的一种调度</font>，在–般的操作系统中都必须配置进程调度。</p>
<p>进程调度的<font color="red">频率很高</font>，一般几十毫秒-一次。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212084849.png"></p>
<h2 id="7-5三层调度的区别"><a href="#7-5三层调度的区别" class="headerlink" title="7.5三层调度的区别"></a>7.5三层调度的区别</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212085335.png"></p>
<h2 id="7-6七状态模型"><a href="#7-6七状态模型" class="headerlink" title="7.6七状态模型"></a>7.6七状态模型</h2><p>暂时调到外存等待的进程状态为<font color="red">挂起状态(挂起态，suspend)</font>。</p>
<p>挂起态又可以进一-步细分为<font color="red">就绪挂起、阻塞挂起</font>两种状态。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212085054.png"></p>
<p>注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是<font color="red">将进程映像调到外存</font>去了，而阻塞态下进程<font color="red">映像还在内存中</font>。</p>
<p>有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p>
<p>​                                                                <strong><font size="15px">小结：</font></strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212085413.png"></p>
<h1 id="八，进程调度"><a href="#八，进程调度" class="headerlink" title="八，进程调度"></a>八，进程调度</h1><h2 id="8-1进程调度的时机"><a href="#8-1进程调度的时机" class="headerlink" title="8.1进程调度的时机"></a>8.1进程调度的时机</h2><p>进程调度(低级调度)：就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p>
<p>需要进程调度与切换的时机：<img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212090439.png"></p>
<p>禁止进程调度与切换的时机：<img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212090501.png"></p>
<p><font color="red">注意：</font></p>
<p>​            进程在<font color="red">操作系统内核程序临界区</font>中<font color="red">不能</font>进行调度与切换。  √</p>
<p>​            进程处于<font color="red">临界区</font>时<font color="red">不能</font>进行处理机调度。   ×</p>
<p>**临界资源:**一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。</p>
<p><strong>临界区</strong>:访问临界资源的那段代码。</p>
<p><font color="red">内核程序临界区</font>一般是用来访问<font color="red">某种内核数据结构</font>的，比如进程的就绪队列(由各就绪进程的PCB组成)</p>
<p>例如：</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212091136.png"></p>
<p>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界期间不能进行调度 与切换。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212091237.png"></p>
<p>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。</p>
<h2 id="8-2进程调度的切换与过程"><a href="#8-2进程调度的切换与过程" class="headerlink" title="8.2进程调度的切换与过程"></a>8.2进程调度的切换与过程</h2><p>“狭义的进程调度”与“进程切换”的区别:</p>
<p><strong>狭义的进程调度</strong>：指的是从就绪队列中<font color="red">选中一个要运行的进程</font>。(这个进程可以是刚刚被暂停执行的进程，也可能是<font color="red">另一个进程</font>，后-种情况就需要<font color="red">进程切换</font>)。</p>
<p><strong>进程切换</strong>：是指一个进程让出处理机，由另一个进程占用处理机的过程。</p>
<p><strong>广义的进程调度</strong>：包含了选择-一个进程和进程切换两个步骤。</p>
<p>进程切换的过程主要完成了：</p>
<p>​        1.对原来运行进程各种数据的保存。</p>
<p>​        2.对新的进程各种数据的恢复(如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)。</p>
<p>注意:<font color="red">进程切换是有代价的</font>，因此如果<font color="red">过于频繁</font>的进行进程<font color="red">调度、切换</font>，必然会使整个<font color="red">系统的效率降低</font>,使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
<h2 id="8-3进程调度的方式"><a href="#8-3进程调度的方式" class="headerlink" title="8.3进程调度的方式"></a>8.3进程调度的方式</h2><p><strong>非剥夺调度方式</strong>，又称<strong>非抢占方式</strong>。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</p>
<p>​        实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。</p>
<p><strong>剥夺调度方式</strong>，又称<strong>抢占方式</strong>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</p>
<p>​        可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能(通过时钟中断)。适合于分时操作系统、实时操作系统。</p>
<p>​                                                                <strong><font size="15px">小结：</font></strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212094214.png"></p>
<h1 id="九，调度算法的评价指标"><a href="#九，调度算法的评价指标" class="headerlink" title="九，调度算法的评价指标"></a>九，调度算法的评价指标</h1><h2 id="9-1CPU利用率"><a href="#9-1CPU利用率" class="headerlink" title="9.1CPU利用率"></a>9.1CPU利用率</h2><p>由于早期的CPU造价极其昂贵，因此人们会希望让CPU尽可能多地工作</p>
<p><strong>CPU利用率</strong>:指CPU“忙碌”的时间占总时间的比例。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212095308.png"></p>
<h2 id="9-2系统吞吐量"><a href="#9-2系统吞吐量" class="headerlink" title="9.2系统吞吐量"></a>9.2系统吞吐量</h2><p>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业。</p>
<p><strong>系统吞吐量</strong>:单位时间内完成作业的数量。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212095425.png"></p>
<h2 id="9-3周转时间"><a href="#9-3周转时间" class="headerlink" title="9.3周转时间"></a>9.3周转时间</h2><p>对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。</p>
<p><strong>周转时间</strong>：是指从<font color="red">作业被提交给系统开始</font>，到<font color="red">作业完成为止</font>的这段时间间隔。</p>
<p>它包括四个部分:作业在外存后备队列上等待作业调度(高级调度)的时间、进程在就绪队列上等待进程调度(低级调度)的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212095620.png"></p>
<p><strong>带权周转时间：</strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212095731.png"></p>
<h2 id="9-4等待时间"><a href="#9-4等待时间" class="headerlink" title="9.4等待时间"></a>9.4等待时间</h2><p>计算机的用户希望自己的作业尽可能少的等待处理机。</p>
<p><strong>等待时间</strong>:指进程/作业<font color="red">处于等待处理机状态时间之和</font>，等待时间越长，用户满意度越低。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212095931.png"></p>
<p>对于<font color="red">进程</font>来说，等待时间就是指进程建立后<font color="red">等待被服务的时间之和</font>，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</p>
<p>对于<font color="red">作业</font>来说，不仅要考虑<font color="red">建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</font>。</p>
<p>一个作业总共需要被CPU服务多久，被I/0设备服务多久一-般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“<font color="red">平均等待时间</font>”来评价整体性能。</p>
<h2 id="9-5响应时间"><a href="#9-5响应时间" class="headerlink" title="9.5响应时间"></a>9.5响应时间</h2><p>对于计算机用户来说，会希望自己的提交的请求(比如通过键盘输入了一个调试命令)尽早地开始被系统服务、回应。</p>
<p><strong>响应时间</strong>:指从用户提交请求到首次产生响应所用的时间。</p>
<p>​                                                                <strong><font size="15px">小结：</font></strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212100106.png"></p>
<h1 id="十，调度算法"><a href="#十，调度算法" class="headerlink" title="十，调度算法"></a>十，调度算法</h1><h2 id="10-1-先来先服务-FCFS"><a href="#10-1-先来先服务-FCFS" class="headerlink" title="10.1 先来先服务(FCFS)"></a>10.1 先来先服务(FCFS)</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212105645.png"></p>
<p><strong>举例：</strong><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212105648.png"></p>
<h2 id="10-2-短作业优先-SJF"><a href="#10-2-短作业优先-SJF" class="headerlink" title="10.2 短作业优先(SJF)"></a>10.2 短作业优先(SJF)</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212105654.png"></p>
<p><strong>非抢占式的举例：</strong><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212105658.png"></p>
<p><strong>抢占式的举例：</strong><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212105703.png"></p>
<p><strong>细节问题：</strong></p>
<p>1.如果题目中<font color="red">未特别说明</font>，所提到的“短作业/进程优先算法”<font color="red">默认是非抢占式的</font>。</p>
<p>2.很多书上都会说“SJF调度算法的平均等待时间、平均周转时间最少”。</p>
<p>严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少</p>
<p>应该加上一一个条件“在<font color="red">所有进程同时可运行</font>时，采用SJF调度算法的平均等待时间、平均周转时间最少”;</p>
<p>或者说“在<font color="red">所有进程都几乎同时到达</font>时，采用SJF调度算法的平均等待时间、平均周转时间最少”;</p>
<p>如果不加。上述前提条件，则应该说“<font color="red">抢占式</font>的短作业/进程优先调度算法(<font color="red">最短剩余时间优先, SRNT</font>算法)的平均等待时间、平均周转时间最少”。</p>
<p>3.虽然严格来说， SJF的平均等待时间、平均周转时间并不- - 定最少，但相比于其他算法(如FCFS)，SJF依然可以获得较少的平均等待时间、平均周转时间</p>
<p>4.如果选择题中遇到“SJIF算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项。</p>
<h2 id="10-4-高响应比优先-HRRN"><a href="#10-4-高响应比优先-HRRN" class="headerlink" title="10.4 高响应比优先(HRRN)"></a>10.4 高响应比优先(HRRN)</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212110033.png"></p>
<p><strong>举例：</strong><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212110046.png"></p>
<p>​                                                                <strong><font size="15px">小结：</font></strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212110148.png"></p>
<p>注：这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于<font color="red">早期的批处理系统</font>，当然， FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。</p>
<h2 id="10-4-时间片轮转-RR"><a href="#10-4-时间片轮转-RR" class="headerlink" title="10.4 时间片轮转(RR)"></a>10.4 时间片轮转(RR)</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212140802.png"></p>
<p><strong>例题：</strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212140944.png"></p>
<p><strong>补充：</strong></p>
<p>​        如果时间片太大，使得每个进程都可以在-一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</p>
<p>​        另一-方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</p>
<p>​        一般来说时间片时要让切换进程的开销占比不超过1%。</p>
<h2 id="10-5-优先级调度"><a href="#10-5-优先级调度" class="headerlink" title="10.5 优先级调度()"></a>10.5 优先级调度()</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212141322.png"></p>
<p><strong>非抢占式的例题：</strong><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212141243.png"></p>
<p><strong>抢占式的例题：</strong><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212141248.png"></p>
<p><strong>补充：</strong></p>
<p>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置。</p>
<p>根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。</p>
<p>​        **静态优先级:**创建进程时确定，之后一直不变 。</p>
<p>​        **动态优先级:**创建进程时有一个初始值，之后会根据情况动态地调整优先级。</p>
<p>如何合理地设置各类进程的优先级?</p>
<p>​    通常：系统进程优先级高于用户进程。前台进程优先级高于后台进程。操作系统更偏好I/O型进程(或称/0繁忙型进程)。</p>
<p>​    注:与I/0型进 程相对的是计算型进程( 或称CPU繁忙型进程)。</p>
<p>如果采用的是动态优先级，什么时候应该调整?</p>
<p>​        可以从追求公平、提升资源利用率等角度考虑。</p>
<p>​        如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级。</p>
<p>​        如果某进程占用处理机运行了很长时间，则可适当降低其优先级。</p>
<p>​        如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</p>
<h2 id="10-6-多级反馈队列调度"><a href="#10-6-多级反馈队列调度" class="headerlink" title="10.6 多级反馈队列调度()"></a>10.6 多级反馈队列调度()</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212141733.png"></p>
<p><strong>例题：</strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212141904.png"></p>
<p>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。</p>
<p>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下- -级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾。</p>
<p>只有第k级队列为空时，，才会为k+1级队头的进程分配时间片。</p>
<p>被抢占处理机的进程重新放回原队列队尾。</p>
<p>​                                                                <strong><font size="15px">小结：</font></strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212142133.png"></p>
<p>注:比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统(包括分时操作系统、实时操作系统等)更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。(比如UNIX使用的就是多级反馈队列调度算法)。</p>
<h1 id="十一，进程的同步和互斥"><a href="#十一，进程的同步和互斥" class="headerlink" title="十一，进程的同步和互斥"></a>十一，进程的同步和互斥</h1><h2 id="11-1进程同步"><a href="#11-1进程同步" class="headerlink" title="11.1进程同步"></a>11.1进程同步</h2><p>知识点回顾:进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212143056.png"></p>
<p>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据&gt;读数据”的顺序来执行的。</p>
<p>如何解决这种异步问题，就是“ 进程同步”所讨论的内容。</p>
<p><font color="red">同步</font>亦称<font color="red">直接制约关系</font>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上<font color="red">协调</font>它们的<font color="red">工作次序</font>而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<h2 id="11-2进程互斥"><a href="#11-2进程互斥" class="headerlink" title="11.2进程互斥"></a>11.2进程互斥</h2><p>进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源(比如内存，又比如打印机、摄像头这样的/0设备)。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212143338.png"></p>
<p>我们把<font color="red">一个时间段内只允许一个进程使用</font>的资源称为<font color="red">临界资源</font>。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p>
<p>对临界资源的访问，必须<font color="red">互斥</font>地进行。互斥，亦称<font color="red">间接制约关系</font>。<font color="red">进程互斥</font>指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</p>
<p>对临界资源的互斥访问，可以在<strong>逻辑上分为如下四个部分:</strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212143541.png"></p>
<p>注意:临界区是进程中访问临界资源的代码段。</p>
<p>​        进入区和退出区是负责实现互斥的代码段。</p>
<p>​        临界区也可称为“临界段”</p>
<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，<strong>需要遵循以下原则:</strong></p>
<p>​        1.**<font color="red">空闲让进</font>**。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区;</p>
<p>​        2.**<font color="red">忙则等待</font>**。当已有进程进入临界区时，其他试图进入临界区的进程必须等待; .</p>
<p>​        3.**<font color="red">有限等待</font>**。对请求访问的进程，应保证能在有限时间内进入临界区( 保证不会饥饿) ;</p>
<p>​        4.**<font color="red">让权等待</font>**。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</p>
<p>​                                                                <strong><font size="15px">小结：</font></strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212142914.png"></p>
<h1 id="十二，进程互斥的软件实现方法"><a href="#十二，进程互斥的软件实现方法" class="headerlink" title="十二，进程互斥的软件实现方法"></a>十二，进程互斥的软件实现方法</h1><h2 id="12-1-单标志法"><a href="#12-1-单标志法" class="headerlink" title="12.1 单标志法"></a>12.1 单标志法</h2><p><strong>算法思想</strong>：两个进程在<font color="red">访问完临界区后</font>会把使用临界区的权限转交给另-一个进程。也就是说<font color="red">每个进程进入临界区的权限只能被另一个进程赋予</font>。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212145904.png"></p>
<p>turn的初值为0,即刚开始只允许0号进程进入临界区。</p>
<p>若P1先上处理机运行，则会一直卡在⑤。直到P1的时间片用完，发生调度，切换PO.上处理机运行。</p>
<p>代码①不会卡住PO, PO可以正常访问临界区，在PO访问临界区期间即时切换回P1, P1依然会卡在⑤。</p>
<p>只有PO在退出区将turn改为1后，P1才能进入临界区。</p>
<p>因此，该算法可以实现“<font color="red">同一时刻最多只允许一个进程访问临界区</font>”。</p>
<p>​            <font color="red">单标志法</font>存在的主要问题是：<font color="red">违背”空闲让进“原则</font>。</p>
<h2 id="12-2-双标志先检查"><a href="#12-2-双标志先检查" class="headerlink" title="12.2 双标志先检查"></a>12.2 双标志先检查</h2><p><strong>算法思想</strong>：设置一个布尔型数组flag[]，数组中各个元素用来<font color="red">标记各进程想进入临界区的意愿</font>，比如“flag[0] = ture”意味着0号进程PO现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true,之后开始访问临界区。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212150337.png"></p>
<p>若按照①⑤②⑥3…的顺序执行，PO 和P1将会同时访问临界区。</p>
<p>因此，双标志先检查法的<font color="red">主要问题</font>是：<font color="red">违反“忙则等待”原则</font>。</p>
<p>原因在于，<font color="red">进入区</font>的“检查”和“上锁”<font color="red">两个处理不是一气呵成的</font>。“检查” 后，“上锁”前可能发生进程切换。</p>
<h2 id="12-3-双标志后检查"><a href="#12-3-双标志后检查" class="headerlink" title="12.3 双标志后检查"></a>12.3 双标志后检查</h2><p><strong>算法思想</strong>：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212150631.png"></p>
<p>若按照①⑤②⑥…的顺序执行，PO和P1将都无法进入临界区。</p>
<p>因此，双标志后检查法虽然<font color="red">解决了“忙则等待”</font>的问题，但是<font color="red">又违背了“空闲让进”和“有限等待”原则</font>，会因各进程都长期无法访问临界资源而<font color="red">产生“饥饿”</font>现象。</p>
<h2 id="12-4-Peterson算法"><a href="#12-4-Peterson算法" class="headerlink" title="12.4 Peterson算法"></a>12.4 Peterson算法</h2><p>算法思想:结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”(谦让)。, 做一个有礼貌的进程。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212150840.png"></p>
<p>Peterson算法用软件方法解决了进程互斥问题，<font color="red">遵循了空闲让进、忙则等待、有限等待三个原则</font>，但是依然<font color="red">未遵循让权等待</font>的原则。</p>
<p>​                                                                <strong><font size="15px">小结：</font></strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212151023.png"></p>
<h1 id="十三，进程互斥的硬件实现方法"><a href="#十三，进程互斥的硬件实现方法" class="headerlink" title="十三，进程互斥的硬件实现方法"></a>十三，进程互斥的硬件实现方法</h1><h2 id="13-1-中断屏蔽方法"><a href="#13-1-中断屏蔽方法" class="headerlink" title="13.1 中断屏蔽方法"></a>13.1 中断屏蔽方法</h2><p>利用“开/关中断指令”实现(与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况)。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212155414.png"></p>
<p><strong>优点</strong>：简单、高效。</p>
<p><strong>缺点</strong>：不适用于多处理机;只适用于操作系统内核进程，不适用于用户进程(因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)。</p>
<h2 id="13-2-TestAndSet（TS指令-TSL指令）"><a href="#13-2-TestAndSet（TS指令-TSL指令）" class="headerlink" title="13.2 TestAndSet（TS指令/TSL指令）"></a>13.2 TestAndSet（TS指令/TSL指令）</h2><p>简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令。</p>
<p>TSL指令是用硬件实现的，执行的过程不允许被中断，只能- -气呵成。以下是用C语言描述的逻辑。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212155635.png"></p>
<p>若刚开始lock是false，则TSL返回的old 值为false, while 循环条件不满足，直接跳过循环，进入临界区。若刚开始lock是true，则执行TLS后old返回的值为true, while 循环条件满足，会-直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p>
<p>相比软件实现方法，TSL 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</p>
<p><strong>优点</strong>：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞;适用于多处理机环境。</p>
<p><strong>缺点</strong>：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致”忙等“。</p>
<h2 id="13-3-Swap指令-XCHG指令"><a href="#13-3-Swap指令-XCHG指令" class="headerlink" title="13.3 Swap指令(XCHG指令)"></a>13.3 Swap指令(XCHG指令)</h2><p>有的地方也叫Exchange指令，或简称XCHG指令。.</p>
<p>Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212155841.png"></p>
<p>逻辑.上来看Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁(记录在old变量上)，再将.上锁标记lock设置为true，最后检查old，如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p>
<p><strong>优点</strong>:实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞;适用于多处理机环境。</p>
<p><strong>缺点</strong>:不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行Swap指令，从而导致“忙等”</p>
<p>​                                                                <strong><font size="15px">小结：</font></strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212155910.png"></p>
<h1 id="十四，信号量机制"><a href="#十四，信号量机制" class="headerlink" title="十四，信号量机制"></a>十四，信号量机制</h1><p>用户进程可以通过使用操作系统提供的<font color="red">一对原语</font>来对<font color="red">信号量</font>进行操作，从而很方便的实现了进程互斥、进程同步。</p>
<p><font color="red"><strong>信号量</strong></font>：其实就是一个变量(<font color="blue">可以是一个整数，也可以是更复杂的记录型变量</font>)，可以用一个信号量来<font color="red">表示系统中某种资源的数量</font>，比如:系统中只有一-台打印机，就可以设置一个初值为1的信号量。</p>
<p>**<font color="red">原语</font>**：是一种特殊的程序段，其<font color="red">执行只能一气呵成，不可被中断</font>。原语是由<font color="red">关中断/开中断指令</font>实现的。软件解决方案的主要问题是由“进入区的各种操作无法- -气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</p>
<p><strong>一对原语</strong>：<font color="red">wait(S)</font>原语和<font color="red">signal(S)</font>原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal,括号里的<font color="red">信号量S</font>其实就是函数调用时传入的一一个参数。</p>
<p>wait、signal原语常<font color="red">简称为P、V操作</font>(来自荷兰语proberen和verhogen)。因此，做题的时候常把wait(S)、sigal(S) 两个操作分别写为<font color="red">P(S)、V(S)</font>。</p>
<h2 id="14-1-整形信号量"><a href="#14-1-整形信号量" class="headerlink" title="14.1 整形信号量"></a>14.1 整形信号量</h2><p><strong>整形信号量</strong>：用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</p>
<p>与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作。</p>
<p>Eg:某计算机系统中有一台打印机…</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212161122.png"></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212161254.png"></p>
<p><strong>作用</strong>：检查”和“上锁”一气呵成，避免了并发、异步导致的问题。</p>
<p><strong>存在的问题</strong>:不满足“让权等待”原则，会发生“忙等”。</p>
<h2 id="14-2-记录型信号量"><a href="#14-2-记录型信号量" class="headerlink" title="14.2 记录型信号量"></a>14.2 记录型信号量</h2><p><strong>记录型信号量</strong>：即用记录型数据结构表示的信号量。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212161503.png"></p>
<p>在考研题目中wait(S)、sinal(S) 也可以记为P(S)、V(S),这对原语可用于<font color="red">实现系统资源的“申请”和“释放”</font>。</p>
<p><font color="red">S.value的初值</font>表示系统中<font color="red">某种资源的数目</font>。</p>
<p>对信号量S的<font color="red">一次P操作</font>意味着进程<font color="red">请求一个单位的该类资源</font>，因此需要执行S.value–， 表示资源数减1，当S.value&lt;0时表示该类资源已分配完毕，因此进程应<font color="red">调用block原语进行自我阻塞</font>(当前运行的进程从<font color="red">运行态→阻塞态</font>)，主动放弃处理机，并插入该类资源的等待队列S.L中。可见，该机制<font color="red">遵循了“让权等待”原则</font>，不会出现“忙等”现象。</p>
<p>对信号量S的<font color="red">一次V操作</font>意味着进程<font color="red">释放一个单位的该类资源</font>，因此需要执行S.value++，表示资源数加1,若加1后仍是S.value &lt;= 0，表示依然有进程在等待该类资源，因此应<font color="red">调用wakeup原语唤醒等待队列中的第一个进程</font>(被唤醒进程从<font color="red">阻塞态&gt;就绪态</font>)。</p>
<p>​                                                                <strong><font size="15px">小结：</font></strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212162133.png"></p>
<h1 id="十五，信号量机制的使用"><a href="#十五，信号量机制的使用" class="headerlink" title="十五，信号量机制的使用"></a>十五，信号量机制的使用</h1><h2 id="15-1-实现进程互斥"><a href="#15-1-实现进程互斥" class="headerlink" title="15.1 实现进程互斥"></a>15.1 实现进程互斥</h2><p>理解:信号量mutex表示“进入临界区的名额”。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212173644.png"></p>
<h2 id="15-2-实现进程同步"><a href="#15-2-实现进程同步" class="headerlink" title="15.2 实现进程同步"></a>15.2 实现进程同步</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212173824.png"></p>
<h2 id="15-3-实现进程前驱关系"><a href="#15-3-实现进程前驱关系" class="headerlink" title="15.3 实现进程前驱关系"></a>15.3 实现进程前驱关系</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212173828.png"></p>
<p>​                                                                <strong><font size="15px">小结：</font></strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212173907.png"></p>
<h1 id="十六，生产者消费者问题"><a href="#十六，生产者消费者问题" class="headerlink" title="十六，生产者消费者问题"></a>十六，生产者消费者问题</h1><p><strong>题目分析：</strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212174117.png"></p>
<p><strong>实现：</strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212174234.png"></p>
<p><strong>修改：</strong>  </p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212174326.png"></p>
<p>​                                                                <strong><font size="15px">小结：</font></strong></p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201212174402.png"></p>
<h1 id="十七，多生产者和多消费者"><a href="#十七，多生产者和多消费者" class="headerlink" title="十七，多生产者和多消费者"></a>十七，多生产者和多消费者</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223164347.png"></p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223164427.png"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223164525.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223164628.png"></p>
<h1 id="十八，管程"><a href="#十八，管程" class="headerlink" title="十八，管程"></a>十八，管程</h1><h2 id="18-1-管程的定义和基本特征"><a href="#18-1-管程的定义和基本特征" class="headerlink" title="18.1 管程的定义和基本特征"></a>18.1 管程的定义和基本特征</h2><ul>
<li>管程是一种特殊的软件模块，有这些部分组成: .<ul>
<li>1.局部于管程的共享数据结构说明;</li>
<li>2.对该数据结构进行操作的–组过程;</li>
<li>3.对局部于管程的共享数据设置初始值的语句;.</li>
<li>4.管程有一个名字。</li>
</ul>
</li>
<li>管程的基本特征:<ul>
<li>1.局部于管程的数据只能被局部于管程的过程所访问;</li>
<li>2.一个进程只有通过调用管程内的过程才能进入管程访问共享数据;</li>
<li>3.每次仅允许一个进程在管程内执行某个内部过程。</li>
</ul>
</li>
<li>引入管程的目的无非就是要更方便地实现进程互斥和同步。<ul>
<li>1.需要在管程中定义共享数据(如生产者消费者问题的缓冲区)</li>
<li>2.需要在管程中定义用于访问这些共享数据的“入口”–其实就是- -些函数(如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品)</li>
<li>3.只有通过这些特定的“入口”才能访问共享数据</li>
<li>4.管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或线程进入(如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意:这种互斥特性是由编译器负责实现的，程序员不用关心)</li>
<li>5.可在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让-一个进程或线程在条件变量上等待(此时，该进程应先释放管程的使用权，也就是让出“入口”) ;可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。</li>
</ul>
</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223181258.png"></p>
<h1 id="第十九节：死锁"><a href="#第十九节：死锁" class="headerlink" title="第十九节：死锁"></a>第十九节：死锁</h1><h2 id="19-1-死锁的概念"><a href="#19-1-死锁的概念" class="headerlink" title="19.1 死锁的概念"></a>19.1 死锁的概念</h2><ul>
<li>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”发生死锁后若无外力干涉，这些进程都将无法向前推进。</li>
<li>死锁:各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li>
<li>饥饿:由于长期得不到想要的资源，某进程无法向前推进的现象。比如:在短进程优先(SPF) 算法中，若有源源不断的短进程到来，则长进程将一直 得不到处理机，从而发生长进程“饥饿”</li>
<li>死循环:某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223182852.png"></p>
<h2 id="19-2-死锁产生的必要条件"><a href="#19-2-死锁产生的必要条件" class="headerlink" title="19.2 死锁产生的必要条件"></a>19.2 死锁产生的必要条件</h2><ul>
<li>产生死锁必须同时满足一下四个条件， 只要其中任一条件不成立， 死锁就不会发生。<ul>
<li><strong>互斥条件</strong>:只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源)。</li>
<li><strong>不剥夺条件</strong>:进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li><strong>请求和保持条件</strong>:进程已经保持了至少-一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li><strong>循环等待条件</strong>:存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ul>
</li>
<li>注意!发生死锁时一.定有循环等待，但是发生循环等待时未必死锁(循环等待是死锁的必要不充分条件)</li>
</ul>
<h2 id="19-3-死锁的发生"><a href="#19-3-死锁的发生" class="headerlink" title="19.3 死锁的发生"></a>19.3 死锁的发生</h2><ul>
<li>1.对系统资源的竞争。各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的。</li>
<li>2.进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又 申请资源R1,两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li>
<li>3.信号量的使用不当也会造成死锁。如生产者~消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。(可 以把互斥信号量、同步信号量也看做是一种抽象的系统资源。</li>
<li>总之，对不可剥夺资源的不合理分配，可能导致死锁。</li>
</ul>
<h2 id="19-4-死锁的处理策略"><a href="#19-4-死锁的处理策略" class="headerlink" title="19.4 死锁的处理策略"></a>19.4 死锁的处理策略</h2><ul>
<li>1.预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li>
<li>2.避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁(银行家算法)</li>
<li>3.死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li>
</ul>
<h2 id="19-5-总结"><a href="#19-5-总结" class="headerlink" title="19.5 总结"></a>19.5 总结</h2><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223183648.png"></p>
<h1 id="第二十节：死锁的处理策略"><a href="#第二十节：死锁的处理策略" class="headerlink" title="第二十节：死锁的处理策略"></a>第二十节：死锁的处理策略</h1><h2 id="20-1-预防死锁"><a href="#20-1-预防死锁" class="headerlink" title="20.1 预防死锁"></a>20.1 预防死锁</h2><h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><ul>
<li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。</li>
<li>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: SPOOLing技术。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技 术将打印机改造为共享设备….</li>
<li>该策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还不行保护这种互斥性，因此，很多时候都无法破坏互斥条件。</li>
</ul>
<h3 id="破坏不可剥夺条件"><a href="#破坏不可剥夺条件" class="headerlink" title="破坏不可剥夺条件"></a>破坏不可剥夺条件</h3><ul>
<li>不剥夺条件:进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li>破坏不剥夺条件:<ul>
<li>方案一:当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</li>
<li>方案二:当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级(比如:剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)</li>
</ul>
</li>
<li>该策略的缺点:<ul>
<li>1.实现起来比较复杂。</li>
<li>2.释放己获得的资源可能造成前一阶段工作的失效。因此这种方法- -般只适用于易保存和恢复状态的资源，如CPU。</li>
<li>3.反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li>
<li>4.若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li>
</ul>
</li>
</ul>
<h3 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h3><ul>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li>可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一.旦投入运行后，这些资源就一直归它所有， 该进程就不会再请求别的任何资源了。</li>
<li>该策略实现起来简单，但也有明显的缺点：有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一-直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</li>
</ul>
<h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><ul>
<li>循环等待条件:存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
<li>可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源(即编号相同的资源)一次申请完。</li>
<li>原理分析: - 一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。</li>
<li>该策略的缺点:<ul>
<li>1.不方便增加新的设备，因为可能需要重新分配所有的编号;</li>
<li>2.进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费;</li>
<li>3.必须按规定次序申请资源，用户编程麻烦。</li>
</ul>
</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223185245.png"></p>
<h2 id="20-2-避免死锁"><a href="#20-2-避免死锁" class="headerlink" title="20.2 避免死锁"></a>20.2 避免死锁</h2><ul>
<li>所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</li>
<li>如果分配了资源之后，系统中找不出任何一一个安全序列，系统就进入了不安全状态。这就意味着之后.可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。</li>
<li>如果系统处于安全状态，就一定不 会发生死锁。如果系统进入不安全状态，就可能发生死锁(处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)</li>
<li>因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源<br>分配请求。这也是“银行家算法”的核心思想。</li>
<li>银行家算法是荷兰学者Dijkstra为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于避免死锁。</li>
<li>核心思想:在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223203438.png"></p>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223203536.png"></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>数据结构: .<ul>
<li>长度为m的一-维数组Available表示还有多少可用资源</li>
<li>n*m矩阵Max表示各进程对资源的最大需求数</li>
<li>n*m矩阵Allocation表示已经给各进程分配了多少资源</li>
<li>Max-Allocation=Need矩阵表示各进程最多还需要多少资源</li>
<li>用长度为m的一位数组Request表示进程此次申请的各种资源数</li>
</ul>
</li>
<li>银行家算法步骤:<ul>
<li>①检查此次申请是否超过了之前声明的最大需求数</li>
<li>②检查此时系统剩余的可用资源是否还能满足这次请求</li>
<li>③试探着分配，更改各数据结构</li>
<li>④用安全性算法检查此次分配是否会导致系统进入不安全状态</li>
</ul>
</li>
<li>安全性算法步骤:<ul>
<li>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。</li>
<li>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</li>
</ul>
</li>
<li>系统处于不安全状态未必死锁，但死锁时-定处于不安全状态。系统处于安全状态一定 不会死锁。</li>
</ul>
<h2 id="20-3-死锁的检测和解除"><a href="#20-3-死锁的检测和解除" class="headerlink" title="20.3 死锁的检测和解除"></a>20.3 死锁的检测和解除</h2><ul>
<li>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法:<ul>
<li>①死锁检测算法:用于检测系统状态，以确定系统中是否发生了死锁。</li>
<li>②死锁解除算法:当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</li>
</ul>
</li>
</ul>
<h3 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h3><ul>
<li>为了能对系统是否己发生了死锁进行检测，必须:<ul>
<li>①用某种数据结构来保存资源的请求和分配信息;</li>
<li>②提供一种算法， 利用上述信息来检测系统是否已进入死锁状态。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223204639.png"></p>
<ul>
<li>死锁的检测<ul>
<li>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。</li>
<li>如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。</li>
<li>相应的，这些被激活的进程执行完了之后又会归还一-些资源，这样可能又会激活另外- -些阻塞的进程…</li>
<li>如果按，上述过程分析，最终能消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁 (相当于能找到一个安全序列)。</li>
<li>如果最终不能消除所有边，那么此时就是发生了死锁。</li>
<li>最终还连着边的那些进程就是处于死锁状态的进程。</li>
</ul>
</li>
<li>检测死锁的算法:<ul>
<li>1)在资源分配图中，找出既不阻塞又不是孤点的进程Pi(即找出一-条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如下图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源)。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中,P1是满足这-条件的进程结点，于是将P1的所有边消去。</li>
<li>2)进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，P2就满足这样的条件。根据1)中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的。</li>
</ul>
</li>
<li><strong>死锁定理</strong>：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</li>
</ul>
<h3 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h3><ul>
<li>一旦检测出死锁的发生，就应该立即解除死锁。</li>
<li>补充:并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程</li>
<li>解除死锁的主要方法有:<ul>
<li>1.资源剥夺法。挂起(暂时放到外存上)某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li>2.撤销进程法(或称终止进程法)。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li>3.进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程<br>的历史信息，设置还原点。</li>
</ul>
</li>
<li>如何决定“对谁动手”<ul>
<li>1.进程优先级</li>
<li>2.已执行多长时间</li>
<li>3.还要多久能完成</li>
<li>4.进程已经使用了多少资源</li>
<li>5.进程是交互式的还是批处理式的</li>
</ul>
</li>
</ul>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201223204500.png"></p>

    </div>

    
    
    


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/" rel="prev" title="第五章-中央处理器">
      <i class="fa fa-chevron-left"></i> 第五章-中央处理器
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="next" title="第二章-内存管理">
      第二章-内存管理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%EF%BC%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E7%BB%84%E6%88%90%EF%BC%8C%E7%89%B9%E5%BE%81"><span class="nav-number">1.</span> <span class="nav-text">一，进程的概念，组成，特征</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">1.1进程的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">1.2.</span> <span class="nav-text">1.2进程的组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-number">1.3.</span> <span class="nav-text">1.3进程的特征</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%EF%BC%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.</span> <span class="nav-text">二，进程的状态与转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">2.1.</span> <span class="nav-text">2.1进程的状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.</span> <span class="nav-text">2.2状态之间的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="nav-number">2.3.</span> <span class="nav-text">2.3进程的组织方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%EF%BC%8C%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">三，进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.1.</span> <span class="nav-text">3.1基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2%E7%9B%B8%E5%85%B3%E5%8E%9F%E8%AF%AD"><span class="nav-number">3.2.</span> <span class="nav-text">3.2相关原语</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%EF%BC%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">4.</span> <span class="nav-text">四，进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="nav-number">4.1.</span> <span class="nav-text">4.1共享存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="nav-number">4.2.</span> <span class="nav-text">4.2管道通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="nav-number">4.3.</span> <span class="nav-text">4.3消息传递</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="nav-number">5.</span> <span class="nav-text">五，线程概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">5.1.</span> <span class="nav-text">5.1线程的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B%E5%90%8E%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">5.2.</span> <span class="nav-text">5.2引入线程后的变化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">5.3.</span> <span class="nav-text">5.3线程的属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%EF%BC%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">六，线程的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">6.1.</span> <span class="nav-text">6.1线程的实现方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.2.</span> <span class="nav-text">6.2多线程模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%EF%BC%8C%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="nav-number">7.</span> <span class="nav-text">七，处理机调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">7.1.</span> <span class="nav-text">7.1基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-number">7.2.</span> <span class="nav-text">7.2高级调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-number">7.3.</span> <span class="nav-text">7.3中级调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-number">7.4.</span> <span class="nav-text">7.4低级调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5%E4%B8%89%E5%B1%82%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.5.</span> <span class="nav-text">7.5三层调度的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.6.</span> <span class="nav-text">7.6七状态模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%EF%BC%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">8.</span> <span class="nav-text">八，进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-number">8.1.</span> <span class="nav-text">8.1进程调度的时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B"><span class="nav-number">8.2.</span> <span class="nav-text">8.2进程调度的切换与过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">8.3.</span> <span class="nav-text">8.3进程调度的方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%EF%BC%8C%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="nav-number">9.</span> <span class="nav-text">九，调度算法的评价指标</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1CPU%E5%88%A9%E7%94%A8%E7%8E%87"><span class="nav-number">9.1.</span> <span class="nav-text">9.1CPU利用率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2%E7%B3%BB%E7%BB%9F%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-number">9.2.</span> <span class="nav-text">9.2系统吞吐量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4"><span class="nav-number">9.3.</span> <span class="nav-text">9.3周转时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4"><span class="nav-number">9.4.</span> <span class="nav-text">9.4等待时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4"><span class="nav-number">9.5.</span> <span class="nav-text">9.5响应时间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%EF%BC%8C%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">10.</span> <span class="nav-text">十，调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-FCFS"><span class="nav-number">10.1.</span> <span class="nav-text">10.1 先来先服务(FCFS)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88-SJF"><span class="nav-number">10.2.</span> <span class="nav-text">10.2 短作业优先(SJF)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-4-%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88-HRRN"><span class="nav-number">10.3.</span> <span class="nav-text">10.4 高响应比优先(HRRN)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-4-%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC-RR"><span class="nav-number">10.4.</span> <span class="nav-text">10.4 时间片轮转(RR)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-5-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-number">10.5.</span> <span class="nav-text">10.5 优先级调度()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-6-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6"><span class="nav-number">10.6.</span> <span class="nav-text">10.6 多级反馈队列调度()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%EF%BC%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5"><span class="nav-number">11.</span> <span class="nav-text">十一，进程的同步和互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">11.1.</span> <span class="nav-text">11.1进程同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="nav-number">11.2.</span> <span class="nav-text">11.2进程互斥</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%EF%BC%8C%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">12.</span> <span class="nav-text">十二，进程互斥的软件实现方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95"><span class="nav-number">12.1.</span> <span class="nav-text">12.1 单标志法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5"><span class="nav-number">12.2.</span> <span class="nav-text">12.2 双标志先检查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5"><span class="nav-number">12.3.</span> <span class="nav-text">12.3 双标志后检查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-4-Peterson%E7%AE%97%E6%B3%95"><span class="nav-number">12.4.</span> <span class="nav-text">12.4 Peterson算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%89%EF%BC%8C%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">13.</span> <span class="nav-text">十三，进程互斥的硬件实现方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#13-1-%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E6%96%B9%E6%B3%95"><span class="nav-number">13.1.</span> <span class="nav-text">13.1 中断屏蔽方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-2-TestAndSet%EF%BC%88TS%E6%8C%87%E4%BB%A4-TSL%E6%8C%87%E4%BB%A4%EF%BC%89"><span class="nav-number">13.2.</span> <span class="nav-text">13.2 TestAndSet（TS指令&#x2F;TSL指令）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-3-Swap%E6%8C%87%E4%BB%A4-XCHG%E6%8C%87%E4%BB%A4"><span class="nav-number">13.3.</span> <span class="nav-text">13.3 Swap指令(XCHG指令)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E5%9B%9B%EF%BC%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="nav-number">14.</span> <span class="nav-text">十四，信号量机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1-%E6%95%B4%E5%BD%A2%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">14.1.</span> <span class="nav-text">14.1 整形信号量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">14.2.</span> <span class="nav-text">14.2 记录型信号量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%BA%94%EF%BC%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">15.</span> <span class="nav-text">十五，信号量机制的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#15-1-%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="nav-number">15.1.</span> <span class="nav-text">15.1 实现进程互斥</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-2-%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">15.2.</span> <span class="nav-text">15.2 实现进程同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-3-%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="nav-number">15.3.</span> <span class="nav-text">15.3 实现进程前驱关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E5%85%AD%EF%BC%8C%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">16.</span> <span class="nav-text">十六，生产者消费者问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%83%EF%BC%8C%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">17.</span> <span class="nav-text">十七，多生产者和多消费者</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="nav-number">17.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-number">17.2.</span> <span class="nav-text">问题分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">17.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">17.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E5%85%AB%EF%BC%8C%E7%AE%A1%E7%A8%8B"><span class="nav-number">18.</span> <span class="nav-text">十八，管程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#18-1-%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="nav-number">18.1.</span> <span class="nav-text">18.1 管程的定义和基本特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">18.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B9%9D%E8%8A%82%EF%BC%9A%E6%AD%BB%E9%94%81"><span class="nav-number">19.</span> <span class="nav-text">第十九节：死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#19-1-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">19.1.</span> <span class="nav-text">19.1 死锁的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-2-%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">19.2.</span> <span class="nav-text">19.2 死锁产生的必要条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-3-%E6%AD%BB%E9%94%81%E7%9A%84%E5%8F%91%E7%94%9F"><span class="nav-number">19.3.</span> <span class="nav-text">19.3 死锁的发生</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-4-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="nav-number">19.4.</span> <span class="nav-text">19.4 死锁的处理策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-5-%E6%80%BB%E7%BB%93"><span class="nav-number">19.5.</span> <span class="nav-text">19.5 总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E8%8A%82%EF%BC%9A%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="nav-number">20.</span> <span class="nav-text">第二十节：死锁的处理策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#20-1-%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="nav-number">20.1.</span> <span class="nav-text">20.1 预防死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A0%B4%E5%9D%8F%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6"><span class="nav-number">20.1.1.</span> <span class="nav-text">破坏互斥条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A0%B4%E5%9D%8F%E4%B8%8D%E5%8F%AF%E5%89%A5%E5%A4%BA%E6%9D%A1%E4%BB%B6"><span class="nav-number">20.1.2.</span> <span class="nav-text">破坏不可剥夺条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A0%B4%E5%9D%8F%E8%AF%B7%E6%B1%82%E5%92%8C%E4%BF%9D%E6%8C%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">20.1.3.</span> <span class="nav-text">破坏请求和保持条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A0%B4%E5%9D%8F%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="nav-number">20.1.4.</span> <span class="nav-text">破坏循环等待条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">20.1.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-2-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">20.2.</span> <span class="nav-text">20.2 避免死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="nav-number">20.2.1.</span> <span class="nav-text">银行家算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-number">20.2.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-3-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4"><span class="nav-number">20.3.</span> <span class="nav-text">20.3 死锁的检测和解除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="nav-number">20.3.1.</span> <span class="nav-text">死锁的检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4"><span class="nav-number">20.3.2.</span> <span class="nav-text">死锁的解除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-4"><span class="nav-number">20.3.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Plum Reiver</p>
  <div class="site-description" itemprop="description">技术，日常，笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
	
  </nav>
</div>


      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plum Reiver</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
