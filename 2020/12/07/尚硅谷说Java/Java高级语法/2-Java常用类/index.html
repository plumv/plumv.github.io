<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"plumv.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="包含字符串，日期，数组，排序，以及大数的表示">
<meta property="og:type" content="article">
<meta property="og:title" content="Java常用类">
<meta property="og:url" content="https://plumv.github.io/2020/12/07/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/2-Java%E5%B8%B8%E7%94%A8%E7%B1%BB/index.html">
<meta property="og:site_name" content="李川的个人博客">
<meta property="og:description" content="包含字符串，日期，数组，排序，以及大数的表示">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184348.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184349.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184350.png">
<meta property="article:published_time" content="2020-12-06T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-20T12:15:08.601Z">
<meta property="article:author" content="Plum Reiver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184348.png">

<link rel="canonical" href="https://plumv.github.io/2020/12/07/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/2-Java%E5%B8%B8%E7%94%A8%E7%B1%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java常用类 | 李川的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李川的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>日志</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://plumv.github.io/2020/12/07/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/2-Java%E5%B8%B8%E7%94%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plum Reiver">
      <meta itemprop="description" content="技术，日常，笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李川的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java常用类
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-07 00:00:00" itemprop="dateCreated datePublished" datetime="2020-12-07T00:00:00+08:00">2020-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-20 20:15:08" itemprop="dateModified" datetime="2021-03-20T20:15:08+08:00">2021-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">Java高级语法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>包含字符串，日期，数组，排序，以及大数的表示</p>
<span id="more"></span>
<h1 id="字符串相关的类"><a href="#字符串相关的类" class="headerlink" title="字符串相关的类"></a>字符串相关的类</h1><h2 id="String的特性"><a href="#String的特性" class="headerlink" title="String的特性"></a>String的特性</h2><ul>
<li><p>String类：代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。</p>
</li>
<li><p>String是一个final类，代表不可变的字符序列。 </p>
</li>
<li><p>字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。 </p>
</li>
<li><p>String对象的字符内容是存储在一个字符数组value[]中的。</p>
</li>
<li><p>部分源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>String对象的创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//本质上this.value = new char[0];</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(); </span><br><span class="line"><span class="comment">//this.value = original.value;</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(String original); </span><br><span class="line"><span class="comment">//this.value = Arrays.copyOf(value, value.length);</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a); </span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> count);</span><br></pre></td></tr></table></figure></li>
<li><p>String的赋值方法：字面量赋值；构造方法赋值</p>
<ul>
<li>字面量赋值：字符串常量存储在字符串常量池，目的是共享。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在内存的字符串常量池中开辟了一块空间存放“abc&quot;，假设地址为0x1212</span></span><br><span class="line"><span class="comment">//s1指向0x1212</span></span><br><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">//s2指向0x1212</span></span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在内存的字符串常量池中又开辟了一块空间存放“hello&quot;</span></span><br><span class="line">s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">System.out.println(s1);</span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//s3指向0x1212</span></span><br><span class="line">String s3 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">//由s3指向：在堆空间内开辟了一片空间存放”abcdef&quot;</span></span><br><span class="line">s3 += <span class="string">&quot;def&quot;</span>;</span><br><span class="line"><span class="comment">//由s6指向：在字符串常量池内开辟了一片空间存放”abcdef&quot;</span></span><br><span class="line">String s6 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3);</span><br><span class="line">System.out.println(s2);</span><br><span class="line"><span class="comment">//s4指向0x1212</span></span><br><span class="line">String s4 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">//s4不变。</span></span><br><span class="line"><span class="comment">// s5指向 ：在内存的字符串常量池中又开辟了一块空间存放“mbc&quot;</span></span><br><span class="line">String s5 = s4.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">System.out.println(s4);</span><br><span class="line">System.out.println(s5);</span><br></pre></td></tr></table></figure></li>
<li>构造方法赋值：字符串非常量对象存储在堆中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在堆空间中开辟了一个存放String对象的空间0x1111</span></span><br><span class="line"><span class="comment">//在内存的字符串常量池中开辟了一块空间存放“abc&quot;，假设地址为0x1212</span></span><br><span class="line"><span class="comment">//s1指向0x1111,s1中的value属性指向0x1212</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">//在堆空间中开辟了一个存放String对象的空间0x2222</span></span><br><span class="line"><span class="comment">//s2指向0x2222,s2中的value属性指向0x1212</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">//s3指向0x1212</span></span><br><span class="line">String s3 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在堆空间中开辟了一个存放Person对象的空间0x3333</span></span><br><span class="line"><span class="comment">//person1指向0x3333,person1中的属性name指向0x1212</span></span><br><span class="line">Person person1 = <span class="keyword">new</span> Person(<span class="string">&quot;abc&quot;</span>,<span class="number">11</span>);</span><br><span class="line"><span class="comment">//在堆空间中开辟了一个存放Person对象的空间0x4444</span></span><br><span class="line"><span class="comment">//person2指向0x4444,person2中的属性name指向0x1212</span></span><br><span class="line">Person person2 = <span class="keyword">new</span> Person(<span class="string">&quot;abc&quot;</span>,<span class="number">12</span>);</span><br><span class="line">System.out.println(person1.name == person2.name);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184348.png"></li>
</ul>
</li>
<li><p>字符串的特性</p>
<ul>
<li>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。 </li>
<li>只要其中有一个是变量，结果就在堆中</li>
<li>如果拼接的结果调用intern()方法，返回值就在常量池中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s1,s2的指向在常量池中</span></span><br><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;def&quot;</span>;</span><br><span class="line"><span class="comment">//s3,s4的指向在常量池中</span></span><br><span class="line">String s3 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">String s4 = <span class="string">&quot;abc&quot;</span>+<span class="string">&quot;def&quot;</span>;</span><br><span class="line"><span class="comment">//s5,s6的指向在堆中</span></span><br><span class="line">String s5 = s1+<span class="string">&quot;def&quot;</span>;</span><br><span class="line">String s6 = <span class="string">&quot;abc&quot;</span> + s2;</span><br><span class="line"><span class="comment">//s7的指向在常量池中</span></span><br><span class="line">String s7 = s5.intern();</span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s7);<span class="comment">//true</span></span><br><span class="line">System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">String str1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str3 = str2 + <span class="string">&quot;def&quot;</span>;</span><br><span class="line"><span class="comment">//由于str2在声明时就被确认为常量，因此str3右边的赋值操作中两个都是常量</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>String使用陷阱</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;a&quot;</span>; </span><br><span class="line">说明：在字符串常量池中创建了一个字面量为<span class="string">&quot;a&quot;</span>的字符串。</span><br><span class="line">    </span><br><span class="line">s1 = s1 + <span class="string">&quot;b&quot;</span>; </span><br><span class="line">说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+<span class="string">&quot;b&quot;</span>（也就是<span class="string">&quot;ab&quot;</span>)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。 </span><br><span class="line">    </span><br><span class="line">String s2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">说明：直接在字符串常量池中创建一个字面量为<span class="string">&quot;ab&quot;</span>的字符串。</span><br><span class="line">    </span><br><span class="line">String s3 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">说明：s3指向字符串常量池中已经创建的<span class="string">&quot;ab&quot;</span>的字符串。</span><br><span class="line">    </span><br><span class="line">String s4 = s1.intern();</span><br><span class="line">说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的<span class="string">&quot;ab&quot;</span>字符串赋值给s4。</span><br></pre></td></tr></table></figure></li>
<li><p>String常用的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>：返回字符串的长度： return value.length</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span>： 返回某索引处的字符return value[index] </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>：判断是否是空字符串：return value.length </span>== <span class="number">0</span> </span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所有字符转换为小写</span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所有字符转换为大写</span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span>：返回字符串的副本，忽略前导空白和尾部空白</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>：比较字符串的内容是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span>：与equals方法类似，忽略大小写</span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span>：将指定字符串连接到此字符串的结尾。 等价于用“+”</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span>：比较两个字符串的大小</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span>：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> ：返回一个新字符串，它是此字符串从beginIndex开始截取到<span class="title">endIndex</span><span class="params">(不包含)</span>的一个子字符串。</span></span><br><span class="line"><span class="function">---------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">		String s1 </span>= <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        <span class="comment">//返回字符串的长度</span></span><br><span class="line">        System.out.println(s1.length());</span><br><span class="line">        <span class="comment">// 返回某索引处的字符</span></span><br><span class="line">        System.out.println(s1.charAt(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//判断是否是空字符串：根据字符串长度判断，长度等于0则为空</span></span><br><span class="line">        System.out.println(s1.isEmpty());</span><br><span class="line">        String s2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(s2.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转换为大写</span></span><br><span class="line">        String s3 = s1.toUpperCase();</span><br><span class="line">        <span class="comment">//转换为小写</span></span><br><span class="line">        String s4 = s3.toLowerCase();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s3);</span><br><span class="line">        System.out.println(s4);</span><br><span class="line">        String s5 = <span class="string">&quot;  asd fgh  &quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;---&quot;</span> + s5 + <span class="string">&quot;---&quot;</span>);</span><br><span class="line">        <span class="comment">//返回字符串忽略前导空白和尾部空白后的副本</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---&quot;</span> + s5.trim() + <span class="string">&quot;---&quot;</span>);</span><br><span class="line">        <span class="comment">//比较字符串的内容是否相同</span></span><br><span class="line">        System.out.println(s4.equals(s1));</span><br><span class="line">        <span class="comment">//比较字符串的内容是否相同。忽略大小写</span></span><br><span class="line">        System.out.println(s3.equalsIgnoreCase(s1));</span><br><span class="line">        <span class="comment">//将指定字符串连接到此字符串的结尾。</span></span><br><span class="line">        String s6 = s1.concat(<span class="string">&quot;pig&quot;</span>);</span><br><span class="line">        System.out.println(s6);</span><br><span class="line">        String s7 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String s8 = <span class="string">&quot;abe&quot;</span>;</span><br><span class="line">        <span class="comment">//比较两个字符串的大小，返回差值</span></span><br><span class="line">        System.out.println(s7.compareTo(s8));</span><br><span class="line">        <span class="comment">//返回一个新的字符串，从给定位置开始截取，到最后</span></span><br><span class="line">        System.out.println(s1.substring(<span class="number">5</span>));</span><br><span class="line">        <span class="comment">//返回一个新的字符串，从给定位置开始截取，到给定的位置截止。前闭后开</span></span><br><span class="line">        System.out.println(s1.substring(<span class="number">5</span>, <span class="number">10</span>));    </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span>：测试此字符串是否以指定的后缀结束</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span>：测试此字符串是否以指定的前缀开始</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span>：当且仅当此字符串包含指定的 <span class="keyword">char</span> 值序列时，返回 <span class="keyword">true</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中第一次出现处的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中最右边出现处的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</span></span><br><span class="line"><span class="function">注：indexOf和lastIndexOf方法如果未找到都是返回-1    </span></span><br><span class="line"><span class="function">---------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">    	String str1 </span>= <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        <span class="comment">//返回字符串是否以指定的后缀结束</span></span><br><span class="line">        System.out.println(str1.endsWith(<span class="string">&quot;ld&quot;</span>));</span><br><span class="line">        <span class="comment">//返回此字符串是否以指定的前缀开始</span></span><br><span class="line">        System.out.println(str1.startsWith(<span class="string">&quot;he&quot;</span>));</span><br><span class="line">        <span class="comment">//返回字符串从指定索引开始往后的子字符串是否以指定前缀开始</span></span><br><span class="line">        System.out.println(str1.startsWith(<span class="string">&quot;lo&quot;</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回指定的字符串是否是字符串的子串</span></span><br><span class="line">        System.out.println(str1.contains(<span class="string">&quot;wor&quot;</span>));</span><br><span class="line">        <span class="comment">//返回指定子字符串在此字符串中第一次出现处的索引</span></span><br><span class="line">        System.out.println(str1.indexOf(<span class="string">&quot;lo&quot;</span>));</span><br><span class="line">        <span class="comment">//返回从指定索引开始往后的字符串中指定子字符串第一次出现的索引</span></span><br><span class="line">        System.out.println(str1.indexOf(<span class="string">&quot;wo&quot;</span>, <span class="number">2</span>));</span><br><span class="line">        String str2 = <span class="string">&quot;helohelohelo&quot;</span>;</span><br><span class="line">        <span class="comment">//返回指定子字符串在此字符串中最右边出现处的索引</span></span><br><span class="line">        System.out.println(str2.lastIndexOf(<span class="string">&quot;he&quot;</span>));</span><br><span class="line">        <span class="comment">//返回从指定索引开始往前的字符串中指定子字符串最右边出现处的索引</span></span><br><span class="line">        System.out.println(str2.lastIndexOf(<span class="string">&quot;he&quot;</span>, <span class="number">7</span>));</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span>：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 </span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span>：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。 </span></span><br><span class="line"><span class="function">String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> ： 使 用 给 定 的</span></span><br><span class="line"><span class="function">replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 </span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span> ： 使 用 给 定 的</span></span><br><span class="line"><span class="function">replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span>：告知此字符串是否匹配给定的正则表达式。 </span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex)</span>：根据给定正则表达式的匹配拆分此字符串。 </span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex, <span class="keyword">int</span> limit)</span>：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</span></span><br></pre></td></tr></table></figure></li>
<li><p>字符串与其他类型之间的转换</p>
<ul>
<li>字符串 –&gt; 基本数据类型、包装类<ul>
<li>Integer包装类的public static int parseInt(String s)：可以将由“数字”字符组成的字符串转换为整型。</li>
<li>类似地,使用java.lang包中的Byte、Short、Long、Float、Double类调相应的类方法可以将由“字”字符组成的字符串，转化为相应的基本数据类型。</li>
</ul>
</li>
<li>基本数据类型、包装类 –&gt; 字符串<ul>
<li>调用String类的public String valueOf(int n)可将int型转换为字符串</li>
<li>相应的valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double d)、valueOf(boolean b)可由参数的相应类型到字符串的转换</li>
</ul>
</li>
<li>字符数组 –&gt; 字符串<ul>
<li>String 类的构造器：String(char[]) 和 String(char[]，int offset，int length) 分别用字符数组中的全部字符和部分字符创建字符串对象。</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串 –&gt; 字符数组</p>
<ul>
<li>public char[] toCharArray()：将字符串中的全部字符存放在一个字符数组中的方法。</li>
<li>public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)：提供了将指定索引范围内的字符串存放到数组中的方法。</li>
</ul>
</li>
<li><p>字节数组 –&gt; 字符串</p>
<ul>
<li>String(byte[])：通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。 </li>
<li>String(byte[]，int offset，int length) ：用指定的字节数组的一部分，即从数组起始位置offset开始取length个字节构造一个字符串对象。 </li>
<li>字符串 –&gt; 字节数组</li>
<li>public byte[] getBytes() ：使用平台的默认字符集将此 String 编码为byte 序列，并将结果存储到一个新的 byte 数组中。 <ul>
<li>public byte[] getBytes(String charsetName) ：使用指定的字符集将 此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  String s = <span class="string">&quot;TRUE&quot;</span>;</span><br><span class="line">  <span class="keyword">boolean</span> b = Boolean.parseBoolean(s);</span><br><span class="line">  System.out.println(b);</span><br><span class="line">  </span><br><span class="line">  String string = <span class="string">&quot;sadad&quot;</span>;</span><br><span class="line">  <span class="keyword">char</span>[] chars = string.toCharArray();</span><br><span class="line">System.out.println(Arrays.toString(chars));</span><br><span class="line">  </span><br><span class="line">  String string1 = <span class="keyword">new</span> String(chars);</span><br><span class="line">  System.out.println(string1);</span><br><span class="line">  </span><br><span class="line">  String str1 = <span class="string">&quot;123asd中国&quot;</span>;</span><br><span class="line">  <span class="comment">//以默认编码方式编码</span></span><br><span class="line">  <span class="keyword">byte</span>[] bytes = str1.getBytes();</span><br><span class="line">  System.out.println(Arrays.toString(bytes));</span><br><span class="line">  <span class="keyword">byte</span>[] gbks=<span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//以gbk编码方式编码</span></span><br><span class="line">      gbks = str1.getBytes(<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">      System.out.println(Arrays.toString(gbks));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//以默认的解码方式解码</span></span><br><span class="line">  String str2 = <span class="keyword">new</span> String(bytes);</span><br><span class="line">  System.out.println(str2);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//输出乱码：因为解码方式与编码方式不一致</span></span><br><span class="line">  String str3 = <span class="keyword">new</span> String(gbks);</span><br><span class="line">  System.out.println(str3);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      String str4 = <span class="keyword">new</span> String(gbks, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">      <span class="comment">//输出正常：因为解码方式与编码方式相同</span></span><br><span class="line">      System.out.println(str4);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2></li>
</ul>
</li>
</ul>
</li>
<li><p>java.lang.StringBuffer代表可变的字符序列，JDK1.0中声明，可以对字符<br>串内容进行增删，此时不会产生新的对象。</p>
</li>
<li><p>很多方法与String相同。</p>
</li>
<li><p>作为参数传递时，方法内部可以改变值。</p>
</li>
<li><p>StringBuffer类不同于String，其对象必须使用构造器生成。有三个构造器： </p>
<ul>
<li>StringBuffer()：初始容量为16的字符串缓冲区</li>
<li>StringBuffer(int size)：构造指定容量的字符串缓冲区</li>
<li>StringBuffer(String str)：将内容初始化为指定字符串内容</li>
</ul>
</li>
<li><p>StringBuffer类的常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">append</span><span class="params">(xxx)</span>：提供了很多的<span class="title">append</span><span class="params">()</span>方法，用于进行字符串拼接</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>：删除指定位置的内容</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span>：把[start,end)位置替换为str</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, xxx)</span>：在指定位置插入xxx</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">reverse</span><span class="params">()</span> ：把当前字符序列逆转</span></span><br><span class="line"><span class="function">当append和insert时，如果原来value数组长度不够，可扩容。 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">此外，还定义了如下的方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">---------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">		StringBuffer stringBuffer </span>= <span class="keyword">new</span> StringBuffer(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line">        <span class="comment">//返回字符串存储字符的数量</span></span><br><span class="line">        System.out.println(stringBuffer.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在原有字符串后拼接字符串</span></span><br><span class="line">        stringBuffer.append(<span class="string">&quot;asd&quot;</span>);</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除指定范围内的字符，前闭后开</span></span><br><span class="line">        stringBuffer.delete(<span class="number">2</span>, <span class="number">4</span>);;</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改指定位置的字符</span></span><br><span class="line">        stringBuffer.setCharAt(<span class="number">5</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改指定范围内的字符字符串，前闭后开</span></span><br><span class="line">        stringBuffer.replace(<span class="number">2</span>, <span class="number">4</span>, <span class="string">&quot;china&quot;</span>);</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在指定位置上插入字符串</span></span><br><span class="line">        stringBuffer.insert(<span class="number">2</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(stringBuffer);</span><br></pre></td></tr></table></figure>
<h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2></li>
<li><p>StringBuilder 和 StringBuffer 非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样</p>
</li>
<li><p>面试题：对比String、StringBuffer、StringBuilder</p>
<ul>
<li>String(JDK1.0)：不可变字符序列</li>
<li>StringBuffer(JDK1.0)：可变字符序列、效率低、线程安全</li>
<li>StringBuilder(JDK 5.0)：可变字符序列、效率高、线程不安全</li>
<li>注意：作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值。<br>String与StringBuffer，StringBuilder的效率的差别<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始设置</span></span><br><span class="line"><span class="keyword">long</span> startTime = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">long</span> endTime = <span class="number">0L</span>;</span><br><span class="line">String text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;&quot;</span>);</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//开始对比</span></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">    buffer.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;StringBuffer的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">    builder.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;StringBuilder的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">    text = text + i; &#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;String的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"><span class="comment">//实际的一次记录：StringBuffer的执行时间：4</span></span><br><span class="line"><span class="comment">//             StringBuilder的执行时间：1</span></span><br><span class="line"><span class="comment">//             String的执行时间：1057</span></span><br></pre></td></tr></table></figure>
<h1 id="日期时间API"><a href="#日期时间API" class="headerlink" title="日期时间API"></a>日期时间API</h1><h2 id="JDK8之前的"><a href="#JDK8之前的" class="headerlink" title="JDK8之前的"></a>JDK8之前的</h2></li>
</ul>
</li>
<li><p>继承关系图<br><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184349.png"></p>
</li>
<li><p> java.lang.System类</p>
</li>
<li><p>System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</p>
<ul>
<li>此方法适于计算时间差。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> time = System.currentTimeMillis();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>计算世界时间的主要标准有：</p>
<ul>
<li>UTC(Coordinated Universal Time)</li>
<li>GMT(Greenwich Mean Time) 格林威治标准时间</li>
<li>CST(Central Standard Time) 中部标准时间</li>
</ul>
</li>
<li><p>java.util.Date类</p>
<ul>
<li>表示特定的瞬间，精确到毫秒</li>
<li> 构造器： </li>
<li>Date()：使用无参构造器创建的对象可以获取本地当前时间。</li>
<li>Date(long date)</li>
<li>常用方法<ul>
<li>getTime():返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</li>
<li>toString():把此 Date 对象转换为以下形式的 String： dow mon ddhh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准。 </li>
<li>其它很多方法都过时了。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器一：创建一个当前时间的Date对象</span></span><br><span class="line">Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">//getTime()方法：返回date对象对应的毫秒数</span></span><br><span class="line">System.out.println(date1.getTime());</span><br><span class="line"><span class="comment">//toString():Date重写了这个方法；方法返回Date对象的年，月，日，时，分，秒，星期</span></span><br><span class="line">System.out.println(date1.toString());</span><br><span class="line"><span class="comment">//构造器二：创建一个指定毫秒时间(时间戳)的Date对象</span></span><br><span class="line">Date date2 = <span class="keyword">new</span> Date(<span class="number">1604639688137L</span>);</span><br><span class="line">System.out.println(date2.getTime());</span><br><span class="line">System.out.println(date2.toString());</span><br><span class="line"></span><br><span class="line">java.sql.Date date3 = <span class="keyword">new</span> java.sql.Date(<span class="number">1604639688137L</span>);</span><br><span class="line">System.out.println(date3.toString());</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>java.text.SimpleDateFormat类 </p>
<ul>
<li>java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</li>
<li>它允许进行格式化：日期 –&gt; 文本；解析：文本 –&gt; 日期。</li>
<li>格式化：<ul>
<li> SimpleDateFormat() ：默认的模式和语言环境创建对象</li>
<li>public SimpleDateFormat(String pattern)：该构造方法可以用参数pattern<br>指定的格式创建一个对象，该对象调用： </li>
<li>public String format(Date date)：方法格式化时间对象date</li>
</ul>
</li>
<li>解析：<ul>
<li>public Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化SimpleDateFormat</span></span><br><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line"></span><br><span class="line">Date date1= <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(date1);</span><br><span class="line"><span class="comment">//格式化：日期 ---&gt;字符串</span></span><br><span class="line">String format = simpleDateFormat.format(date1);</span><br><span class="line">System.out.println(format);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析：字符串 ---&gt;日期。解析堆字符串的样式由一定要求</span></span><br><span class="line">String string =  <span class="string">&quot;20-11-6 下午2:06&quot;</span>;</span><br><span class="line">Date date2 = simpleDateFormat.parse(string);</span><br><span class="line">System.out.println(date2);</span><br><span class="line"></span><br><span class="line">SimpleDateFormat simpleDateFormat1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy.MM.dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line">String format1 = simpleDateFormat1.format(date1);</span><br><span class="line">System.out.println(format1);</span><br><span class="line"><span class="comment">//解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现)，否则抛异常</span></span><br><span class="line">Date date3 = simpleDateFormat1.parse(format1);</span><br><span class="line">System.out.println(date3);</span><br></pre></td></tr></table></figure>
<img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184350.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>java.util.Calendar(日历)类 </p>
<ul>
<li>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。</li>
<li> 获取Calendar实例的方法</li>
<li>使用Calendar.getInstance()方法</li>
<li>调用它的子类GregorianCalendar的构造器。</li>
<li>一个Calendar的实例是系统时间的抽象表示，通过get(int field)方法来取得想要的时间信息。比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND<ul>
<li>public void set(int field,int value)   设置操作</li>
<li>public void add(int field,int amount)  增加操作</li>
<li>public final Date getTime()  //获取操作</li>
<li>public final void setTime(Date date)  //设置操作</li>
</ul>
</li>
<li> 注意: </li>
<li>获取月份时：一月是0，二月是1，以此类推，12月是11</li>
<li>获取星期时：周日是1，周二是2 ， 。。。。周六是7<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GregorianCalendar</span></span><br><span class="line">Calendar instance = Calendar.getInstance();</span><br><span class="line">System.out.println(instance.getClass());</span><br><span class="line"><span class="comment">//get()方法的使用</span></span><br><span class="line"><span class="comment">//获取instance中的日期是这个月中的第几天</span></span><br><span class="line">System.out.println(instance.get(Calendar.DAY_OF_MONTH));</span><br><span class="line"><span class="comment">//获取instance中的日期是这个星期中的第几天</span></span><br><span class="line">System.out.println(instance.get(Calendar.DAY_OF_WEEK));</span><br><span class="line"><span class="comment">//set()方法</span></span><br><span class="line"><span class="comment">//设置instance中的日期是这个月的第10天</span></span><br><span class="line">instance.set(Calendar.DAY_OF_MONTH, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//add()方法</span></span><br><span class="line"><span class="comment">//instance中的日期是这个月的第几天的基础上加上几天</span></span><br><span class="line">instance.add(Calendar.DAY_OF_MONTH, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//getTime()方法：日历类 --&gt; Date</span></span><br><span class="line">Date date = instance.getTime();</span><br><span class="line">System.out.println(date);</span><br><span class="line"><span class="comment">//setTime()方法: Date --&gt; 日历类</span></span><br><span class="line">Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">instance.setTime(date1);</span><br><span class="line">System.out.println(instance.get(Calendar.DAY_OF_MONTH));</span><br></pre></td></tr></table></figure>
<h2 id="JDK8以后的"><a href="#JDK8以后的" class="headerlink" title="JDK8以后的"></a>JDK8以后的</h2></li>
</ul>
</li>
<li><p>Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。新的 java.time 中包含了所有关于本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了日期时间和本地化的管理。</p>
</li>
<li><p>新时间日期API</p>
<ul>
<li>java.time – 包含值对象的基础包</li>
<li>java.time.chrono – 提供对不同的日历系统的访问</li>
<li>java.time.format – 格式化和解析时间和日期</li>
<li>java.time.temporal – 包括底层框架和扩展特性</li>
<li>java.time.zone – 包含时区支持的类</li>
</ul>
</li>
<li><p>LocalDate、LocalTime、LocalDateTime 类</p>
<ul>
<li>它们的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。</li>
<li>它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。 </li>
<li>LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期。</li>
<li>LocalTime表示一个时间，而不是日期。 </li>
<li>LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。</li>
<li>注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历。</li>
<li>常用方法</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><font color="red">now() / * now(ZoneId zone)</font></td>
<td align="center">静态方法，根据当前时间创建对象/指定时区的对象</td>
</tr>
<tr>
<td align="center"><font color="red">of()</font></td>
<td align="center">静态方法，根据指定日期/时间创建对象</td>
</tr>
<tr>
<td align="center"><font color="blue">getDayOfMonth()/getDayOfYear()</font></td>
<td align="center">获得月份天数(1-31) /获得年份天数(1-366)</td>
</tr>
<tr>
<td align="center"><font color="blue">getDayOfWeek()</font></td>
<td align="center">获得星期几(返回一个 DayOfWeek 枚举值)</td>
</tr>
<tr>
<td align="center"><font color="blue">getMonth()</font></td>
<td align="center">获得月份, 返回一个 Month 枚举值</td>
</tr>
<tr>
<td align="center"><font color="blue">getMonthValue() / getYear()</font></td>
<td align="center">获得月份(1-12) /获得年份</td>
</tr>
<tr>
<td align="center"><font color="blue">getHour()/getMinute()/getSecond()</font></td>
<td align="center">获得当前对象对应的小时、分钟、秒</td>
</tr>
<tr>
<td align="center"><font color="green">withDayOfMonth()/withDayOfYear()/withMonth()/withYear()</font></td>
<td align="center">将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</td>
</tr>
<tr>
<td align="center"><font color="purple">plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours()</font></td>
<td align="center">向当前对象添加几天、几周、几个月、几年、几小时</td>
</tr>
<tr>
<td align="center"><font color="purple">minusMonths() / minusWeeks()/minusDays()/minusYears()/minusHours()</font></td>
<td align="center">从当前对象减去几月、几周、几天、几年、几小时</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//now()：获取当前的日期，时间，日期+时间</span></span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(localTime);</span><br><span class="line">System.out.println(localDate);</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line"><span class="comment">//of():设置指定的年，月，日，时，分，秒。</span></span><br><span class="line">LocalDateTime of = LocalDateTime.of(<span class="number">2020</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">20</span>);</span><br><span class="line">System.out.println(of);</span><br><span class="line"><span class="comment">//getXxx()：获取一些时间的信息</span></span><br><span class="line">System.out.println(localDateTime.getDayOfMonth());</span><br><span class="line">System.out.println(localDateTime.getDayOfWeek());</span><br><span class="line">System.out.println(localDateTime.getDayOfYear());</span><br><span class="line">System.out.println(localDateTime.getHour());</span><br><span class="line">System.out.println(localDateTime.getMonth());</span><br><span class="line">System.out.println(localDateTime.getMonthValue());</span><br><span class="line"><span class="comment">//withXxx()：设置一些时间的信息，返回新的对象</span></span><br><span class="line"><span class="comment">//体现了不可变性</span></span><br><span class="line">LocalDateTime localDateTime1 = localDateTime.withDayOfMonth(<span class="number">22</span>);</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line">System.out.println(localDateTime1);</span><br><span class="line"><span class="comment">//plusXxx():加时间操作</span></span><br><span class="line">LocalDateTime localDateTime2 = localDateTime.plusDays(<span class="number">5</span>);</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line">System.out.println(localDateTime2);</span><br><span class="line"><span class="comment">//minusXxx():减时间操作</span></span><br><span class="line">LocalDateTime localDateTime3 = localDateTime.minusDays(<span class="number">6</span>);</span><br><span class="line">System.out.println(localDateTime3);</span><br><span class="line">System.out.println(localDateTime);</span><br></pre></td></tr></table></figure></li>
<li><p> 瞬时：Instant类</p>
</li>
<li><p>Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。 </p>
</li>
<li><p>在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位。</p>
</li>
<li><p>java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。 </p>
</li>
<li><p>(1 ns = 10-9 s) 1秒 = 1000毫秒 =10^6微秒=10^9纳秒</p>
</li>
<li><p>常用方法</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><font color="red">now()</font></td>
<td align="center">静态方法，返回默认UTC时区的Instant类的对象</td>
</tr>
<tr>
<td align="center"><font color="red">ofEpochMilli(long epochMilli)</font></td>
<td align="center">静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象</td>
</tr>
<tr>
<td align="center"><font color="blue">atOffset(ZoneOffset offset)</font></td>
<td align="center">结合即时的偏移来创建一个 OffsetDateTime</td>
</tr>
<tr>
<td align="center"><font color="green">toEpochMilli()</font></td>
<td align="center">返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳</td>
</tr>
</tbody></table>
</li>
<li><p>时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//now():获取基于本初子午线对应的标准时间</span></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line">System.out.println(instant);</span><br><span class="line"><span class="comment">//atOffset()添加事件的偏移量</span></span><br><span class="line">OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">System.out.println(offsetDateTime);</span><br><span class="line"><span class="comment">//toEpochMilli()：获取自1970-1-1开始的毫秒数。</span></span><br><span class="line"><span class="keyword">long</span> milli = instant.toEpochMilli();</span><br><span class="line">System.out.println(milli);</span><br><span class="line"><span class="comment">//ofEpochMilli(long time)：通过指定的毫秒数创建Instant对象</span></span><br><span class="line">Instant instant1 = Instant.ofEpochMilli(<span class="number">1604662722362L</span>);</span><br><span class="line">System.out.println(instant1);</span><br></pre></td></tr></table></figure></li>
<li><p>DateTimeFormatter 类:格式化与解析日期或时间</p>
<ul>
<li>java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：</li>
<li> 预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</li>
<li>本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)</li>
<li>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">格式</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><font color="red">ofPattern(String pattern)</font></td>
<td align="center">静态方法 ， 返 回 一 个 指 定 字 符 串 格 式 的DateTimeFormatter</td>
</tr>
<tr>
<td align="center"><font color="purple">format(TemporalAccessor t)</font></td>
<td align="center">格式化一个日期、时间，返回字符串</td>
</tr>
<tr>
<td align="center"><font color="blue">parse(CharSequence text)</font></td>
<td align="center">将指定格式的字符序列解析为一个日期、时间</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.now();</span><br><span class="line">String string = formatter.format(localDateTime1);</span><br><span class="line">System.out.println(string);</span><br><span class="line">System.out.println(localDateTime1);</span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line">String string1 = <span class="string">&quot;2020-11-06T20:07:39.608&quot;</span>;</span><br><span class="line">TemporalAccessor parse = formatter.parse(string1);</span><br><span class="line">System.out.println(parse);</span><br><span class="line"></span><br><span class="line">DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line">String format = formatter1.format(localDateTime1);</span><br><span class="line">System.out.println(format);</span><br><span class="line"></span><br><span class="line">DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line">String format1 = formatter2.format(LocalDate.now());</span><br><span class="line">System.out.println(format1);</span><br><span class="line"></span><br><span class="line">DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line">String format2 = formatter3.format(LocalDateTime.now());</span><br><span class="line">System.out.println(format2);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>其它API</p>
</li>
<li><p>ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris</p>
</li>
<li><p>ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12-03T10:15:30+01:00 Europe/Paris。 </p>
<ul>
<li>其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如：Asia/Shanghai等 </li>
</ul>
</li>
<li><p>Clock：使用时区提供对当前即时、日期和时间的访问的时钟。 </p>
</li>
<li><p>持续时间：Duration，用于计算两个“时间”间隔</p>
</li>
<li><p>日期间隔：Period，用于计算两个“日期”间隔</p>
</li>
<li><p>TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。</p>
</li>
<li><p>TemporalAdjusters : 该类通过静态方法(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用TemporalAdjuster 的实现。</p>
<h1 id="Java比较器"><a href="#Java比较器" class="headerlink" title="Java比较器"></a>Java比较器</h1></li>
<li><p>在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题。</p>
</li>
<li><p>Java实现对象排序的方式有两种：</p>
<ul>
<li>自然排序：java.lang.Comparable接口</li>
<li> 定制排序：java.util.Comparator接口<h2 id="自然排序：java-lang-Comparable接口"><a href="#自然排序：java-lang-Comparable接口" class="headerlink" title="自然排序：java.lang.Comparable接口"></a>自然排序：java.lang.Comparable接口</h2></li>
</ul>
</li>
<li><p>Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。 </p>
</li>
<li><p>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。如果当前对象this大 于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零。 </p>
</li>
<li><p>实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 </p>
</li>
<li><p>对于类 C 的每一个 e1 和 e2 来说，当且仅当 e1.compareTo(e2) == 0 与e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals 一致。建议（虽然不是必需的）最好使自然排序与 equals 一致。</p>
</li>
<li><p>Comparable 的典型实现：(默认都是从小到大排列的) </p>
<ul>
<li>String：按照字符串中字符的Unicode值进行比较</li>
<li>Character：按照字符的Unicode值来进行比较</li>
<li>数值类型对应的包装类以及BigInteger、BigDecimal：按照它们对应的数值大小进行比较</li>
<li>Boolean：true 对应的包装类实例大于 false 对应的包装类实例</li>
<li>Date、Time等：后面的日期时间比前面的日期时间大<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;dd&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;ee&quot;</span>,<span class="string">&quot;gg&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">Person[] peoples = <span class="keyword">new</span> Person[<span class="number">5</span>];</span><br><span class="line">peoples[<span class="number">0</span>] = <span class="keyword">new</span> Person(<span class="string">&quot;aa&quot;</span>,<span class="number">18</span>);</span><br><span class="line">peoples[<span class="number">1</span>] = <span class="keyword">new</span> Person(<span class="string">&quot;bb&quot;</span>,<span class="number">32</span>);</span><br><span class="line">peoples[<span class="number">2</span>] = <span class="keyword">new</span> Person(<span class="string">&quot;cc&quot;</span>,<span class="number">21</span>);</span><br><span class="line">peoples[<span class="number">3</span>] = <span class="keyword">new</span> Person(<span class="string">&quot;dd&quot;</span>,<span class="number">53</span>);</span><br><span class="line">peoples[<span class="number">4</span>] = <span class="keyword">new</span> Person(<span class="string">&quot;ee&quot;</span>,<span class="number">32</span>);</span><br><span class="line"><span class="comment">//3.排序</span></span><br><span class="line">Arrays.sort(peoples);</span><br><span class="line">System.out.println(Arrays.toString(peoples));</span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//实现Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.重写方法</span></span><br><span class="line"><span class="comment">     * 指明对象比较大小的具体方式：按年龄从低到高进行排序,再按照姓名从大到小进行排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            Person person = (Person) o;</span><br><span class="line">            <span class="comment">//方式一</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; person.age)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; person.age)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//return 0;</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="keyword">this</span>.name.compareTo(person.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//方式二</span></span><br><span class="line">            <span class="comment">//return Integer.compare(this.age,person.age);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不一致&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定制排序：java-util-Comparator接口"><a href="#定制排序：java-util-Comparator接口" class="headerlink" title="定制排序：java.util.Comparator接口"></a>定制排序：java.util.Comparator接口</h2></li>
</ul>
</li>
<li><p>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序，强行对多个对象进行整体排序的比较。</p>
</li>
<li><p>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</p>
</li>
<li><p>可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。 </p>
</li>
<li><p>还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;dd&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;ee&quot;</span>,<span class="string">&quot;gg&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.排序时传入一个比较器</span></span><br><span class="line"><span class="comment">//这个比较器可以采用匿名对象的方式实现</span></span><br><span class="line">Arrays.sort(arr, <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.重写方法</span></span><br><span class="line"><span class="comment">     * 按照字符串从大到小排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> String &amp;&amp; o2 <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">            String string1 = (String) o1;</span><br><span class="line">            String string2 = (String) o2;</span><br><span class="line">            <span class="keyword">return</span> -string1.compareTo(string2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不一致&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">Person[] peoples = <span class="keyword">new</span> Person[<span class="number">5</span>];</span><br><span class="line">peoples[<span class="number">0</span>] = <span class="keyword">new</span> Person(<span class="string">&quot;aa&quot;</span>,<span class="number">18</span>);</span><br><span class="line">peoples[<span class="number">1</span>] = <span class="keyword">new</span> Person(<span class="string">&quot;bb&quot;</span>,<span class="number">32</span>);</span><br><span class="line">peoples[<span class="number">2</span>] = <span class="keyword">new</span> Person(<span class="string">&quot;cc&quot;</span>,<span class="number">21</span>);</span><br><span class="line">peoples[<span class="number">3</span>] = <span class="keyword">new</span> Person(<span class="string">&quot;dd&quot;</span>,<span class="number">53</span>);</span><br><span class="line">peoples[<span class="number">4</span>] = <span class="keyword">new</span> Person(<span class="string">&quot;ee&quot;</span>,<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">Arrays.sort(peoples,<span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Person &amp;&amp; o2 <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            Person person1 = (Person) o1;</span><br><span class="line">            Person person2 = (Person) o2;</span><br><span class="line">            <span class="keyword">if</span> (person1.age == person2.age)&#123;</span><br><span class="line">                <span class="keyword">return</span> -person1.name.compareTo(person2.name);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> -Integer.compare(person1.age,person2.age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不一致&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(peoples));</span><br></pre></td></tr></table></figure>
<h1 id="其他常用类"><a href="#其他常用类" class="headerlink" title="其他常用类"></a>其他常用类</h1><h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2></li>
<li><p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。 </p>
</li>
<li><p>由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。  </p>
</li>
<li><p>成员变量</p>
<ul>
<li>System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。 </li>
</ul>
</li>
<li><p>成员方法</p>
<ul>
<li>native long currentTimeMillis()： 该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</li>
<li>void exit(int status)： 该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等</li>
<li>void gc()： 该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</li>
<li>String getProperty(String key)： 该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">属性说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">java.version</td>
<td align="center">Java运行时环境版本</td>
</tr>
<tr>
<td align="center">java.home</td>
<td align="center">Java的JRE安装目录</td>
</tr>
<tr>
<td align="center">os.name</td>
<td align="center">操作系统名称</td>
</tr>
<tr>
<td align="center">os.version</td>
<td align="center">操作系统的版本</td>
</tr>
<tr>
<td align="center">user.name</td>
<td align="center">用户的账户名称</td>
</tr>
<tr>
<td align="center">user.home</td>
<td align="center">用户的主目录</td>
</tr>
<tr>
<td align="center">user.dir</td>
<td align="center">用户的当前项目的工作目录</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String javaVersion = System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;java的version:&quot;</span> + javaVersion);</span><br><span class="line">String javaHome = System.getProperty(<span class="string">&quot;java.home&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;java的home:&quot;</span> + javaHome);</span><br><span class="line">String osName = System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;os的name:&quot;</span> + osName);</span><br><span class="line">String osVersion = System.getProperty(<span class="string">&quot;os.version&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;os的version:&quot;</span> + osVersion);</span><br><span class="line">String userName = System.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;user的name:&quot;</span> + userName);</span><br><span class="line">String userHome = System.getProperty(<span class="string">&quot;user.home&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;user的home:&quot;</span> + userHome);</span><br><span class="line">String userDir = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;user的dir:&quot;</span> + userDir);</span><br></pre></td></tr></table></figure>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2></li>
</ul>
</li>
<li><p>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">abs()</td>
<td align="center">绝对值</td>
</tr>
<tr>
<td align="center">acos(),asin(),atan(),cos(),sin(),tan()</td>
<td align="center">三角函数</td>
</tr>
<tr>
<td align="center">sqrt()</td>
<td align="center">平方根</td>
</tr>
<tr>
<td align="center">pow(double a,double b)</td>
<td align="center">a的b次幂</td>
</tr>
<tr>
<td align="center">log()</td>
<td align="center">自然对数</td>
</tr>
<tr>
<td align="center">exp()</td>
<td align="center">e为底的指数</td>
</tr>
<tr>
<td align="center">max(double a,double b)</td>
<td align="center">最大值</td>
</tr>
<tr>
<td align="center">min(double a,double b)</td>
<td align="center">最小值</td>
</tr>
<tr>
<td align="center">random()</td>
<td align="center">返回0.0到1.0的随机数</td>
</tr>
<tr>
<td align="center">long round(double a)</td>
<td align="center">double型数据a转换成long型</td>
</tr>
<tr>
<td align="center">toDegrees(double angrad)</td>
<td align="center">弧度 –&gt; 角度</td>
</tr>
<tr>
<td align="center">toRadians(double angdeg)</td>
<td align="center">角度 –&gt; 弧度</td>
</tr>
</tbody></table>
<h2 id="BigInteger类与BigDecimal类"><a href="#BigInteger类与BigDecimal类" class="headerlink" title="BigInteger类与BigDecimal类"></a>BigInteger类与BigDecimal类</h2><h3 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h3></li>
<li><p>Integer类作为int的包装类，能存储的最大整型值为2^31-1，Long类也是有限的，最大为2^63-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。</p>
</li>
<li><p>java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。</p>
</li>
<li><p>另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。</p>
</li>
<li><p>构造器   </p>
<ul>
<li>BigInteger(String val)：根据字符串构建BigInteger对象</li>
</ul>
</li>
<li><p>常用方法</p>
<ul>
<li>public BigInteger abs()：返回此 BigInteger 的绝对值的 BigInteger。 </li>
<li>BigInteger add(BigInteger val) ：返回其值为 (this + val) 的 BigInteger</li>
<li>BigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigInteger</li>
<li>BigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigInteger</li>
<li>BigInteger divide(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数相除只保留整数部分。 </li>
<li>BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。 </li>
<li>BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (this / val) 后跟(this % val) 的两个 BigInteger 的数组。 </li>
<li>BigInteger pow(int exponent) ：返回其值为 (thisexponent) 的 BigInteger。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">&quot;1243351685481215471241123&quot;</span>);</span><br><span class="line">System.out.println(bi);</span><br></pre></td></tr></table></figure>
<h3 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h3></li>
</ul>
</li>
<li><p>一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。 </p>
</li>
<li><p>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p>
</li>
<li><p>构造器     </p>
<ul>
<li>public BigDecimal(double val) </li>
<li> public BigDecimal(String val) </li>
</ul>
</li>
<li><p>常用方法</p>
<ul>
<li>public BigDecimal add(BigDecimal augend)</li>
<li>public BigDecimal subtract(BigDecimal subtrahend)</li>
<li>public BigDecimal multiply(BigDecimal multiplicand)</li>
<li>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bd = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;12435.351&quot;</span>);</span><br><span class="line">BigDecimal bd2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">System.out.println(bd.divide(bd2, <span class="number">15</span>, BigDecimal.ROUND_HALF_UP));</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  String:字符串，使用一对&quot;&quot;引起来表示</span></span><br><span class="line"><span class="comment"> *      1.String声明为final的，不可以被继承</span></span><br><span class="line"><span class="comment"> *      2.String实现了Serializable接口，表示字符串是支持序列化的，因此它可以被网络传输</span></span><br><span class="line"><span class="comment"> *              实现了Comparable接口：表示String可以比较大小</span></span><br><span class="line"><span class="comment"> *      3.String内部定义了final char[] value用于存储字符串数据</span></span><br><span class="line"><span class="comment"> *      4.String：代表不可变的字符序列。简称：不可变性。</span></span><br><span class="line"><span class="comment"> *          体现：1.当对字符串重新赋值时，需要重新开一片空间进行赋值，不会使用原有的空间进行赋值。</span></span><br><span class="line"><span class="comment"> *               2.当对现有的字符串进行连接操作时，会重新开一片空间存放连接后的值，不会让原有的空间存放连接后的值。</span></span><br><span class="line"><span class="comment"> *               3.当调用String的replace()方法修改指定字符或字符串时，也会会重新开一片空间存放修改后的值，不会让原有的</span></span><br><span class="line"><span class="comment"> *                 空间存放连接后的值。</span></span><br><span class="line"><span class="comment"> *          总结：当创建很多字符串，让他们的值都是一样的时候，它们在内存中指向的都是同一个区域。</span></span><br><span class="line"><span class="comment"> *             当修改字符串(无论是拼接替换等等)，都是在内存中重新开辟一片空间存放新的字符串。</span></span><br><span class="line"><span class="comment"> *      5.通过字面量的方式(区别于new方式)给一个字符串赋值，此时的字符串值声明在字符串常量池(值具有唯一性)中</span></span><br><span class="line"><span class="comment"> *      6.字符串常量池中是不会存储相同内容的字符串的。</span></span><br><span class="line"><span class="comment"> *  String实例化方式：</span></span><br><span class="line"><span class="comment"> *      方式一：通过字面量定义的方式。 例 String str=&quot;asd&quot;;</span></span><br><span class="line"><span class="comment"> *      方式二：通过new+构造器的方式。 例 String str=new String();</span></span><br><span class="line"><span class="comment"> *      面试题：String s = new String(&quot;abc&quot;)，这句代码在内存中创建了几个对象？</span></span><br><span class="line"><span class="comment"> *          两个：一个是堆空间中new结构，另一个是char[]对应的常量池中的数据</span></span><br><span class="line"><span class="comment"> *       String中的常见构造方式</span></span><br><span class="line"><span class="comment"> *          public String() &#123;&#125;  &lt;--&gt; 本质上相当于this.value = new char[0]。注意char数组的长度为0.</span></span><br><span class="line"><span class="comment"> *          public String(String original) &#123;&#125;  &lt;--&gt; 本质上相当于this.value = original.value;</span></span><br><span class="line"><span class="comment"> *          public String(char value[]) &#123;&#125; &lt;--&gt; 本质上相当于this.value = </span></span><br><span class="line"><span class="comment"> *             Arrays.copyOf(value,value.length);</span></span><br><span class="line"><span class="comment"> *          public String(char value[], int offset, int count) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *  String字面量的实例化结论</span></span><br><span class="line"><span class="comment"> *      1.常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量</span></span><br><span class="line"><span class="comment"> *      2.拼接字符串时，只要其中一个是变量，则拼接后的字符串就在堆中</span></span><br><span class="line"><span class="comment"> *      3.如果拼接的结果调用intern()方法，方法的返回值的字符串实在常量池中</span></span><br><span class="line"><span class="comment"> *  String与其他数据类型之间的转换</span></span><br><span class="line"><span class="comment"> *      String --&gt; 基本数据类型变量: 调用基本数据类型的包装类.parseXxx(String string);</span></span><br><span class="line"><span class="comment"> *      基本数据类型变量 --&gt; String: 调用String.valueOf(Xxx xx);</span></span><br><span class="line"><span class="comment"> *      String --&gt; char[]: 使用&quot;变量名.toCharArray()&quot;转换成char数组</span></span><br><span class="line"><span class="comment"> *      char[] --&gt; String: 调用String的构造器</span></span><br><span class="line"><span class="comment"> *      编码：String --&gt; byte[]: 调用String的getBytes()</span></span><br><span class="line"><span class="comment"> *      解码：byte[] --&gt;String: 调用String的构造器</span></span><br><span class="line"><span class="comment"> *          注意：解码时，字符集的解码方式要和编码方式一致</span></span><br><span class="line"><span class="comment"> *  String与StringBuffer，StringBuilder的区别</span></span><br><span class="line"><span class="comment"> *      String:</span></span><br><span class="line"><span class="comment"> *          不可变的字符序列(final char[]),</span></span><br><span class="line"><span class="comment"> *          底层使用char[]存储</span></span><br><span class="line"><span class="comment"> *          可以通过字面量的方式赋值，因此这个类型的字符串可能在堆中，也可能在字符串常量池中</span></span><br><span class="line"><span class="comment"> *      StringBuffer:</span></span><br><span class="line"><span class="comment"> *          可变的字符序列(transient char[])；</span></span><br><span class="line"><span class="comment"> *          线程安全的(大部分的方法都用synchronized修饰)，效率低；</span></span><br><span class="line"><span class="comment"> *          底层使用char[]存储</span></span><br><span class="line"><span class="comment"> *          不能通过字面量的方式赋值，也意味着这个类型的字符串只能在堆空间中</span></span><br><span class="line"><span class="comment"> *      StringBuilder:</span></span><br><span class="line"><span class="comment"> *          可变的字符序列(transient char[])；</span></span><br><span class="line"><span class="comment"> *          线程不安全的(方法不都用synchronized修饰)，效率高；</span></span><br><span class="line"><span class="comment"> *          底层使用char[]存储</span></span><br><span class="line"><span class="comment"> *          不能通过字面量的方式赋值，也意味着这个类型的字符串只能在堆空间中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          StringBuffer和StringBuilder的方法大致相同，不同的是StringBuffer的方法被synchronized修饰，</span></span><br><span class="line"><span class="comment"> *          StringBuffer str1 = new StringBuffer(); --&gt; char[] = new char[16];</span></span><br><span class="line"><span class="comment"> *          StringBuffer str2 = new StringBuffer(&quot;abc&quot;); --&gt; char[] = new char[3+16];</span></span><br><span class="line"><span class="comment"> *          str1.length() --&gt; 返回0</span></span><br><span class="line"><span class="comment"> *          str2.length() --&gt; 返回3</span></span><br><span class="line"><span class="comment"> *          扩容问题：如果要添加的数据底层数组盛不下了，那么就需要扩容底层的数组。</span></span><br><span class="line"><span class="comment"> *              默认情况下，扩容为原来容量的2倍+2，同时将原有数组中的元素复制到新的数组中</span></span><br><span class="line"><span class="comment"> *          StringBuffer和StringBuilder中都有一个可一个可以指明初始数组大小的构造器</span></span><br><span class="line"><span class="comment"> *      实际工作中建议使用StringBuffer()和StringBuilder()</span></span><br><span class="line"><span class="comment"> *      StringBuffer和StringBuilder比String多出的几个常用的方法</span></span><br><span class="line"><span class="comment"> *          增：append(xxx);</span></span><br><span class="line"><span class="comment"> *          删：delete(int start,int end);</span></span><br><span class="line"><span class="comment"> *          改：setCharAt(int n,char ch);/replace(int start,int end,String str)</span></span><br><span class="line"><span class="comment"> *          查：charAt(int n)</span></span><br><span class="line"><span class="comment"> *          插：insert(int offset,xxx)</span></span><br><span class="line"><span class="comment"> *          长度：length()</span></span><br><span class="line"><span class="comment"> *  String与StringBuffer，StringBuilder的效率的差别</span></span><br><span class="line"><span class="comment"> *      String &lt;&lt;&lt; StringBuffer &lt; StringBuilder</span></span><br><span class="line"><span class="comment"> *      实际的一次记录：StringBuffer的执行时间：4</span></span><br><span class="line"><span class="comment"> *                   StringBuilder的执行时间：1</span></span><br><span class="line"><span class="comment"> *                   String的执行时间：1057</span></span><br><span class="line"><span class="comment"> * 时间日期的常用类</span></span><br><span class="line"><span class="comment"> *  System.currentTimeMillis()：返回从1970年1月1日到现在过去了多少毫秒，类型为long。</span></span><br><span class="line"><span class="comment"> *      这个毫秒数一般成为时间戳</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  java.util.Date类</span></span><br><span class="line"><span class="comment"> *      |--java.sql.Date类</span></span><br><span class="line"><span class="comment"> *  关系：java.sql.Date类是java.util.Date类的子类</span></span><br><span class="line"><span class="comment"> *  java.util.Date类</span></span><br><span class="line"><span class="comment"> *      1.两个构造器的使用：</span></span><br><span class="line"><span class="comment"> *          Date():创建一个对应当前时间的Date对象</span></span><br><span class="line"><span class="comment"> *          Date(long time):创建指定毫秒数的Date对象</span></span><br><span class="line"><span class="comment"> *      2.两个方法的使用</span></span><br><span class="line"><span class="comment"> *          toString():显示对象的年，月，日，时，分，秒，星期</span></span><br><span class="line"><span class="comment"> *          getTime():返回对象对应的毫秒数</span></span><br><span class="line"><span class="comment"> *   java.sql.Date类</span></span><br><span class="line"><span class="comment"> *      1.它对应者数据库中的日期类型</span></span><br><span class="line"><span class="comment"> *      2.构造方法只有一个</span></span><br><span class="line"><span class="comment"> *          Date(long time):创建指定毫秒数的Date对象</span></span><br><span class="line"><span class="comment"> *      3.toString()方法：只返回年，月，日</span></span><br><span class="line"><span class="comment"> *      4.如何将java.util.Date类的对象转换成java.sql.Date类的对象</span></span><br><span class="line"><span class="comment"> *          先调用java.util.Date类的对象的getTime()获取时间戳</span></span><br><span class="line"><span class="comment"> *          然后根据java.sql.Date类的构造器创建对象</span></span><br><span class="line"><span class="comment"> *  SimpleDateFormat类：常用于对Date的格式化和解析</span></span><br><span class="line"><span class="comment"> *      格式化：日期 ---&gt;字符串</span></span><br><span class="line"><span class="comment"> *             通过format(date)方法。</span></span><br><span class="line"><span class="comment"> *      解析：字符串 ---&gt;日期。</span></span><br><span class="line"><span class="comment"> *             通过parse(string)方法。</span></span><br><span class="line"><span class="comment"> *          注意：要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现)，否则抛异常</span></span><br><span class="line"><span class="comment"> *  Calendar类：日历类(抽象类)的使用</span></span><br><span class="line"><span class="comment"> *      实例化方法：</span></span><br><span class="line"><span class="comment"> *          创建其子类 GregorianCalendar 的对象</span></span><br><span class="line"><span class="comment"> *          调用Calendar类的静态方法getInstance()   //常用这个方法</span></span><br><span class="line"><span class="comment"> *      常用方法</span></span><br><span class="line"><span class="comment"> *              field可以传Calendar.DAY_OF_MONTH等等</span></span><br><span class="line"><span class="comment"> *          set(field,value):设置field的值为value,</span></span><br><span class="line"><span class="comment"> *          get(field)：获取field的值。</span></span><br><span class="line"><span class="comment"> *          add(field,value)：将field的值加上value</span></span><br><span class="line"><span class="comment"> *          setTime(Date): Date --&gt; 日历类</span></span><br><span class="line"><span class="comment"> *          Date getTime(): 日历类 --&gt; Date</span></span><br><span class="line"><span class="comment"> *       注意：</span></span><br><span class="line"><span class="comment"> *          获取月份时：一月是0，二月是1，三月是2.。。。12月是11</span></span><br><span class="line"><span class="comment"> *          获取星期时：周日是1，周一是2，。。。周六是7</span></span><br><span class="line"><span class="comment"> *  LocalDate,LocalTime和LocalDateTime的使用</span></span><br><span class="line"><span class="comment"> *      1.实例化方法</span></span><br><span class="line"><span class="comment"> *          now()：获取当前的日期，时间，日期+时间</span></span><br><span class="line"><span class="comment"> *              例如：LocalDateTime.now();</span></span><br><span class="line"><span class="comment"> *      2.of():设置指定的年，月，日，时，分，秒。</span></span><br><span class="line"><span class="comment"> *          例如：LocalDateTime of = LocalDateTime.of(2020, 11, 1, 10, 5, 20);</span></span><br><span class="line"><span class="comment"> *      3.getXxx()：获取一些时间的信息</span></span><br><span class="line"><span class="comment"> *          例如：localDateTime.getDayOfMonth()</span></span><br><span class="line"><span class="comment"> *      4.withXxx()：设置一些时间的信息，返回新的对象</span></span><br><span class="line"><span class="comment"> *          例如：LocalDateTime localDateTime1 = localDateTime.withDayOfMonth(22);</span></span><br><span class="line"><span class="comment"> *      5.plusXxx():加时间操作</span></span><br><span class="line"><span class="comment"> *          例如：LocalDateTime localDateTime2 = localDateTime.plusDays(5);</span></span><br><span class="line"><span class="comment"> *      6.minusXxx():减时间操作</span></span><br><span class="line"><span class="comment"> *          例如：LocalDateTime localDateTime3 = localDateTime.minusDays(6);</span></span><br><span class="line"><span class="comment"> *    说明</span></span><br><span class="line"><span class="comment"> *      1.LocalDateTime较于LocalDate,LocalTime更常用</span></span><br><span class="line"><span class="comment"> *      2.类似于Calendar</span></span><br><span class="line"><span class="comment"> *  Instant类的应用</span></span><br><span class="line"><span class="comment"> *      Instant：瞬时</span></span><br><span class="line"><span class="comment"> *      1.now():获取基于本初子午线对应的标准时间</span></span><br><span class="line"><span class="comment"> *           Instant instant = Instant.now();</span></span><br><span class="line"><span class="comment"> *      2.atOffset()：添加事件的偏移量</span></span><br><span class="line"><span class="comment"> *           OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8));</span></span><br><span class="line"><span class="comment"> *      3.toEpochMilli()：获取自1970-1-1开始的毫秒数。</span></span><br><span class="line"><span class="comment"> *           long milli = instant.toEpochMilli();</span></span><br><span class="line"><span class="comment"> *      4.ofEpochMilli(long time)：通过指定的毫秒数创建Instant对象</span></span><br><span class="line"><span class="comment"> *           Instant instant1 = Instant.ofEpochMilli(1604662722362L);</span></span><br><span class="line"><span class="comment"> *  DateTimeFormatter类的应用</span></span><br><span class="line"><span class="comment"> *      类似于SimpleDateFormat。</span></span><br><span class="line"><span class="comment"> *      有三种类别的创建实例的方法</span></span><br><span class="line"><span class="comment"> *      常用自己指定格式的的方法来创建实例：ofPattern(String);</span></span><br><span class="line"><span class="comment"> * 比较器的应用</span></span><br><span class="line"><span class="comment"> *  一，Java中的对象，正常情况下只能进行地址的比较：== 或 !=。不能使用 &gt;或 &lt;。</span></span><br><span class="line"><span class="comment"> *  但是在实际开发过程中，我们需要对多个对象进行排序，言外之意就是比较对象的大小。</span></span><br><span class="line"><span class="comment"> *  如何实现? 答：使用两个接口中的一个：Comparable接口 或 Comparator接口</span></span><br><span class="line"><span class="comment"> *  二，Comparable的使用  自然排序</span></span><br><span class="line"><span class="comment"> *      1.像String,包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式</span></span><br><span class="line"><span class="comment"> *      2.像String,包装类等重写了compareTo(obj)方法以后，进行了从小到大的排列</span></span><br><span class="line"><span class="comment"> *      3.重写compareTo(obj)方法的规则</span></span><br><span class="line"><span class="comment"> *          如果当前对象this大于形参对象obj,则返回正整数；</span></span><br><span class="line"><span class="comment"> *          如果当前对象this小于形参对象obj,则返回负整数；</span></span><br><span class="line"><span class="comment"> *          如果当前对象this等于形参对象obj,则返回零；</span></span><br><span class="line"><span class="comment"> *      4.使用步骤</span></span><br><span class="line"><span class="comment"> *          ① 将对象实现Comparable接口，然后重写compareTo(obj)方法，在方法中编写排序的规则</span></span><br><span class="line"><span class="comment"> *          ② 创建对象的数组，调用Arrays.sort(对象数组)方法。然后就排好了。</span></span><br><span class="line"><span class="comment"> *  三，Comparator的使用 定制排序</span></span><br><span class="line"><span class="comment"> *      1.当对象没有实现Comparable接口而又不方便修改代码</span></span><br><span class="line"><span class="comment"> *         或已经实现了Comparable接口而又像采用其他的排序方式</span></span><br><span class="line"><span class="comment"> *         那么可以考虑使用Comparator接口的对象来排序</span></span><br><span class="line"><span class="comment"> *      2. 重写compare(Object o1,Object o2)方法，比较o1,o2的大小</span></span><br><span class="line"><span class="comment"> *          如果o1在o2前面则返回值正整数</span></span><br><span class="line"><span class="comment"> *          如果o1在o2后面则返回值负整数</span></span><br><span class="line"><span class="comment"> *          如果o1在o2相同则返回值零</span></span><br><span class="line"><span class="comment"> *  四，Comparable接口 和 Comparator接口 的区别</span></span><br><span class="line"><span class="comment"> *      1. 对象实现了Comparable接口后，其排序的方式也就确认了。</span></span><br><span class="line"><span class="comment"> *          Comparator接口不需要对象实现，因此用匿名对象的方式来确定排序的方法</span></span><br><span class="line"><span class="comment"> *      2.Comparable接口中的比较方法是当前对象this和形参的比较</span></span><br><span class="line"><span class="comment"> *          Comparator接口中的比较方法是两个形参之间的比较</span></span><br><span class="line"><span class="comment"> * 其他常用类的使用</span></span><br><span class="line"><span class="comment"> * 一，System类</span></span><br><span class="line"><span class="comment"> *      系统的类，可以获取系统的信息，或者让系统做一些操作</span></span><br><span class="line"><span class="comment"> * 二，Math类</span></span><br><span class="line"><span class="comment"> *      对数据的操作的类，包含所有对数进行操作的方法，包括一些公式</span></span><br><span class="line"><span class="comment"> * 三，BigInteger类</span></span><br><span class="line"><span class="comment"> *      整数类型int无法表示太大的数，因此可以使用BigInteger来表示。</span></span><br><span class="line"><span class="comment"> *      BigInteger可以定义一些不可改变的无限大小的整数</span></span><br><span class="line"><span class="comment"> *      实例化方法 BigInteger(String val)</span></span><br><span class="line"><span class="comment"> * 四，BigDecimal类</span></span><br><span class="line"><span class="comment"> *      小数类型double,float无法表示太精确的小数，因此可以使用BigDecimal来表示。</span></span><br><span class="line"><span class="comment"> *       BigInteger可以定义一些不可改变的不限精度的小数</span></span><br><span class="line"><span class="comment"> *      实例化方法 BigDecimal(String val)</span></span><br><span class="line"><span class="comment"> *      注意：当输出的小数是无限小数时，需要给出要保留的小数位</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

    </div>

    
    
    


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/07/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/6-IO%E6%B5%81/" rel="prev" title="IO流">
      <i class="fa fa-chevron-left"></i> IO流
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/07/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/Java8%E9%83%A8%E5%88%86%E6%96%B0%E7%89%B9%E6%80%A7/" rel="next" title="Java8新特性">
      Java8新特性 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text">字符串相关的类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">String的特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StringBuffer%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">StringBuffer类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StringBuilder%E7%B1%BB"><span class="nav-number">1.3.</span> <span class="nav-text">StringBuilder类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API"><span class="nav-number">2.</span> <span class="nav-text">日期时间API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK8%E4%B9%8B%E5%89%8D%E7%9A%84"><span class="nav-number">2.1.</span> <span class="nav-text">JDK8之前的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK8%E4%BB%A5%E5%90%8E%E7%9A%84"><span class="nav-number">2.2.</span> <span class="nav-text">JDK8以后的</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E6%AF%94%E8%BE%83%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">Java比较器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F%EF%BC%9Ajava-lang-Comparable%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.1.</span> <span class="nav-text">自然排序：java.lang.Comparable接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F%EF%BC%9Ajava-util-Comparator%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.2.</span> <span class="nav-text">定制排序：java.util.Comparator接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">其他常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#System%E7%B1%BB"><span class="nav-number">4.1.</span> <span class="nav-text">System类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math%E7%B1%BB"><span class="nav-number">4.2.</span> <span class="nav-text">Math类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BigInteger%E7%B1%BB%E4%B8%8EBigDecimal%E7%B1%BB"><span class="nav-number">4.3.</span> <span class="nav-text">BigInteger类与BigDecimal类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BigInteger%E7%B1%BB"><span class="nav-number">4.3.1.</span> <span class="nav-text">BigInteger类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BigDecimal%E7%B1%BB"><span class="nav-number">4.3.2.</span> <span class="nav-text">BigDecimal类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Plum Reiver</p>
  <div class="site-description" itemprop="description">技术，日常，笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
	
  </nav>
</div>


      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plum Reiver</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
