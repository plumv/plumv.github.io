<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"plumv.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="Lambda表达式,函数式接口，空指针处理，StreamAPI集合">
<meta property="og:type" content="article">
<meta property="og:title" content="Java8新特性">
<meta property="og:url" content="https://plumv.github.io/2020/12/07/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/Java8%E9%83%A8%E5%88%86%E6%96%B0%E7%89%B9%E6%80%A7/index.html">
<meta property="og:site_name" content="李川的个人博客">
<meta property="og:description" content="Lambda表达式,函数式接口，空指针处理，StreamAPI集合">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184450.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184451.png">
<meta property="article:published_time" content="2020-12-06T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-20T12:12:10.528Z">
<meta property="article:author" content="Plum Reiver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184450.png">

<link rel="canonical" href="https://plumv.github.io/2020/12/07/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/Java8%E9%83%A8%E5%88%86%E6%96%B0%E7%89%B9%E6%80%A7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java8新特性 | 李川的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李川的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>日志</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://plumv.github.io/2020/12/07/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/Java8%E9%83%A8%E5%88%86%E6%96%B0%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plum Reiver">
      <meta itemprop="description" content="技术，日常，笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李川的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java8新特性
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-07 00:00:00" itemprop="dateCreated datePublished" datetime="2020-12-07T00:00:00+08:00">2020-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-20 20:12:10" itemprop="dateModified" datetime="2021-03-20T20:12:10+08:00">2021-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">Java高级语法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Lambda表达式,函数式接口，空指针处理，StreamAPI集合</p>
<span id="more"></span>
<p>Java8新特性简介</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184450.png"></p>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><ul>
<li><p>Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p>
</li>
<li><p>从匿名类到 Lambda 的转换举例1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来的写法</span></span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">runnable.run();</span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"><span class="comment">//Lambda表达式的写法一</span></span><br><span class="line">Runnable runnable2 = () -&gt; System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">runnable2.run();</span><br></pre></td></tr></table></figure></li>
<li><p>从匿名类到 Lambda 的转换举例2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来的写法</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator1 = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(comparator1.compare(<span class="number">12</span>, <span class="number">34</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;*****************&quot;</span>);</span><br><span class="line"><span class="comment">//lambda写法</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator2 = (o1,o2) -&gt; Integer.compare(o1,o2);</span><br><span class="line">System.out.println(comparator2.compare(<span class="number">54</span>, <span class="number">34</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;*****************&quot;</span>);</span><br><span class="line"><span class="comment">//方法引用的写法</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator3 = Integer::compare;</span><br><span class="line">System.out.println(comparator3.compare(<span class="number">4</span>, <span class="number">54</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。<br>这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符或箭头操作符。</p>
</li>
<li><p>它将 Lambda 分为两个部分：</p>
<ul>
<li>左侧：指定了 Lambda 表达式需要的参数列表</li>
<li>右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即Lambda 表达式要执行的功能</li>
</ul>
</li>
<li><p>语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.无参，无返回值</span></span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">runnable.run();</span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">runnable2.run();</span><br><span class="line"><span class="comment">//2.有参数，无返回值</span></span><br><span class="line">Consumer&lt;String&gt; consumer = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">consumer.accept(<span class="string">&quot;格式二:正常情况&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line">Consumer&lt;String&gt; consumer2 = (String s) -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;;</span><br><span class="line">consumer2.accept(<span class="string">&quot;格式二:Lambda&quot;</span>);</span><br><span class="line"><span class="comment">//3.数据类型可以省略，因为可由编译器推断得出，称为“类型推断”;</span></span><br><span class="line">Consumer&lt;String&gt; consumer3 = (String s) -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;;</span><br><span class="line">consumer3.accept(<span class="string">&quot;格式三:&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line">Consumer&lt;String&gt; consumer4 = (s) -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;;</span><br><span class="line">consumer4.accept(<span class="string">&quot;格式三:Lambda&quot;</span>);</span><br><span class="line"><span class="comment">//4.只有一个参数，没有返回值，小括号也可以省略</span></span><br><span class="line">Consumer&lt;String&gt; consumer5 = (s) -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;;</span><br><span class="line">consumer5.accept(<span class="string">&quot;格式四:Lambda&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line">Consumer&lt;String&gt; consumer6 = s -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;;</span><br><span class="line">consumer6.accept(<span class="string">&quot;格式四:Lambda&quot;</span>);</span><br><span class="line"><span class="comment">//5.有多个参数，多条执行语句，且有返回值</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator1 = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(comparator1.compare(<span class="number">12</span>, <span class="number">34</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;*****************&quot;</span>);</span><br><span class="line">Comparator&lt;Integer&gt; comparator2 = (o1,o2) -&gt; &#123;</span><br><span class="line">    System.out.println(o1);</span><br><span class="line">    System.out.println(o2);</span><br><span class="line">    <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(comparator2.compare(<span class="number">54</span>, <span class="number">34</span>));</span><br><span class="line"><span class="comment">//6.若只有一条执行语句，return和大括号若有可以省略</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator3 = (o1,o2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(comparator3.compare(<span class="number">54</span>, <span class="number">34</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;*****************&quot;</span>);</span><br><span class="line">Comparator&lt;Integer&gt; comparator4 = (o1,o2) -&gt; Integer.compare(o1,o2);</span><br><span class="line">System.out.println(comparator4.compare(<span class="number">54</span>, <span class="number">34</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>上述 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的“类型推断”。</li>
</ul>
</li>
</ul>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><ul>
<li>只包含一个抽象方法的接口，称为函数式接口。 </li>
<li>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。</li>
<li>我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</li>
<li>在java.util.function包下定义了Java 8 的丰富的函数式接口</li>
<li>如何理解函数式接口<ul>
<li>Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还可以支持OOF（面向函数编程） </li>
<li>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。 </li>
<li>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。</li>
<li>所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。</p>
</li>
<li><p>Java 内置四大核心函数式接口</p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer<T>消费型接口</td>
<td>T</td>
<td>void</td>
<td>对类型为T的对象应用操作，包含方法：void accept(T t)</td>
</tr>
<tr>
<td>Supplier<T>供给型接口</td>
<td>无</td>
<td>T</td>
<td>返回类型为T的对象，包含方法：T get()</td>
</tr>
<tr>
<td>Function&lt;T, R&gt;函数型接口</td>
<td>T</td>
<td>R</td>
<td>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t)</td>
</tr>
<tr>
<td>Predicate<T>断定型接口</td>
<td>T</td>
<td>boolean</td>
<td>确定类型为T的对象是否满足某约束，并返回boolean 值。包含方法：boolean test(T t)</td>
</tr>
</tbody></table>
</li>
<li><p>其他接口</p>
<table>
<thead>
<tr>
<th align="center">函数式接口</th>
<th align="center">参数类型</th>
<th align="center">返回类型</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BiFunction&lt;T, U, R&gt;</td>
<td align="center">T, U</td>
<td align="center">R</td>
<td align="center">对类型为 T, U 参数应用操作，返回 R 类型的结果。包含方法为： R apply(T t, U u);</td>
</tr>
<tr>
<td align="center">UnaryOperator<T>(Function子接口)</td>
<td align="center">T</td>
<td align="center">T</td>
<td align="center">对类型为T的对象进行一元运算，并返回T类型的结果。包含方法为：T apply(T t);</td>
</tr>
<tr>
<td align="center">BinaryOperator<T>(BiFunction 子接口)</td>
<td align="center">T,T</td>
<td align="center">T</td>
<td align="center">对类型为T的对象进行二元运算，并返回T类型的结果。包含方法为： T apply(T t1, T t2);</td>
</tr>
<tr>
<td align="center">BiConsumer&lt;T, U&gt;</td>
<td align="center">T, U</td>
<td align="center">void</td>
<td align="center">对类型为T, U 参数应用操作。包含方法为： void accept(T t, U u)</td>
</tr>
<tr>
<td align="center">BiPredicate&lt;T,U&gt;</td>
<td align="center">T, U</td>
<td align="center">boolean</td>
<td align="center">包含方法为： boolean test(T t,U u)</td>
</tr>
<tr>
<td align="center">ToIntFunction<T><br/>ToLongFunction<T><br/>ToDoubleFunction<T></td>
<td align="center">T</td>
<td align="center">int<br/>long<br/>double</td>
<td align="center">分别计算int、long、double值的函数</td>
</tr>
<tr>
<td align="center">IntFunction<R><br/>LongFunction<R><br/>DoubleFunction<R></td>
<td align="center">int<br/>long<br/>double</td>
<td align="center">R</td>
<td align="center">参数分别为int、long、double 类型的函数</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h1><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><ul>
<li>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</li>
<li>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</li>
<li>要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！</li>
<li>格式：使用操作符 “::” 将类(或对象) 与 方法名分隔开来。</li>
<li>如下三种主要使用情况： <ul>
<li>对象::实例方法名</li>
<li>类::静态方法名</li>
<li>类::实例方法名</li>
</ul>
</li>
<li>注意：当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二个参数是需要引用方法的参数(或无参数)时：ClassName::methodName</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一： 对象 :: 实例方法</span></span><br><span class="line"><span class="comment">//Consumer中的void accept(T t)</span></span><br><span class="line"><span class="comment">//PrintStream中的void println(T t)</span></span><br><span class="line">Consumer&lt;String&gt; consumer = string -&gt; System.out.println(string);</span><br><span class="line">consumer.accept(<span class="string">&quot;背景&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;*****************&quot;</span>);</span><br><span class="line">PrintStream out = System.out;</span><br><span class="line">Consumer&lt;String&gt; consumer1 =out::println;</span><br><span class="line">consumer1.accept(<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二： 类 :: 静态方法</span></span><br><span class="line"><span class="comment">//Comparator中的int compare(T t1,T t2)</span></span><br><span class="line"><span class="comment">//Integer中的int compare(T t1,T t2)</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator = (t1,t2) -&gt; Integer.compare(t1,t2);</span><br><span class="line">System.out.println(comparator.compare(<span class="number">12</span>,<span class="number">35</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;********************&quot;</span>);</span><br><span class="line">Comparator&lt;Integer&gt; comparator1 = Integer::compareTo;</span><br><span class="line">System.out.println(comparator1.compare(<span class="number">12</span>,<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况三： 类 :: 实例方法</span></span><br><span class="line"><span class="comment">//Comparator中的int compare(T t1,T t2)</span></span><br><span class="line"><span class="comment">//String中的int t1.compareTo(t2);</span></span><br><span class="line">Comparator&lt;String&gt; comparator = (t1, t2) -&gt; t1.compareTo(t2);</span><br><span class="line">System.out.println(comparator.compare(<span class="string">&quot;as&quot;</span>, <span class="string">&quot;zx&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;******************&quot;</span>);</span><br><span class="line">Comparator&lt;String&gt; comparator1 = String::compareTo;</span><br><span class="line">System.out.println(comparator1.compare(<span class="string">&quot;ds&quot;</span>, <span class="string">&quot;re&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><ul>
<li>格式： ClassName::new </li>
<li>与函数式接口相结合，自动与函数式接口中方法兼容。</li>
<li>可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器引用</span></span><br><span class="line">Supplier&lt;Person&gt; supplier = ()-&gt;<span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(supplier.get());</span><br><span class="line">System.out.println(<span class="string">&quot;*************&quot;</span>);</span><br><span class="line">Supplier&lt;Person&gt; supplier1 = Person :: <span class="keyword">new</span>;</span><br><span class="line">System.out.println(supplier1.get());</span><br></pre></td></tr></table></figure>

<h2 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h2><ul>
<li>格式： type[] :: new</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组引用</span></span><br><span class="line">Function&lt;Integer,String[]&gt; function = length -&gt; <span class="keyword">new</span> String[length];</span><br><span class="line">String[] arr1 = function.apply(<span class="number">5</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line">System.out.println(<span class="string">&quot;********************&quot;</span>);</span><br><span class="line">Function&lt;Integer,String[]&gt; function1 = String[]::<span class="keyword">new</span>;</span><br><span class="line">String[] arr2 = function1.apply(<span class="number">10</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr2));</span><br></pre></td></tr></table></figure>

<h1 id="StreamAPI"><a href="#StreamAPI" class="headerlink" title="StreamAPI"></a>StreamAPI</h1><ul>
<li><p>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API。 </p>
</li>
<li><p>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 </p>
</li>
<li><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p>
</li>
<li><p>Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p>
</li>
<li><p>Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</p>
</li>
<li><p>“集合讲的是数据，Stream讲的是计算！”</p>
</li>
<li><p>注意：</p>
<ul>
<li>①Stream 自己不会存储元素。</li>
<li>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 </li>
<li>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li>
</ul>
</li>
<li><p>Stream 的操作三个步骤</p>
<ul>
<li>创建 Stream<ul>
<li>一个数据源（如：集合、数组），获取一个流</li>
</ul>
</li>
<li>中间操作<ul>
<li>一个中间操作链，对数据源的数据进行处理</li>
</ul>
</li>
<li>终止操作(终端操作)<ul>
<li>一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184451.png"></p>
</li>
<li><p>创建 Stream方式一：通过集合</p>
<ul>
<li>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法： <ul>
<li>default Stream<E> stream() : 返回一个顺序流</li>
<li>default Stream<E> parallelStream() : 返回一个并行流</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：通过集合</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//default Stream&lt;E&gt; stream()：返回一个顺序流</span></span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line"><span class="comment">//default Stream&lt;E&gt; parallelStream()：返回一个并行流</span></span><br><span class="line">Stream&lt;Integer&gt; integerStream = list.parallelStream();</span><br></pre></td></tr></table></figure></li>
<li><p>创建 Stream方式二：通过数组</p>
<ul>
<li>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：</li>
<li>static <T> Stream<T> stream(T[] array): 返回一个流</li>
<li>重载形式，能够处理对应基本类型的数组：<ul>
<li>public static IntStream stream(int[] array)</li>
<li>public static LongStream stream(long[] array)</li>
<li>public static DoubleStream stream(double[] array)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式二：通过数组</span></span><br><span class="line"><span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//static &lt;T&gt;Stream&lt;T&gt; stream(T[] array)：返回一个流</span></span><br><span class="line">IntStream stream1 = Arrays.stream(ints);</span><br></pre></td></tr></table></figure></li>
<li><p>创建 Stream方式三：通过Stream的of()</p>
<ul>
<li>可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数。</li>
<li>public static<T> Stream<T> of(T… values) : 返回一个流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式三：通过Stream的of()</span></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.of(<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>创建 Stream方式四：创建无限流</p>
<ul>
<li>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</li>
<li>迭代<ul>
<li>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) </li>
</ul>
</li>
<li>生成<ul>
<li>public static<T> Stream<T> generate(Supplier<T> s)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式四：创建无限流</span></span><br><span class="line"><span class="comment">//迭代的方式：遍历前10个偶数</span></span><br><span class="line"><span class="comment">//iterate(T seed, UnaryOperator&lt;T&gt; f)：seed:种子，初始值。f：要执行的操作</span></span><br><span class="line"><span class="comment">//limit(long maxSize)：maxSize:限制执行的次数</span></span><br><span class="line"><span class="comment">//forEach(Consumer&lt;? super T&gt; action)：action：终止操作，终止后执行的操作</span></span><br><span class="line">Stream.iterate(<span class="number">0</span>, t-&gt;t+<span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//生成的方式：生成10个随机数</span></span><br><span class="line">Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li><p>Stream 的中间操作</p>
<ul>
<li>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</li>
<li>1-筛选与切片</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方 法</th>
<th align="center">描 述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">filter(Predicate p)</td>
<td align="center">接收 Lambda ， 从流中排除某些元素</td>
</tr>
<tr>
<td align="center">distinct()</td>
<td align="center">筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</td>
</tr>
<tr>
<td align="center">limit(long maxSize)</td>
<td align="center">截断流，使其元素不超过给定数量</td>
</tr>
<tr>
<td align="center">skip(long n)</td>
<td align="center">跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line">list.add(<span class="number">7</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//筛选和切片</span></span><br><span class="line"><span class="comment">//Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)：接受Lambda，从流中排除一些元素</span></span><br><span class="line"><span class="comment">//输出list中值大于4的数</span></span><br><span class="line">list.stream().filter(i-&gt;(i&gt;<span class="number">4</span>)).forEach(System.out::println);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//Stream&lt;T&gt; limit(long maxSize)：截断流，使其元素不超过给定的数量</span></span><br><span class="line"><span class="comment">//输出前2个元素</span></span><br><span class="line">list.stream().limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//Stream&lt;T&gt; distinct()：筛选，通过流所生成元素的hashCode()和equals()方法去除重复元素</span></span><br><span class="line">list.add(<span class="number">9</span>);</span><br><span class="line">list.add(<span class="number">9</span>);</span><br><span class="line">list.add(<span class="number">9</span>);</span><br><span class="line"><span class="comment">//输出不含重复元素的数据</span></span><br><span class="line">list.stream().distinct().forEach(System.out::println);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//Stream&lt;T&gt; skip(long n):跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n个则返回一个空流</span></span><br><span class="line">list.stream().skip(<span class="number">3</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<ul>
<li>2-映 射</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方 法</th>
<th align="center">描 述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">map(Function f)</td>
<td align="center">接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td>
</tr>
<tr>
<td align="center">mapToDouble(ToDoubleFunction f)</td>
<td align="center">接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</td>
</tr>
<tr>
<td align="center">mapToInt(ToIntFunction f)</td>
<td align="center">接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。</td>
</tr>
<tr>
<td align="center">mapToLong(ToLongFunction f)</td>
<td align="center">接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。</td>
</tr>
<tr>
<td align="center">flatMap(Function f)</td>
<td align="center">接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射</span></span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">list1.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">list1.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="comment">//Stream&lt;R&gt; map(Function mapper)：接受一个函数作为参数，函数会被应用到所有的元素上，并将映射后的元素构建成一个流后输出.</span></span><br><span class="line"><span class="comment">//函数表示映射关系</span></span><br><span class="line"><span class="comment">//将字符串都转换成大写的，然后输出</span></span><br><span class="line">list1.stream().map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line"><span class="comment">//Stream&lt;R&gt; flatMap(Function mapper)：接受一个函数作为参数。元素经函数转换后的变成新元素</span></span><br><span class="line"><span class="comment">//如果这个新元素是一个流，则将所有新元素流中的元素都取出从新构成一个大流，然后返回这个大流</span></span><br><span class="line"><span class="comment">//换句话说，这个大流中的元素：是新元素流中的元素，而不是新元素流。</span></span><br><span class="line">Stream&lt;Character&gt; characterStream = list1.stream().flatMap(str -&gt; toStream(str));</span><br><span class="line">characterStream.forEach(System.out::println);</span><br><span class="line"><span class="comment">//对照map(Function mapper)方法</span></span><br><span class="line">Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list1.stream().map(str -&gt; toStream(str));</span><br><span class="line">streamStream.forEach(s-&gt;&#123;</span><br><span class="line">    s.forEach(System.out::println);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>3-排序</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sorted()</td>
<td align="center">产生一个新流，其中按自然顺序排序</td>
</tr>
<tr>
<td align="center">sorted(Comparator com)</td>
<td align="center">产生一个新流，其中按比较器顺序排序</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="comment">//Stream&lt;T&gt; sorted():返回自然排序后的流</span></span><br><span class="line">list.stream().sorted().forEach(System.out::println);</span><br><span class="line"><span class="comment">//Stream&lt;T&gt; sorted(Comparator comparator):返回定制排序后的流</span></span><br><span class="line">list.stream().sorted(Integer::compareTo).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li><p>Stream 的终止操作</p>
<ul>
<li>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void </li>
<li>流进行了终止操作后，不能再次使用。</li>
<li>1-匹配与查找</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">allMatch(Predicate p)</td>
<td align="center">检查是否匹配所有元素</td>
</tr>
<tr>
<td align="center">anyMatch(Predicate p)</td>
<td align="center">检查是否至少匹配一个元素</td>
</tr>
<tr>
<td align="center">noneMatch(Predicate p)</td>
<td align="center">检查是否没有匹配所有元素</td>
</tr>
<tr>
<td align="center">findFirst()</td>
<td align="center">返回第一个元素</td>
</tr>
<tr>
<td align="center">findAny()</td>
<td align="center">返回当前流中的任意元素</td>
</tr>
<tr>
<td align="center">count()</td>
<td align="center">返回流中元素总数</td>
</tr>
<tr>
<td align="center">max(Comparator c)</td>
<td align="center">返回流中最大值</td>
</tr>
<tr>
<td align="center">min(Comparator c)</td>
<td align="center">返回流中最小值</td>
</tr>
<tr>
<td align="center">forEach(Consumer c)</td>
<td align="center">内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代——它帮你把迭代做了)</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">8</span>);</span><br><span class="line">list.add(<span class="number">6</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//匹配与查找</span></span><br><span class="line"><span class="comment">//boolean allMatch(Predicate predicate):对于每个元素predicate都返回true，则allMatch返回true</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = list.stream().allMatch(i -&gt; (i &gt; <span class="number">4</span>));</span><br><span class="line">System.out.println(b1);</span><br><span class="line"><span class="comment">//boolean anyMatch(Predicate predicate):对于每个元素predicate有一个返回true，则anyMatch返回true</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = list.stream().anyMatch(i -&gt; (i &gt; <span class="number">4</span>));</span><br><span class="line">System.out.println(b2);</span><br><span class="line"><span class="comment">//boolean noneMatch(Predicate predicate):对于每个元素predicate都返回false，则noneMatch返回true</span></span><br><span class="line"><span class="keyword">boolean</span> b3 = list.stream().noneMatch(i -&gt; (i &gt; <span class="number">4</span>));</span><br><span class="line">System.out.println(b3);</span><br><span class="line"><span class="comment">//Optional&lt;T&gt; findFirst()：返回第一个元素</span></span><br><span class="line">Optional&lt;Integer&gt; first = list.stream().findFirst();</span><br><span class="line">System.out.println(first);</span><br><span class="line"><span class="comment">//Optional&lt;T&gt; findAny()：返回随机的元素</span></span><br><span class="line">Optional&lt;Integer&gt; any = list.parallelStream().findAny();</span><br><span class="line">System.out.println(any);</span><br><span class="line"><span class="comment">//long count()：返回元素的个数</span></span><br><span class="line"><span class="keyword">long</span> count = list.stream().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"><span class="comment">//Optional&lt;T&gt; max(Comparator comparator)：返回排序后的最大值</span></span><br><span class="line">Optional&lt;Integer&gt; max = list.stream().max(Integer::compareTo);</span><br><span class="line">System.out.println(max);</span><br><span class="line"><span class="comment">//Optional&lt;T&gt; min(Comparator comparator)：返回排序后的最小值</span></span><br><span class="line">Optional&lt;Integer&gt; min = list.stream().min(Integer::compareTo);</span><br><span class="line">System.out.println(min);</span><br><span class="line"><span class="comment">//void forEach(Consumer action):内部迭代</span></span><br><span class="line">list.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<ul>
<li>2-归约</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">reduce(T iden, BinaryOperator b)</td>
<td align="center">可以将流中元素反复结合起来，得到一个值。返回 T</td>
</tr>
<tr>
<td align="center">reduce(BinaryOperator b)</td>
<td align="center">可以将流中元素反复结合起来，得到一个值。返回 Optional<T></td>
</tr>
</tbody></table>
<ul>
<li>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规约</span></span><br><span class="line">List&lt;Integer&gt; list1 = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line"><span class="comment">//T reduce(T identity, BinaryOperator accumulator)：从初始值开始，将流中的元素返回结合起来得到一个值</span></span><br><span class="line"><span class="comment">//identity：初始值</span></span><br><span class="line"><span class="comment">//计算前十个数的和</span></span><br><span class="line">Integer reduce = list1.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">System.out.println(reduce);</span><br><span class="line"><span class="comment">//Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)：将流中的元素返回结合起来得到一个值</span></span><br><span class="line"><span class="comment">//计算前十个数的和</span></span><br><span class="line">Optional&lt;Integer&gt; reduce1 = list1.stream().reduce(Integer::sum);</span><br><span class="line">System.out.println(reduce1);</span><br></pre></td></tr></table></figure>

<ul>
<li>3-收集</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方 法</th>
<th align="center">描 述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">collect(Collector c)</td>
<td align="center">将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收集</span></span><br><span class="line"><span class="comment">//collect(Collector collector):将流转换成其他的形式。接受一个Collectors接口的实现方法，</span></span><br><span class="line">List&lt;Integer&gt; collect = list1.stream().collect(Collectors.toList());</span><br><span class="line">collect.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li><p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。</p>
</li>
<li><p>另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，<br>具体方法与实例如下表：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回类型</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">toList</td>
<td align="center">List<T></td>
<td align="center">把流中元素收集到List</td>
</tr>
<tr>
<td align="center">toSet</td>
<td align="center">Set<T></td>
<td align="center">把流中元素收集到Set</td>
</tr>
<tr>
<td align="center">toCollection</td>
<td align="center">Collection<T></td>
<td align="center">把流中元素收集到创建的集合</td>
</tr>
<tr>
<td align="center">counting</td>
<td align="center">Long</td>
<td align="center">计算流中元素的个数</td>
</tr>
<tr>
<td align="center">summingInt</td>
<td align="center">Integer</td>
<td align="center">对流中元素的整数属性求和</td>
</tr>
<tr>
<td align="center">averagingInt</td>
<td align="center">Double</td>
<td align="center">计算流中元素Integer属性的平均值</td>
</tr>
<tr>
<td align="center">summarizingInt</td>
<td align="center">IntSummaryStatistics</td>
<td align="center">收集流中Integer属性的统计值。如：平均值</td>
</tr>
<tr>
<td align="center">joining</td>
<td align="center">String</td>
<td align="center">连接流中每个字符串</td>
</tr>
<tr>
<td align="center">maxBy</td>
<td align="center">Optional<T></td>
<td align="center">根据比较器选择最大值</td>
</tr>
<tr>
<td align="center">minBy</td>
<td align="center">Optional<T></td>
<td align="center">根据比较器选择最小值</td>
</tr>
<tr>
<td align="center">reducing</td>
<td align="center">归约产生的类型</td>
<td align="center">从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值</td>
</tr>
<tr>
<td align="center">collectingAndThen</td>
<td align="center">转换函数返回的类型</td>
<td align="center">包裹另一个收集器，对其结果转换函数</td>
</tr>
<tr>
<td align="center">groupingBy</td>
<td align="center">Map&lt;K, List<T>&gt;</td>
<td align="center">根据某属性值对流分组，属性为K，结果为V</td>
</tr>
<tr>
<td align="center">partitioningBy</td>
<td align="center">Map&lt;Boolean, List<T>&gt;</td>
<td align="center">根据true或false进行分区</td>
</tr>
</tbody></table>
<ul>
<li>举例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; emps= list.stream().collect(Collectors.toList());</span><br><span class="line">Set&lt;Employee&gt; emps= list.stream().collect(Collectors.toSet());</span><br><span class="line">Collection&lt;Employee&gt; emps =list.stream().collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line"><span class="keyword">long</span> count = list.stream().collect(Collectors.counting());</span><br><span class="line"><span class="keyword">int</span> total=list.stream().collect(Collectors.summingInt(Employee::getSalary));</span><br><span class="line"><span class="keyword">double</span> avg = list.stream().collect(Collectors.averagingInt(Employee::getSalary));</span><br><span class="line"><span class="keyword">int</span> SummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</span><br><span class="line">String str= list.stream().map(Employee::getName).collect(Collectors.joining());</span><br><span class="line">Optional&lt;Emp&gt;max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</span><br><span class="line">Optional&lt;Emp&gt; min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</span><br><span class="line"><span class="keyword">int</span> total=list.stream().collect(Collectors.reducing(<span class="number">0</span>, Employee::getSalar, Integer::sum));</span><br><span class="line"><span class="keyword">int</span> how= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</span><br><span class="line">Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus));</span><br><span class="line">Map&lt;Boolean,List&lt;Emp&gt;&gt; vd = list.stream().collect(Collectors.partitioningBy(Employee::getManage));</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h1><ul>
<li><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</p>
</li>
<li><p>Optional<T> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 </p>
</li>
<li><p>Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p>
</li>
<li><p>Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
</li>
<li><p>创建Optional类对象的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Optional.of(T t)</td>
<td align="center">创建一个 Optional 实例，t必须非空；</td>
</tr>
<tr>
<td align="center">Optional.empty()</td>
<td align="center">创建一个空的 Optional 实例</td>
</tr>
<tr>
<td align="center">Optional.ofNullable(T t)</td>
<td align="center">t可以为null</td>
</tr>
</tbody></table>
</li>
<li><p>判断Optional容器中是否包含对象：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean isPresent()</td>
<td align="center">判断是否包含对象</td>
</tr>
<tr>
<td align="center">void ifPresent(Consumer&lt;? super T&gt; consumer)</td>
<td align="center">如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。</td>
</tr>
</tbody></table>
</li>
<li><p>获取Optional容器的对象：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T get()</td>
<td align="center">如果调用对象包含值，返回该值，否则抛异常</td>
</tr>
<tr>
<td align="center">T orElse(T other)</td>
<td align="center">如果有值则将其返回，否则返回指定的other对象。</td>
</tr>
<tr>
<td align="center">T orElseGet(Supplier&lt;? extends T&gt; other)</td>
<td align="center">如果有值则将其返回，否则返回由Supplier接口实现提供的对象。</td>
</tr>
<tr>
<td align="center">T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</td>
<td align="center">如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Optional.of(T t)：创建一个值为t的Optional实例。t不可以为空</span></span><br><span class="line">Boy boy = <span class="keyword">new</span> Boy();</span><br><span class="line">Optional&lt;Boy&gt; optionalBoy1 = Optional.of(boy);</span><br><span class="line">System.out.println(optionalBoy1);</span><br><span class="line"><span class="comment">//Optional.ofNullable(T t)：创建一个值为t的Optional实例。t可以为空</span></span><br><span class="line">boy=<span class="keyword">null</span>;</span><br><span class="line">Optional&lt;Boy&gt; optionalBoy2 = Optional.ofNullable(boy);</span><br><span class="line">System.out.println(optionalBoy2);</span><br><span class="line"><span class="comment">//T orElse(T other):如果对象不为空则返回对象的值，如果对象为空则返回other</span></span><br><span class="line">Boy cl = optionalBoy2.orElse(<span class="keyword">new</span> Boy(<span class="keyword">new</span> Student(<span class="string">&quot;cl&quot;</span>)));</span><br><span class="line">System.out.println(cl);</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">* Lambda表达式的使用</span><br><span class="line">*  <span class="number">1.</span>举例：(o1,o2) -&gt; Integer.compare(o1,o2);</span><br><span class="line">*  <span class="number">2.</span>格式：</span><br><span class="line">*      -&gt; ：lambda操作符 或 箭头操作符</span><br><span class="line">*          左边：lambda形参列表 (其实就是接口中抽象方法的形参列表)</span><br><span class="line">*          右边：lambda体 (其实就是重写的抽象方法的方法体)</span><br><span class="line">*  <span class="number">3.</span>Lambda表达式的使用：(<span class="number">6</span>种情况)</span><br><span class="line">*      总结：</span><br><span class="line">*         ① 左边参数列表</span><br><span class="line">*              没有参数时一个小括号即可</span><br><span class="line">*              只有一个参数时，可以将参数类型和小括号都省略</span><br><span class="line">*              有多个参数时，可以省略参数类型，不能省略小括号</span><br><span class="line">*         ② 右边：正常时，由一对大括号包裹</span><br><span class="line">*              当只有一条执行语句语句(或只有一条返回语句),大括号也可以省略</span><br><span class="line">*         ③  要求接口是函数式接口</span><br><span class="line">*  <span class="number">4.</span>Lambda表达式的本质：作为接口的实例</span><br><span class="line">* 函数式接口：只有一个抽象方法的接口就是一个函数式接口。</span><br><span class="line">*      一般情况下在函数式接口上用<span class="meta">@FunctionalInterface</span>注解标识，此注解可以判断这个接口是否是一个函数式接口</span><br><span class="line">* 方法引用的使用</span><br><span class="line">*      <span class="number">1.</span>使用情景：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用</span><br><span class="line">*      <span class="number">2.</span>方法引用，本质就是Lambda表达式，而Lambda表达式作为函数式接口的实例。</span><br><span class="line">*          所以方法引用也是函数式接口的实例</span><br><span class="line">*      <span class="number">3.</span>使用格式： 类(或对象) :: 方法名</span><br><span class="line">*      <span class="number">4.</span>使用情况：</span><br><span class="line">*          ① 对象 :: 非静态方法</span><br><span class="line">*          ② 类 :: 静态方法</span><br><span class="line">*          ③ 类 :: 实例方法</span><br><span class="line">*      <span class="number">5.</span>使用要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的一样</span><br><span class="line">*      <span class="number">6.</span>构造器引用：和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。</span><br><span class="line">*              抽象方法的返回值类型即为构造器所属的类的类型</span><br><span class="line">*      <span class="number">7.</span>数组引用：当把数组看成一个特殊的类，则写法与构造器引用相同</span><br><span class="line">* StreamAPI</span><br><span class="line">*      <span class="number">1.</span>Stream关注的式对数据的运算，与CPU打交道</span><br><span class="line">*          集合关注的是数据的存储，与内存打交道。</span><br><span class="line">*      <span class="number">2.</span>Stream自己不会存储元素；</span><br><span class="line">*        Stram不会改变源对象。相反，他们会返回一个持有结果的新Stream;</span><br><span class="line">*        Stream操作是延迟执行的，这意味着它们会等到需要结果的时候才执行。</span><br><span class="line">*      <span class="number">3.</span>Stream执行流程：</span><br><span class="line">*          ① Stream的实例化</span><br><span class="line">*          ② 一系列中间操作(过滤，映射)</span><br><span class="line">*          ③ 终止操作</span><br><span class="line">*      <span class="number">4.</span>说明：</span><br><span class="line">*          ① 一个中间操作链，对数据源的数据进行处理</span><br><span class="line">*          ② 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</span><br></pre></td></tr></table></figure>




    </div>

    
    
    


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/07/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/2-Java%E5%B8%B8%E7%94%A8%E7%B1%BB/" rel="prev" title="Java常用类">
      <i class="fa fa-chevron-left"></i> Java常用类
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/07/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/8-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" rel="next" title="反射机制">
      反射机制 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">Lambda表达式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.</span> <span class="nav-text">函数式接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">方法引用与构造器引用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-number">3.1.</span> <span class="nav-text">方法引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="nav-number">3.2.</span> <span class="nav-text">构造器引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8"><span class="nav-number">3.3.</span> <span class="nav-text">数组引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#StreamAPI"><span class="nav-number">4.</span> <span class="nav-text">StreamAPI</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Optional%E7%B1%BB"><span class="nav-number">5.</span> <span class="nav-text">Optional类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Plum Reiver</p>
  <div class="site-description" itemprop="description">技术，日常，笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
	
  </nav>
</div>


      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plum Reiver</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
