<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"plumv.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="Java的Class类和动态代理">
<meta property="og:type" content="article">
<meta property="og:title" content="反射机制">
<meta property="og:url" content="https://plumv.github.io/2020/12/07/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/8-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="李川的个人博客">
<meta property="og:description" content="Java的Class类和动态代理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184442.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184443.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184444.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184445.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184446.png">
<meta property="article:published_time" content="2020-12-06T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-20T12:10:23.735Z">
<meta property="article:author" content="Plum Reiver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184442.png">

<link rel="canonical" href="https://plumv.github.io/2020/12/07/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/8-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>反射机制 | 李川的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李川的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>日志</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://plumv.github.io/2020/12/07/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/8-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plum Reiver">
      <meta itemprop="description" content="技术，日常，笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李川的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          反射机制
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-07 00:00:00" itemprop="dateCreated datePublished" datetime="2020-12-07T00:00:00+08:00">2020-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-20 20:10:23" itemprop="dateModified" datetime="2021-03-20T20:10:23+08:00">2021-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">Java高级语法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Java的Class类和动态代理</p>
<span id="more"></span>
<h1 id="Java反射机制概述"><a href="#Java反射机制概述" class="headerlink" title="Java反射机制概述"></a>Java反射机制概述</h1><ul>
<li><p>Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 </p>
</li>
<li><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184442.png"></p>
</li>
<li><p>动态语言 vs 静态语言</p>
<ul>
<li>动态语言：是一类在运行时可以改变其结构的语言：<ul>
<li>例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</li>
<li>主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。 </li>
</ul>
</li>
<li>静态语言：运行时结构不可变的语言<ul>
<li>如Java、C、C++。</li>
</ul>
</li>
<li>Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。</li>
<li>Java的动态性让编程的时候更加灵活！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java作为动态语言的体现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">        String className = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                className = <span class="string">&quot;java.util.Random&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                className = <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                className = <span class="string">&quot;com.atguigu.reflex.Person&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object object = getInstance(className);</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(String className)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">    Class clazz = Class.forName(className);</span><br><span class="line">    <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Java反射机制提供的功能</p>
<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
</ul>
</li>
<li><p>反射相关的主要API</p>
<ul>
<li>java.lang.Class:代表一个类 </li>
<li>java.lang.reflect.Method:代表类的方法</li>
<li>java.lang.reflect.Field:代表类的成员变量</li>
<li>java.lang.reflect.Constructor:代表类的构造器</li>
</ul>
</li>
<li></li>
</ul>
<h1 id="Class类的理解"><a href="#Class类的理解" class="headerlink" title="Class类的理解"></a>Class类的理解</h1><ul>
<li><p>在Object类中定义了以下的方法，此方法将被所有子类继承：</p>
<ul>
<li>public final Class getClass()</li>
</ul>
</li>
<li><p>以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。</p>
</li>
<li><p>对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息。 </p>
<ul>
<li>Class本身也是一个类</li>
<li>Class 对象只能由系统建立对象</li>
<li>一个加载的类在 JVM 中只会有一个Class实例</li>
<li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li>
<li>每个类的实例都会记得自己是由哪个 Class 实例所生成</li>
<li>通过Class可以完整地得到一个类中的所有被加载的结构</li>
<li>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</li>
</ul>
</li>
<li><p>Class类的常用方法</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">static Class forName(String name)</td>
<td align="center">返回指定类名 name 的 Class 对象</td>
</tr>
<tr>
<td align="center">Object newInstance()</td>
<td align="center">调用缺省构造函数，返回该Class对象的一个实例</td>
</tr>
<tr>
<td align="center">getName()</td>
<td align="center">返回此Class对象所表示的实体（类、接口、数组类、基本类型或void）名称</td>
</tr>
<tr>
<td align="center">Class getSuperClass()</td>
<td align="center">返回当前Class对象的父类的Class对象</td>
</tr>
<tr>
<td align="center">Class [] getInterfaces()</td>
<td align="center">获取当前Class对象的接口</td>
</tr>
<tr>
<td align="center">ClassLoader getClassLoader()</td>
<td align="center">返回该类的类加载器</td>
</tr>
<tr>
<td align="center">Class getSuperclass()</td>
<td align="center">返回表示此Class所表示的实体的超类的Class</td>
</tr>
<tr>
<td align="center">Constructor[] getConstructors()</td>
<td align="center">返回一个包含某些Constructor对象的数组</td>
</tr>
<tr>
<td align="center">Field[] getDeclaredFields()</td>
<td align="center">返回Field对象的一个数组</td>
</tr>
<tr>
<td align="center">Method getMethod(String name,Class … paramTypes)</td>
<td align="center">返回一个Method对象，此对象的形参类型为paramType</td>
</tr>
</tbody></table>
</li>
<li><p>获取Class类的实例(四种方法) </p>
<ul>
<li>前提：若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高<ul>
<li>实例：Class clazz = String.class; </li>
</ul>
</li>
<li>前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象<ul>
<li>实例：Class clazz = “<a target="_blank" rel="noopener" href="http://www.atguigu.com”.getclass()/">www.atguigu.com”.getClass()</a>;</li>
</ul>
</li>
<li>前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException<ul>
<li>实例：Class clazz = Class.forName(“java.lang.String”);</li>
</ul>
</li>
<li>其他方式(不做要求)<ul>
<li>ClassLoader cl = this.getClass().getClassLoader();</li>
<li>Class clazz4 = cl.loadClass(“类的全类名”);</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class实例化的方式：4种</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//方式一：调用运行时类的属性：.class</span></span><br><span class="line">    Class&lt;Person&gt; clazz1 = Person.class;</span><br><span class="line">    System.out.println(clazz1);</span><br><span class="line">    <span class="comment">//方式二：通过运行时类的对象：调用getClass()</span></span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    Class clazz2 = person.getClass();</span><br><span class="line">    System.out.println(clazz2);</span><br><span class="line">    <span class="comment">//方式三：调用Class的静态方法：foeName(String classPath) --&gt;常用</span></span><br><span class="line">    <span class="comment">//classPath：类的全列名路径。包含包路径和类名</span></span><br><span class="line">    Class clazz3 = Class.forName(<span class="string">&quot;com.atguigu.reflex.Person&quot;</span>);</span><br><span class="line">    <span class="comment">//clazz3 = Class.forName(&quot;java.lang.String&quot;);</span></span><br><span class="line">    System.out.println(clazz3);</span><br><span class="line"></span><br><span class="line">    System.out.println(clazz1 == clazz2);<span class="comment">//true</span></span><br><span class="line">    System.out.println(clazz1 == clazz3);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式四：使用类的加载器：ClassLoader  --&gt;了解即可</span></span><br><span class="line">    <span class="comment">//ClassLoader classLoader = Person.class.getClassLoader();</span></span><br><span class="line">    ClassLoader classLoader = ReflesTest.class.getClassLoader();</span><br><span class="line">    Class clazz4 = classLoader.loadClass(<span class="string">&quot;com.atguigu.reflex.Person&quot;</span>);</span><br><span class="line">    System.out.println(clazz4);</span><br><span class="line">    System.out.println(clazz4 == clazz3);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>哪些类型可以有Class对象？</p>
<ul>
<li>class： 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类</li>
<li>interface：接口</li>
<li>[]：数组</li>
<li>enum：枚举</li>
<li>annotation：注解@interface</li>
<li>primitive type：基本数据类型</li>
<li>void</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有反射式，可以对Person的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException </span>&#123;</span><br><span class="line">    Class&lt;Person&gt; pclass = Person.class;</span><br><span class="line">    <span class="comment">//getConstructor()：可以获取类声明的公共的构造器对象</span></span><br><span class="line">    Constructor constructors1 = pclass.getConstructor(String.class,<span class="keyword">int</span>.class);</span><br><span class="line">    <span class="comment">//getDeclaredConstructor()：可以获取类声明的所有构造器对象，包括四个权限以内的，不包括继承的</span></span><br><span class="line">    Constructor constructors2 = pclass.getDeclaredConstructor(String.class);</span><br><span class="line">    <span class="comment">//setAccessible(flag)：flag --&gt; true ：表示禁用Java语言检查</span></span><br><span class="line">    <span class="comment">//flag --&gt; false (默认值)：表示不禁用Java语言检查</span></span><br><span class="line">    <span class="comment">//当要使用私有构造器对象，私有方法对象，私有属性对象时</span></span><br><span class="line">    <span class="comment">//需要将此设置为true，然后这个对象才能正常使用</span></span><br><span class="line">    constructors2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//newInstance()：通过构造器对象创建这个类的对象</span></span><br><span class="line">    Object o = constructors2.newInstance(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    System.out.println(o.toString());</span><br><span class="line">    <span class="comment">//通过反射获取类的指定的属性和方法。</span></span><br><span class="line">    <span class="comment">//getDeclaredField()：获取类对象声明的属性</span></span><br><span class="line">    Field name = pclass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//set(obj,value)：属性对象调用此方法后，可以设置obj对象的这个属性的值为value</span></span><br><span class="line">    name.set(o,<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    System.out.println(o.toString());</span><br><span class="line">    <span class="comment">//getDeclaredMethod()：获取类对象声明的方法</span></span><br><span class="line">    Method show = pclass.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line">    show.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//Object show(obj,args)：方法对象调用此方法后，可以调用obj对象的此方法，并传入参数args，</span></span><br><span class="line">    <span class="comment">// 返回obj对象的此方法会返回的值</span></span><br><span class="line">    show.invoke(o,<span class="string">&quot;中国&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有反射时。对Person的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建Person类的对象</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;tom&quot;</span>,<span class="number">16</span>);</span><br><span class="line">    <span class="comment">//2.通过对象，调用其内部公共的属性，方法</span></span><br><span class="line">    p1.age = <span class="number">23</span>;</span><br><span class="line">    System.out.println(p1.getAge());</span><br><span class="line">    System.out.println(p1.toString());</span><br><span class="line">    <span class="comment">//在Person类外部，不可以通过Person类的对象调用其内部的私有的属性，方法，构造器</span></span><br><span class="line">    <span class="comment">//比如此Person类的name,show()以及私有的构造器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ClassLoader的理解"><a href="#ClassLoader的理解" class="headerlink" title="ClassLoader的理解"></a>ClassLoader的理解</h1><ul>
<li><p>类的加载过程</p>
<ul>
<li>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184443.png"></p>
</li>
<li><p>加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要类加载器参与。 </p>
</li>
<li><p>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。</p>
<ul>
<li>验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题</li>
<li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。 </li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 </li>
</ul>
</li>
<li><p>初始化：</p>
<ul>
<li>执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。 </li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 </li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步</li>
</ul>
</li>
<li><p>什么时候会发生类初始化？</p>
</li>
<li><p>类的主动引用（一定会发生类的初始化）</p>
<ul>
<li>当虚拟机启动，先初始化main方法所在的类 </li>
<li>new一个类的对象</li>
<li>调用类的静态成员（除了final常量）和静态方法</li>
<li>使用java.lang.reflect包的方法对类进行反射调用</li>
<li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</li>
</ul>
</li>
<li><p>类的被动引用（不会发生类的初始化） </p>
<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化<ul>
<li>当通过子类引用父类的静态变量，不会导致子类初始化</li>
</ul>
</li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li>
</ul>
</li>
<li><p>类加载器的作用：</p>
<ul>
<li>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。 </li>
<li>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184444.png"></p>
</li>
<li><p>ClassLoader类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的类的加载器。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184445.png"></p>
</li>
<li><p>引导类加载器：用C++编写的，是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库。该加载器无法直接获取</p>
</li>
<li><p>扩展类加载器：负责jre/lib/ext目录下的jar包或 –D java.ext.dirs 指定目录下的jar包装入工作库</p>
</li>
<li><p>系统类加载器：负责java –classpath 或 –D java.class.path所指的目录下的类与jar包装入工作 ，是最常用的加载器</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassLoader的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//对于自定义类，使用系统类加载器进行加载</span></span><br><span class="line">    ClassLoader classLoader1 = Person.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader1);</span><br><span class="line">    <span class="comment">//获取系统类加载器的父类：扩展类加载器</span></span><br><span class="line">    ClassLoader classLoader2 = classLoader1.getParent();</span><br><span class="line">    System.out.println(classLoader2);</span><br><span class="line">    <span class="comment">//扩展类加载器的父类是引导类加载器</span></span><br><span class="line">    <span class="comment">//引导类加载器是无法获取的，因此，此时返回为null</span></span><br><span class="line">    <span class="comment">//引导类加载器主要负责加载Java核心类库，无法加载自定义类</span></span><br><span class="line">    ClassLoader classLoader3 = classLoader2.getParent();</span><br><span class="line">    System.out.println(classLoader3);</span><br><span class="line"></span><br><span class="line">    ClassLoader classLoader4 = String.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h1><ul>
<li>创建类的对象：调用Class对象的newInstance()方法</li>
<li>要 求： <ul>
<li>类必须有一个无参数的构造器。</li>
<li>类的构造器的访问权限需要足够。</li>
</ul>
</li>
<li>难道没有无参的构造器就不能创建对象了吗？<ul>
<li>不是！只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。</li>
</ul>
</li>
<li>步骤如下：<ul>
<li>通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器</li>
<li>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。</li>
<li>通过Constructor实例化对象。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; clazz1 = Person.class;</span><br><span class="line"><span class="comment">//newInstance():调用此方法，创建对应的运行时类的对象。内部调用的是运行时类的空参构造器</span></span><br><span class="line"><span class="comment">//要想此方法正常运行：①运行时类必须提供空参构造器。②构造器的权限要能被访问到。</span></span><br><span class="line">Person person = clazz1.newInstance();</span><br><span class="line">System.out.println(person);</span><br></pre></td></tr></table></figure>

<h1 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h1><ul>
<li>类的完整结构包括：Field、Method、Constructor、Superclass、Interface、Annotation</li>
<li>使用反射可以取得：</li>
<li>实现的全部接口<ul>
<li>public Class&lt;?&gt;[] getInterfaces() ：确定此对象所表示的类或接口实现的接口。</li>
</ul>
</li>
<li>所继承的父类<ul>
<li>public Class&lt;? Super T&gt; getSuperclass()：返回表示此 Class 所表示的实体（类、接口、基本类型）的父类的Class。</li>
</ul>
</li>
<li>全部的构造器<ul>
<li>public Constructor<T>[] getConstructors()：返回此 Class 对象所表示的类的所有public构造方法。</li>
<li>public Constructor<T>[] getDeclaredConstructors()：返回此 Class 对象表示的类声明的所有构造方法。</li>
</ul>
</li>
<li>Constructor类中：<ul>
<li>取得修饰符: public int getModifiers();</li>
<li>取得方法名称: public String getName();</li>
<li>取得参数的类型：public Class&lt;?&gt;[] getParameterTypes();</li>
</ul>
</li>
<li>全部的方法<ul>
<li>public Method[] getDeclaredMethods()：返回此Class对象所表示的类或接口的全部方法</li>
<li>public Method[] getMethods()：返回此Class对象所表示的类或接口的public的方法</li>
</ul>
</li>
<li>Method类中：<ul>
<li>public Class&lt;?&gt; getReturnType()：取得全部的返回值</li>
<li>public Class&lt;?&gt;[] getParameterTypes()：取得全部的参数</li>
<li>public int getModifiers()：取得修饰符</li>
<li>public Class&lt;?&gt;[] getExceptionTypes()：取得异常信息</li>
</ul>
</li>
<li>全部的Field<ul>
<li>public Field[] getFields()： 返回此Class对象所表示的类或接口的public的Field。 </li>
<li>public Field[] getDeclaredFields() ：返回此Class对象所表示的类或接口的全部Field。 </li>
</ul>
</li>
<li>Field方法中：<ul>
<li>public int getModifiers() ：以整数形式返回此Field的修饰符</li>
<li>public Class&lt;?&gt; getType() ：得到Field的属性类型</li>
<li>public String getName() ：返回Field的名称。</li>
</ul>
</li>
<li> Annotation相关</li>
<li>get Annotation(Class<T> annotationClass) </li>
<li>getDeclaredAnnotations() </li>
<li>泛型相关<ul>
<li>获取父类泛型类型：Type getGenericSuperclass()</li>
</ul>
</li>
<li>泛型类型：ParameterizedType<ul>
<li>获取实际的泛型类型参数数组：getActualTypeArguments()</li>
</ul>
</li>
<li>类所在的包 Package getPackage()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取运行时类的完整结构</span></span><br><span class="line"><span class="comment">//属性的获取</span></span><br><span class="line">Class clazz2 = Student.class;</span><br><span class="line"><span class="comment">//getFields()：能获取当前运行时类及其父类中声明为public的属性</span></span><br><span class="line">Field[] fields1 = clazz2.getFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields1) &#123;</span><br><span class="line">    System.out.println(field.toString());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//getDeclaredFields()：获取当前运行时类中声明的所有属性。(不包含父类的)</span></span><br><span class="line">Field[] fields2 = clazz2.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields2) &#123;</span><br><span class="line">    System.out.println(field.toString());</span><br><span class="line">    <span class="comment">//获取属性的权限修饰符</span></span><br><span class="line">    <span class="keyword">int</span> modifiers = field.getModifiers();</span><br><span class="line">    System.out.println(Modifier.toString(modifiers));</span><br><span class="line">    <span class="comment">//获取属性的类型</span></span><br><span class="line">    Class type = field.getType();</span><br><span class="line">    System.out.println(type.getName());</span><br><span class="line">    <span class="comment">//获取属性名</span></span><br><span class="line">    String name = field.getName();</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="comment">//获取属性的注解</span></span><br><span class="line">    Annotation[] annotations = field.getAnnotations();</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">        System.out.println(annotation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法的获取</span></span><br><span class="line"><span class="comment">//getMethods()：能获取当前运行时类及其父类中声明为public的方法</span></span><br><span class="line">Method[] methods1 = clazz2.getMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method : methods1) &#123;</span><br><span class="line">    System.out.println(method);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//getDeclaredMethods()：获取当前运行时类中声明的所有方法。(不包含父类的)</span></span><br><span class="line">Method[] methods2 = clazz2.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method : methods2) &#123;</span><br><span class="line">    System.out.println(method);</span><br><span class="line">    <span class="comment">//获取方法的权限修饰符</span></span><br><span class="line">    <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">    System.out.println(Modifier.toString(modifiers));</span><br><span class="line">    <span class="comment">//获取方法的名字</span></span><br><span class="line">    String name = method.getName();</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="comment">//获取方法的注解</span></span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">        System.out.println(annotation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取方法的返回值类型</span></span><br><span class="line">    Class returnType = method.getReturnType();</span><br><span class="line">    System.out.println(returnType.getName());</span><br><span class="line">    <span class="comment">//获取方法的参数信息</span></span><br><span class="line">    Parameter[] parameters = method.getParameters();</span><br><span class="line">    <span class="keyword">for</span> (Parameter parameter : parameters) &#123;</span><br><span class="line">        System.out.println(parameter.getType());</span><br><span class="line">        System.out.println(parameter.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取方法的异常信息</span></span><br><span class="line">    Class&lt;?&gt;[] exceptionTypes = method.getExceptionTypes();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; exceptionType : exceptionTypes) &#123;</span><br><span class="line">        System.out.println(exceptionType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器的获取</span></span><br><span class="line">Constructor[] constructors1 = clazz2.getConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor constructor : constructors1) &#123;</span><br><span class="line">    System.out.println(constructor);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">Constructor[] constructors2 = clazz2.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor constructor : constructors2) &#123;</span><br><span class="line">    System.out.println(constructor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取父类</span></span><br><span class="line">Class superclass = clazz2.getSuperclass();</span><br><span class="line">System.out.println(superclass);</span><br><span class="line"><span class="comment">//获取带泛型的父类</span></span><br><span class="line">Type genericSuperclass = clazz2.getGenericSuperclass();</span><br><span class="line">System.out.println(genericSuperclass);</span><br><span class="line"><span class="comment">//获取父类的泛型</span></span><br><span class="line">ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass;</span><br><span class="line">Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">System.out.println(actualTypeArguments[<span class="number">0</span>].getTypeName());</span><br><span class="line"><span class="comment">//获取接口</span></span><br><span class="line">Class[] interfaces = clazz2.getInterfaces();</span><br><span class="line">System.out.println(Arrays.toString(interfaces));</span><br><span class="line"><span class="comment">//获取带泛型的接口</span></span><br><span class="line">Type[] genericInterfaces = clazz2.getGenericInterfaces();</span><br><span class="line">System.out.println(Arrays.toString(genericInterfaces));</span><br><span class="line"><span class="comment">//获取运行时类所在的包</span></span><br><span class="line">Package aPackage = clazz2.getPackage();</span><br><span class="line">System.out.println(aPackage);</span><br><span class="line"><span class="comment">//获取运行时类的注解</span></span><br><span class="line">Annotation[] annotations = clazz2.getAnnotations();</span><br><span class="line"><span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">    System.out.println(annotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="调用运行时类的指定结构"><a href="#调用运行时类的指定结构" class="headerlink" title="调用运行时类的指定结构"></a>调用运行时类的指定结构</h1><ul>
<li><p>调用指定方法</p>
<ul>
<li>通过反射，调用类中的方法，通过Method类完成。步骤：</li>
<li>通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。</li>
<li>之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184446.png"></p>
</li>
<li><p>Object invoke(Object obj, Object … args)说明：</p>
<ul>
<li>Object 对应原方法的返回值，若原方法无返回值，此时返回null</li>
<li>若原方法若为静态方法，此时形参Object obj可为null</li>
<li>若原方法形参列表为空，则Object[] args为null</li>
<li>若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。</li>
</ul>
</li>
<li><p>调用指定属性</p>
<ul>
<li>在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设置和取得属性内容的操作。</li>
<li>public Field getField(String name) 返回此Class对象表示的类或接口的指定的public的Field。 </li>
<li>public Field getDeclaredField(String name)返回此Class对象表示的类或接口的指定的Field。 </li>
<li>在Field中：<ul>
<li>public Object get(Object obj) 取得指定对象obj上此Field的属性内容</li>
<li>public void set(Object obj,Object value) 设置指定对象obj上此Field的属性内容</li>
</ul>
</li>
</ul>
</li>
<li><p>关于setAccessible方法的使用</p>
<ul>
<li>Method和Field、Constructor对象都有setAccessible()方法。 </li>
<li>setAccessible启动和禁用访问安全检查的开关。</li>
<li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。 <ul>
<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。 </li>
<li>使得原本无法访问的私有成员也可以访问</li>
</ul>
</li>
<li>参数值为false则指示反射的对象应该实施Java语言访问检查。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用运行时类中指定的结构：属性，方法，构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">    Person person = clazz.newInstance();</span><br><span class="line">    <span class="comment">//获取指定的属性。要求属性为public的</span></span><br><span class="line">    Field age = clazz.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="comment">//设置属性的值</span></span><br><span class="line">    age.set(person, <span class="number">18</span>);</span><br><span class="line">    Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    name.set(person,<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">    <span class="comment">//获取指定的方法</span></span><br><span class="line">    <span class="comment">//getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line">    <span class="comment">//name表示方法名，parameterTypes表示方法的形参，根据形参的不同可确定是哪个方法</span></span><br><span class="line">    Method show = clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line">    show.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//Object invoke(Object obj, Object... args):</span></span><br><span class="line">    <span class="comment">//obj表示方法的调用者，args表示要给方法的形参传递的实参</span></span><br><span class="line">    <span class="comment">//Object：表示方法的返回值</span></span><br><span class="line">    Object o = show.invoke(person, <span class="string">&quot;中国&quot;</span>);</span><br><span class="line">    System.out.println(o);</span><br><span class="line">    <span class="comment">//获取静态的结构</span></span><br><span class="line">    Method method = clazz.getEnclosingMethod();</span><br><span class="line">    System.out.println(method);</span><br><span class="line">    <span class="comment">//获取指定的构造器</span></span><br><span class="line">    Constructor&lt;Person&gt; declaredConstructor = clazz.getDeclaredConstructor();</span><br><span class="line">    declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Person person1 = declaredConstructor.newInstance();</span><br><span class="line">    System.out.println(person1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="反射的应用：动态代理"><a href="#反射的应用：动态代理" class="headerlink" title="反射的应用：动态代理"></a>反射的应用：动态代理</h1><ul>
<li>代理设计模式的原理: <ul>
<li>使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 </li>
</ul>
</li>
<li>静态代理，特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。最好可以通过一个代理类完成全部的代理功能</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态代理举例</span></span><br><span class="line"><span class="comment"> * 特点：代理类和被代理类在编译期间就确定下来了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClothFactory clothFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyClothFactory</span><span class="params">(ClothFactory clothFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clothFactory = clothFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行准备工作&quot;</span>);</span><br><span class="line">        clothFactory.produceCloth();</span><br><span class="line">        System.out.println(<span class="string">&quot;进行收尾工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NikeClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClothFactory clothFactory = <span class="keyword">new</span> NikeClothFactory();</span><br><span class="line">        ProxyClothFactory factory = <span class="keyword">new</span> ProxyClothFactory(clothFactory);</span><br><span class="line">        factory.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<ul>
<li>动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。</li>
<li>动态代理使用场合: <ul>
<li>调试</li>
<li>远程方法调用</li>
</ul>
</li>
<li>动态代理相比于静态代理的优点：<ul>
<li>抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。</li>
</ul>
</li>
<li>Java动态代理相关API<ul>
<li>Proxy ：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态地生成实现类。</li>
<li>提供用于创建动态代理类和动态代理对象的静态方法<ul>
<li>static Class<?> getProxyClass(ClassLoader loader, Class<?>… interfaces) 创建一个动态代理类所对应的Class对象</li>
<li>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 直接创建一个动态代理对象</li>
</ul>
</li>
</ul>
</li>
<li>动态代理步骤<ul>
<li>创建一个实现接口InvocationHandler的类，它必须实现invoke方法，以完成代理的具体操作。</li>
<li>创建被代理的类以及接口</li>
<li>通过Proxy的静态方法newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 创建一个Subject接口代理</li>
<li>通过 Subject代理调用RealSubject实现类的方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理的举例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getBelief</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">implements</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBelief</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I have a dream&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃&quot;</span>+food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现动态代理，需要解决的问题</span></span><br><span class="line"><span class="comment"> * 问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。</span></span><br><span class="line"><span class="comment"> * 问题二：当通过代理类的对象调用方法时，如何让动态的去调用被代理类的同名方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用此方法，返回一个代理类的对象。解决问题一。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 被代理类的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理类的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxyInstance</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(obj);</span><br><span class="line">        <span class="comment">//第一个参数：类加载器。由被代理类的对象引出</span></span><br><span class="line">        <span class="comment">//第二个参数：接口列表。让代理类实现和被代理类一样的接口</span></span><br><span class="line">        <span class="comment">//第三个参数：调用方法的调用处理程序</span></span><br><span class="line">        <span class="comment">//返回值即为代理类的对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理类的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line"><span class="comment">     * 将被代理类要执行的方法a的功能声明在incoke()中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理类的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 用代理类对象调用的方法对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//method:代理类的方法的对象</span></span><br><span class="line">        <span class="comment">//object：被代理类的对象</span></span><br><span class="line">        <span class="comment">//args：方法的参数</span></span><br><span class="line">        Object returnValue = method.invoke(object, args);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建被代理类的对象</span></span><br><span class="line">        Human human = <span class="keyword">new</span> SuperMan();</span><br><span class="line">        <span class="comment">//传入被代理类的对象，返回代理类的对象</span></span><br><span class="line">        Object proxyInstance1 = ProxyFactory.getProxyInstance(human);</span><br><span class="line">        Human human1 = (Human) proxyInstance1;</span><br><span class="line">        <span class="comment">//通过代理类对象调用方法，从而执行被代理类中相应的方法</span></span><br><span class="line">        System.out.println(human1.getBelief());</span><br><span class="line">        human1.eat(<span class="string">&quot;肉&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*************************&quot;</span>);</span><br><span class="line">        ClothFactory clothFactory = <span class="keyword">new</span> NikeClothFactory();</span><br><span class="line">        ClothFactory proxyInstance2 = (ClothFactory) ProxyFactory.getProxyInstance(clothFactory);</span><br><span class="line">        proxyInstance2.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有太大的意义。通常都是为指定的目标对象生成动态代理</li>
<li>这种动态代理在AOP中被称为AOP代理，AOP代理可代替目标对象，AOP代理包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异：AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* 反射的使用</span><br><span class="line">*  一，关于java.lang.Class类的理解</span><br><span class="line">*      <span class="number">1.</span>类的加载过程：程序经过javac.exe编译后会生成一个或多个字节码文件(.class结尾)。</span><br><span class="line">*          接着我们使用java.exe对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。</span><br><span class="line">*          解释运行的过程被称为类的加载。加载到内存中的类，我们就称为运行时类，</span><br><span class="line">*          此运行时类就作为Class的一个实例。</span><br><span class="line">*      <span class="number">2.</span>换句话说，Class的实例就对应着一个运行时类</span><br><span class="line">*      <span class="number">3.</span>加载到内存中的运行时类，会缓存一定的时间。在此时间内，可以通过不同方式获取此运行时类</span><br><span class="line">*      <span class="number">4.</span>对于数组而言，只要维度和元素类型一致，就是同一个<span class="class"><span class="keyword">class</span>实例</span></span><br></pre></td></tr></table></figure>




    </div>

    
    
    


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/07/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/Java8%E9%83%A8%E5%88%86%E6%96%B0%E7%89%B9%E6%80%A7/" rel="prev" title="Java8新特性">
      <i class="fa fa-chevron-left"></i> Java8新特性
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/07/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%AF%B4Java/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/1-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="next" title="多线程">
      多线程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">Java反射机制概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Class%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">Class类的理解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ClassLoader%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">3.</span> <span class="nav-text">ClassLoader的理解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.</span> <span class="nav-text">创建运行时类的对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84"><span class="nav-number">5.</span> <span class="nav-text">获取运行时类的完整结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84"><span class="nav-number">6.</span> <span class="nav-text">调用运行时类的指定结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text">反射的应用：动态代理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Plum Reiver</p>
  <div class="site-description" itemprop="description">技术，日常，笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
	
  </nav>
</div>


      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plum Reiver</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
