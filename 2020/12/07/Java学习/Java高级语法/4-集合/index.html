<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"plumv.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="Collection接口和list链表，map，以及set">
<meta property="og:type" content="article">
<meta property="og:title" content="集合">
<meta property="og:url" content="https://plumv.github.io/2020/12/07/Java%E5%AD%A6%E4%B9%A0/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/4-%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="李川的个人博客">
<meta property="og:description" content="Collection接口和list链表，map，以及set">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184400.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184401.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184402.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184403.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184404.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184405.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184406.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184407.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184408.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184409.png">
<meta property="og:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184410.png">
<meta property="article:published_time" content="2020-12-06T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-20T12:17:12.208Z">
<meta property="article:author" content="Plum Reiver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184400.png">

<link rel="canonical" href="https://plumv.github.io/2020/12/07/Java%E5%AD%A6%E4%B9%A0/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/4-%E9%9B%86%E5%90%88/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>集合 | 李川的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李川的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>日志</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://plumv.github.io/2020/12/07/Java%E5%AD%A6%E4%B9%A0/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/4-%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plum Reiver">
      <meta itemprop="description" content="技术，日常，笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李川的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          集合
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-07 00:00:00" itemprop="dateCreated datePublished" datetime="2020-12-07T00:00:00+08:00">2020-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-20 20:17:12" itemprop="dateModified" datetime="2021-03-20T20:17:12+08:00">2021-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%AD%A6%E4%B9%A0/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">Java高级语法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Collection接口和list链表，map，以及set</p>
<span id="more"></span>
<h1 id="Java集合框架概述"><a href="#Java集合框架概述" class="headerlink" title="Java集合框架概述"></a>Java集合框架概述</h1><ul>
<li><p>一方面， 面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。另一方面，使用Array存储对象方面具有一些弊端，而Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中。</p>
</li>
<li><p>数组在内存存储方面的特点：</p>
<ul>
<li>数组初始化以后，长度就确定了。</li>
<li>数组声明的类型，就决定了进行元素初始化时的类型</li>
</ul>
</li>
<li><p>数组在存储数据方面的弊端：</p>
<ul>
<li>数组初始化以后，长度就不可变了，不便于扩展</li>
<li>数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。同时无法直接获取存储元素的个数</li>
<li>数组存储的数据是有序的、可以重复的。—-&gt;存储数据的特点单一</li>
</ul>
</li>
<li><p>Java 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。</p>
</li>
<li><p>Java 集合可分为 Collection 和 Map 两种体系</p>
<ul>
<li>Collection接口：单列数据，定义了存取一组对象的方法的集合<ul>
<li>List：元素有序、可重复的集合</li>
<li>Set：元素无序、不可重复的集合</li>
</ul>
</li>
<li>Map接口：双列数据，保存具有映射关系“key-value对”的集合</li>
</ul>
</li>
<li><p>Collection接口继承树</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184400.png"></p>
</li>
<li><p>Map接口继承树</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184401.png"></p>
</li>
</ul>
<h1 id="Collection接口方法"><a href="#Collection接口方法" class="headerlink" title="Collection接口方法"></a>Collection接口方法</h1><ul>
<li><p>Collection 接口是 List、Set 和 Queue 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。 </p>
</li>
<li><p>JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。 </p>
</li>
<li><p>在 Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object 类型处理；从 JDK 5.0 增加了泛型以后，Java 集合可以记住容器中对象的数据类型。</p>
</li>
<li><p>接口的方法</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add(Object obj)</td>
<td align="center">添加元素obj到集合中</td>
</tr>
<tr>
<td align="center">addAll(Collection coll)</td>
<td align="center">将coll集合中的元素添加到当前集合中</td>
</tr>
<tr>
<td align="center">int size()</td>
<td align="center">获取有效元素的个数</td>
</tr>
<tr>
<td align="center">void clear()</td>
<td align="center">清空集合</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">是否是空集合</td>
</tr>
<tr>
<td align="center">boolean contains(Object obj)</td>
<td align="center">是否包含某个元素：是通过元素的equals方法来判断是否是同一个对象</td>
</tr>
<tr>
<td align="center">boolean containsAll(Collection c)</td>
<td align="center">是否包含某个元素：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。</td>
</tr>
<tr>
<td align="center">boolean remove(Object obj)</td>
<td align="center">通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素</td>
</tr>
<tr>
<td align="center">boolean removeAll(Collection coll)</td>
<td align="center">取当前集合的差集</td>
</tr>
<tr>
<td align="center">boolean retainAll(Collection c)</td>
<td align="center">把交集的结果存在当前集合中，不影响c</td>
</tr>
<tr>
<td align="center">boolean equals(Object obj)</td>
<td align="center">集合是否相等</td>
</tr>
<tr>
<td align="center">Object[] toArray()</td>
<td align="center">集合转成成对象数组</td>
</tr>
<tr>
<td align="center">hashCode()</td>
<td align="center">获取集合对象的哈希值</td>
</tr>
<tr>
<td align="center">iterator()</td>
<td align="center">返回迭代器对象，用于集合遍历</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Collection collection = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//add(Object obj):将元素obj添加到集合中</span></span><br><span class="line">collection.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">collection.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">collection.add(<span class="number">123</span>);</span><br><span class="line">collection.add(<span class="keyword">new</span> Date());</span><br><span class="line">collection.add(<span class="keyword">new</span> String(<span class="string">&quot;asd&quot;</span>));</span><br><span class="line"><span class="comment">//size():获取集合中元素的个数</span></span><br><span class="line">System.out.println(collection.size());</span><br><span class="line"><span class="comment">//addAll(Collection coll1):将coll1集合中的元素添加到当前集合中</span></span><br><span class="line">Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll1.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">coll1.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">collection.addAll(coll1);</span><br><span class="line">System.out.println(collection.size());</span><br><span class="line">System.out.println(collection);</span><br><span class="line"><span class="comment">//clear():清空集合中的元素</span></span><br><span class="line">collection.clear();</span><br><span class="line"><span class="comment">//isEmpty():判断当前集合是否为空</span></span><br><span class="line">System.out.println(collection.isEmpty());</span><br><span class="line"></span><br><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> Date());</span><br><span class="line">coll.add(<span class="keyword">new</span> String(<span class="string">&quot;asd&quot;</span>));</span><br><span class="line">coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;lc&quot;</span>,<span class="number">18</span>));</span><br><span class="line"><span class="comment">//contains(Object obj):判断当前集合中是否包含obj</span></span><br><span class="line"><span class="comment">//在判断时，会调用obj的equals方法，因此对于自定义的类要重写equals方法</span></span><br><span class="line">System.out.println(coll.contains(<span class="string">&quot;aa&quot;</span>));</span><br><span class="line">System.out.println(coll.contains(<span class="keyword">new</span> String(<span class="string">&quot;asd&quot;</span>)));</span><br><span class="line">System.out.println(coll.contains(<span class="keyword">new</span> Person(<span class="string">&quot;lc&quot;</span>,<span class="number">18</span>)));</span><br><span class="line"><span class="comment">//containsAll(Collection coll2):判断coll2中的元素是否都位于当前集合中</span></span><br><span class="line">Collection coll2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll2.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">coll2.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">System.out.println(coll.containsAll(coll2));</span><br><span class="line"><span class="comment">//remove(Object obj):移除当前集合中和obj相同的一个元素</span></span><br><span class="line">System.out.println(coll);</span><br><span class="line">System.out.println(coll.remove(<span class="number">123</span>));</span><br><span class="line">System.out.println(coll);</span><br><span class="line"><span class="comment">//removeAll(Collection coll3):移除当前集合与coll3中重复的元素,如果重复的元素则全部被移除</span></span><br><span class="line">Collection coll3 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll3.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">coll3.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">System.out.println(coll);</span><br><span class="line">System.out.println(coll.removeAll(coll3));</span><br><span class="line">System.out.println(coll);</span><br><span class="line"><span class="comment">//retainAll(Collection coll4):保留当前集合与coll4中相同的元素，其他的都移除。如果有重复元素则都保留</span></span><br><span class="line">Collection coll4 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll4.add(<span class="number">123</span>);</span><br><span class="line">coll4.add(<span class="number">345</span>);</span><br><span class="line">coll4.add(<span class="keyword">new</span> Person(<span class="string">&quot;lc&quot;</span>,<span class="number">18</span>));</span><br><span class="line">System.out.println(coll);</span><br><span class="line">System.out.println(coll.retainAll(coll4));</span><br><span class="line">System.out.println(coll);</span><br><span class="line"><span class="comment">//equals(Object obj)：当前集合和obj集合中的元素都相同则返回true,如果两个集合的顺序不同则看具体的集合种类。</span></span><br><span class="line">Collection coll5 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll5.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">coll5.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">System.out.println(coll3.equals(coll5));</span><br><span class="line"><span class="comment">//hashCode()：返回当前对象的哈希值</span></span><br><span class="line">System.out.println(coll.hashCode());</span><br><span class="line"><span class="comment">//toArray():集合 --&gt; 数组</span></span><br><span class="line">Object[] objects = coll.toArray();</span><br><span class="line">System.out.println(Arrays.toString(objects));</span><br><span class="line"><span class="comment">//Arrays.asList(数组):数组 --&gt; 集合 ; 注意基本数据类型数组的声明要用包装类</span></span><br><span class="line">List strings = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;asd&quot;</span>,<span class="string">&quot;qwe&quot;</span>&#125;);</span><br><span class="line">System.out.println(strings);</span><br></pre></td></tr></table></figure>

<h1 id="Iterator迭代器接口"><a href="#Iterator迭代器接口" class="headerlink" title="Iterator迭代器接口"></a>Iterator迭代器接口</h1><ul>
<li><p>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。</p>
</li>
<li><p>GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。 </p>
</li>
<li><p>Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。 </p>
</li>
<li><p>Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。</p>
</li>
<li><p>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</p>
</li>
<li><p>迭代器接口中的方法</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hasNext()</td>
<td align="center">当前指向的集合是否有下一个</td>
</tr>
<tr>
<td align="center">next()</td>
<td align="center">指向下移，然后返回当前指向的数据</td>
</tr>
<tr>
<td align="center">remove()</td>
<td align="center">移除当前指向的数据</td>
</tr>
</tbody></table>
<ul>
<li>在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。</li>
<li>迭代器的执行原理</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184402.png"></p>
<ul>
<li>Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方 法，不是集合对象的remove方法。 </li>
<li>如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> Date());</span><br><span class="line">coll.add(<span class="keyword">new</span> String(<span class="string">&quot;asd&quot;</span>));</span><br><span class="line">coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;lc&quot;</span>,<span class="number">18</span>));</span><br><span class="line"><span class="comment">//集合元素的遍历</span></span><br><span class="line">Iterator iterator = coll.iterator();</span><br><span class="line"><span class="comment">//hasNext()：判断iterator指向的容器中是否有下一个对象</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    <span class="comment">//next()：返回迭代器的下一个元素</span></span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collection coll2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll2.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">coll2.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">coll2.add(<span class="number">123</span>);</span><br><span class="line">coll2.add(<span class="keyword">new</span> Date());</span><br><span class="line">coll2.add(<span class="keyword">new</span> String(<span class="string">&quot;asd&quot;</span>));</span><br><span class="line">coll2.add(<span class="keyword">new</span> Person(<span class="string">&quot;lc&quot;</span>,<span class="number">18</span>));</span><br><span class="line">Iterator iterator2 = coll2.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator2.hasNext())&#123;</span><br><span class="line">    Object object = iterator2.next();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;asd&quot;</span>.equals(object))&#123;</span><br><span class="line">        <span class="comment">//remove():删除迭代器返回的最后一个元素，即next()指向的元素</span></span><br><span class="line">        iterator2.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(coll2);</span><br></pre></td></tr></table></figure>

<h2 id="增强for循环：foreach"><a href="#增强for循环：foreach" class="headerlink" title="增强for循环：foreach()"></a>增强for循环：foreach()</h2><ul>
<li><p>Java 5.0 提供了 foreach 循环迭代访问 Collection和数组。</p>
</li>
<li><p>遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。</p>
</li>
<li><p>遍历集合的底层调用Iterator完成操作。</p>
</li>
<li><p>foreach还可以用来遍历数组。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184403.png"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> Date());</span><br><span class="line">coll.add(<span class="keyword">new</span> String(<span class="string">&quot;asd&quot;</span>));</span><br><span class="line">coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;lc&quot;</span>,<span class="number">18</span>));</span><br><span class="line"><span class="comment">//for(元素的类型 局部变量:遍历对象)</span></span><br><span class="line"><span class="comment">//内部实质还是使用iterator来遍历元素</span></span><br><span class="line"><span class="keyword">for</span> (Object obj : coll) &#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Collection子接口一：List"><a href="#Collection子接口一：List" class="headerlink" title="Collection子接口一：List"></a>Collection子接口一：List</h1><ul>
<li><p>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组</p>
</li>
<li><p>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</p>
</li>
<li><p>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</p>
</li>
<li><p>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。</p>
</li>
<li><p>List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。 </p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void add(int index, Object ele)</td>
<td align="center">在index位置插入ele元素</td>
</tr>
<tr>
<td align="center">boolean addAll(int index, Collection eles)</td>
<td align="center">从index位置开始将eles中的所有元素添加进来</td>
</tr>
<tr>
<td align="center">Object get(int index)</td>
<td align="center">获取指定index位置的元素</td>
</tr>
<tr>
<td align="center">int indexOf(Object obj)</td>
<td align="center">返回obj在集合中首次出现的位置</td>
</tr>
<tr>
<td align="center">int lastIndexOf(Object obj)</td>
<td align="center">返回obj在当前集合中末次出现的位置</td>
</tr>
<tr>
<td align="center">Object remove(int index)</td>
<td align="center">移除指定index位置的元素，并返回此元素</td>
</tr>
<tr>
<td align="center">Object set(int index, Object ele)</td>
<td align="center">设置指定index位置的元素为ele</td>
</tr>
<tr>
<td align="center">List subList(int fromIndex, int toIndex)</td>
<td align="center">返回从fromIndex到toIndex位置的子集合</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">List  list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list1.add(<span class="number">123</span>);</span><br><span class="line">list1.add(<span class="string">&quot;asd&quot;</span>);</span><br><span class="line">list1.add(<span class="string">&quot;asd&quot;</span>);</span><br><span class="line">list1.add(<span class="string">&quot;asd&quot;</span>);</span><br><span class="line">list1.add(<span class="keyword">true</span>);</span><br><span class="line">list1.add(<span class="number">12.54</span>);</span><br><span class="line">list1.add(<span class="keyword">new</span> String(<span class="string">&quot;qwe&quot;</span>));</span><br><span class="line">list1.add(<span class="keyword">new</span> Person(<span class="string">&quot;lc&quot;</span>,<span class="number">18</span>));</span><br><span class="line">System.out.println(list1.toString());</span><br><span class="line"><span class="comment">//void add(int index, Object element)：在index位置插入element元素</span></span><br><span class="line">list1.add(<span class="number">1</span>, <span class="number">456</span>);</span><br><span class="line">System.out.println(list1.toString());</span><br><span class="line"><span class="comment">//void addAll(int index, Collection c)：从index位置开始将list2中的所有元素插入到当前list中</span></span><br><span class="line">List list2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list2.add(<span class="number">67</span>);</span><br><span class="line">list2.add(<span class="number">67</span>);</span><br><span class="line">list2.add(<span class="number">7</span>);</span><br><span class="line">list2.add(<span class="number">8</span>);</span><br><span class="line">list1.addAll(<span class="number">3</span>, list2);</span><br><span class="line">System.out.println(list1.toString());</span><br><span class="line"><span class="comment">//Object get(int index);获取位于index位置的元素。越界则返回-1</span></span><br><span class="line">System.out.println(list1.get(<span class="number">3</span>));</span><br><span class="line"><span class="comment">//int indexOf(Object o);返回元素o在集合中首次出现的位置</span></span><br><span class="line">System.out.println(list1.indexOf(<span class="string">&quot;asd&quot;</span>));</span><br><span class="line"><span class="comment">//int lastIndexOf(Object o);返回元素o在集合中最后一次出现的位置</span></span><br><span class="line">System.out.println(list1.lastIndexOf(<span class="string">&quot;asd&quot;</span>));</span><br><span class="line"><span class="comment">//Object remove(int index);移除集合中位于index位置的元素并返回这个元素</span></span><br><span class="line">System.out.println(list1.remove(<span class="number">2</span>));</span><br><span class="line">System.out.println(list1.toString());</span><br><span class="line"><span class="comment">//Object set(int index, Object element);设置集合的index位置的元素为element</span></span><br><span class="line">list1.set(<span class="number">0</span>, <span class="string">&quot;asd&quot;</span>);</span><br><span class="line">System.out.println(list1.toString());</span><br><span class="line"><span class="comment">//List subList(int fromIndex, int toIndex);将当前集合的从fromIndex到toIndex位置的元素复制到一个子集和中，并返回这个子集和</span></span><br><span class="line"><span class="comment">//范围：前闭后开。不会对当前集合的元素造成影响</span></span><br><span class="line">List list3 = list1.subList(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(list1.toString());</span><br><span class="line">System.out.println(list3.toString());</span><br><span class="line"><span class="comment">//boolean remove(Object o);删除集合中和o相等的元素，如果有多个则只删除第一个</span></span><br><span class="line">System.out.println(list1.remove(<span class="keyword">new</span> Integer(<span class="string">&quot;67&quot;</span>)));</span><br><span class="line">System.out.println(list1.toString());</span><br></pre></td></tr></table></figure>

<h2 id="List的实现类一：ArrayList"><a href="#List的实现类一：ArrayList" class="headerlink" title="List的实现类一：ArrayList"></a>List的实现类一：ArrayList</h2><ul>
<li>ArrayList 是 List 接口的典型实现类、主要实现类</li>
<li>本质上，ArrayList是对象引用的一个”变长”数组</li>
<li>ArrayList的JDK1.8之前与之后的实现区别？<ul>
<li>JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组</li>
<li>JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组</li>
</ul>
</li>
<li>Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合</li>
</ul>
<h2 id="List的实现类二：LinkedList"><a href="#List的实现类二：LinkedList" class="headerlink" title="List的实现类二：LinkedList"></a>List的实现类二：LinkedList</h2><ul>
<li><p>对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高</p>
</li>
<li><p>LinkedList：双向链表，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。<br>同时，定义内部类Node，作为LinkedList中保存数据的基本结构。Node除了保存数据，还定义了两个变量：</p>
<ul>
<li>prev变量记录前一个元素的位置</li>
<li>next变量记录下一个元素的位置</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184404.png"></p>
</li>
<li><p>新增方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void addFirst(Object obj)</td>
<td align="center">将一个元素添加在第一位</td>
</tr>
<tr>
<td align="center">void addLast(Object obj)</td>
<td align="center">将一个元素添加在最后一位</td>
</tr>
<tr>
<td align="center">Object getFirst()</td>
<td align="center">获取第一位上的元素</td>
</tr>
<tr>
<td align="center">Object getLast()</td>
<td align="center">获取最后一位上的元素</td>
</tr>
<tr>
<td align="center">Object removeFirst()</td>
<td align="center">移除第一位上的元素</td>
</tr>
<tr>
<td align="center">Object removeLast()</td>
<td align="center">移除最后一位上的元素</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="List的实现类三：Vector"><a href="#List的实现类三：Vector" class="headerlink" title="List的实现类三：Vector"></a>List的实现类三：Vector</h2><ul>
<li><p>Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。</p>
</li>
<li><p>在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。</p>
</li>
<li><p>新增方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void addElement(Object obj)</td>
<td align="center">往集合中添加一个元素obj</td>
</tr>
<tr>
<td align="center">void insertElementAt(Object obj,int index)</td>
<td align="center">在index位置上插入一个元素obj</td>
</tr>
<tr>
<td align="center">void setElementAt(Object obj,int index)</td>
<td align="center">把index位置上的元素设置为obj</td>
</tr>
<tr>
<td align="center">void removeElement(Object obj)</td>
<td align="center">移除元素obj</td>
</tr>
<tr>
<td align="center">void removeAllElements()</td>
<td align="center">移除集合中所有 的元素</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">面试题：</span><br><span class="line">请问ArrayList&#x2F;LinkedList&#x2F;Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别? </span><br><span class="line"></span><br><span class="line">1.ArrayList和LinkedList的异同</span><br><span class="line"> 	二者都线程不安全，相对线程安全的Vector，执行效率高。此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链</span><br><span class="line">表的数据结构。对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指</span><br><span class="line">插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。</span><br><span class="line">2.ArrayList和Vector的区别</span><br><span class="line"> 	Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比</span><br><span class="line">ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。</span><br><span class="line">Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。</span><br></pre></td></tr></table></figure>

<h1 id="Collection子接口二：Set"><a href="#Collection子接口二：Set" class="headerlink" title="Collection子接口二：Set"></a>Collection子接口二：Set</h1><ul>
<li>Set接口是Collection的子接口，set接口没有提供额外的方法</li>
<li>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败。</li>
<li>Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法</li>
</ul>
<h2 id="Set的实现类一：HashSet"><a href="#Set的实现类一：HashSet" class="headerlink" title="Set的实现类一：HashSet"></a>Set的实现类一：HashSet</h2><ul>
<li><p>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。</p>
</li>
<li><p>HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。 </p>
</li>
<li><p>HashSet 具有以下特点：</p>
<ul>
<li>不能保证元素的排列顺序</li>
<li>HashSet 不是线程安全的</li>
<li>集合元素可以是 null</li>
</ul>
</li>
<li><p>HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。 </p>
</li>
<li><p>对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。</p>
</li>
<li><p>向HashSet中添加元素的过程：</p>
<ul>
<li>当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好） </li>
<li>如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过链表的方式继续链接。 </li>
<li>如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。</li>
</ul>
</li>
<li><p>图解添加过程</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184405.png"></p>
</li>
<li><p>重写 hashCode() 方法的基本原则</p>
<ul>
<li>在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值。</li>
<li>当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode() 方法的返回值也应相等。</li>
<li>对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</li>
</ul>
</li>
<li><p>重写 equals() 方法的基本原则</p>
<ul>
<li>当一个类有自己特有的“逻辑相等”概念,当改写equals()的时候，总是要改写hashCode()，根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法，它们仅仅是两个对象。</li>
<li>因此，违反了“相等的对象必须具有相等的散列码”。</li>
<li>结论：复写equals方法的时候一般都需要同时复写hashCode方法。通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算</li>
</ul>
</li>
<li><p>以Eclipse/IDEA为例，在自定义类中可以调用工具自动重写equals和hashCode。</p>
<ul>
<li>问题：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？</li>
<li>原因：选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）</li>
<li>并且31只占用5bits,相乘造成数据溢出的概率较小。</li>
<li>31可以 由i*31== (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）</li>
<li>31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set set = <span class="keyword">new</span> HashSet();</span><br><span class="line">set.add(<span class="number">123</span>);</span><br><span class="line">set.add(<span class="number">13</span>);</span><br><span class="line">set.add(<span class="number">12</span>);</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="string">&quot;lc&quot;</span>,<span class="number">18</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="string">&quot;lc&quot;</span>,<span class="number">18</span>));</span><br><span class="line">Iterator iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line">Person&#123;name=<span class="string">&#x27;lc&#x27;</span>, age=<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Set的实现类二：LinkedHashSet"><a href="#Set的实现类二：LinkedHashSet" class="headerlink" title="Set的实现类二：LinkedHashSet"></a>Set的实现类二：LinkedHashSet</h2><ul>
<li><p>LinkedHashSet 是 HashSet 的子类</p>
</li>
<li><p>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。</p>
</li>
<li><p>LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</p>
</li>
<li><p>LinkedHashSet 不允许集合元素重复。</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184406.png"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set set = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">set.add(<span class="number">123</span>);</span><br><span class="line">set.add(<span class="number">13</span>);</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="string">&quot;lc&quot;</span>,<span class="number">18</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="string">&quot;lc&quot;</span>,<span class="number">18</span>));</span><br><span class="line">set.add(<span class="number">12</span>);</span><br><span class="line">Iterator iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line">Person&#123;name=<span class="string">&#x27;lc&#x27;</span>, age=<span class="number">18</span>&#125;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<h2 id="Set的实现类三：TreeSet"><a href="#Set的实现类三：TreeSet" class="headerlink" title="Set的实现类三：TreeSet"></a>Set的实现类三：TreeSet</h2><ul>
<li><p>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。</p>
</li>
<li><p>TreeSet底层使用红黑树结构存储数据</p>
</li>
<li><p>新增的方法如下： (了解) </p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Comparator comparator()</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Object first()</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Object last()</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Object lower(Object e)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Object higher(Object e)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SortedSet subSet(fromElement, toElement)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SortedSet headSet(toElement)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SortedSet tailSet(fromElement)</td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
<li><p>TreeSet 两种排序方法：自然排序和定制排序。默认情况下，TreeSet 采用自然排序。</p>
</li>
<li><p>特点：有序，查询速度比List快</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Set set1 = <span class="keyword">new</span> TreeSet();</span><br><span class="line">set1.add(<span class="number">123</span>);</span><br><span class="line">set1.add(<span class="number">13</span>);</span><br><span class="line">set1.add(<span class="number">13</span>);</span><br><span class="line">set1.add(<span class="number">12</span>);</span><br><span class="line">set1.add(<span class="number">12</span>);</span><br><span class="line">Iterator iterator3 = set1.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator3.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator3.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<h3 id="自然排序："><a href="#自然排序：" class="headerlink" title="自然排序："></a>自然排序：</h3><ul>
<li>TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列</li>
<li>如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。<ul>
<li>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。 </li>
</ul>
</li>
<li>Comparable 的典型实现：<ul>
<li>BigDecimal、BigInteger 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较</li>
<li>Character：按字符的 unicode值来进行比较</li>
<li>Boolean：true 对应的包装类实例大于 false 对应的包装类实例</li>
<li>String：按字符串中字符的 unicode 值进行比较</li>
<li>Date、Time：后边的时间、日期比前面的时间、日期大</li>
</ul>
</li>
<li>向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。</li>
<li>因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是同一个类的对象。</li>
<li>对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值。</li>
<li>当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保证该方法与 compareTo(Object obj) 方法有一致的结果：如果两个对象通过equals() 方法比较返回 true，则通过 compareTo(Object obj) 方法比较应返回 0。否则，让人难以理解。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Set set = <span class="keyword">new</span> TreeSet();</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="string">&quot;lc&quot;</span>,<span class="number">18</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="string">&quot;lsc&quot;</span>,<span class="number">14</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="string">&quot;ldc&quot;</span>,<span class="number">19</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="string">&quot;ldc&quot;</span>,<span class="number">18</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="string">&quot;lfc&quot;</span>,<span class="number">10</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="string">&quot;lfc&quot;</span>,<span class="number">15</span>));</span><br><span class="line">Iterator iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Person&#123;name=<span class="string">&#x27;lc&#x27;</span>, age=<span class="number">18</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;ldc&#x27;</span>, age=<span class="number">18</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;ldc&#x27;</span>, age=<span class="number">19</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;lfc&#x27;</span>, age=<span class="number">10</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;lfc&#x27;</span>, age=<span class="number">15</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;lsc&#x27;</span>, age=<span class="number">14</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h3><ul>
<li>TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来实现。需要重写compare(T o1,T o2)方法。 </li>
<li>利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。 </li>
<li>要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。</li>
<li>此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常。</li>
<li>使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Set set2 = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Person &amp;&amp; o2 <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(((Person) o1).getAge(), ((Person) o2).getAge());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不一致&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">set2.add(<span class="keyword">new</span> Person(<span class="string">&quot;lc&quot;</span>,<span class="number">18</span>));</span><br><span class="line">set2.add(<span class="keyword">new</span> Person(<span class="string">&quot;lsc&quot;</span>,<span class="number">14</span>));</span><br><span class="line">set2.add(<span class="keyword">new</span> Person(<span class="string">&quot;ldc&quot;</span>,<span class="number">19</span>));</span><br><span class="line">set2.add(<span class="keyword">new</span> Person(<span class="string">&quot;ldc&quot;</span>,<span class="number">17</span>));</span><br><span class="line">set2.add(<span class="keyword">new</span> Person(<span class="string">&quot;lfc&quot;</span>,<span class="number">10</span>));</span><br><span class="line">set2.add(<span class="keyword">new</span> Person(<span class="string">&quot;lfc&quot;</span>,<span class="number">15</span>));</span><br><span class="line">Iterator iterator2 = set2.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator2.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator2.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Person&#123;name=<span class="string">&#x27;lfc&#x27;</span>, age=<span class="number">10</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;lsc&#x27;</span>, age=<span class="number">14</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;lfc&#x27;</span>, age=<span class="number">15</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;ldc&#x27;</span>, age=<span class="number">17</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;lc&#x27;</span>, age=<span class="number">18</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;ldc&#x27;</span>, age=<span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><ul>
<li><p>Map与Collection并列存在。用于保存具有映射关系的数据:key-value</p>
</li>
<li><p>Map 中的 key 和 value 都可以是任何引用类型的数据</p>
</li>
<li><p>Map 中的 key 用Set来存放，不允许重复，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法</p>
</li>
<li><p>常用String类作为Map的“键”</p>
</li>
<li><p>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value</p>
</li>
<li><p>Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是 Map 接口使用频率最高的实现类</p>
</li>
<li><p>常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Object put(Object key,Object value)</td>
<td align="center">将指定key-value添加到(或修改)当前map对象中</td>
</tr>
<tr>
<td align="center">void putAll(Map m)</td>
<td align="center">将m中的所有key-value对存放到当前map中</td>
</tr>
<tr>
<td align="center">Object remove(Object key)</td>
<td align="center">移除指定key的key-value对，并返回value</td>
</tr>
<tr>
<td align="center">void clear()</td>
<td align="center">清空当前map中的所有数据</td>
</tr>
<tr>
<td align="center">Object get(Object key)</td>
<td align="center">获取指定key对应的value</td>
</tr>
<tr>
<td align="center">boolean containsKey(Object key)</td>
<td align="center">是否包含指定的key</td>
</tr>
<tr>
<td align="center">boolean containsValue(Object value)</td>
<td align="center">是否包含指定的value</td>
</tr>
<tr>
<td align="center">int size()</td>
<td align="center">返回map中key-value对的个数</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">判断当前map是否为空</td>
</tr>
<tr>
<td align="center">boolean equals(Object obj)</td>
<td align="center">判断当前map和参数对象obj是否相等</td>
</tr>
<tr>
<td align="center">Set keySet()</td>
<td align="center">返回所有key构成的Set集合</td>
</tr>
<tr>
<td align="center">Collection values()</td>
<td align="center">返回所有value构成的Collection集合</td>
</tr>
<tr>
<td align="center">Set entrySet()</td>
<td align="center">返回所有key-value对构成的Set集合</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="comment">//添加Object put(K key, V value);</span></span><br><span class="line">map.put(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aa&quot;</span>);</span><br><span class="line">map.put(<span class="number">23</span>, <span class="keyword">new</span> Person(<span class="string">&quot;lc&quot;</span>,<span class="number">18</span>));</span><br><span class="line">map.put(<span class="string">&quot;bb&quot;</span>, <span class="number">45</span>);</span><br><span class="line">map.put(<span class="string">&quot;cc&quot;</span>, <span class="number">15.5</span>);</span><br><span class="line"><span class="comment">//修改Object put(K key, V value);</span></span><br><span class="line">map.put(<span class="string">&quot;cc&quot;</span>, <span class="number">18.5</span>);</span><br><span class="line">System.out.println(map.toString());</span><br><span class="line">System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">Map map2 = <span class="keyword">new</span> HashMap();</span><br><span class="line">map2.put(<span class="string">&quot;cc&quot;</span>, <span class="number">49</span>);</span><br><span class="line">map2.put(<span class="string">&quot;dd&quot;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//putAll(Map m);</span></span><br><span class="line">map.putAll(map2);</span><br><span class="line">System.out.println(map.toString());</span><br><span class="line">System.out.println(map2.toString());</span><br><span class="line">System.out.println(<span class="string">&quot;*************************&quot;</span>);</span><br><span class="line"><span class="comment">//Object remove(Object key)</span></span><br><span class="line">Object bb = map.remove(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">System.out.println(bb);</span><br><span class="line">System.out.println(map.toString());</span><br><span class="line">System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line"><span class="comment">//void clear() :</span></span><br><span class="line">map.clear();</span><br><span class="line">System.out.println(map.size());</span><br><span class="line">System.out.println(map.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">HashMap map3 = <span class="keyword">new</span> HashMap();</span><br><span class="line">map3.put(<span class="string">&quot;aa&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map3.put(<span class="string">&quot;bb&quot;</span>, <span class="number">2</span>);</span><br><span class="line">map3.put(<span class="string">&quot;cc&quot;</span>, <span class="number">3</span>);</span><br><span class="line">map3.put(<span class="string">&quot;dd&quot;</span>, <span class="number">4</span>);</span><br><span class="line">System.out.println(map3.get(<span class="string">&quot;bb&quot;</span>));</span><br><span class="line">System.out.println(map3.containsKey(<span class="string">&quot;bb&quot;</span>));</span><br><span class="line">System.out.println(map3.containsValue(<span class="number">4</span>));</span><br><span class="line">System.out.println(map3.size());</span><br><span class="line">System.out.println(map3.isEmpty());</span><br><span class="line">System.out.println(map3.equals(map));</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Set set = map3.keySet();</span><br><span class="line">Iterator iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;***********************&quot;</span>);</span><br><span class="line">Collection collection = map3.values();</span><br><span class="line">Iterator iterator1 = collection.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator1.next());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;*********************&quot;</span>);</span><br><span class="line">Set set1 = map3.entrySet();</span><br><span class="line">Iterator iterator2 = set1.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator2.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator2.next());</span><br><span class="line">&#125;</span><br><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="comment">//map.put(..,..)省略</span></span><br><span class="line">System.out.println(<span class="string">&quot;map的所有key:&quot;</span>);</span><br><span class="line">Set keys = map.keySet();<span class="comment">// HashSet</span></span><br><span class="line"><span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;-&gt;&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;map的所有的value：&quot;</span>);</span><br><span class="line">Collection values = map.values();</span><br><span class="line">Iterator iter = values.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    System.out.println(iter.next());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;map所有的映射关系：&quot;</span>);</span><br><span class="line"><span class="comment">// 映射关系的类型是Map.Entry类型，它是Map接口的内部接口</span></span><br><span class="line">Set mappings = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Object mapping : mappings) &#123;</span><br><span class="line">    Map.Entry entry = (Map.Entry) mapping;</span><br><span class="line">    System.out.println(<span class="string">&quot;key是：&quot;</span> + entry.getKey() + <span class="string">&quot;，value是：&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map的实现类一：HashMap"><a href="#Map的实现类一：HashMap" class="headerlink" title="Map的实现类一：HashMap"></a>Map的实现类一：HashMap</h2><ul>
<li><p>HashMap是 Map 接口使用频率最高的实现类。</p>
</li>
<li><p>允许使用null键和null值，与HashSet一样，不保证映射的顺序。</p>
</li>
<li><p>所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写：equals()和hashCode()</p>
</li>
<li><p>所有的value构成的集合是Collection:无序的、可以重复的。所以，value所在的类要重写：equals()</p>
</li>
<li><p>一个key-value构成一个entry</p>
</li>
<li><p>所有的entry构成的集合是Set:无序的、不可重复的</p>
</li>
<li><p>HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true，hashCode 值也相等。</p>
</li>
<li><p>HashMap 判断两个 value相等的标准是：两个 value 通过 equals() 方法返回 true</p>
</li>
<li><p>HashMap的存储结构</p>
<ul>
<li>JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法)</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184407.png"></p>
<ul>
<li>JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。</li>
</ul>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184408.png"></p>
</li>
<li><p>HashMap源码中的重要常量</p>
<table>
<thead>
<tr>
<th align="center">常量名</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DEFAULT_INITIAL_CAPACITY</td>
<td align="center">HashMap的默认容量，16</td>
</tr>
<tr>
<td align="center">MAXIMUM_CAPACITY</td>
<td align="center">HashMap的最大支持容量，2^30</td>
</tr>
<tr>
<td align="center">DEFAULT_LOAD_FACTOR</td>
<td align="center">HashMap的默认加载因子</td>
</tr>
<tr>
<td align="center">TREEIFY_THRESHOLD</td>
<td align="center">Bucket中链表长度大于该默认值，转化为红黑树</td>
</tr>
<tr>
<td align="center">UNTREEIFY_THRESHOLD</td>
<td align="center">Bucket中红黑树存储的Node小于该默认值，转化为链表</td>
</tr>
<tr>
<td align="center">MIN_TREEIFY_CAPACITY</td>
<td align="center">桶中的Node被树化时最小的hash表容量。</td>
</tr>
<tr>
<td align="center">table</td>
<td align="center">存储元素的数组，总是2的n次幂</td>
</tr>
<tr>
<td align="center">entrySet</td>
<td align="center">存储具体元素的集</td>
</tr>
<tr>
<td align="center">size</td>
<td align="center">HashMap中存储的键值对的数量</td>
</tr>
<tr>
<td align="center">modCount</td>
<td align="center">HashMap扩容和结构改变的次数。</td>
</tr>
<tr>
<td align="center">threshold</td>
<td align="center">扩容的临界值，=容量*填充因子</td>
</tr>
<tr>
<td align="center">loadFactor</td>
<td align="center">填充因子</td>
</tr>
</tbody></table>
<ul>
<li>当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。</li>
</ul>
</li>
<li><p>JDK 7之前</p>
<ul>
<li>HashMap的内部存储结构其实是数组和链表的结合。当实例化一个HashMap时，系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。 </li>
<li>每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head。</li>
<li>添加元素的过程：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">向HashMap中添加entry1(key，value)，需要首先计算entry1中key的哈希值(根据</span><br><span class="line">key所在类的hashCode()计算得到)，此哈希值经过处理以后，得到在底层Entry[]数</span><br><span class="line">组中要存储的位置i。如果位置i上没有元素，则entry1直接添加成功。如果位置i上</span><br><span class="line">已经存在entry2(或还有链表存在的entry3，entry4)，则需要通过循环的方法，依次</span><br><span class="line">比较entry1中key和其他的entry。如果彼此hash值不同，则直接添加成功。如果</span><br><span class="line">hash值不同，继续比较二者是否equals。如果返回值为<span class="keyword">true</span>，则使用entry1的value</span><br><span class="line">去替换equals为<span class="keyword">true</span>的entry的value。如果遍历一遍以后，发现所有的equals返回都</span><br><span class="line">为<span class="keyword">false</span>,则entry1仍可添加成功。entry1指向原有的entry元素。</span><br></pre></td></tr></table></figure>

<ul>
<li>HashMap的扩容</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的</span><br><span class="line">长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，而在</span><br><span class="line">HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算</span><br><span class="line">其在新数组中的位置，并放进去，这就是resize。</span><br></pre></td></tr></table></figure>

<ul>
<li>那么HashMap什么时候进行扩容呢？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数</span><br><span class="line">size)*loadFactor 时 ， 就 会 进 行 数 组 扩 容 ，loadFactor的默认值 (DEFAULT_LOAD_FACTOR)为<span class="number">0.75</span>，这是一个折中的取值。也就是说，默认情况</span><br><span class="line">下，数组大小(DEFAULT_INITIAL_CAPACITY)为<span class="number">16</span>，那么当HashMap中元素个数</span><br><span class="line">超过<span class="number">16</span>*<span class="number">0.75</span>=<span class="number">12</span>（这个值就是代码中的threshold值，也叫做临界值）的时候，就把</span><br><span class="line">数组的大小扩展为 <span class="number">2</span>*<span class="number">16</span>=<span class="number">32</span>，即扩大一倍，然后重新计算每个元素在数组中的位置，</span><br><span class="line">而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，</span><br><span class="line">那么预设元素的个数能够有效的提高HashMap的性能。</span><br></pre></td></tr></table></figure></li>
<li><p>JDK 8时</p>
<ul>
<li>HashMap的内部存储结构其实是数组+链表+树的结合。当实例化一个HashMap时，会初始化initialCapacity和loadFactor，在put第一对映射关系时，系统会创建一个长度为initialCapacity的Node数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。 </li>
<li>每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带一个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，每一个TreeNode对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last，或树的叶子结点。</li>
<li>那么HashMap什么时候进行扩容和树形化呢？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数</span><br><span class="line">size)*loadFactor 时 ， 就会进行数组扩容 ， loadFactor 的默认 值 (DEFAULT_LOAD_FACTOR)为<span class="number">0.75</span>，这是一个折中的取值。也就是说，默认</span><br><span class="line">情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为<span class="number">16</span>，那么当HashMap中</span><br><span class="line">元素个数超过<span class="number">16</span>*<span class="number">0.75</span>=<span class="number">12</span>（这个值就是代码中的threshold值，也叫做临界值）</span><br><span class="line">的时候，就把数组的大小扩展为 <span class="number">2</span>*<span class="number">16</span>=<span class="number">32</span>，即扩大一倍，然后重新计算每个元</span><br><span class="line">素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知</span><br><span class="line">HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</span><br><span class="line">    </span><br><span class="line">当HashMap中的其中一个链的对象个数如果达到了<span class="number">8</span>个，此时如果capacity没有</span><br><span class="line">达到<span class="number">64</span>，那么HashMap会先扩容解决，如果已经达到了<span class="number">64</span>，那么这个链会变成</span><br><span class="line">树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，</span><br><span class="line">下次resize方法时判断树的结点个数低于<span class="number">6</span>个，也会把树再转为链表。</span><br></pre></td></tr></table></figure>

<ul>
<li>关于映射关系的key是否可以修改？answer：不要修改</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算</span><br><span class="line">每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的映射关</span><br><span class="line">系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。</span><br></pre></td></tr></table></figure></li>
<li><p>总结：JDK1.8相较于之前的变化：</p>
<ul>
<li>HashMap map = new HashMap();//默认情况下，先不创建长度为16的数组</li>
<li>当首次调用map.put()时，再创建长度为16的数组</li>
<li>数组为Node类型，在jdk7中称为Entry类型</li>
<li>形成链表结构时，新添加的key-value对在链表的尾部（七上八下）</li>
<li>当数组指定索引位置的链表长度&gt;8时，且map中的数组的长度&gt; 64时，此索引位置上的所有key-value对使用红黑树进行存储。</li>
</ul>
</li>
<li><p>面试题：负载因子值的大小，对HashMap有什么影响?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>负载因子的大小决定了HashMap的数据密度。</span><br><span class="line"><span class="number">2.</span>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长,</span><br><span class="line">造成查询或插入时的比较次数增多，性能会下降。</span><br><span class="line"><span class="number">3.</span>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的</span><br><span class="line">几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性</span><br><span class="line">能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建</span><br><span class="line">议初始化预设大一点的空间。</span><br><span class="line"><span class="number">4.</span>按照其他语言的参考及研究经验，会考虑将负载因子设置为<span class="number">0.7</span>~<span class="number">0.75</span>，此</span><br><span class="line">时平均检索长度接近于常数。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Map的实现类二：LinkedHashMap"><a href="#Map的实现类二：LinkedHashMap" class="headerlink" title="Map的实现类二：LinkedHashMap"></a>Map的实现类二：LinkedHashMap</h2><ul>
<li><p>LinkedHashMap 是 HashMap 的子类</p>
</li>
<li><p>在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的顺序</p>
</li>
<li><p>与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致</p>
</li>
<li><p>LinkedHashMap和 HashMap 的区别</p>
<ul>
<li>HashMap中的内部类：Node</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">	<span class="keyword">final</span> K key;</span><br><span class="line">	V value;</span><br><span class="line">	Node&lt;K,V&gt; next; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>LinkedHashMap中的内部类：Entry</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	Entry&lt;K,V&gt; before, after;</span><br><span class="line">	Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">		<span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">map.put(<span class="string">&quot;aa&quot;</span>, <span class="number">12</span>);</span><br><span class="line">map.put(<span class="string">&quot;bb&quot;</span>, <span class="number">12</span>);</span><br><span class="line">map.put(<span class="string">&quot;cc&quot;</span>, <span class="number">12</span>);</span><br><span class="line">map.put(<span class="string">&quot;dd&quot;</span>, <span class="number">12</span>);</span><br><span class="line">System.out.println(map.toString());</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Map实现类之三：TreeMap"><a href="#Map实现类之三：TreeMap" class="headerlink" title="Map实现类之三：TreeMap"></a>Map实现类之三：TreeMap</h2><ul>
<li><p>TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。</p>
</li>
<li><p>TreeMap 可以保证所有的 Key-Value 对处于有序状态。 </p>
</li>
<li><p>TreeSet底层使用红黑树结构存储数据。</p>
</li>
<li><p>TreeMap 的 Key 的排序：</p>
<ul>
<li>自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException</li>
<li>定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现Comparable 接口</li>
</ul>
</li>
<li><p>TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自然排序：key对象对应类继承Comparable接口实现compareTo()方法</span></span><br><span class="line">Map map = <span class="keyword">new</span> TreeMap();</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">&quot;lc&quot;</span>,<span class="number">18</span>), <span class="number">45</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">&quot;qw&quot;</span>,<span class="number">26</span>), <span class="number">85</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">&quot;as&quot;</span>,<span class="number">52</span>), <span class="number">60</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">&quot;zx&quot;</span>,<span class="number">45</span>), <span class="number">98</span>);</span><br><span class="line"><span class="comment">//key类型不一致会报ClassCastException异常</span></span><br><span class="line"><span class="comment">//map.put(&quot;as&quot;, 45);</span></span><br><span class="line">System.out.println(map);</span><br><span class="line">System.out.println(<span class="string">&quot;******************************&quot;</span>);</span><br><span class="line"><span class="comment">//定制排序</span></span><br><span class="line">Map map1 = <span class="keyword">new</span> TreeMap(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Person &amp;&amp; o2 <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(((Person) o1).getAge(), ((Person) o2).getAge());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不一致&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">map1.put(<span class="keyword">new</span> Person(<span class="string">&quot;lc&quot;</span>,<span class="number">18</span>), <span class="number">45</span>);</span><br><span class="line">map1.put(<span class="keyword">new</span> Person(<span class="string">&quot;qw&quot;</span>,<span class="number">26</span>), <span class="number">85</span>);</span><br><span class="line">map1.put(<span class="keyword">new</span> Person(<span class="string">&quot;as&quot;</span>,<span class="number">52</span>), <span class="number">60</span>);</span><br><span class="line">map1.put(<span class="keyword">new</span> Person(<span class="string">&quot;zx&quot;</span>,<span class="number">45</span>), <span class="number">98</span>);</span><br><span class="line">System.out.println(map1);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Map实现类之四：Hashtable"><a href="#Map实现类之四：Hashtable" class="headerlink" title="Map实现类之四：Hashtable"></a>Map实现类之四：Hashtable</h2><ul>
<li>Hashtable是个古老的 Map 实现类，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的。</li>
<li>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。 </li>
<li>与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value</li>
<li>与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序</li>
<li>Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</li>
</ul>
<h2 id="Map实现类之五：Properties"><a href="#Map实现类之五：Properties" class="headerlink" title="Map实现类之五：Properties"></a>Map实现类之五：Properties</h2><ul>
<li><p>Properties 类是 Hashtable 的子类，该对象用于处理属性文件</p>
</li>
<li><p>由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型</p>
</li>
<li><p>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    FileInputStream stream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">    properties.load(stream);</span><br><span class="line">    String name = properties.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    String account = properties.getProperty(<span class="string">&quot;account&quot;</span>);</span><br><span class="line">    System.out.println(name + <span class="string">&quot; &quot;</span> + password + <span class="string">&quot; &quot;</span>+ account);</span><br><span class="line">    stream.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Properties的使用：用来读取配置文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">//方式一：默认加载文件在当前module下</span></span><br><span class="line">    <span class="comment">//        FileInputStream fis = new FileInputStream(&quot;jdbc.properties&quot;);</span></span><br><span class="line">    <span class="comment">//        properties.load(fis);</span></span><br><span class="line">    <span class="comment">//方式二：默认加载文件在当前module的src下</span></span><br><span class="line">    ClassLoader classLoader = Person.class.getClassLoader();</span><br><span class="line">    InputStream is = classLoader.getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">    properties.load(is);</span><br><span class="line"></span><br><span class="line">    String name = properties.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    String account = properties.getProperty(<span class="string">&quot;account&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name: &quot;</span> + name +</span><br><span class="line">                       <span class="string">&quot;\npassword: &quot;</span> + password +</span><br><span class="line">                       <span class="string">&quot;\naccount: &quot;</span> + account);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h1><ul>
<li><p>Collections 是一个操作 Set、List 和 Map 等集合的工具类<br>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</p>
</li>
<li><p>常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>reverse(List)</td>
<td>反转 List 中元素的顺序</td>
</tr>
<tr>
<td>shuffle(List)</td>
<td>对 List 集合元素进行随机排序</td>
</tr>
<tr>
<td>sort(List)</td>
<td>根据元素的自然顺序对指定 List 集合元素按升序排序</td>
</tr>
<tr>
<td>sort(List，Comparator)</td>
<td>根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</td>
</tr>
<tr>
<td>swap(List，int i， int j)</td>
<td>将指定 list 集合中的 i 处元素和 j 处元素进行交换</td>
</tr>
<tr>
<td>Object max(Collection)</td>
<td>根据元素的自然顺序，返回给定集合中的最大元素</td>
</tr>
<tr>
<td>Object max(Collection，Comparator)</td>
<td>根据 Comparator 指定的顺序，返回给定集合中的最大元素</td>
</tr>
<tr>
<td>Object min(Collection)</td>
<td>根据元素的自然顺序，返回给定集合中的最大元小</td>
</tr>
<tr>
<td>Object min(Collection，Comparator)</td>
<td>根据 Comparator 指定的顺序，返回给定集合中的最小元素</td>
</tr>
<tr>
<td>int frequency(Collection，Object)</td>
<td>返回指定集合中指定元素的出现次数</td>
</tr>
<tr>
<td>void copy(List dest,List src)</td>
<td>将src中的内容复制到dest中</td>
</tr>
<tr>
<td>boolean replaceAll(List list，Object oldVal，Object newVal)</td>
<td>使用新值替换List 对象的所有旧值</td>
</tr>
</tbody></table>
</li>
<li><p>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</p>
<p><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184409.png"></p>
</li>
</ul>
<h1 id="补充：Enumeration"><a href="#补充：Enumeration" class="headerlink" title="补充：Enumeration"></a>补充：Enumeration</h1><ul>
<li>Enumeration 接口是 Iterator 迭代器的 “古老版本“</li>
<li><img src="https://gitee.com/plumChuan/picture-bed/raw/master/img/20201207184410.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Enumeration stringEnum = <span class="keyword">new</span> StringTokenizer(<span class="string">&quot;a-b*c-d-e-g&quot;</span>, <span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(stringEnum.hasMoreElements())&#123;</span><br><span class="line">	Object obj = stringEnum.nextElement();</span><br><span class="line">	System.out.println(obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line">* 一，集合框架的概述</span><br><span class="line">*  <span class="number">1.</span>集合，数组都是对多个数据进行存储操作的结构，简称Java容器。</span><br><span class="line">*      说明：此时的存储器，主要指的是内存层面的存储，不涉及到持久化的存储</span><br><span class="line">*  <span class="number">2.1</span>数组在存储多个数据方面的特点</span><br><span class="line">*      &gt;一旦初始化后，其长度就确定了</span><br><span class="line">*      &gt;数组一旦定义好后，其元素的类型也就确定了，我们也就只能操作指定类型的数据</span><br><span class="line">*      例如：String[] strslObject[] objs;</span><br><span class="line">*  <span class="number">2.2</span>数组在存储多个数据方面的缺点：</span><br><span class="line">*      &gt;一旦初始化后，其长度就不可修改</span><br><span class="line">*      &gt;数组中提供的方法非常有限，对于添加，删除，插入数据等操作，非常不便，同时效率不高。</span><br><span class="line">*      &gt;获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</span><br><span class="line">*      &gt;数组存储数据的特点：有序，可重复。对于无序不可重复的需求，不能满足；</span><br><span class="line">* 二，集合框架</span><br><span class="line">*  |---- Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">*      |---- List接口：存储有序的，可重复的数据</span><br><span class="line">*          |---- ArrayList,LinkedList,Vector</span><br><span class="line">*</span><br><span class="line">*      |---- Set接口：存放无序的，不可重复的数据</span><br><span class="line">*          |---- HashSet,LinkedHashSet,ThreeSet</span><br><span class="line">*</span><br><span class="line">*  |---- Map接口：双列集合，用来存储一对(key - value)一对的数据</span><br><span class="line">*      |---- HashMap,LinkedHashMap,TreeMap,Hashtable,Properties</span><br><span class="line">* 三，Collection接口中方法的使用</span><br><span class="line">*      add(Object obj):将元素obj添加到集合中</span><br><span class="line">*      addAll(Collection coll1):将coll1集合中的元素添加到当前集合中</span><br><span class="line">*      size():获取集合中元素的个数</span><br><span class="line">*      clear():清空集合中的元素</span><br><span class="line">*      isEmpty():判断当前集合是否为空</span><br><span class="line">*      contains(Object obj):判断当前集合中是否包含obj。在判断时，会调用obj的equals方法，因此对于自定义的类要重写   </span><br><span class="line">*                           equals方法</span><br><span class="line">*      containsAll(Collection coll2):判断coll2中的元素是否都位于当前集合中</span><br><span class="line">*      remove(Object obj):移除当前集合中和obj相同的一个元素</span><br><span class="line">*      removeAll(Collection coll3):移除当前集合与coll3中重复的元素,如果重复的元素则全部被移除</span><br><span class="line">*      retainAll(Collection coll4):保留当前集合与coll4中相同的元素，其他的都移除。如果有重复元素则都保留</span><br><span class="line">*      equals(Object obj)：当前集合和obj集合中的元素都相同则返回<span class="keyword">true</span>,如果两个集合的顺序不同则看具体的集合种类。</span><br><span class="line">*      hashCode()：返回当前对象的哈希值</span><br><span class="line">*      toArray():集合 --&gt; 数组</span><br><span class="line">*      Arrays.asList(数组):数组 --&gt; 集合 ; 注意基本数据类型数组的声明要用包装类</span><br><span class="line">*      iterator()：返回迭代器对象，用于集合遍历，此时返回的iterator指向的时集合的第一个元素的前面</span><br><span class="line">* 四，Iterator接口的使用：只用来遍历集合，不能遍历Map</span><br><span class="line">*      Iterator：迭代器</span><br><span class="line">*      当访问越界时报NoSuchElementException异常</span><br><span class="line">*    常用方法：</span><br><span class="line">*      hasNext()：判断iterator指向的容器中是否有下一个对象</span><br><span class="line">*      next()：返回集合的下一个元素</span><br><span class="line">*          工作原理：①将iterator指向下一个，②输出iterator指向的值</span><br><span class="line">*      remove():删除迭代器返回的最后一个元素，即next()指向的元素</span><br><span class="line">*          注意：①remove()在使用前必须先使用next()。②remove()方法不能连续使用两次</span><br><span class="line">* 五，增强<span class="keyword">for</span>循环foreach的使用</span><br><span class="line">*      格式：<span class="keyword">for</span>(元素的类型 局部变量:遍历对象)&#123;</span><br><span class="line">*          输出 --&gt; 局部变量</span><br><span class="line">*      &#125;</span><br><span class="line">*      原理：内部实质还是使用iterator来遍历元素</span><br><span class="line">*      注意：foreach循环中，对局部变量的更改不会影响到遍历对象</span><br><span class="line">* 六，List接口实现类的使用</span><br><span class="line">*      |---- ArrayList：作为List接口的主要实现类；<span class="number">1.2</span>版本开始；线程不安全的，效率高；底层使用Object[] elementData</span><br><span class="line">*    					存储</span><br><span class="line">*      |---- LinkedList：底层使用双向链表存储。对于频繁的插入，删除操作，使用此类的效率比ArrayList高。</span><br><span class="line">*      |---- Vector：作为List接口的古老实现类，<span class="number">1.0</span>版本就有了；线程安全的，效率底；底层使用Object[] elementData存储</span><br><span class="line">*   三者的异同？</span><br><span class="line">*    同：三个类都实现了List接口，存储数据的特点相同：存储有序的，可重复的数据</span><br><span class="line">*  ArrayList源码分析：</span><br><span class="line">*    jdk <span class="number">7</span>情况下</span><br><span class="line">*      ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">//底层创建了一个长度是10的Object[]数组elementData</span></span><br><span class="line">*      liat.add(<span class="number">123</span>) <span class="comment">//elementData[0] = new Integer(123)</span></span><br><span class="line">*      ...</span><br><span class="line">*      list.add(<span class="number">456</span>) <span class="comment">//当此次添加导致底层elementData数组容量不够，则扩容。</span></span><br><span class="line">*      默认情况下，扩容为原来容量的<span class="number">1.5</span>倍，同时将原有数组复制到新数组中。容量最大为<span class="keyword">int</span>所能表示的最大数</span><br><span class="line">*    结论：建议开发中使用带参的构造器： ArrayList(<span class="keyword">int</span> initialCapacity)</span><br><span class="line">*    jdk <span class="number">8</span>情况下</span><br><span class="line">*      ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">//底层Object[] elementData = &#123;&#125;，并没有创建带长度的数组</span></span><br><span class="line">*      liat.add(<span class="number">123</span>) <span class="comment">//第一次调用add()时，底层才创建了长度10的数组，并将数组添加到elementData数组中</span></span><br><span class="line">*      ...</span><br><span class="line">*      后续的添加和扩容操作与jdk <span class="number">7</span>无异</span><br><span class="line">*   小结：jdk7中的ArrayList的对象的创建类似与单例的饿汉式，而jdk8的ArrayList的对象的创建类似于</span><br><span class="line">*          单例的懒汉式，延迟了数组的创建，节省内存。</span><br><span class="line">*  LinkedList源码分析</span><br><span class="line">*      LinkedList list = <span class="keyword">new</span> LinkedList() <span class="comment">//内部声明了Node类型的first和last属性，默认值为null</span></span><br><span class="line">*      list.add(<span class="number">123</span>) <span class="comment">//将123封装到Node中，创建一个Node对象，并将这个对象链接在LinkedList对象中</span></span><br><span class="line">*</span><br><span class="line">*      其中，Node定义为：</span><br><span class="line">*          <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">*              E item;</span><br><span class="line">*              Node&lt;E&gt; next;</span><br><span class="line">*              Node&lt;E&gt; prev;</span><br><span class="line">*</span><br><span class="line">*              Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">*                  <span class="keyword">this</span>.item = element;</span><br><span class="line">*                  <span class="keyword">this</span>.next = next;</span><br><span class="line">*                  <span class="keyword">this</span>.prev = prev;</span><br><span class="line">*               &#125;</span><br><span class="line">*           &#125;</span><br><span class="line">*          体现了LinkedList双向链表的说法</span><br><span class="line">*  Vector源码分析</span><br><span class="line">*      和ArrayList的JDK <span class="number">7</span>以前相类似,在创建时对象时都是长度为<span class="number">10</span>的数组，</span><br><span class="line">*      不同在于每次扩容为原来的<span class="number">2</span>倍</span><br><span class="line">* 七，List接口的使用</span><br><span class="line">*      <span class="number">1.</span>有序性：集合中元素的顺序是按照添加的顺序一个一个排列在底层数组中的</span><br><span class="line">*      <span class="number">2.</span>可重复性：集合中可以存放相同的元素</span><br><span class="line">*    常用的方法</span><br><span class="line">*      <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, Object element)</span>：在index位置插入element元素</span></span><br><span class="line"><span class="function">*      <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection c)</span>：从index位置开始将list2中的所有元素插入到当前list中</span></span><br><span class="line"><span class="function">*      Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;获取位于index位置的元素。越界则返回-<span class="number">1</span></span><br><span class="line">*      <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;返回元素o在集合中首次出现的位置</span><br><span class="line">*      <span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;返回元素o在集合中最后一次出现的位置</span><br><span class="line">*      <span class="function">Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;移除集合中位于index位置的元素并返回这个元素</span><br><span class="line">*      <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;删除集合中和o相等的元素，如果有多个则只删除第一个</span><br><span class="line">*      <span class="function">List <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>;将当前集合的从fromIndex到toIndex位置的元素</span><br><span class="line">*          复制到一个子集和中，并返回这个子集和。  范围：前闭后开。不会对当前集合的元素造成影响</span><br><span class="line">* 八，常用方法总结</span><br><span class="line">*      增：add(Object o)</span><br><span class="line">*      删：remove(<span class="keyword">int</span> index) / remove(Object o)</span><br><span class="line">*      改：set(<span class="keyword">int</span> index,Object o)</span><br><span class="line">*      查：get(<span class="keyword">int</span> index)</span><br><span class="line">*      插入：add(<span class="keyword">int</span> index,Object o)</span><br><span class="line">*      长度：size()</span><br><span class="line">*      遍历：① Iterator迭代器方式</span><br><span class="line">*           ② 增强<span class="keyword">for</span>循环</span><br><span class="line">*           ③ 普通的<span class="keyword">for</span>循环</span><br><span class="line">* 九，Set接口实现类的使用</span><br><span class="line">*      |--- HashSet：作为Set接口的主要实现类；线程不安全的；可以存储<span class="keyword">null</span>值</span><br><span class="line">*          |--- LinkedHashSet：作为HashSet的子类；遍历内部数据时，可以按照添加的顺序遍历</span><br><span class="line">*      |--- TreeSet：可以按照添加对象的指定属性，进行排序；集合中元素的类型必须一致</span><br><span class="line">*      Set接口中没有额外定义新的方法，使用的都是Collection中声明的方法</span><br><span class="line">*   HashSet源码分析：</span><br><span class="line">*          创建时，底层创建了一个HashMap</span><br><span class="line">*      <span class="number">1.</span>底层以数组+链表的方式存储。存储一个数组，数组的每一个元素相当于是一个链表</span><br><span class="line">*      <span class="number">2.</span>要求①：向set中添加的数据其所在类一定要重写hashCode()和equals()方法。</span><br><span class="line">*        要求②：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的哈希值</span><br><span class="line">*   LinkedHashSet源码分析：</span><br><span class="line">*          创建时，底层创建了带有LinkedHashMap类部分属性的的HashMap</span><br><span class="line">*      作为HashSet的子类，在添加数据的同时还维护了两个引用head和tail，这两个引用记录了此数据的前一个数据和后一个数据</span><br><span class="line">*          优点：对于频繁的遍历操作，效率比HashSet要高</span><br><span class="line">*   TreeSet源码分析：</span><br><span class="line">*      <span class="number">1.</span>向TreeSet中添加数据时，要求数据是相同类的对象；</span><br><span class="line">*      <span class="number">2.</span>TreeSet中存放的数据会自动排列，因此要求有排列的方法</span><br><span class="line">*          <span class="number">2.1</span> 让存放的数据的类实现Comparable接口(自然排序)。</span><br><span class="line">*          <span class="number">2.2</span> 在创建TreeSet对象时传入一个实现Comparable接口(定制排序)的对象。</span><br><span class="line">*      <span class="number">3.</span> TreeSet中添加时不再是根据equals()方法进行判断，而是根据比较方法进行判断</span><br><span class="line">*          <span class="number">3.1</span> 自然排序中。比较两个对象是否相同的标准为：caopareTo()放回<span class="number">0</span>，不再是equals()</span><br><span class="line">*          <span class="number">3.2</span> 定制排序中。比较两个对象是否相同的标准为：caopare()放回<span class="number">0</span>，不再是equals()</span><br><span class="line">* 十，Set接口的使用</span><br><span class="line">*      以HashSet为例</span><br><span class="line">*      <span class="number">1.</span>无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值有关</span><br><span class="line">*</span><br><span class="line">*      <span class="number">2.</span>不可重复性：保证添加的元素按照equals()判断时，不能返回<span class="keyword">true</span>。即相同的元素只能添加一次。</span><br><span class="line">*</span><br><span class="line">*      添加元素的过程：以HashSet为例 当向HashSet添加元素a时。</span><br><span class="line">*          首先调用元素a所在类的hashCode()方法，计算a的哈希值。</span><br><span class="line">*          然后此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置(即：索引位置)。判断此位置上是否有元素？</span><br><span class="line">*              当此位置上没有元素，则元素a添加成功。 --&gt; 情况<span class="number">1</span></span><br><span class="line">*              当此位置上有元素(或一链表形式存在的多个元素)，则比较元素a与此位置上元素的哈希值？</span><br><span class="line">*                  如果哈希值不相同，则元素a添加成功  --&gt; 情况<span class="number">2</span></span><br><span class="line">*                  如果哈希值相同，则调用元素a所在类的equals()方法与此位置上的元素进行比较？</span><br><span class="line">*                      如果equals()返回<span class="keyword">true</span>,元素a添加失败</span><br><span class="line">*                      如果equals()返回<span class="keyword">false</span>,则元素a添加成功 --&gt; 情况<span class="number">3</span></span><br><span class="line">*          对于添加成功的情况<span class="number">2</span>和<span class="number">3</span>而言：元素a与已经存在指定索引位置上数据以链表的方式存储。</span><br><span class="line">*              JDK <span class="number">7</span> ：元素a放在数组中，指向原来的元素</span><br><span class="line">*              JDK <span class="number">8</span> ：原来的元素在数组中，指向元素a      总结：七上八下</span><br><span class="line">* 十一，Map接口实现类的使用</span><br><span class="line">*      |--- HashMap：作为Map的主要实现类；线程不安全的，效率高；可以存储<span class="keyword">null</span>的key和value。</span><br><span class="line">*          |--- LinkedHashMap：保证在遍历map元素时，可以按照添加的顺序进行遍历。</span><br><span class="line">*                          原因：在原有的HashMap底层结构上，添加了一对指针，指向前一个元素和后一个元素。</span><br><span class="line">*                          对于频繁的遍历操作，此类执行效率高于HashMap。</span><br><span class="line">*      |--- TreeMap：保证按照添加的key-value进行排序。排序的依据是根据key的自然排序或定制排序。底层使用红黑树结构</span><br><span class="line">*      |--- Hashtable：作为古老的实现类；线程安全的，效率低；不能存储<span class="keyword">null</span>的key和value</span><br><span class="line">*          |--- Properties：常用来处理配置文件。key和value都是String类型的</span><br><span class="line">*      DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，<span class="number">16</span></span><br><span class="line">*      DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：<span class="number">0.75</span></span><br><span class="line">*      TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树：<span class="number">8</span></span><br><span class="line">*      MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量。：<span class="number">64</span></span><br><span class="line">*      threshold：扩容的临界值，=容量*填充因子：<span class="number">16</span> * <span class="number">0.75</span> = <span class="number">12</span></span><br><span class="line">*</span><br><span class="line">*      HashMap的底层：数组+链表 （JDK <span class="number">7</span> 以前）</span><br><span class="line">*                    数组+链表+红黑树 （JDK <span class="number">8</span>以后）</span><br><span class="line">*      实现原理：以JDK <span class="number">7</span>为例：</span><br><span class="line">*      HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">*          在实例化后，底层创建了长度为<span class="number">16</span>的一维数组Entry[] table;</span><br><span class="line">*      ...</span><br><span class="line">*      map.put(key1,value1);</span><br><span class="line">*          首先：调用key1所在的hashCode()计算哈希值，此哈希值经过某种算法后，得到此键值对在Entry数组中存放的位置。先</span><br><span class="line">*    				判断此位置是否为空？</span><br><span class="line">*              如果此位置上为空，则将此键值对添加至此位置上，添加成功。  --&gt;情况<span class="number">2</span></span><br><span class="line">*              如果此位置上的数据不为空(即及位置上存在一个或多个以链表形式存在的数据).比较key1和此位置上所有数据的哈希</span><br><span class="line">*     			值？</span><br><span class="line">*                  如果key1的哈希值与已存在数据的都不一样，此时key1-value1添加成功。 --&gt;情况<span class="number">2</span></span><br><span class="line">*                  如果key1的哈希值与已存在数据中的某一个key2-value2的哈希值有一个一样，则调用key1所在类的</span><br><span class="line">*    				equals(key2)方法进行比较</span><br><span class="line">*                      如果equals返回<span class="keyword">false</span>,此时key1-value1添加成功。 --&gt;情况<span class="number">3</span></span><br><span class="line">*                      如果equals返回<span class="keyword">true</span>,此时用value1替换value2</span><br><span class="line">*          补充：关于情况<span class="number">2</span>和情况<span class="number">3</span>，此时的key1-value1和原来的数据一链表的方式存储。</span><br><span class="line">*          在不断添加的过程中，会涉及到扩容问题，默认扩容方式为：扩容为原来的<span class="number">2</span>倍，并将原来的数据复制过来</span><br><span class="line">*          如果给定初始化的容量<span class="number">1</span>，实际上创建的是比给定的数大且是<span class="number">2</span>的次幂的容量的数组，例如给定<span class="number">15</span>，实际创建的容量是<span class="number">16</span></span><br><span class="line">*          扩容时，如果当前容量为<span class="number">16</span>，当添加的元素超过临界值且要添加的位置非空时就会扩容，而不是等到满时才扩容。</span><br><span class="line">*        JDK <span class="number">8</span> 较于<span class="number">7</span>的不同之处</span><br><span class="line">*           <span class="number">1.</span>n<span class="function">ew <span class="title">HashMap</span><span class="params">()</span>:实例化时底层就没有创建数组</span></span><br><span class="line"><span class="function">*           2.JDK 8的底层数组是：Node[]，而非Entry[]</span></span><br><span class="line"><span class="function">*           3.首次调用<span class="title">put</span><span class="params">()</span>方法时，底层创建了长度为16的数组</span></span><br><span class="line"><span class="function">*           4.JDK 7的底层结构是：数组+链表。JDK 8的底层结构：数组+链表+红黑树</span></span><br><span class="line"><span class="function">*           红黑树的体现：当数组的某一位置上存在的链表的元素的个数 &gt; 8且当前数组的长度 &gt; 64时，此位置上的所有元素改用</span></span><br><span class="line"><span class="function">*		     红黑树实现。</span></span><br><span class="line"><span class="function">*      LinkedHashMap底层结构</span></span><br><span class="line"><span class="function">*          完全继承HashMap中的方法，</span></span><br><span class="line"><span class="function">*          不同之处： <span class="keyword">static</span> class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; </span>&#123;</span><br><span class="line">*                          Entry&lt;K,V&gt; before, after;</span><br><span class="line">*                          Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">*                               <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">*                           &#125;</span><br><span class="line">*                    &#125;</span><br><span class="line">*          与HashMap相比，元素添加了before，after用来记录上一个添加的和下一个添加的元素</span><br><span class="line">*      TreeMap的使用</span><br><span class="line">*          <span class="number">1.</span>像TreeMap中添加key-value,要求key必须是由同一个类创建的对象</span><br><span class="line">*              因为要按照key进行排序：自然排序，定制排序。</span><br><span class="line">*          <span class="number">2.</span>不能按照value排序。</span><br><span class="line">*      Properties的使用：</span><br><span class="line">*          <span class="number">1.</span>常用来处理配置文件。key和value都是String类型的</span><br><span class="line">*          <span class="number">2.</span></span><br><span class="line">* 十二，Map接口的底层结构</span><br><span class="line">*      Map中的key：无序的，不可重复的，使用Set存储所有的Key --&gt;key所在的类要重写equals()和hashCode()方法</span><br><span class="line">*      Map中的value：无序的，可重复的，使用Collection存储所有的value --&gt;value所在的类要重写equals()方法</span><br><span class="line">*      一个键值对：key-value构成了一个Entry对象。</span><br><span class="line">*      Map中的entry：无序的，不可重复的，使用Set存储所有的entry.</span><br><span class="line">*     添加、删除、修改操作：</span><br><span class="line">*          <span class="function">Object <span class="title">put</span><span class="params">(Object key,Object value)</span>：将指定key-value添加到<span class="params">(或修改)</span>当前map对象中</span></span><br><span class="line"><span class="function">*          <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map m)</span>:将m中的所有key-value对存放到当前map中</span></span><br><span class="line"><span class="function">*          Object <span class="title">remove</span><span class="params">(Object key)</span>：移除指定key的key-value对，并返回value</span></span><br><span class="line"><span class="function">*          <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>：清空当前map中的所有数据</span></span><br><span class="line"><span class="function">*     元素查询的操作：</span></span><br><span class="line"><span class="function">*          Object <span class="title">get</span><span class="params">(Object key)</span>：获取指定key对应的value</span></span><br><span class="line"><span class="function">*          <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span>：是否包含指定的key</span></span><br><span class="line"><span class="function">*          <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span>：是否包含指定的value</span></span><br><span class="line"><span class="function">*          <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>：返回map中key-value对的个数</span></span><br><span class="line"><span class="function">*          <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>：判断当前map是否为空</span></span><br><span class="line"><span class="function">*          <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>：判断当前map和参数对象obj是否相等</span></span><br><span class="line"><span class="function">*     元视图操作的方法：</span></span><br><span class="line"><span class="function">*          Set <span class="title">keySet</span><span class="params">()</span>：返回所有key构成的Set集合</span></span><br><span class="line"><span class="function">*          Collection <span class="title">values</span><span class="params">()</span>：返回所有value构成的Collection集合</span></span><br><span class="line"><span class="function">*          Set <span class="title">entrySet</span><span class="params">()</span>：返回所有key-value对构成的Set集合</span></span><br><span class="line"><span class="function">*     总结：常用方法</span></span><br><span class="line"><span class="function">*          增：<span class="title">put</span><span class="params">()</span></span></span><br><span class="line"><span class="function">*          删：<span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function">*          改：<span class="title">put</span><span class="params">()</span></span></span><br><span class="line"><span class="function">*          查：<span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">*          长度：<span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">*          遍历：<span class="title">keySet</span><span class="params">()</span>/<span class="title">values</span><span class="params">()</span>/<span class="title">entrySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function">* 十三，Collections工具类的使用</span></span><br><span class="line"><span class="function">*      作用：操作Collection,Map的工具类</span></span><br><span class="line"><span class="function">*      方法：</span></span><br><span class="line"><span class="function">*          <span class="title">reverse</span><span class="params">(list)</span>:翻转list中的元素</span></span><br><span class="line"><span class="function">*          Collections.<span class="title">reverse</span><span class="params">(list)</span></span>;</span><br><span class="line">*          shuffle(list)：对list集合的元素随机排序</span><br><span class="line">*          Collections.shuffle(list);</span><br><span class="line">*          sort(list):根据元素的自然顺序对元素进行排序，要求集合中的元素一致</span><br><span class="line">*          swap(list, i, j)：将list中的第i个和第j个元素进行交换</span><br><span class="line">*          max(list)：返回list自然排序后最后一个位置上的值</span><br><span class="line">*          min(list)：返回list自然排序后第一个位置上的值</span><br><span class="line">*          <span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(list, Object o)</span>:返回list中元素o出现的次数</span></span><br><span class="line"><span class="function">*          <span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(list,oldVal,newVal)</span>：将list集合中的oldVal变成newVal,如果有多个oldVal，则全部替</span></span><br><span class="line"><span class="function">*												     换</span></span><br><span class="line"><span class="function">*          <span class="title">copy</span><span class="params">(dest,src)</span>:将src的内容复制到dest中。</span></span><br><span class="line"><span class="function">*              注意：dest创建的方式：List dest </span>= Arrays.asList(<span class="keyword">new</span> Object[src.size()]);</span><br><span class="line">*          <span class="function">List <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span>返回的list1既是线程安全的</span></span><br></pre></td></tr></table></figure>


    </div>

    
    
    


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/27/Java%E5%AD%A6%E4%B9%A0/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/1-%E5%8F%98%E9%87%8F%E4%B8%8E%E6%A0%87%E8%AF%86%E7%AC%A6/" rel="prev" title="变量与标识符">
      <i class="fa fa-chevron-left"></i> 变量与标识符
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/07/Java%E5%AD%A6%E4%B9%A0/Java%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/6-IO%E6%B5%81/" rel="next" title="IO流">
      IO流 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">Java集合框架概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Collection%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">Collection接口方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.</span> <span class="nav-text">Iterator迭代器接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF%EF%BC%9Aforeach"><span class="nav-number">3.1.</span> <span class="nav-text">增强for循环：foreach()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Collection%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B8%80%EF%BC%9AList"><span class="nav-number">4.</span> <span class="nav-text">Collection子接口一：List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#List%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%80%EF%BC%9AArrayList"><span class="nav-number">4.1.</span> <span class="nav-text">List的实现类一：ArrayList</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BA%8C%EF%BC%9ALinkedList"><span class="nav-number">4.2.</span> <span class="nav-text">List的实现类二：LinkedList</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%89%EF%BC%9AVector"><span class="nav-number">4.3.</span> <span class="nav-text">List的实现类三：Vector</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Collection%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%BA%8C%EF%BC%9ASet"><span class="nav-number">5.</span> <span class="nav-text">Collection子接口二：Set</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Set%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%80%EF%BC%9AHashSet"><span class="nav-number">5.1.</span> <span class="nav-text">Set的实现类一：HashSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BA%8C%EF%BC%9ALinkedHashSet"><span class="nav-number">5.2.</span> <span class="nav-text">Set的实现类二：LinkedHashSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%89%EF%BC%9ATreeSet"><span class="nav-number">5.3.</span> <span class="nav-text">Set的实现类三：TreeSet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="nav-number">5.3.1.</span> <span class="nav-text">自然排序：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">5.3.2.</span> <span class="nav-text">定制排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.</span> <span class="nav-text">Map接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Map%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%80%EF%BC%9AHashMap"><span class="nav-number">6.1.</span> <span class="nav-text">Map的实现类一：HashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BA%8C%EF%BC%9ALinkedHashMap"><span class="nav-number">6.2.</span> <span class="nav-text">Map的实现类二：LinkedHashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E4%B8%89%EF%BC%9ATreeMap"><span class="nav-number">6.3.</span> <span class="nav-text">Map实现类之三：TreeMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E5%9B%9B%EF%BC%9AHashtable"><span class="nav-number">6.4.</span> <span class="nav-text">Map实现类之四：Hashtable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E4%BA%94%EF%BC%9AProperties"><span class="nav-number">6.5.</span> <span class="nav-text">Map实现类之五：Properties</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">7.</span> <span class="nav-text">Collections工具类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9AEnumeration"><span class="nav-number">8.</span> <span class="nav-text">补充：Enumeration</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">9.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Plum Reiver</p>
  <div class="site-description" itemprop="description">技术，日常，笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
	
  </nav>
</div>


      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plum Reiver</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
